---
title: "CMU15445(2023 Fall)数据库组件功能速查"
date: 2024-04-29T14:09:51+08:00
draft: false
tags:
  - C++
  - 水文
  - 数据库
categories: 其他计算机科学
mathjax: true
markup: goldmark
image: cover.jpg
---

为了应对面试官的拷打，写下此文，方便我复习这个数据库的实现方法。

# Project 1

## Task 1

这一部分主要是要求实现一个LRU-K的替换算法。

LRU是最近最少使用算法，也就是把buffer里面，上次使用时间距离现在最远的元素换出去。但是LRU的问题在于，如果有很多“偶发性”数据访问，即只访问一两次的数据，那么LRU会替换掉几乎所有元素，从而降低命中率。

LRU-K的想法是，访问过K次及以上的数据和其他数据分开来算。显然，前者是更需要放在缓存里的，而后者是“偶发性”数据。

这里同样定义了距离，当访问次数大于等于$K$时，该元素的距离为当前时间点减去之前的第$K$次访问的时间点。如果一个元素的访问次数不足$K$，则距离无限大。换出的规则仍然是，把距离最大的元素换出。如果有多个元素距离无限大，则把最近访问最远的那个元素换出。相当于对它们进行朴素的LRU。

下面具体解析一下在`src/include/buffer/lru_k_replacer.h`里面的东西的作用

- `LRUNode`：这里记录我们刚刚提到的元素的信息。其中`history_`记录了最近的至多$K$次访问的时间戳，表头为最远的，表尾为最近的。`k_`代表累计有几次访问，最大等于LRU-K算法设定的$K$值，不能超过。`fid_`代表在buffer pool中的帧号，其作用在于通过帧号找到页号，具体会用在buffer pool中。`is_evictable_`，为真时代表此元素可以换出。

## Task 2

这里要求实现一个磁盘调度算法。不过这个算法并不高深，就是一个简单的FIFO，使用一个并发安全的队列实现。

这个队列在这个项目里是已经提供好了的，不需要自己实现。不过为了防止被面试官拷打，我们来解析一下这个队列的实现方式。其被称作`Channel`

---
title: 从零开始的软渲染器 坐标变换与视角
date: 2023-08-04T22:53:54+08:00
draft: true
tags:
  - 图形学
  - 渲染
categories: 图形学
mathjax: true
markup: goldmark
image: cover.jpg
---

我们的模型并不会停留在原地不动，比如当我们在游戏中前后左右移动时，其他物体相对于我们是在平移的。又比如在游戏中移动鼠标看向不同的地方，其他物体和我们距离保持不变，但方向却改编了。

为此，研究物体的坐标变换是十分有必要的。

我们之前都只是简单的把物体的$z$轴坐标去掉，只用$x,y$轴坐标来画图。这导致的问题是，我们无法实现近大远小的效果，美术上也把这个称为透视原理。为此，我们还必须研究一种方法，让渲染考虑$z$轴坐标，实现对于透视的模拟。

# 坐标变换

一般来说，我们主要用到平移、旋转、缩放，其他的如切变、镜像等并不是很常用到，暂时不做介绍。另外，我们最开始打算的就是在三维空间中运行，所以就不介绍更简单的二维情况了

## 缩放

从最简单的缩放讲起，如果一个点是$(x,y,z)$，那么把他缩放$k$倍，就是简单的$(kx,ky,kz)$。这实在是过于显然的结论。用矩阵实现的话，这个变换的矩阵是

$$
\begin{bmatrix}
 k & 0 & 0\\
 0 & k & 0\\
 0 & 0 & k
\end{bmatrix}
$$

当然，如果你想让各个轴上缩放比例不一样，例如$x$轴缩放$k_x$倍，$y$轴缩放$k_y$倍，$z$轴缩放$k_z$倍，那么

$$
\begin{bmatrix}
 k_x & 0 & 0\\
 0 & k_y & 0\\
 0 & 0 & k_z
\end{bmatrix}
$$

其作用在某一点$(x,y,z)^T$上，结果为

$$
\begin{bmatrix}
 k_x & 0 & 0\\
 0 & k_y & 0\\
 0 & 0 & k_z
\end{bmatrix}
\begin{bmatrix}
 x\\
 y\\
 z
\end{bmatrix}=
\begin{bmatrix}
 k_xx\\
 k_yy\\
 k_zz
\end{bmatrix}
$$

写成四维（后面介绍为什么）的形式就是

$$
\begin{bmatrix}
 k_x & 0 & 0 & 0\\
 0 & k_y & 0 & 0\\
 0 & 0 & k_z & 0\\
 0 & 0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
 x\\
 y\\
 z\\
 1
\end{bmatrix}=
\begin{bmatrix}
 k_xx\\
 k_yy\\
 k_zz\\
 1
\end{bmatrix}
$$

## 平移

事实上，三维矩阵是无法进行平移的，我们必须加入一维。

前面提到，我们在图形学中一般最多也就用到四维坐标，我把为什么用以及如何使用四维坐标放到本章附录里。我们先讨论如何平移。

具体而言，我们引入下面这个矩阵

$$
\begin{bmatrix}
 1 & 0 & 0 & t_x\\
 0 & 1 & 0 & t_y\\
 0 & 0 & 1 & t_z\\
 0 & 0 & 0 & 1
\end{bmatrix}
$$

对于任意一点$(x,y,z,1)^T$应用这个变换，得到

$$
\begin{bmatrix}
 1 & 0 & 0 & t_x\\
 0 & 1 & 0 & t_y\\
 0 & 0 & 1 & t_z\\
 0 & 0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
 x\\
 y\\
 z\\
 1
\end{bmatrix}=
\begin{bmatrix}
 x+t_x\\
 y+t_y\\
 z+t_z\\
 1
\end{bmatrix}
$$

我们很自然地发现，这就是真正的平移，每个坐标都位移了$t$的距离。

## 旋转

旋转需要用到四元数的知识，我们将会在未来探讨（TODO）。

## 复合变换

我们有时会对一个点进行连续的变换，例如先把他缩放50%，再把它旋转某个角度，再把它平移。设缩放矩阵为$M_1$，旋转矩阵为$M_2$，平移矩阵为$M_3$，我们的点初始为$P^{(0)}$

首先进行的是缩放，那么$P^{(1)}=M_1P^{(0)}$，然后再进行旋转，那么$P^{(2)}=M_2P^{(1)}$，然后再平移，那么$P^{(3)}=M_3P^{(2)}$。代入展开得

$$
P^{(3)} = M_3M_2M_1P^{(0)}
$$

这里我想指出非常明显的一点，就是变换的顺序不可以任意交换。例如，对$(1,0)$这个点，先逆时针旋转180度，再向右平移一个单位，得到$(0,0)$。而先平移再旋转就得到$(-2,0)$。

体现在矩阵上也是一样的，根据线性代数知识，我们知道，矩阵乘法有结合律，但是没有交换律。也就是例如，$M_3M_2M_1P^{(0)}$和$M_2M_3M_1P^{(0)}$，在绝大部分情况下都是不相等的。

我们计算确实是从左到右计算，但是我们观察这个式子，判断其是以什么顺序变换的，却是反过来从右到左看，先进行$M_1$变换，再进行$M_2$变换，最后再$M_3$变换

# 视角变换

我们为什么需要变换视角？我们需要先介绍一下空间坐标系统

![1.png](1.png)

看这个图，我们一般会用到$5$个坐标系。

1. 局部空间。其指的是物体模型自己的坐标，也就是我们之前在OBJ文件里见到的那个坐标。它有自己的原点，每个不同的模型、或者相同模型的不同实例都可以有自己的原点，也就有了自己的坐标。其不需要加载到你的程序中，这个坐标就存在了。以真实世界作为类比的话，局部空间相当于你这个人的肚脐眼为原点的空间，只保存我这个人的信息。
2. 世界空间。当你把模型加载到你的“游戏世界”，这个世界本身是有一个坐标的，以真实世界为类比，相当于宇宙的坐标系。你在这个宇宙有一个确切的坐标（如果原点确定）。这个空间存储了许多模型的信息。通过之前提到的平移、缩放、旋转矩阵，我们把物体放到世界各处。刚导入的时候，模型原点和世界原点是重叠的，所以我们只需要对局部空间的坐标应用上变换矩阵，就得到世界空间的坐标了。
3. 观察空间。也可以叫他摄像机空间。比起局部空间，观察空间更像是把世界空间的原点和坐标轴进行位移、旋转后得到的空间，其包含了众多模型的信息。而原来世界的原点会被变换到相机的位置，坐标轴会根据相机的朝向而设定。
4. 裁剪空间。你的摄像机并不能看到所有的东西，例如他有长宽高的限制，又例如你看不到背后的东西，再例如远处的东西太小了对你来说看不见。所以你的摄像机实际上能看到的东西只是整个观察空间中的一个很小的子集。通过投影矩阵（正交或透视投影，之后会介绍），你把能看到的东西映射到一个$[-1,1]^3$的正方形盒子里。看不到的东西则在这个盒子外，也就是被剪裁了。
5. 屏幕空间。这里是离散的，并且是$2$维的，你的屏幕（或者窗口）的分辨率是多少，屏幕空间大小就是多少。把剪裁空间里的东西真正放到屏幕上显示出来，就从剪裁空间转换到了屏幕空间。

## 模型变换

也就是图上的Model Matrix，其实就是之前将的缩放、平移、旋转矩阵，不需要再讲。

## 视口变换

我们先来讲最简单的视口变换，也就是图上的Viewport Transform，最后一步的矩阵。

# 附录

为什么要用四维坐标？其实就是因为平移他不是线性变换，三维的矩阵无法处理三维的平移。但是我们可以通过多加一维的方式来引入平移运算。

具体而言，我们定义三维点$(x,y,z)^T$扩充为四维点$(x,y,z,1)^T$，定义三维向量$(x,y,z)^T$扩充为四维向量$(x,y,z,0)^T$。特别的，对于任意一个四维坐标$(x,y,z,w)^T$，如果$w=0$，则其代表$(x,y,z,0)^T$这个向量，如果$w\neq 0$，则其代表$(x/w,y/w,z/w,1)^T$这个点。

这样做的好处是，如果两个点相减，得到的第四维为$0$，也就得到了一个向量。同理可得两个向量相减还是向量，点减去向量相当于对点进行平移，向量减去点没有意义（除非你理解为点减去向量的相反数）。

还有一个好处，对于任意的平移变换

$$
\begin{bmatrix}
 1 & 0 & 0 & t_x\\
 0 & 1 & 0 & t_y\\
 0 & 0 & 1 & t_z\\
 0 & 0 & 0 & 1
\end{bmatrix}
$$

其作用在点上时，点正确的进行了平移

$$
\begin{bmatrix}
 1 & 0 & 0 & t_x\\
 0 & 1 & 0 & t_y\\
 0 & 0 & 1 & t_z\\
 0 & 0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
 x\\
 y\\
 z\\
 1
\end{bmatrix}=
\begin{bmatrix}
 x+t_x\\
 y+t_y\\
 z+t_z\\
 1
\end{bmatrix}
$$

而其作用在向量上时，并不会平移向量。即

$$
\begin{bmatrix}
 1 & 0 & 0 & t_x\\
 0 & 1 & 0 & t_y\\
 0 & 0 & 1 & t_z\\
 0 & 0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
 x\\
 y\\
 z\\
 0
\end{bmatrix}=
\begin{bmatrix}
 x\\
 y\\
 z\\
 0
\end{bmatrix}
$$

这就是数学意义上的向量，永远从原点开始。而与物理中有时讨论的矢量不同，物理中矢量有时可以让起始点在任意地方。

另外，你可能需要经常检查你的点的第四维坐标是否为1，如果不为1，可能会产生各种奇怪的问题。在某些变换矩阵作用后，第四维可能就不为1了，并且你可能不容易发现这个问题。

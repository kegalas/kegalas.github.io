---
title: "计算机组成原理学习笔记"
date: 2023-03-29T16:00:26+08:00
draft: false
tags: [计算机,组成原理,大学]
description: 计算机组成原理的学习笔记
categories: 其他计算机科学
mathjax: true
markup: pandoc
image: "cover.jpg"
---

# 简称表

| 简称        | 含义        |
|:---------:|:---------:|
| CPU       | 中央处理器     |
| PC        | 程序计数器     |
| IR        | 指令寄存器     |
| CU        | 控制单元      |
| ALU       | 算术逻辑单元    |
| ACC       | 累加器       |
| MQ        | 乘商寄存器     |
| X         | 操作数寄存器    |
| MAR       | 存储器地址寄存器  |
| MDR       | 存储器数据寄存器  |
| MM        | 主寄存器      |
| I/O       | 输入输出设备    |

| 简称        | 含义        |
|:---------:|:---------:|
| SATA      | 串行ATA总线   |
| PCI       | 外围设备互联    |
| DMA       | 直接存储器访问   |
| DMI       | 直接媒体接口    |
| QPI       | 快速通道互联    |
| FSB       | 前端总线      |
| PCH       | 平台控制中心    |
| IOH       | 输入/输出中心   |
| ICH       | 控制器集线器    |
| MCH       | 内存控制器集线器  |
| NVRAM     | 非易失型随机存储器 |
| SCSI      | 小型计算机系统接口 |

| 简称        | 含义          |
|:---------:|:-----------:|
| RAM       | 随机存储器       |
| ROM       | 只读存储器       |
| SRAM      | 静态随机读写存储器   |
| DRAM      | 动态随机读写存储器   |
| DDR SDRAM | 双倍数据率同步DRAM |
| MROM      | 掩模ROM       |
| PROM      | 可一次编程ROM    |
| EPROM     | 可擦除的PROM    |
| EEPROM    | 电可擦除的EPROM  |
| EAROM     | 电改写ROM      |
| SIMM      | 单列直插式存储器模块  |
| DIMM      | 双列直插式存储器模块  |
| FIFO      | 先进先出算法      |
| LRU       | 近期最少使用算法    |
| TLB       | 转换后援缓冲器，快表  |



# 计算机的性能描述

## 机器字长

指CPU一次能处理的数据位数

## 存储容量

存储容量=存储单元个数×存储字长。其中MAR反应存储单元个数，MDR反应存储字长。

## 运行速度

### 主频/时钟周期

主频与时钟周期二者互为倒数

### CPI

执行一条指令（平均）需要的时钟周期数

$$
CPI = \dfrac{\text{所有指令的时钟周期之和}}{\text{指令总数}}\\
= \sum(\text{各类指令的CPI}\times \text{该类指令的比例})
$$

### MIPS

每秒钟CPU能执行的指令总条数（百万条/秒）

$$
MIPS = \dfrac{\text{指令条数}}{\text{执行时间}\times 10^6}
$$

$$
= \dfrac{\text{指令条数}}{\left(\dfrac{\text{所有指令CPU时钟周期数之和}}{f}\right)\times 10^6}\\
$$

$$
= \dfrac{f}{\text{CPI}\times 10^6}
$$

其中最后一个公式又称为全性能公式

## Amdahl定律

**加速比**

$$
\text{加速比} = \dfrac{\text{改进后的系统性能}}{\text{改进前的系统性能}}\\
$$

$$
= \dfrac{\text{改进前的系统执行时间}}{\text{改进后的系统执行时间}}
$$

**可改进比例$f_e$**

可改进部分在原系统执行时间中所占的比例

**部件加速比$r_e$**

可改进部分改进后性能提高的程度

**Amdahl定律**

假设改进前的系统执行时间为$T_0$，改进后的系统执行时间为$T_n$，则

$$
T_n = T_0\bigg(1-f_e+\dfrac{f_e}{r_e}\bigg)
$$

若加速比用$S_p$表示，则有

$$
S_p = \dfrac{1}{1-f_e+\dfrac{f_e}{r_e}}
$$

有多个部件同时可以改进时

$$
S_p = \dfrac{1}{(1-\sum f_e)+\sum(\dfrac{f_e}{r_e})}
$$

# 总线和IO

## 分类

- 按照总线的传输方式不同（定时），可以分为同步总线和异步总线；
- 按照总线中数据线的多少不同（传送信息），可以分为并行总线和串行总线。
- 按照总线的使用方式不同，可以分为专用总线和公用总线。
- 按照连接部件不同，可分为片内总线、系统总线、通信总线
- 按照系统总线传输信息的不同，又可分为数据总线、地址总线、控制总线

## 总线带宽

$$
\text{总线带宽} = \text{数据线宽度}\times \text{总线频率}
$$

## 总线结构

可以分为单总线和多总线结构。

## 总线控制

## 中断

# 存储系统

## 主存

### 技术指标

**存储容量**

$$
\text{存储容量}=\text{存储单元个数}\times\text{存储字长}
$$

上式的单位是位，如果用字节需要除以8。

**存储器带宽**

$$
B_m = \dfrac{n}{t_m}
$$

其中$n$为每次读出/写入的字节数，$t_m$为存储周期

### 半导体存储芯片的译码驱动方式

### DRAM的刷新

### 存储器芯片的扩展

## Cache

### Cache的命中率

在一个程序执行期间，设$N_c$为访问Cache的总命中次数，$N_m$为访问主存的总次数，则命中率$h$（hit rate）为

$$
h = \dfrac{N_c}{N_c+N_m}
$$

设$t_c$为命中时的Cache访问时间，$t_m$为未命中时的主存访问时间，通常$t_m >> tc$ ，$1-h$表示未命中率（缺失率，miss rate）

当Cache和主存同时访问时，Cache-主存系统的平均访问时间$ta$为：

$$
t_a = ht_c + (1-h)t_m
$$

当Cache和主存不同时访问时，Cache-主存系统的平均访问时间$ta$为（我们一般考虑同时访问的情况）：

$$
t_a = ht_c+(1-h)(t_m+t_c) = t_c+(1-h)t_m
$$

### Cache-主存系统的效率

$$
e = \dfrac{t_c}{t_a} = \dfrac{\text{访问Cache的时间}}{\text{平均访问时间}}\times 100\%
$$

$$
= \dfrac{t_c}{t_c+(1-h)\times t_m}\times 100\%
$$

### Cache-主存系统的加速比

$$
S_p = \dfrac{t_m}{t_a} = \dfrac{t_m}{t_c+(1-h)\times t_m} = \dfrac{1}{1-h+\dfrac{1}{r}}
$$

其中，$r=t_m/t_c$为从主存到Cache速度提升的倍数。

### Cache-主存系统的成本

假设计算机中的主存与Cache的容量分别为$S_1$和$S_2$,显然$S_1 >> S_2$；

主存与Cache的单位价格分别为$C_1$和$C_2$，且$C_1$是价格较低的。

那么Cache—主存系统的平均价格$C$为

$$
C = \dfrac{C_1\times S_1+C_2\times S_2}{S_1+S_2}
$$

### Cache的映射

### 替换算法

### 多级Cache

## 虚拟存储器

## 外部存储器

### 磁盘

**非格式化容量**

$$
\text{非格式化容量} = \text{位密度}\times\dfrac{\text{内圈磁道周长}+\text{外圈磁道周长}}{2}\times\text{每盘面磁道数}\times\text{盘面数}
$$

**格式化容量**

$$
\text{格式化容量} = \text{每扇区字节数}\times\text{每道扇区数}\times\text{每盘面磁道数}\times\text{盘面数}
$$

**平均存取时间**

$$
\text{平均存取时间} = \text{平均寻道时间}+\text{平均等待时间}+\text{传输时间}
$$

**数据传输率**

$$
\text{数据传输率} = \text{每个扇区的字节数}\times\text{每道扇区数}\times\text{磁盘的转速}
$$

# 数据表示

## 带符号的定点小数

其一般形式为

$$
X_s.X_{-1}X_{-2}\cdots X_{-(n-1)}
$$

其中第一位是符号位，后面的每一位都在小数点后，也就是说定点小数一定是纯小数，不含整数部分。

## 原码、反码、补码、移码

原码转换为另外三个码的规则

| 原码符号 | 反码     | 补码   | 移码     |
|:----:|:-------:|:----:|:------:|
| 正    | 相同      | 相同   | 符号位改为1 |
| 负    | 除符号位外取反 | 反码+1 | 符号位与补码相反 |
假设不含符号位有$n$位，则原码和反码的范围为$-2^{n}+1\sim 2^{n}-1$，补码和移码的范围为$-2^{n}\sim 2^{n}-1$

以上是定点整数的转换方法，定点小数的转换方法相同，数据范围不同

假设不含符号位有$n$位，则原码和反码的范围为$-(1-2^n)\sim 1-2^n$，补码和移码的范围为$-1\sim 1-2^n$

## 浮点数

浮点数$N$由三部分来决定，阶码$E$，尾数$M$和阶码的底$B$

$$
N = B^E\cdot M
$$

阶码的底$B$一般隐含表示，取决于机器本身。阶码是定点整数，尾数是定点小数。

### 非规格化浮点数

非规格化浮点数不要求定点小数的第一位是1.其数据范围如下，假设尾数部分$n+1$位，阶码部分$k+1$位，均用补码表示

| 阶码最小值    | $-2^k$                  | 阶码最大值    | $2^k-1$                  |
|:--------:|:-----------------------:|:--------:|:------------------------:|
| 尾数最小负值   | $-1$                    | 尾数最大负值   | $-2^{-n}$                |
| 尾数最小正值   | $2^{-n}$                | 尾数最大正值   | $1-2^{-n}$               |
| 可表示的最小负数 | $-1\times 2^{2^k-1}$    | 可表示的最大负数 | $-2^{-n}\times 2^{-2^k}$ |
| 可表示的最小正数 | $2^{-n}\times 2^{-2^k}$ | 可表示的最大正数 | $(1-2^{-n})\times 2^{2^k-1}$ |

### 规格化浮点数
要求定点小数的第一位是1.在用补码表示时，符号位和第一位如果不同，则为规格化浮点数。


| 阶码最小值    | $-2^k$                  | 阶码最大值    | $2^k-1$                  |
|:--------:|:-----------------------:|:--------:|:------------------------:|
| 尾数最小负值   | $-1$                    | 尾数最大负值   | $-(1/2+2^{-n})$                |
| 尾数最小正值   | $+1/2$                | 尾数最大正值   | $1-2^{-n}$               |
| 可表示的最小负数 | $-1\times 2^{2^k-1}$    | 可表示的最大负数 | $-(1/2+2^{-n})\times 2^{-2^k}$ |
| 可表示的最小正数 | $1/2\times 2^{-2^k}$ | 可表示的最大正数 | $(1-2^{-n})\times 2^{2^k-1}$ |

### IEEE754标准浮点数

以单精度为例，单精度有32位长，最高位($S$)是浮点数的符号位，接下来8位是指数($E$)，最后23位是尾数($F$)。

其表示为

$$
(-1)^S\times (1+F)\times 2^{(E-Bias)}
$$

其中，尾数本来应该为1.xxxxx，但是我们将第一位暗含了，所以式子中为$1+F$，那23位尾数只包含小数点后面的数。这个尾数永远为正，不需要考虑补码等问题，符号由符号位提供。

而$Bias$提供了一种类似于移码的方式来表示正负，在单精度中，Bias为$127$，也就是说，如果我们要表示$2^6$，则$E = 6+127 = 133$，而133才是会被记录在那8位尾数中的数字。

单精度表示对象表如下

|指数|尾数|表示对象|
|:-:|:-:|:-:|
|0|0|0|
|0|非0|$\pm$非规格化数|
|1-254|任意|$\pm$浮点数|
|255|0|$\pm$无穷|
|255|非0|NaN|

其中浮点数的表示范围为$\pm[1,2)\times 2^{[-126,127]}$

双精度浮点数的Bias为1023。

## ASCII码

## 汉字编码

$$
\text{国标码} = (\text{区位码})_{16} + 2020H
$$

$$
\text{机内码} = (\text{国标码})_{16} + 8080H
$$

$$
\text{机内码} = (\text{区位码})_{16} + A0A0H
$$

## Unicode与UTF-8

## 检错与纠错码

### 校验码的码距

$$
d_{min} \geq t+e+1, 且e>t
$$

其中$d_{min}$为编码码距，$t$为可纠错的位数，$e$为可检错的位数

$d_{min}\geq 2$的数据校验码具有检错的能力

### 奇偶校验

### 海明码

设信息码为$n$位，欲检测$1$位错误，增添$k$位校验位，组成$m=n+k$位的校验码，应满足

$$
2^k\geq n+k-1
$$

### CRC码


# 运算方法与运算器

## 机器数的逻辑运算

按位与、或、非、异或等等。

## 机器数的移位运算

### 算术移位

正数的原码、补码、反码，左移右移都补0.

负数的原码左右都补0；补码右补1，左移补0；反码左右都补1.

运算的结果$p+q$位，保留前$p$位，常见的舍入方法有：

1. 恒舍（切断）。实现简单，误差大。
2. 冯诺依曼舍入法，又称恒置1法，把保留部分$p$位的最低位置1.实现简单，平均误差接近0，应用较多。
3. 下舍上入法，即0舍1入。用$q$位的最高位作为标志。如果为0，则全部舍去；如果为1，则在保留的$p$位的最低位上加1.
4. 查表舍入法，或ROM舍入法。每次经查表来读得相应的处理结果。表的设计通常是当尾数最低$k-1$位全1时用截断法，其余用舍入法。实现速度快，虽然增加了硬件，但是整体性能最佳。

### 逻辑移位

把所有码都看成无符号码，左移右移都添加0，多出来的位直接舍弃。

### 循环移位

![1.jpg](1.jpg)

## 一位全加器

输入$X_i,Y_i,C_i$，表示两个加数和一个进位。

输出$Z_i,C_{i+1}$，表示结果和进位。

$$
Z_i = X_i\oplus Y_i\oplus C_i
$$

$$
C_{i+1} = (X_i\cdot Y_i)+(X_i+ Y_i)\cdot C_i
$$

若果令$G_i = X_i\cdot Y_i, P_i = X_i+ Y_i$，则$C_{i+1}=G_i+P_i\cdot C_i$

当然$P_i=X_i\oplus Y_i$其实是等效的，有些地方会这么写。

## n位加减法器

### 串行（行波）进位的并行加减法器

### 并行加法器的快速进位

1. 并行进位（先行进位、同时进位、CLA）方式

即把$C_{i+2}$用$C_{i+1}$表示，把$C_{i+3}$用$C_{i+2}$表示，以此类推，然后从一开始就得到进位信息。

2. 分组并行进位

单级先行进位，即，组内并行，组间串行。因为全部都并行电路很复杂，所以采用这个方法。

多级先行进位，即组内并行，组间并行。

## ALU电路

既能完成算术运算又能完成逻辑运算的部件。

## 定点数加减运算

### 补码

两个数连同符号位一起相加，符号位产生的进位丢掉。减法则是把右边的加数变成相反数的补码再来相加。得到的结果也是补码。

### 符号扩展

将采用给定位数表示的数转换成具有更多位数的某种表示形式。

对于补码，正数用0填充，负数用1填充。

### 溢出判断

有两种情况，一种是正溢，即两个正数相加。一种是负溢，即两个负数相加。

1. 采用符号位判断。如果正数相加符号位变成1了，那么正溢。如果负数相加符号位变成0了，那么负溢。
2. 采用进位法。如果正数相加，最高有效位产生进位而符号位不产生进位，那么正溢。如果负数相加最高有效位不产生进位，而符号位产生进位，那么负溢。
3. 采用变形补码（双符号位补码，模4补码）。计算方法相同，都是相加然后进位。如果符号位为00，则为正数；11则为负数，01则为正溢，10则为负溢。
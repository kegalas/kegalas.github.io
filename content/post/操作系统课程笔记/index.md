---
title: "操作系统课程笔记"
date: 2024-01-01T20:01:20+08:00
draft: false
tags:
  - 大学
  - 操作系统
description: 本笔记不会涉及过深的操作系统知识，因为笔者在人工智能学院，本课程是选修。本笔记只会介绍操作系统有什么，后续笔者可能会研究操作系统的具体实现。
categories: 其他计算机科学
mathjax: true
markup: goldmark
image: cover.jpg
---

# 概论

除了老师在课上的PPT课件，我还参考了人民邮电出版社的《操作系统导论》中的内容。本笔记也会像书中一样分为三大板块，但是也会介绍一些其他内容例如系统安全。另外本课程讲的实在过于浅显，我之后可能会专门写《操作系统导论》的笔记。

## 什么是操作系统？

对于高层应用程序的程序员来说，操作系统就是一个扩展的机器，其隐藏对于硬件的操作的具体实现，提供简单易用的API、虚拟机等给程序员使用。

对于开发系统内核的程序员来说，它是一个资源管理器，负责管理CPU的分时复用、存储器的使用等等。协调各种程序的运行。

对于普通使用者来说，操作系统是用户使用计算机的界面（UI）。

比较正式地说，操作系统是控制和管理计算机硬件和软件资源、合理地组织和管理计算机的工作流程以方便用户使用的程序的集合。

![1.jpg](1.jpg)

![2.jpg](2.jpg)

## 引入操作系统的目的

- 方便：给用户提供一个硬件接口，易于操作
- 有效：以有效的方式使用软硬件资源
- 改善性能：组织计算机的工作流程，改善系统性能
- 提供扩展能力：方便引进新的功能

## 现代操作系统的特征

按照《操作系统导论》来说是虚拟化、并发、持久性。下面是PPT中的，个人感觉它没涉及持久性。

### 并发（concurrency）

并发指多个事件在同一时间段内发生。单个CPU核其实只能单独执行一个进程（即串行），我们可以让多个进程交替进行，只要交替得够快，宏观上就像在并发。OS就要完成这些并发过程的管理。

程序的静态实体是可执行文件，动态实体是进程，并发是进程在并发。

并发与并行（parallel）不同，并行是不存在交替过程的，是真正的同时进行。

### 共享（sharing）

计算机中的有限资源不再为某个用户独占，而是可以多个用户共享。OS就负责管理共享的时候如何分配管理。

有两种共享：

- 互斥共享。同一时间内某个资源只能最多有一个用户使用，使用完后别的用户才能用。例：打印机
- 非互斥共享。同一时间内某个资源可以有多个用户“同时”使用。同时并不是并行意义上的，而是并发意义上的。例：CPU、内存。

### 虚拟（virtual）

在并发的时候，切换执行的进程对进程本身是不可见的，它们都以为自己完整地占用了CPU。也就是说，一个物理CPU被虚拟化成多个逻辑CPU，每个进程一个。

虚拟分成分时复用（CPU）和分空间复用（存储器）。

### 不确定性（uncertainty）

也称为异步性（asynchronism）。指多个进程并发时，执行顺序的不确定，导致结果的不确定。

# 虚拟化

虚拟化主要分为虚拟化CPU和虚拟化内存。虽然虚拟化CPU会提到进程和并发的基础概念，但是这里主要讲进程调度，并发部分会主要讲锁。

## 进程

### 基本概念

程序的并发执行使得程序的执行成为一个动态的过程。程序更像是描述一个静态的可执行文件，于是引入进程来描述动态执行的程序。

这些并发的进程的特性为：程序执行的间断性；资源贡献；独立和合作（制约）性。

进程，直观地定义的话，就是执行中的程序。该进程可与其他进程并发执行；它是一个动态的实体，既是资源的基本分配单元，也是基本的执行单元。

**进程与程序的区别**

- 程序是静态的，是有序代码的集合。进程是动态的，是程序的一次执行。
- 程序是永久的，没有生命周期。进程是暂时的，有生命周期，会不断变化。
- 进程是操作系统资源分配和保护的基本单位，而程序不是。
- 进程与程序的结构不同

**进程与程序的联系**

- 通过多次执行，一个程序可以对应多个进程。
- 通过调用，一个进程可以包括多个程序。

![3.jpg](3.jpg)

### 组成成分

![4.jpg](4.jpg)

PCB包含的信息有：进程ID、用户ID、创建时间、父子进程关系等标识信息。CPU寄存器内容等现场信息。持有句柄、进程状态、信号量、调度信息、优先级等控制信息。

## 进程控制

OS对进程的控制和管理是通过操作系统内核中的原语实现的。

原语指的是原子操作，即该操作要么完全进行了，要么根本不进行，不存在进行了一半被打断的情况。原语的原子性主要是通过屏蔽中断保证的。

原语主要分为：进程控制原语、进程通信原语、资源管理原语、其他。常见的有：创建、撤销、阻塞、唤醒、挂起、激活等。

进程主要有三种状态

![5.jpg](5.jpg)

![6.jpg](6.jpg)

## 进程调度

进程调度关注的问题是：当有多个进程/线程准备就绪时，先执行哪一个？这又有两个子问题，什么时候进行这个决策？如何决策？

设计算法的时候，要同时考虑到系统和用户。对于系统来说，需要有公平性（不会有进程被饿死）和较大的吞吐量。对于用户来说，需要有及时性和较短的周转时间。

周转时间为

$$
T_{周转时间}=T_{完成时间}-T_{到达时间}
$$

而响应时间为

$$
T_{响应时间}=T_{首次运行}-T_{到达时间}
$$

**抢占式和非抢占式**

非抢占式调度意味着，一旦某个进程开始运行，那么直到该进程放弃CPU之前，操作系统只能干看着，无论后面有什么进程在等待。

抢占式意味着，操作系统非常愿意停止一个进程，然后运行新的进程，只要它觉得有必要。

### 先来先服务算法（FCFS）

也就是FIFO，也就是队列。让最早开始等待的进程占用CPU。非抢占式。

其有公平性，但是吞吐量、及时性、周转时间都很差。

### 最短任务优先（SJF）

就和小学经典的排队节水问题一样，接水最少的人最先。这里也是，执行时间最短的任务最先。

可以证明，如果所有任务同时到达，SJF是最优的调度算法（周转意义上）。但是没有这个前提，任务随机地在某个时间点到达（贴近现实），则可能会很差。比如一个超长的任务先到达，过了一两秒后两个很短的任务到达，那么这两个任务就会等很久，造成周转时间长。

这是一个非抢占式算法。

但是考虑到公平性，一个进程可以反复发起短时间的占用，最终占用了长时间的CPU。所以并不公平。

另外我们几乎不可能知道一个进程要占用多长时间。

### 最短完成时间优先（STCF）

在SJF最后的问题中，可能会立刻想到一个抢占式的算法，即让完成最快的任务先进行。显然是抢占式的。

可以证明，STCF在周转意义上是最优的。其他缺点同SJF。

### 基于优先数的调度算法

其给每个进程设置一个优先级，系统在调度的时候优先选择高优先级的进程。如果有相同的优先级则按照FCFS。

优先级有两种确定方法

- 静态优先数法：进程创建时就规定好优先级，运行时不改变
- 动态优先数法：进程的优先级在执行过程中可以改变

PPT没说优缺点，我估计是跟优先级的选择有关。

### 时间片轮转法（RR）

思想很简单，系统规定一个时间长度作为运行一个进程运行的时间，如果这段时间内进程没有运行完，则必须让出CPU然后回去排队。

显然，其及时性很好，但是周转时间很差。

老师的PPT还给出其公平性差，我不明白为什么，这是非常公平的算法。有其他资料印证我的想法。

### 多级反馈队列（MLFQ）

MLFQ中有许多独立的队列，每个队列有不同的优先级。每个任务只能存在于一个队列之中。MLFQ总是执行优先级较高的队列中的工作。优先级相同的工作则对他们使用轮转法。具体规则为：

1. 如果A的优先级>B的优先级，运行A
2. 如果A的优先级=B的优先级，轮转运行A和B
3. 任务进入系统时，放在最高优先级队列
4. 一旦任务用完了时间配额，就把它放入低一级队列
5. 经过一段时间S，将所有工作重新加入到最高优先级队列

Windows内核采用的就是这种算法的修改版

![11.jpg](11.jpg)

# 并发

## 线程

把进程介绍放到虚拟化，把线程介绍放到并发，并不是说进程不能并发，只是《操作系统导论》中API的介绍是这样安排的。我这里也一样。

### 基本概念

线程算是一种轻型的进程，是一个可执行的实体单元，是线代操作系统中处理器调度（执行）的基本单位。

**线程和进程的关系**

- 线程是进程的一个组成部分，线程由进程创建，一个进程中可以有多个线程。
- 进程是资源分配和保护的基本单位。每个进程都有自己独立的资源，而一个进程内的多个线程使用资源有很多是一样的，也即进程的资源。
- 所有线程的代码段和数据段是一样的，但是可以执行在不同的代码上
- 每个线程可独立运行也可以互相合作
- 每个线程的上下文是独立的，也即寄存器、栈等。

![7.jpg](7.jpg)

### 线程的实现方式

**用户态线程**

![8.jpg](8.jpg)

即进程自己管理线程。

优点：

- 线程对操作系统不可见，操作系统适应性强
- 线程切换快

缺点：

- 程序设计困难
- 并发度低

**内核态线程**

![9.jpg](9.jpg)

即操作系统来管理线程。

优点：实现简单，并发度高

缺点：执行效率低、资源消耗高

**混合模型**

![10.jpg](10.jpg)

## 进程通信

进程通信简单来说就是在进程间传输数据

![12.jpg](12.jpg)

![13.jpg](13.jpg)

**共享内存模式**

它是间接通信，是最快捷有效的方法之一。

![14.jpg](14.jpg)

**消息传递模式**

由发送方形成，通过一定的机制传递给接收方的一组信息，它的长度可以固定，也可以变化。和客户端-服务端的形式比较像。

消息也是分为消息头和消息体。就像HTTP请求一样。

![15.jpg](15.jpg)

![16.jpg](16.jpg)

**共享文件模式（管道）**

Linux的管道就是经典的例子。

管道是一种信息流缓冲机构，基于文件系统，可以连接两个进程，以FIFO的方式单向传送数据。

*匿名管道*

匿名管道是一种未命名的、单向管道。常用在父子进程之间。匿名管道是本地的，不能用在网络之间。匿名管道如果想要双向通信，通常会创建两个单向管道。

*命名管道*

命名管道是一种有名称的，可在本地或者网络间传输，支持可靠的单向或双向通信。

## 锁

- 临界区：是访问共享资源的一段代码，资源通常是一个变量或数据结构
- 竞态条件：出现在多个执行线程大致同时进入临界区时，它们都试图更新共享资源，达到了错误的结果
- 不确定性：程序里面有竞态条件，就会导致程序的输出不确定。
- 互斥原语：即可以把临界区原子化的操作

大致上，锁是这样用的

```cpp
lock();
a = a+1;
unlock();
```

### 控制中断

即在临界区关中断，防止调度程序切换线程。

```c
void lock(){
    DisableInterrupts();
}
void unlock(){
    EnableInterrupts();
}
```

缺点：

1. 恶意程序可以在lock之后死循环，让系统假死
2. 不支持多处理器
3. 导致中断丢失
4. 效率低

### 测试并设置（Test-And-Set）

```c
typedef struct lock_t{
    int flag;
} lock_t;

void init(lock_t *lock){
    lock->flag = 0; // 0代表未加锁，1代表加锁
}

void lock(lock_t *lock){
    while (TestAndSet(&lock->flag, 1)==1)
        ; //自旋
}

void unlock(lock_t *lock){
    lock->flag = 0;
}
```

测试并设置所要做的事是，当一个进程要进入临界区时，首先测试这把锁，如果锁的值为$0$，则设置为$1$并进入临界区。否则等待直到其变为$0$

结果意义上，等价于设置新值，返回旧值。其等价于如下c语言代码。

```c
int TestAndSet(int *old_ptr, int new){
    int old = *old_ptr;
    *old_ptr = new;
    return old;
}
```

注意，不能用C语言就实现锁，必须要有硬件的支持。上述测试并设置并不是原子的，可能会在中间中断。

幸运的是，操作系统提供这样的指令，如`HSL`和`XCHG`。

这个锁并不保证任何的公平性，线程可能会永远自旋。

另外，一直在自旋也会导致性能开销很大，CPU会一直处于忙等待（Busy waiting）状态

### 比较并交换（compare-and-exchange（swap））

也是需要硬件支持的。

```c
int CompareAndSwap(int *ptr, int expected, int new){
    int actual = *ptr;
    if(actual == expected)
        *ptr = new
    return actual;
}

void lock(lock_t *lock){
    while(CompareAndSwap(&lock->flag, 0, 1)==1)
        ;
}
```

如果只是实现简单的自旋锁，那么等价于测试并设置。

### 链接的加载和条件式存储指令

TODO

### 获取并增加

TODO

## 条件变量

TODO

## 信号量

### 生产者-消费者模型

TODO

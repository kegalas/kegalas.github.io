---
title: "微机原理学习笔记"
date: 2023-11-08T08:23:07+08:00
draft: true
tags:
  - 大学
  - 汇编
  - 组成原理
  - 计算机
description: x86汇编的常见规则、限制，以及x86硬件设计
categories: 其他计算机科学
mathjax: true
markup: goldmark
image: cover.jpg
---

# 绪论

![1.jpg](1.jpg)

![2.jpg](2.jpg)

# 数制与码制

在计组、数电中已经学过这部分内容，这里着重讨论硬件的操作。

## 有符号数加减运算的溢出

设次高位向最高位的进位标志为$C_p$，最高位和次高位进位相加的进位标志为$C_s$，则当且仅当$C_p\oplus C_s=1$时，计算溢出。

8086CPU中PSW的OF标志位表示有符号数运算是否溢出。

# CPU的结构和功能

## 外部结构

![3.jpg](3.jpg)

微处理器的外部结构表现为`数量有限的输入输出引脚`（共40个），这些引脚构成了微处理器级总线

这些引脚用来与存储器、IO设备交换信息，以及输入输出必要的信号。

通过分时复用技术，实现了引脚的复用。对于存储器，总共地址线为20条，寻址范围1M。对于IO设备则只有16条地址线。采用了独立编址的方式。控制线和数据线分别只有16条。也就是最大表示范围为$0\sim 2^{16}-1$

## 内部结构

![4.jpg](4.jpg)

## 功能结构

![5.jpg](5.jpg)

## 寄存器组织

### 通用寄存器

8086一共有8个通用寄存器，虽然通用并不意味着可以随便交换使用，还是有些操作只能用某个寄存器实现。

**数据寄存器**

一共有4个，分别叫AX，BX，CX，DX。每个都是16位大小的，但也可以拆成两个8位的使用。例如AH、AL分别表示AX的高8位、低8位。BH、BL表示BX的。

A的意思是Accumulator，即累加器。A在以前是8位寄存器，X代表miX，AX就为16位，而之后的EAX的E是Extend，为32位。再之后的RAX是64位。这些寄存器一般用来做运算操作。

B的意思是Base Register，基址寄存器，用于表示数据段的段内地址。

C的意思是Count Register，计数器，用于表示循环计数。

D的意思是Data Register，数据寄存器，用于表示IO端口的地址。

**地址指针与变址寄存器**

总共有4个，SP、BP、SI、DI。都是16位。前两个是地址指针

SP为Stack Pointer，堆栈指针，用于保存堆栈段的段内偏移地址。

BP为Base Pointer，基址指针，用于表示段内偏移地址，默认段地址由SS提供。

SI为Source Index，源变址寄存器。

DI为Destination Index，目的变址寄存器。

这两个寄存器用于字符串操作中，源操作数和目的操作数的段内偏移地址。

### 段寄存器

总共有4个，CS、DS、ES、SS。都是16位。

CS为Code Segment，代码段寄存器。用于保存当前执行程序的段地址，不能做被用户操作。

DS为Data Segment，数据段寄存器。用于保存数据段的段地址。

ES为Extra Segment，附加数据段寄存器。用于保存附加数据段的段地址。

SS为Stack Segment，堆栈段寄存器。用于保存堆栈段的段地址。

### 控制寄存器

总共有2个，IP、PSW。都是16位。

IP为Instruction Pointer，指令指针寄存器。始终指向下一条要执行的指令的偏移地址（段地址由CS提供）。相当于一般讨论中的程序计数器PC。IP的值不能被用户更改。

PSW为微处理器状态字。虽然有16位但是有用的只有其中9位。

![6.jpg](6.jpg)

其中CF、PF、AF、ZF、SF、OF这6个是状态标志，反应ALU运算后的结果状态。

TF、IF、DF这3个是控制标志，用来控制CPU的运行状态。

CF表示最高位有无进/借位标志，有进位为1。

PF表示第8位含有1的个数，偶数个为1，奇数个为0。

AF表示D3位有无进/借位，有则为1。D3为即为8位二进制的第3位（从0位开始算）

ZF表示运算结果是否为0，是则为1。

SF为符号位，和数字的符号位一致。即等于D7或者等于D15。

OF之前介绍过，表示是否溢出，是则为1。

DF为方向标志，在进行字符串操作时，CPU每执行一条串操作指令，对源或(与)目的操作数的地址会自动进行一次调整。当DF为0时，SI/DI自动递增；DF为1时，SI/DI自动递减。在汇编中CLD指令把DF置0，STD指令把DF置1。

IF为外部中断允许标志，IF为1时，CPU能响应外部可屏蔽中断，即开中断状态。IF为0时为关中断状态。显然可以推知，对内部中断和外部不可屏蔽中断不起作用。STI指令置1，CLI指令置0。

TF为陷阱标志。当TF=1时，CPU每执行完一条指令便自动产生一个内部中断(类型为1)，转去执行一个中断服务程序，用户可以借助中断服务程序来检查每条指令执行的情况，称为单步工作方式，常用于程序的调试(Debug)。没有专门的设置指令。

## 存储器和IO组织

8086有20条地址线。

对于存储器用了全部的20条，寻址范围为1M，最小单位为字节，所以总共的空间为1MB。地址范围为00000H~FFFFFH。

对于IO端口则只使用低16条，寻址范围为64K。

由于寄存器全都是16位的，要表述20位的地址，就要用到两个寄存器。这两个寄存器加起来可以有32位，所以所有地址都可以有多重表示方式。之后会介绍。

## 数据在存储器中的存储

**字节型数据**

例如指令`DB 5, -12, 'a'`，存放三个字节型数据，它们顺序存放在内存中。

![7.jpg](7.jpg)

**字型数据**

字是16位，即两个字节。其低8位放在低地址，高8位放在高地址。例如1234H放在内存中，指令为`DW 1234H`，内存中就是34，12。这也叫做小端序。

整个字型数据的地址是低字节的地址。8086字的地址可以从任何地方开始。当地址为偶地址时，称为对准的；地址为奇地址时，称为未对准的。

![8.jpg](8.jpg)

8086的数据总线为16位，所以存取一个字节只需要1个周期。而对于字，对准的需要1个周期，未对准的需要2个周期。

## 存储器的分段

由于寄存器全都是16位的，要表述20位的地址，就要用到两个寄存器。8086采用分段的方式，把地址空间分为若干个逻辑段。即20位地址表示为5位16进制数，例如12345H，1234H表示段地址，5H表示段内偏移。即高16位表示段地址，且每个段的起始地址可以被16整除（即XXXX0H可以被16整除）。

更具体的说，由于用两个寄存器表示，就可以写作1234H:0005H，前面的为段地址的寄存器，后面位段内偏移的寄存器。

显然的，这样操作，1MB的空间最多可以分为64K个段。每个段也最多可以有64KB的大小。但是我们最多也就1MB内存的大小，而不是64KB\*64K这么大的空间。我们几乎可以立即得到，段是可以重叠的，地址可以有多重表示方式。

事实上、$物理地址=段地址 \times 10H+偏移地址$。这样，00100H就可以表示为0000H:0100H和0010H:0000H，等等。

在硬件实现上，把段地址的寄存器（如CS、DS、ES、SS）的内容左移4位，加上偏移寄存器（如BX、BP、SP、SI、DI）中的内容，形成20位地址。

## 程序的分段存储

每个程序使用的内存可以分为三个段，即代码段、数据段、堆栈段。

![9.jpg](9.jpg)

其中代码段的物理地址由CS:IP表示，数据段由DS/ES:BX/SI/DI表示，堆栈段由SS:SP/BP表示。

# 8086汇编

## 语句类型

**指令**

每条指令都对应一条CPU能执行的语句，即对应一条机器语言。

**伪指令**

不对应机器语言的代码，CPU无法进行操作。只是给汇编器看的，告诉汇编器如何汇编。

**宏指令**

用户自定义的一条能完成某一特定功能的新指令，由指令和伪指令组成，在程序汇编时展开，用指令和伪指令替代宏指令

## 语句格式

`[名称:] 助记符 [操作数] [;注释]`

其中名称有点像C/C++里面的label，给goto用的那个label。为可选项。

助记符就是指令、伪指令、宏指令的名字。必选项。

操作数，具体要看助记符要使用什么操作。有时候没有操作数，算是可选项。

注释用`;`开头，可选项。

## 常数和表达式

常数分为数值常数和字符（串）常数。

二进制数以B结尾，八进制数以O结尾，十六进制数以0开头，H结尾。

字符串用单引号括住。

表达式用的符号有算术、逻辑、关系等

`+,-,*,/,MOD`是算术操作

`AND, OR, XOR, NOT`是逻辑操作（其实是按位运算，不是逻辑与或）

`EQ, NE, LT, GT, LE, GE`是关系操作

这些运算符只能给常量使用，不能给寄存器使用。变量名使用是把变量名当作其偏移地址常数使用。

另外，关系判断中，如果为真，则所有位全取1，为假则全取0.

## 名称（标号）

前面提到，名称和goto里使用的label差不多。以冒号结尾，其后半部分的语句可以在下一行也可以在同一行。

标号还有一些属性，例如可以代表标号所在段的段地址，在段内的偏移，以及其类型。其分为两类，如果标号只在本段内使用，则其为NEAR型，如果在段间使用，则为FAR型。

## 变量

变量是用伪指令来表达的。分为五种类型

- DB，1字节变量
- DW，字，即2字节变量
- DD，双字，即4字节变量
- DQ，长字，即8字节变量
- DT，10字节变量。

变量可以有名称，但是名称不需要冒号。一个伪指令可以包含多个数值，用逗号分隔。例如

```asm
VAR1 DB 12H, 0A5H, 18+20, 50/3, 0, -1
```

它是单字节的，在内存中存储如下（注意这里内存+1不像C语言的指针+1是偏移一整个类型，这里就是偏移一个字节）

|地址|内容|
|-|-|
|VAR1|12H|
|VAR1+1|A5H|
|VAR1+2|26H|
|VAR1+3|10H|
|VAR1+4|0|
|VAR1+5|FFH|

由于x86是小端序，在2字节存储时

```asm
VAR2 DW 12H,$+1
```

其在内存中为

|地址|内容|
|-|-|
|VAR2|12H|
|VAR2+1|00H|
|VAR2+2|09H|
|VAR2+3|00H|

此处`$`表示当前汇编语句的偏移地址（假设前面已经定义VAR1），可以看到，逗号分隔的前面的数值算做了2个字节的偏移。再加上前面的6个字节，`$`表示8，那么8+1=9；另外`$`的长度为字形
    
另外，可以用`?`表示保留空间，但不预先赋值

```asm
VAR3 DB ?, ?
```

利用DUP，可以表示重复的声明

```asm
VAR4 DB 3 DUP(?) ; 这一句保留了3个未赋值的DB
VAR5 DB 4 DUP(0FFH, ?) ; 而且内部参数是可以有多个的，就保存了四个0FFH, ?的数据
VAR6 DB 3 DUP(55H,2 DUP(77H)) ; 而且还可以嵌套
```

表达字符串时，只能用DB和DW

```asm
VAR7 DB 'ABCD' ; 其等价于DB 'A', 'B', 'C', 'D'或者DB 'ABC', 'D'等
VAR8 DW 'AB', 'C', 'D'
; DW型保存字符时，要么两个字符，要么一个字符，不能多
; 其仍然遵循小端序，即B在低位，A在高位。或者C在低位，00H填充高位
```

变量也有类型：段地址、段内偏移、类型、长度、大小。长度为第一个DUP前的系数（没有DUP则为1），大小不是占用空间大小，是类型乘以长度。类型即为变量字节数（1/2/4/8/10）。可以用伪代码获取这些属性，获取的都是立即数常数。

```asm
MOV AX, SEG    VAR1 ; 获取段地址
MOV AX, OFFSET VAR1 ; 获取段内偏移
MOV AL, TYPE   VAR1 ; 获取类型
MOV AX, LENGTH VAR1 ; 获取长度
MOV AL, SIZE   VAR1 ; 获取大小
```

## PTR操作符

TODO

## 数据寻址操作

即`MOV`命令。其格式如下

```asm
MOV DST, SRC
```

把SRC里的东西放到DST里。根据DST和SRC的不同可以有很多种MOV操作。

### 立即数寻址

```asm
MOV AX, 1200H
```

即源操作数为立即数。

### 寄存器寻址

```asm
MOV AX, BX
```

两个寄存器的大小要匹配。另外CS不能作为目的操作数。

### 直接寻址

```asm
MOV AX, [1200H]
```

其中`[]`括起来的东西代表偏移地址，其加上段寄存器（默认为DS）的段地址得到物理地址，再把物理地址里的东西给AX。

可以指定段寄存器

```asm
MOV AX, ES:[1200H]
```

SRC可以是变量

```asm
MOV AX, VAR1+5
```

其中是把`VAR1+5`对应的地址开始的一个字给AX

还可以把立即数给变量

```asm
MOV VAR1, 2500
```

### 寄存器间接寻址

```asm
MOV AX,[SI]
```

把SI中的数据当作段内偏移，加上段地址（默认为DS）得到物理地址，再把物理地址里的东西赋值给AX。

但是，`[]`中的寄存器只能是BX、SI、DI这三个

也可以反过来进行

```asm
MOV ES:[SI], AL
```

即把寄存器里的东西放到内存里。

注意：

1. 不能DST和SRC都表示内存单元
2. 不能直接把立即数当作SRC，内存当作DST，因为没有指定类型，应当：

```asm
MOV WORD PTR [DI], 12H
; 而不是 MOV [DI], 12H
```

### 寄存器相对寻址

和上面的寄存器间接寻址相比，其就是增加了常数偏移。形式为

$$
[REG\pm 常数],常数[REG],变量名[REG],变量名[REG\pm 常数]
$$

其中REG可以为BX、BP、SI、DI，相比间接寻址多了BP。

当偏移为常数时，段地址为段寄存器，BX、SI、DI默认为DS段，BP默认为SS段。

偏移有变量名时，段地址取变量的段地址。

例如

```asm
MOV BX, [SI+5]
MOV BX, 5[SI] ; 和上一行等同
MOV CX, VAR1[BX] ; 变量名意味着段地址以变量为准
MOV AL, VAR2[DI-15]
```

### 基址变址寻址

```asm
MOV DX, [BX][SI]
```

如上例，操作数在存储器中，其地址为一个基址寄存器和一个变址寄存器之和，即((BX)+(SI))为其内容。

其中基址寄存器可以是BX和BP，变址寄存器可以为SI和DI。当BX时，默认为DS段，BP时，默认为SS段。

### 基址变址且相对寻址

把上面的基址变址缝上相对寻址，即加上偏移

$$
[BX/BP\pm 常数][SI/DI\pm 常数],常数[BX/BP][SI/DI]
$$

$$
变量名[BX/BP][SI/DI],变量名[BX/BP\pm 常数][SI/DI\pm 常数]
$$

有变量名时段由变量决定。

### 隐含寻址

即操作码本身隐含（提前规定）了操作数地址。例如乘除、字符串操作指令

```asm
MUL BL ; AX <- AL x BL
MOVSB ; (ES:DI) <- (DS:SI), SI+-1, DI+-1
```

### 一般化的要求

1. CS不能做DST
2. 立即数不能直接给段寄存器
3. 存储单元不能直接到存储单元
4. 段寄存器不能直接到段寄存器
5. 立即数不能作为DST
6. 源和目的至少有一个类型明确
7. 源和目的都有类型时，类型必须一致

## 转移地址寻址操作

CPU要执行的指令的地址由CS:IP决定，即IP指向下一条要执行（取）的指令。CPU每执行一
条指令，IP自动增加，使之指向下一条指令。IP增加的值为当前指令的指令长度。

可以通过改变CS：IP的内容实现程序的跳转 。

如果程序转移后只有IP发生改变，则称为段内转移（近程、NEAR转移）。如果CS也改变，则称为段间转移（远程、FAR转移）。

两种转移都有间接和直接寻址。

### 段内直接寻址

```asm
JMP LABEL
```

直接用标号给出地址（是16位大小的偏移地址），且标号应与该指令在同一个段。也可以直接给出偏移地址，例如用常数。但是不能用变量，变量算地址保存在存储器中。

实际汇编后，其会把IP修改为，JMP指令的下一条指令的IP+16位偏移的形式。16位偏移是汇编器直接在编译期转化为常数的。

但是，段内偏移和JMP指令的偏移是不同的，段内偏移就是内存物理地址中的那个段内偏移，我们明文写给JMP的地址是这个，但是JMP生成的机器码，其偏移是下一行指令的地址加上的一个偏移，可正可负。

### 段内间接寻址

```asm
JMP BX
JMP VAR1 ; VAR1为字型变量
JMP VAR1[SI]
```

诸如此类，16位偏移地址保存在寄存器或存储单元里。之前介绍的各种存储器寻址方式都可以在这里使用。

同前，我们写的16位偏移是段内偏移，但是JMP对应的机器码是相对于下一行指令地址的偏移。

### 段间直接寻址

```asm
JMP LABEL
```

其中LABEL和当前指令不在一个段。LABEL给出了16位段地址和16位段内偏移。

### 段间间接寻址

```asm
JMP VAR3 ; VAR3是双字变量，第一个字为段内偏移，第二个字为段地址
JMP VAR3[SI] ; 有效地址为(SI)+VAR3
```

也可以采用之前的存储器寻址方式。

### 转移指令

无条件转移：JMP、CALL、RET、IRET

条件转移：JZ、JC、JCXZ、LOOP等

## 程序结构

### 段定义伪指令

```asm
<段名> SEGMENT (定位类型)(组合类型)(类别)
    ...
    段体
    ...
<段名> ENDS
```

段名和普通的名称一致，具有段地址、偏移地址、定位类型、组合类型、类别五个属性

**定位类型**

|定位类型|段起始地址（2进制）|段起始地址（16进制）|特性|含义|
|-|-|-|-|-|
|PAGE(页)|xxxx xxxx xxxx 0000 0000|xxx00H|可以被256整除|本段从页的边界开始|
|PARA(节，默认)|xxxx xxxx xxxx xxxx 0000|xxxx0H|可以被16整除|本段从段的边界开始|
|PAGE(页)|xxxx xxxx xxxx xxxx xxx0|/|可以被2整除|本段从偶地址开始|
|PAGE(页)|xxxx xxxx xxxx xxxx xxxx|xxxxxH|起始为任意地址|起始为任意地址|

**组合类型**

NONE：表示本段与其他段不发生任何关系，该段有自己的段基址，是默认的组合关系。

PUBLIC：在满足定位类型的前提下与其他模块的同名段连接在一起，形成一个新的逻辑段，共用一个段基址。

COMMON：表示产生一个覆盖段。连接时，把本段与其他同名段置成相同的起始地址，重叠在一起，共享相同的存储区，其段长度由最长的段确定。

STACK：在每个汇编程序中，只能且必须有一个堆栈段，连接时，将本段与其同名段连接成一个连续的STACK段，汇编程序自动初始化SS和SP寄存器，使SS的内容为该连续段的段基址，SP指向堆栈底部加1的存储单元。

MEMORY： 表示本段在存储器中应定位在所有其他段的最高地址。

AT<表达式>：表示本段从表达式指定的地址处开始装入，这样，在程序中用户就可以直接定义段地址，这种方式不适用于代码段。

**类别**

如代码段（'CODE'）、数据段（'DATA'）、堆栈段（'STACK'），注意包括单引号，其本质是字符串。也允许自定义类别，方便连接同类别的段。

### ASSUME伪指令

```asm
ASSUME 段寄存器:段名[, 段寄存器2:段名2, ...]
```

通知寄存器把哪个段寄存器当作哪个段的寄存器，例如

```
CODE SEGMENT
    ASSUME CS:CODE, DS:DATA, SS:STACK
```

注意：当程序运行时，DOS的程序加载器(Loader)负责把CS、IP、SS、SP初始化成正确的段地址和段内偏移地址（如果设定了合适的组合类型），因此用户在程序中就不必设置。但是，在用户程序中必须用两条指令对DS和ES进行初始化，以装入用户的数据段段地址。

```asm
CODE SEGMENT
    ASSUME CS:CODE, DS:DATA, SS:STACK
    MOV AX, DATA ; DATA为段名，为立即数寻址
    MOV DS, AX
```

### END伪指令

```asm
END 表达式
```

该伪指令表示整个源程序的结束，其表达式的值为该程序运行时的启动地址，它通常是第一条可执行语句的标号（例如START:）。

### PAGE伪指令

```asm
PAGE 参数1, 参数2
```

该伪指令可以为汇编过程产生的列表文件指定每页的行数“参数 1”和每行的字符数“参数 2”。

### TITLE伪指令

```asm
TITLE 正文
```

该伪指令可以为汇编过程产生的列表文件指定一个标题“正文”，它不能超过 60 个字符。在列表文件的每一页的第一行将打印出这个标题。

### LABEL伪指令

```
名称 LABEL 类型
```

该伪指令用来定义变量或标号的类型，它具有段地址与偏移地址的属性，但它并不占用内存单元。

如果名称为变量名，其类型主要有三种：BYTE、WORD、DWORD

如果名词为标号，其类型主要有两种：NEAR、FAR

### EQU伪指令和“=”伪指令

```
名称 EQU 表达式
```

很类似C语言的#define，即给表达式一个名称，可以在程序里随地替换。

但是EQU定义的名称不能重复。而

```
名称=数值
```

可以重复定义，值为最近一次定义的值

### ORG伪指令

```
ORG 表达式
```

该伪指令用于为后续指令指定段内偏移地址，可以方便地将程序存入适当的地址，这一点对中断设计非常有用。

## 程序的加载和运行

当用户编写的程序在必须加载到内存中从才能运行，这是由操作系统的程序加载器（Loader）实现的，其具体工作包括：
- 决定使用存储器哪一部分的内存
- 初始化SS:SP和CS:IP(程序的第1条指令的位置)

当加载到内存的程序在计算机中运行时，计算机的控制由操作系统（OS）交给用户程序，当用户程序运行结束后，应再将控制权交回操作系统，可由系统中断程序中INT 21H的4C号程序实现。

用户程序的代码前一定有100个字节的程序段前缀(Program Segment Prefix, 简称PSP)，PSP给
出了用户的可执行文件(.EXE)的若干控制信息。

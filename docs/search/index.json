[{"content":"第一部分 第一篇 协和和弦——三和弦 第一章 大调式三和弦 自然大调的七个三和弦中，I、IV、V是大三和弦，II、III、VI是小三和弦，VII是减三和弦。\nI级上的三和弦称之为主和弦，IV上的为下属和弦，V上的称为属和弦。\n按功能分，主和弦组：I、VI；属和弦组：V、III；下属和弦组：IV、II；\n第二章 大调式三和弦的连接 对于初学者来说，根据低音写出另外三个声部的音，应当重复根音。\n除相邻的音级上建立的三和弦，任意两个三和弦至少有一个共同音。\n对于初学者，链接两个三和弦应当将共同音保持，不是共同音的音按照最近的方式排列；\n显然旋律音的位置受到共同音的影响，但是根音可以较为自由的上行或下行，如果一定要在六度跳进或是三度进行中做出选择，那后者应该更好。\n第三章 无共同音的三和弦连接 不允许有两个声部间出现平行五度和平行八度。按照之前的共同音保持法链接，显然不会出现平行五八。但如果两个和弦间没有共同音，则上方声部的音应当和根音做反向进行。并且上方声部的两个和弦之间，音的排列顺序不能相同。\n第四章 打破三和弦连接规则 打破规则的原因：如果坚持规则可能会导致某一声部的音太高。\n要注意的有：\n  两个三和弦，上方声部连接时不能保持同样的音的排列顺序，否则必然出现平行五八。\n  最上方声部不能跳进超过四度。\n  低声部和高声部要反向进行，防止出现隐伏五八度。当两个声部通向进行到五度或八度，则会构成隐伏五八度。（注意高声部内部也不要出现隐伏五度）。\n  不允许违背规则的情况：\n  属和弦进行到主和弦时，如果属和弦的三音即导音位于最高声部，必须上行到主音。如果导音在内声部，可以下行三度进行。\n  主和弦到下属和弦时，主和弦的三音类似导音，处理方式同上。\n  第五章 和声模进 模进动机保持相同的声部排列位置。\nVII是减三和弦，使用的时候要特别谨慎，但在和弦模进中，它是允许的，因为可以作为动机重复和模进进行。\n当然减三和弦还可以作为两个和弦的经过和弦。这种连接必须同一声部保留共同音。\n第六章 小调式和声 小调式和声建立在和声小调之上。除七音升高半音外，其他与平行大调音阶上的音相同。\n和声小调上的三和弦：小三和弦：I、IV；大三和弦V、VI；减三和弦：II、VII；增三和弦：III。\n和声小调的和弦连接也应当遵从前面的规则。\n不协和和弦（除小三和大三）要有预备，可以与两个相邻的三和弦作正确连接，或是作为一个动机内的和弦。\n不协和和弦连接具体如下：\n  VII级通常连到V级，而不连到II和IV级，因为此时会出现增二度进行，及其不悦耳。\n  II级可以与IV、V、VI连接，但要避免隐伏五八、增二度进行；减三和弦与属三和弦连接时，上方三声部与低声部作反向进行就不会出现增二度。\n  III级与I、V、VI连接不会有问题。\n  任何时候都要避免使用增二度。因此，导音（属和弦三音）要上行解决到VI级三和弦时，VI级三和弦应当重复三音。当VI进行到V时（比较少见），也应当重复VI的三音。\n第七章 密集排列与开放排列 声部之间的音排列比较密集，成为密集排列。否则称为开放排列。\n将密集排列改写为开放排列时，注意要一个声部整体移动八度，不能出现声部更换，也不能出现声部超越。\n第八章 三和弦的转位 将根音转移到上方其他声部，低声部不是根音的三和弦，被称为和弦的转位。\n第一转位，即最低声部为三音，被称为三六和弦，简称六和弦。\n第二转位，即最低声部为五音，被称为四六和弦。\n原位和弦因为具有纯五度，音响协和程度要高于两个转位和弦。\n和弦通常重复根音或者五音，重复三音不够自然，仅用在一些特殊位置（如可以获得更好的声部进行）。\n我们常常会碰到连续的六和弦级进进行。这种情况最好让两个声部与低音作同向进行，另一声部作反向进行。如果低音上行，首先重复五音；如果低音下行，首先重复根音。\n如果是属六和弦进行到主和弦，那么属六和弦的三音不能重复，因为其是导音。\n第九章 减三和弦与增三和弦的转位 减三和弦的第一转为接近协和和弦，所以用的比原位多。\n减六和弦与其他和弦的连接分为两种情况\n  在主和弦之前。减三和弦的根音，即导音，必须上行解决，因为它不能重复。最好重复五音，偶尔可以重复三音。由于导音在任何时候都必须解决到主音，因此减三和弦中的五音位于根音上方时，不能上行，否则必定会出现禁止进行（平行五度）(所以必须让在根音上方的五音下行)。因此，我们必须避免减六和弦中的两个五音都位于根音上方(这样会导致两个五音之后一个上行一个下行)。\n  除主和弦外的其他和弦之前。大多数重复根音（就像其他六和弦一样），因为这里根音不作为导音。\n  小调中II级上的减六和弦也遵从这些规则。\n第二篇 不协和和弦——七和弦和九和弦 七和弦和九和弦都不是独立的和弦，都需要有准备，并要合理地进行到后面的和弦。不协和和弦进行到协和和弦，被称为“解决”。每一个七和弦都必须要解决到三和弦上。\n第十章 属七和弦 所有七和弦中，最重要，最常用的是V级上的七和弦，即属七和弦。属七和弦解决到主和弦。\n属七和弦的解决方式：七音级进下行解决到主和弦的三音。五音级进上行或下行解决到主和弦的三音或根音，更多解决到根音。三音（即导音）级进上行到主音，根音四度上行或五度下行到主和弦的根音。\n属七和弦的解决会产生缺五音的不完全主和弦。\n","date":"2021-12-31T22:44:43+08:00","permalink":"https://kegalas.top/p/%E5%AE%9E%E7%94%A8%E5%92%8C%E5%A3%B0%E5%AD%A6%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"《实用和声学指南》读书笔记"},{"content":"函数与极限 等价无穷小 当$x\\to 0$时，有\n$$ sinx\\sim x\\qquad tanx\\sim x\\qquad ln(1+x)\\sim x\\qquad e^x-1\\sim x $$\n$$ arcsinx\\sim x\\qquad arctanx\\sim x\\qquad log_a(1+x)\\sim \\frac{x}{lna} $$\n$$ x-ln(1+x)\\sim \\frac{1}{2}x^2\\qquad 1-cosx\\sim\\frac{1}{2}x^2\\qquad ln(x+\\sqrt{1+x^2})\\sim x $$\n$$ x-sinx\\sim \\frac{1}{6}x^3\\qquad tanx-x\\sim \\frac{1}{3}x^3\\qquad (1+x)^a-1\\sim ax $$\n$$ arcsinx-x\\sim \\frac{1}{6}x^3\\qquad x-arctanx\\sim\\frac{1}{3}x^3\\qquad tanx-sinx\\sim\\frac{1}{2}x^3 $$\n两个重要极限 $$ \\lim_{x\\to 0}\\frac{sinx}{x}=1 $$\n$$ \\lim_{x\\to \\infty}(1+\\frac1x)^x=e $$\n间断点的分类 第一类间断点 如果$x_0$是函数的间断点，且左极限$f(x_0^-)$及右极限$f(x_0^+)$都存在。\n  若左极限和右极限相等，但不等于该点函数值或函数在该点无定义，则称为可去间断点。\n  若左极限右极限不相等，则称为跳跃间断点。\n  第二类间断点 不是第一类间断点的任何间断点称之为第二类间断点，包含震荡间断点，无穷间断点等。\n部分函数及其图像 双曲函数 $$ sh\\ x=\\frac{e^x-e^{-x}}{2}\\qquad ch\\ x=\\frac{e^x+e^{-x}}{2}\\qquad th\\ x=\\frac{sh\\ x}{ch\\ x}=\\frac{e^x-e^{-x}}{e^x+e^{-x}} $$\n函数图像如下\n \n其常用公式如下：\n$$ sh(x+y)=sh\\ xch\\ x+ch\\ xsh\\ y $$\n$$ sh(x-y)=sh\\ xch\\ x-ch\\ xsh\\ y $$\n$$ ch(x+y)=ch\\ xch\\ x+sh\\ xsh\\ y $$\n$$ ch(x-y)=ch\\ xch\\ x-sh\\ xsh\\ y $$\n$$ ch^2x-sh^2x=1\\qquad sh\\ 2x=2sh\\ xch\\ x\\qquad ch\\ 2x=ch^2x+sh^2x $$\n反双曲函数如下\n$$ arsh\\ x=ln(x+\\sqrt{x^2+1}) $$\n$$ arch\\ x=ln(x+\\sqrt{x^2-1}) $$\n$$ arth\\ x=\\frac{1}{2}ln\\frac{1+x}{1-x} $$\n部分三角函数和反三角函数 $cot\\ x,sec\\ x,csc\\ x$的函数图像如下\n \n \n \n反三角函数图像如下\n \n三角函数公式 和差化积 ​ $$sin\\alpha+sin\\beta=2sin\\frac{\\alpha+\\beta}{2}\\cdot cos\\frac{\\alpha-\\beta}{2}$$ ​ $$sin\\alpha-sin\\beta=2cos\\frac{\\alpha+\\beta}{2}\\cdot sin\\frac{\\alpha-\\beta}{2}$$ ​ $$cos\\alpha+cos\\beta=2cos\\frac{\\alpha+\\beta}{2}\\cdot cos\\frac{\\alpha-\\beta}{2}$$ ​ $$cos\\alpha-cos\\beta=-2sin\\frac{\\alpha+\\beta}{2}\\cdot sin\\frac{\\alpha-\\beta}{2}$$\n积化和差 ​ $$sin\\alpha cos\\beta=\\frac{1}{2}\\left[sin(\\alpha+\\beta)+sin(\\alpha-\\beta)\\right]$$ ​ $$cos\\alpha sin\\beta=\\frac{1}{2}\\left[sin(\\alpha+\\beta)-sin(\\alpha-\\beta)\\right]$$ ​ $$cos\\alpha cos\\beta=\\frac{1}{2}\\left[cos(\\alpha+\\beta)+cos(\\alpha-\\beta)\\right]$$ ​ $$sin\\alpha sin\\beta=-\\frac{1}{2}\\left[cos(\\alpha+\\beta)-cos(\\alpha-\\beta)\\right]$$\n半角公式 ​ $$sin\\frac{\\theta}{2}=\\pm \\sqrt{\\frac{1-cos\\alpha}{2}}$$ ​ $$sin\\frac{\\theta}{2}=\\pm \\sqrt{\\frac{1+cos\\alpha}{2}}$$ ​ $$tan\\frac{\\theta}{2}=\\pm \\sqrt{\\frac{1-cos\\alpha}{1+cos\\alpha}}=\\frac{sin\\alpha}{1+cos\\alpha}=\\frac{1-cos\\alpha}{sin\\alpha}$$\n辅助角公式 ​ $$asin\\theta\\pm bcos\\theta=\\sqrt{a^2+b^2}sin(\\theta\\pm\\varphi),\\quad tan\\varphi=\\frac{b}{a}$$\n$sin\\ x$和$cos\\ x$的$tan\\ \\frac x2$有理式表示 $$ sin\\ x=\\frac{2tan\\frac x2}{1+tan^2\\frac x2} $$\n$$ cos\\ x=\\frac{1-tan^2\\frac x2}{1+tan^2\\frac x2} $$\n导数与微分 反函数求导 如果函数$x=f(y)$在区间$I_y$内单调、可导且$f'(y)\\ne 0$，那么它的反函数$y=f^{-1}(x)$在区间$ I_x = \\{ x | x = f(y) , y\\in I_y \\} $内也可导，且\n$$ [f^{-1}(x)]'=\\frac{1}{f'(y)}\\quad or \\quad \\frac{dy}{dx}=\\frac{1}{\\frac {dx}{dy}} $$\n部分常用导数 $$ (tan\\ x)'=sec^2x\\qquad (cot\\ x)'=-csc^2x $$\n$$ (sec\\ x)'=sec\\ xtan\\ x\\qquad (csc\\ x)'=-csc\\ xcot\\ x $$\n$$ (a^x)'=a^xlna(a\u0026gt;0,a\\ne 1)\\qquad (log_ax)'=\\frac{1}{xlna} $$\n$$ (arcsin\\ x)'=\\frac{1}{\\sqrt{1-x^2}}\\qquad (arccosx)'=-\\frac{1} {\\sqrt{1-x^2}} $$\n$$ (arctan\\ x)'=\\frac{1}{1+x^2}\\qquad (arccotx)'=-\\frac{1}{1+x^2} $$\n$$ (sh\\ x)'=ch\\ x,\\ (ch\\ x)'=sh\\ x,\\ (th\\ x)'=\\frac{1}{ch^2x} $$\n$$ (arsh\\ x)'=\\frac{1}{\\sqrt{x^2+1}},\\ (arch\\ x)'=\\frac{1}{\\sqrt{x^2-1}}, \\ (arth\\ x)'=\\frac{1}{1-x^2} $$\n参数方程求导 对如下参数方程\n$$ x = \\varphi (t),\\ y = \\psi (t) $$\n求导得\n$$ \\frac{dy}{dx}=\\frac{dy}{dt}\\cdot \\frac{1}{\\frac{dx}{dt}}= \\frac{\\psi'(t)}{\\varphi'(t)} $$\n中值定理 罗尔定理 如果函数$f(x)$满足\n（1）在闭区间$[a,b]$上连续\n（2）在开区间$(a,b)$内可导\n（3）在区间端点处的函数值相等，即$f(a)=f(b)$,\n那么在$(a,b)$内至少有一点$\\xi\\ (a\u0026lt;\\xi\u0026lt;b)$，使得$f'(\\xi)=0.$\n拉格朗日中值定理 如果函数$f(x)$满足\n（1）在闭区间$[a,b]$上连续；\n（2）在开区间$(a,b)$内可导，\n那么在$(a,b)$内至少有一点$\\xi (a\u0026lt;\\xi\u0026lt;b)$，使等式\n$$ f(b)-f(a)=f'(\\xi)(b-a) $$\n成立\n柯西中值定理 如果函数$f(x)$及$F(x)$满足\n（1）在闭区间$[a,b]$上连续\n（2）在开区间$(a,b)$内可导\n（3）对任一$x\\in(a,b),F'(x)\\ne0$\n那么在$(a,b)$内至少有一点$\\xi$，使等式\n$$ \\frac{f(b)-f(a)}{F(b)-F(a)}=\\frac{f'(x)}{F'(x)} $$\n成立\n泰勒公式 在$x_0$处展开如下\n$$ f(x)=f(x_0)+f'(x_0)(x-x_0)+\\frac{f''(x_0)}{2!}(x-x_0)^2+\\dots+ \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x) $$\n皮亚诺余项 $$ R_n(x)=o((x-x_0)^n) $$\n拉格朗日余项 $$ R_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-x_0)^{(n+1)} $$\n这里$\\xi$是$x_0$与$x$之间的某个值\n曲率 弧微分公式 $$ ds=\\sqrt{1+y'^2}dx $$\n曲率表达式 对于$y=f(x)$，曲率$K$为\n$$ K=\\frac{|y''|}{(1+y'^2)^{3/2}} $$\n对于$x = \\varphi (t),y = \\psi (t)$，有\n$$ K=\\frac{|\\varphi'(t)\\psi''(t)-\\varphi''(t)\\psi'(t)|}{[\\varphi'^2(t)+ \\psi'^2(t)]^{3/2}} $$\n曲率圆与曲率半径 曲率半径与曲率的关系\n$$ \\rho = \\frac{1}{K},\\ K=\\frac{1}{\\rho} $$\n曲率中心$D(\\alpha,\\beta)$\n$$ \\alpha = x-\\frac{y'(1+y'^2)}{y''},\\quad \\beta = y+\\frac{1+y'^2}{y''} $$\n不定积分 常用积分表 $$ \\int\\frac{dx}{1+x^2}=arctan\\ x+C,\\quad \\int\\frac{dx}{\\sqrt{1-x^2}} =arcsin\\ x+C $$\n$$ \\int\\frac{dx}{cos^2x}=\\int{sec^2x}dx=tan\\ x+C,\\quad\\int\\frac{dx}{sin^2x}= \\int csc^2xdx=-cot\\ x+C $$\n$$ \\int sec\\ xtan\\ xdx=sec\\ x+C,\\quad \\int csc\\ xcot\\ xdx=-csc\\ x+C $$\n$$ \\int sh\\ xdx=ch\\ x+C,\\quad \\int ch\\ xdx=sh\\ x+C $$\n$$ \\int tan\\ xdx=-ln|cos\\ x|+C,\\quad \\int cot\\ xdx=ln|sin\\ x|+C $$\n$$ \\int sec\\ xdx=ln|sec\\ x+tan\\ x|+C,\\quad \\int csc\\ xdx=ln|csc\\ x-cot\\ x|+C $$\n$$ \\int \\frac{dx}{a^2+x^2}=\\frac{1}{a}arctan\\frac{x}{a}+C,\\quad \\int \\frac{dx}{x^2-a^2}=\\frac{1}{2a}ln\\left |\\frac{x-a}{x+a}\\right |+C $$\n$$ \\int \\frac{dx}{\\sqrt{a^2-x^2}}=arcsin\\frac xa+C,\\quad \\int \\frac{dx}{\\sqrt{x^2+a^2}}=ln(x+\\sqrt{x^2+a^2})+C $$\n$$ \\int \\frac{dx}{\\sqrt{x^2-a^2}}=ln|x+\\sqrt{x^2-a^2}|+C $$\n换元积分法 第一类换元法 设$f(u)$具有原函数，$u=\\varphi(x)$可导，则有换元公式\n$$ \\int f[\\varphi(x)]\\varphi'(x)dx=\\left[\\int f(u)du \\right]_{u=\\varphi(x)} $$\n设要求$\\int g(x)dx$，如果$g(x)$可以化为$g(x)=f[\\varphi(x)]\\varphi'(x)$的形式，那么\n$$ \\int g(x)dx= \\int f[\\varphi(x)]\\varphi'(x)dx=\\left[\\int f(u)du \\right]_{u=\\varphi(x)} $$\n第二类换元法 设$x=\\psi(t)$是单调的可导函数，并且$\\psi'(t)\\ne 0$.又设$f[\\psi(x)]\\psi'(x)dx$具有原函数 ，则有换元公式\n$$ \\int f(x)dx= \\left[\\int f[\\psi(t)]\\psi'(t)dt\\right]_{t=\\psi^{-1}(x)} $$\n分部积分法 设函数$u=u(x)$及$v=v(x)$具有连续导数，则有\n$$ \\int uv\u0026rsquo;dx=uv-\\int u\u0026rsquo;vdx $$\n定积分 积分上限的函数的导数 若\n$$ \\Phi(x)=\\int_{a}^{x}f(t)dt $$\n则\n$$ \\Phi'(x)=f(x) $$\n若\n$$ \\Phi(x)=\\int_{a}^{g(x)}f(t)dt $$\n则\n$$ \\Phi'(x)=f(g(x))g'(x) $$\n定积分在几何学上的应用 平面图形的面积 直角坐标 例如，以$x$为积分变量，求$f(x)$及直线$x=a$, $x=b$与$x$轴围成的曲边梯形的面积\n$$ A=\\int_a^bf(x)dx $$\n以y为积分变量，则求的是两直线、函数、与$y$轴围成的曲边梯形的面积\n极坐标 $$ dA=\\frac12(\\rho(\\theta))^2d\\theta $$\n$$ A=\\int_\\alpha^\\beta\\frac12[\\rho(\\theta)]^2d\\theta $$\n体积 旋转体的体积 $$ V=\\int_a^b\\pi[f(x)]^2dx $$\n平行截面面积为已知的立体的体积 $$ V=\\int_a^bA(x)dx $$\n平面曲线的弧长 参数方程 $x=\\varphi(t),\\quad y=\\psi(t).\\quad(\\alpha\\leq t\\leq\\beta)$\n$$ s=\\int_\\alpha^\\beta\\sqrt{\\varphi'^2(t)+\\psi'^2(t)}dt $$\n直角坐标 $$ s=\\int_a^b\\sqrt{1+y'^2}dx $$\n极坐标 $$ s=\\int_\\alpha^\\beta\\sqrt{\\rho^2(\\theta)+\\rho'^2(\\theta)}d\\theta $$\n微分方程 齐次方程 如果一阶微分方程可化成\n$$ \\frac{dy}{dx}=\\varphi\\left(\\frac yx\\right) $$\n的形式，那么就称这方程为齐次方程。在齐次方程中，引入新的未知函数$u=\\frac{y}{x}$，有\n$$ y=ux,\\ \\frac{dy}{dx}=u+x\\frac{du}{dx} $$\n$$ u+x\\frac{du}{dx}=\\varphi(u) $$\n用分离变量的办法求出关于$u$的积分，最后再以$\\frac yx$代替$u$.\n一阶线性微分方程  方法一  方程\n$$ \\frac{dy}{dx}+P(x)y=Q(x) $$\n的通解为\n$$ y=Ce^{-\\int P(x)dx}+e^{-\\int P(x)dx}\\int Q(x)e^{\\int P(x)dx}dx $$\n方法二  先求对应齐次方程\n$$ \\frac{dy}{dx}+P(x)y=0 $$\n的解，得到\n$$ y=Ce^{-\\int P(x)dx} $$\n将$C$替换为$u$，再对上解求导得$\\frac{dy}{dx}$，将其代入原非齐次方程，解出$u$，则\n$$ y=ue^{-\\int P(x)dx} $$\n可降阶的高阶微分方程   $y''=f(x,y')$型的微分方程\n设$y'=p$则$y''=\\frac{dp}{dx}=p'$，代入原方程中求解$p$，再求解$y$\n  $y''=f(y,y')$型的微分方程\n设$y'=p$\n$$ y''=\\frac{dp}{dx}=\\frac{dp}{dy}\\cdot\\frac{dy}{dx}=p\\frac{dp}{dy} $$\n代入原方程中求解$p$，再求解$y$\n  高阶线性微分方程 定理1 如果函数$y_1(x)$与$y_2(x)$是方程\n$$ y''+P(x)y'+Q(x)y=0 $$\n的两个特解，那么\n$$ y=C_1y_1(x)+C_2y_2(x) $$\n也是方程的解\n定理2 如果函数$y_1(x)$与$y_2(x)$是方程的两个线性无关的特解，那么\n$$ y=C_1y_1(x)+C_2y_2(x) $$\n就是 方程的通解\n定理3 设$y^*(x)$是方程\n$$ y''+P(x)y'+Q(x)y=f(x) $$\n的一个特解，$Y(x)$是该方程对应的齐次方程的通解，则\n$$ y=Y(x)+y^*(x) $$\n是该非齐次方程的通解\n定理4 设定理三种的非齐次线性方程的右端$f(x)$是两个函数之和，即\n$$ y''+P(x)y'+Q(x)y=f_1(x)+f_2(x) $$\n而$y_1^* (x)$与$y_2^*(x)$分别是方程\n$$ y''+P(x)y'+Q(x)y=f_1(x) $$\n与\n$$ y''+P(x)y'+Q(x)y=f_2(x) $$\n的特解，则$y_1^*(x)+y_2^ *(x)$就是原方程的特解\n常系数齐次线性微分方程 二阶形式如下 $$ y''+py'+qy=0 $$\n先求解如下方程\n$$ r^2+pr+q=0 $$\n分为三种情况\n  有两个不等实根$r_1,r_2$\n则通解为\n$$ y=C_1e^{r_1x}+C_2e^{r_2x} $$\n  有两个相等实根$r_{1,2}$\n则通解为\n$$ y=(C_1+C_2x)e^{r_1x} $$\n  有一对共轭复根\n$$ r_1=\\alpha+\\beta i,\\quad r_2=\\alpha-\\beta i $$\n$$ \\alpha=-\\frac{p}{2},\\quad \\beta=\\frac{\\sqrt{4q-p^2}}{2} $$\n则通解为\n$$ y=e^{\\alpha x}(C_1cos\\ \\beta x+C_2sin\\ \\beta x) $$\n  n阶形式如下 $$ y^{(n)}+p_1y^{(n-1)}+p_2y^{(n-2)}+\\dots+p_{n-1}y'+p_ny=0 $$\n其中$p_1\\dots p_n$都是常数。\n其特征方程如下\n$$ r^n+p_1r^{n-1}+\\dots+p_{n-1}r+p_n=0 $$\n分四种情况\n  单实根$r$，给出一项：$Ce^{rx}$\n  一对单负根$r_{1,2}=\\alpha\\pm\\beta i$，给出两项：$e^{\\alpha x}(C_1cos\\beta x+C_2sin\\beta x)$\n  k重实根r，给出$k$项：$e^{rx}(C_1+C_2x+\\dots+C_kx^{k-1})$\n  一对k重复根$r_{1,2}=\\alpha\\pm\\beta i$，给出$2k$项：$e^{\\alpha x}[(C_1+C_2x+\\dots+C_kx^{k-1})cos\\beta x+(D_1+D_2x+\\dots+D_kx^{k-1})sin\\beta x]$\n  常系数非齐次线性微分方程 二阶常系数非齐次线性微分方程的一般形式是\n$$ y''+py'+qy=f(x) $$\n求其通解只用求该方程的一个特解和上一节学到的求其对应齐次方程的通解，高数上册只介绍了$f(x)$的两种形式\n  $f(x)=e^{\\lambda x}P_m(x)$，其中$\\lambda$是常数，$P_m(x)$是$x$的一个$m$次多项式\n$$ P_m(x)=a_0x^m+a_1x^{m-1}+\\dots+a_{m-1}x+a_{m} $$\n  $f(x)=e^{\\lambda x}[P_l(x)cos\\omega x+Q_n(x)sin\\omega x]$，其中$\\lambda,\\omega$是常数，$\\omega\\ne0$，$P_l(x),Q_n(x)$分别是$x$的$l$次、$n$次多项式，且仅有一个可为零.\n  $f(x)=e^{\\lambda x}P_m(x)$型 $$ y^*=x^kR_m(x)e^{\\lambda x} $$\n其中 $R_m(x)$是与$P_m(x)$同次的多项式，而$k$按$\\lambda$不是特征方程(即$r^2+pr+q=0$)的根，是特征方程的单根或是特征方程的重根依次取值为0,1,2.\n其中$R_m(x)$中的每一个系数，应当代入原方程中进行计算。\n$f(x)=e^{\\lambda x}[P_l(x)cos\\omega x+Q_n(x)sin\\omega x]$型 $$ y^*=x^ke^{\\lambda x}[R^{(1)}_m(x)cos\\omega x+R^{(2)}_m(x)sin\\omega x] $$\n其中$R^{(1)}_m(x)$、$R^{(2)}_m(x)$是$m$次多项式，$m=max\\{l,n\\}$，而$k$按$\\lambda+\\omega i$(或$\\lambda-\\omega i$)不是特征方程的根、或是特征方程的单根依次取0或1\n","date":"2021-12-27T16:45:49+08:00","permalink":"https://kegalas.top/p/%E6%88%91%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A%E5%86%8C%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/","title":"我的高等数学上册资料整理"},{"content":"排序 只给出归并排序，有可能在求逆序对的时候用得上。其他时候排序用sort函数即可。\n归并排序 #include \u0026lt;stdio.h\u0026gt; void merge(long *num,long *tmp, int left, int mid_index ,int right){ int first=left, second = mid_index+1, tmp_index = left; while(first\u0026lt;mid_index+1\u0026amp;\u0026amp;second\u0026lt;right+1){ if(*(num+first)\u0026lt;*(num+second)){ tmp[tmp_index] = *(num+first); tmp_index++; first++; } else{ tmp[tmp_index] = *(num+second); tmp_index++; second++; } } while(first\u0026lt;mid_index+1){ tmp[tmp_index++] = *(num+first); first++; } while(second\u0026lt;right+1){ tmp[tmp_index++] = *(num+second); second++; } int i; for(i=left;i\u0026lt;=right;i++){ num[i]=tmp[i]; } return; } void merge_sort(long *num,long *tmp, int left, int right){ int mid_index; if(left\u0026lt;right){ mid_index = left + (right-left)/2;//这样写疑似可以避免int溢出  merge_sort(num,tmp,left,mid_index); merge_sort(num,tmp,mid_index+1,right); merge(num,tmp,left,mid_index,right); } return; } int main(){ int num_count; long num[20000]; long tmp[20000]; scanf(\u0026#34;%d\u0026#34;,\u0026amp;num_count); int i; for(i=1;i\u0026lt;=num_count;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;num[i]); } merge_sort(num,tmp,1,num_count); for(i=1;i\u0026lt;=num_count;i++){ printf(\u0026#34;%d \u0026#34;,num[i]); } return 0; } 技巧 快速幂 #include \u0026lt;iostream\u0026gt; using namespace std; long long binpow(long long n, long long p){ long long res = 1; while(p\u0026gt;0){ if(p\u0026amp;1){ res = res * n; } n *= n; p\u0026gt;\u0026gt;=1; } return res; } int main(){ long long n,p; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;p; cout\u0026lt;\u0026lt;binpow(n,p)\u0026lt;\u0026lt;endl; return 0; } 字符串 KMP #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;string\u0026gt; using namespace std; #define MAXN 1000005  int nxt[MAXN]; string s1,s2; int getNext(){ nxt[0]=0; int r = 1; int l = 0; while (r\u0026lt;s2.length()){ if (s2[l] == s2[r]){ nxt[r]=l+1; r++; l++; } else if (l){ l = nxt[l-1]; } else{ nxt[r]=0; r++; } } return 0; } int main(){ cin\u0026gt;\u0026gt;s1\u0026gt;\u0026gt;s2; getNext(); int pos=0,tar=0; while (tar\u0026lt;s1.length()) { if(s1[tar]==s2[pos]){ pos++; tar++; } else if (pos){ pos = nxt[pos-1]; } else{ tar++; } if (pos==s2.length()){ cout\u0026lt;\u0026lt;tar-pos+1\u0026lt;\u0026lt;endl; pos = nxt[pos-1]; } } for(int i=0;i\u0026lt;s2.length();i++){ cout\u0026lt;\u0026lt;nxt[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; return 0; } 字典树(Trie) #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt; #define MAXN 500005  using namespace std; int nxt[MAXN][26]; int cnt; void init(){ memset(nxt,0,sizeof(nxt)); cnt = 1; } void insert(string s){ int cur = 1; for(auto c:s){ if(!nxt[cur][c-\u0026#39;a\u0026#39;]){ nxt[cur][c-\u0026#39;a\u0026#39;]=++cnt; } cur = nxt[cur][c-\u0026#39;a\u0026#39;]; } } bool find_prefix(string s){ int cur=1; for(auto c:s){ if (!nxt[cur][c - \u0026#39;a\u0026#39;]) { return false; } cur = nxt[cur][c - \u0026#39;a\u0026#39;]; } return true; } int main(){ int n; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ string s1; cin\u0026gt;\u0026gt;s1; insert(s1); } while(1){ string s1; cin\u0026gt;\u0026gt;s1; cout\u0026lt;\u0026lt;find_prefix(s1)\u0026lt;\u0026lt;endl; } return 0; } 数论 扩展欧几里得 //求解ax+by=gcd(a,b)的一组解 //扩展欧几里得 #include \u0026lt;iostream\u0026gt; using namespace std; int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y){ if(!b){ x = 1; y = 0;//此时ax+by=gcd(a,b)中b=0，任何数与0的最大公约数是他本身，所以ax+0y=a，x=1 y=0  return a; } int d = exgcd(b, a%b, x, y); int t = x; x = y; y = t-(a/b)*y; return d; } int main(){ int a,b,x,y,z; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; z = exgcd(a,b,x,y); cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl; return 0; } 欧几里得算法 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ long long a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(a\u0026lt;b){ a=a+b; b=a-b; a=a-b; } long long ans = b; while((a%b)!=0){ long long tmp = a%b; a = b; b = tmp; ans = b; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } 欧拉筛 //欧拉筛 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#define MAXN 50005  using namespace std; int main(){ int n, prime[MAXN], cnt=0; bool is_not_prime[MAXN]; cin\u0026gt;\u0026gt;n; memset(is_not_prime, 0, sizeof(prime)); for (int i = 2;i\u0026lt;=n;i++){ if(!is_not_prime[i]) prime[++cnt] = i; for(int j = 1;j\u0026lt;=cnt\u0026amp;\u0026amp;i*prime[j]\u0026lt;=n;j++){ is_not_prime[i*prime[j]] = 1; if(i%prime[j]==0) break; } } for(int i = 1;i\u0026lt;=cnt;i++){ cout\u0026lt;\u0026lt;prime[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } Miller-Rabin素数测试 //miller-rabin #include \u0026lt;iostream\u0026gt;#include \u0026lt;ctime\u0026gt;#include \u0026lt;cstdio\u0026gt; using namespace std; const int cnt = 10; int qPowMod(int a, int m, int n){ if(m==0) return 1; if(m==1) return (a%n); long long ans = 1; //不打ll会溢出  while(m){ if(m\u0026amp;1){ ans = ans%n*a%n; } a = (long long)a%n*a%n;//这里不打ll会溢出导致判断错误  m\u0026gt;\u0026gt;=1; } return ans; } bool millerRabin(int n){ if(n==2) return true; for(int i=0;i\u0026lt;cnt;i++){ int a = rand() % (n-2) + 2; if(qPowMod(a,n,n)!=a) return false; } return true; } int main(){ srand(time(NULL)); int n; cin\u0026gt;\u0026gt;n; if(millerRabin(n)){ cout\u0026lt;\u0026lt;\u0026#34;Probably a prime\u0026#34;\u0026lt;\u0026lt;endl; } else{ cout\u0026lt;\u0026lt;\u0026#34;A composite\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } 乘法逆元 //乘法逆元 //分为扩展欧几里得法、快速幂法、线性求逆元 //ax≡1(mod b)，x为a在乘法意义上的逆元，记作a^(-1)，或者inv(a) //用扩展欧几里得法的角度看，就是求ax+by=1的整数解 //快速幂法利用费马小定理，需要b为素数  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt; using namespace std; const int MAXN = 3000005; int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y){ if(!b){ x=1; y=0; return a; } int d = exgcd(b,a%b,x,y); int tmp = x; x = y; y = tmp - a/b*y; return d; } void exgcd_inv(int a, int b){ int x,y; int d = exgcd(a,b,x,y); if(d!=1){//显然a，b要互质才会有逆元  cout\u0026lt;\u0026lt;\u0026#34;None\u0026#34;\u0026lt;\u0026lt;endl; } else{ cout\u0026lt;\u0026lt;(x+b)%b\u0026lt;\u0026lt;endl;//实际上是为了防止出现x为负数的情况  } } int qPowMod(int a, int n, int b){ int ans = 1; while(n){ if(n\u0026amp;1){ ans = ans%b*a%b; } a = a%b*a%b; n\u0026gt;\u0026gt;=1; } return ans; } void fermat_inv(int a, int b){ cout\u0026lt;\u0026lt;qPowMod(a,b-2,b)\u0026lt;\u0026lt;endl; } long long inv[MAXN]; int main(){ long long a,b,n; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; exgcd_inv(a,b); //fermat_inv(a,b);  /* //线性求逆元 inv[1] = 1; for(long long i = 2;i\u0026lt;=n;i++){ //inv[i] = -(b/i)*inv[b%i]; //这样写会出现负数 inv[i] = (long long)(b-b/i)*inv[b%i]%b; } for(long long i=1;i\u0026lt;=n;i++){ printf(\u0026#34;%lld\\n\u0026#34;,inv[i]); } */ return 0; } 线性同余方程 #include \u0026lt;iostream\u0026gt; using namespace std; int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y){ if(!b){ x=1; y=0; return a; } int d = exgcd(b, a%b, x, y); int tmp=x; x = y; y = tmp-a/b*y; return d; } int linearEquation(int a, int b, int c, int \u0026amp;x, int \u0026amp;y){ int d = exgcd(a,b,x,y); if(c%d!=0) return -1; x = x*c/d; y = y*c/d; return d; } int main(){ int a,b,c,x,y; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; c=1; int d = linearEquation(a,b,c,x,y); if(d==-1){ cout\u0026lt;\u0026lt;\u0026#34;None\u0026#34;\u0026lt;\u0026lt;endl; } else{ //cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  //下面输出的是最小整数解  int t = b/d; x = (x%t+t)%t; cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; } return 0; } 中国剩余定理 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; const int MAXN = 10005; long long a[MAXN],r[MAXN]; long long exgcd(ll a, ll b, ll \u0026amp;x, ll \u0026amp;y){ if(!b){ x=1; y=0; return a; } ll d = exgcd(b,a%b,x,y); ll tmp = x; x = y; y = tmp - (a/b)*y; return d; } int main(){ int k; cin\u0026gt;\u0026gt;k; for(int i=1;i\u0026lt;=k;i++){ cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;r[i]; } ll n=1,ans=0; for(int i=1;i\u0026lt;=k;i++){ n = n * r[i]; } for(int i=1;i\u0026lt;=k;i++){ ll m = n/r[i]; ll x,y; exgcd(m,r[i],x,y); ans = (ans+a[i]*m*x%n)%n; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } 图论 最短路 Dijkstra //dijkstra #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;queue\u0026gt;#define MAXN 500005 #define MAXINT 0x7fffffff  using namespace std; struct edge{ int v,w;//下一点，权 }; struct node { int dis, u; bool operator\u0026gt;(const node\u0026amp; a) const { return dis \u0026gt; a.dis; } }; int n,m,s;//点，边，起点  vector\u0026lt;edge\u0026gt; graph[MAXN]; int dis[MAXN]; bool tag[MAXN]; priority_queue\u0026lt;node, vector\u0026lt;node\u0026gt;, greater\u0026lt;node\u0026gt; \u0026gt; pq; int main(){ //freopen(\u0026#34;in.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);  //freopen(\u0026#34;out.out\u0026#34;,\u0026#34;w\u0026#34;,stdout);  scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;s); for(int i=1;i\u0026lt;=m;i++){ int a,b,c; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c); edge t; t.v=b; t.w=c; graph[a].push_back(t); } for(int i=1;i\u0026lt;=n;i++){ dis[i] = MAXINT; } dis[s]=0; node tmp; tmp.dis=0; tmp.u=s; pq.push(tmp); while (!pq.empty()) { int u = pq.top().u; pq.pop(); if(tag[u]) continue; tag[u]=1; for(auto g : graph[u]){ int v = g.v, w = g.w; if(dis[v]\u0026gt;dis[u]+w){ dis[v] = dis[u]+w; tmp.dis = dis[v]; tmp.u = v; pq.push(tmp); } } } for(int i=1;i\u0026lt;=n;i++){ printf(\u0026#34;%d \u0026#34;,dis[i]); } return 0; } Bellman-Ford //bellman-ford #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;cstring\u0026gt; #define MAXN 500005 #define INF 0x6fffffff  using namespace std; struct edge{ int v;//下一点  int w;//权 }; int n,m,s; int dis[MAXN]; vector\u0026lt;edge\u0026gt; graph[MAXN]; int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s; for(int i=1;i\u0026lt;=n;i++) dis[i]=INF; for(int i=1;i\u0026lt;=m;i++){ edge tmp; int a,b,c; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; tmp.v=b; tmp.w=c; graph[a].push_back(tmp); } dis[s] = 0; bool flag; for (int i=1;i\u0026lt;=n;i++)//松弛n-1轮，若第n轮还能松弛，就说明有负环  { flag = 0; for(int u=1;u\u0026lt;=n;u++){//这里看似是两层循环，实际上总数是边数，整个算法的复杂度是mn  for (auto e : graph[u]){ int w=e.w,v=e.v; if(dis[v]\u0026gt;dis[u]+w){ dis[v]=dis[u]+w; flag = 1; } } } if(!flag){ break; } } cout\u0026lt;\u0026lt;flag\u0026lt;\u0026lt;endl;//可以输出是否有负权环  for(int i=1;i\u0026lt;=n;i++){ //if(dis[i]!=INF){  cout\u0026lt;\u0026lt;dis[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //}  //else{  // cout\u0026lt;\u0026lt;\u0026#34;2147483647 \u0026#34;;//根据luogu P3371要输出这个数  //}  } return 0; } SPFA /* spfa bellman-ford的优化 只有上一次被松弛的结点，所连接的边， 才有可能引起下一次的松弛操作 */ #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;queue\u0026gt; #define MAXN 500005 #define INF 0x5fffffff  using namespace std; struct edge{ int v; int w; }; int dis[MAXN];//距离 int cnt[MAXN];//算到达本节点所要经过的边数，若cnt\u0026gt;=n，则说明有负权环 bool tag[MAXN];//用于判断是否为上次松弛过的节点的边所连的点  int n,m,s; queue\u0026lt;int\u0026gt; qu; vector\u0026lt;edge\u0026gt; graph[MAXN]; int main(){ cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s; for(int i=1;i\u0026lt;=n;i++){ dis[i] = INF; } dis[s] = 0; tag[s] = 1; for(int i=1;i\u0026lt;=m;i++){ int a,b,c; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; edge tmp; tmp.v=b; tmp.w=c; graph[a].push_back(tmp); } qu.push(s); bool is_negative_circle = 0; while(!qu.empty()){ if(is_negative_circle) break; int u = qu.front(); qu.pop(); tag[u]=0; for(auto e : graph[u]){ int v = e.v, w = e.w; if(dis[v]\u0026gt;dis[u]+w){ dis[v]=dis[u]+w; cnt[v]=cnt[u]+1; if(cnt[v]\u0026gt;=n) { is_negative_circle = 1; break; } if(!tag[v]){ qu.push(v); tag[v]=1; } } } } cout\u0026lt;\u0026lt;is_negative_circle\u0026lt;\u0026lt;endl;//可以输出是否有负权环  for(int i=1;i\u0026lt;=n;i++){ //if(dis[i]!=INF){  cout\u0026lt;\u0026lt;dis[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //}  //else{  // cout\u0026lt;\u0026lt;\u0026#34;2147483647 \u0026#34;;//根据luogu P3371要输出这个数  //}  } return 0; } Floyd //floyd #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; #define MAXN 5005 #define MAXINT 0x3fffffff //不能设置为int的最大值，否则后面加法可能导致溢出  using namespace std; int graph[MAXN][MAXN]; int main(){ int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i = 1;i\u0026lt;=n;i++){ for(int j = 1;j\u0026lt;=n;j++){ graph[i][j] = MAXINT; } } for(int i = 1;i\u0026lt;=n;i++){ graph[i][i] = 0; } for(int i=1;i\u0026lt;=m;i++){ int a,b,v; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;v; graph[a][b] = v; } for(int k = 1;k\u0026lt;=n;k++){ for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=n;j++){ graph[i][j] = min(graph[i][j],graph[i][k]+graph[k][j]); } } } for(int i = 1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=n;j++){ cout\u0026lt;\u0026lt;graph[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } return 0; } 拓扑排序 //拓扑排序 #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;queue\u0026gt; using namespace std; struct graph{ int value; int to; }; struct point { int in_num; vector\u0026lt;graph\u0026gt; graph1; }point1[100]; int main(){ int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i = 1;i\u0026lt;=n;i++){ point1[i].in_num=0; } for (int i=1;i\u0026lt;=m;i++){ int a,b,value; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;//本次是无权图  graph tmp; tmp.to=b; tmp.value = 0; point1[a].graph1.push_back(tmp); point1[b].in_num++; } queue\u0026lt;int\u0026gt; que; vector\u0026lt;int\u0026gt; ans; for (int i = 1; i \u0026lt;= n; i++) { if(point1[i].in_num == 0){ que.push(i); } } while (!que.empty()) { int p = que.front(); que.pop(); ans.push_back(p); for(int i = 0;i\u0026lt;point1[p].graph1.size();i++){ int next = point1[p].graph1[i].to; point1[next].in_num--; if(point1[next].in_num==0){ que.push(next); } } } if(ans.size()==n){ for(int i = 0;i\u0026lt;ans.size();i++){ cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } } else{ cout\u0026lt;\u0026lt;\u0026#34;none\u0026#34;; } return 0; } 最小生成树 Kruskal //kruskal #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#define MAXN 500005  using namespace std; int u[MAXN],v[MAXN],w[MAXN];//一条边的两个点和边权值 int r[MAXN];//临时边序号，间接排序 int find_sets[MAXN];//并查集  int cmp(const int i, const int j){return w[i]\u0026lt;w[j];} int find(int x){return find_sets[x]==x ? x : find_sets[x] = find(find_sets[x]);} int main(){ int n,m;//点数和边数  cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ cin\u0026gt;\u0026gt;u[i]\u0026gt;\u0026gt;v[i]\u0026gt;\u0026gt;w[i]; } for(int i = 1;i\u0026lt;=n;i++){ find_sets[i]=i; } for(int i=1;i\u0026lt;=m;i++){ r[i]=i; } sort(r+1,r+m+1,cmp); int ans = 0; for(int i=1;i\u0026lt;=m;i++){ int tmp = r[i]; int x = find(u[tmp]); int y = find(v[tmp]); if(x!=y){ ans += w[tmp]; find_sets[x] = y; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } 网络流 最大流 Ford-Fulkerson DFS实现的Ford-Fulkerson #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cstdio\u0026gt; using namespace std; typedef long long ll; typedef unsigned long long ull; const ll INF = 0xffffffff; const int MAXM = 100005; struct Edge{ int to; int rev; ll cap; Edge()=default; Edge(int to, ll cap, int rev):to(to),cap(cap),rev(rev){} }; vector\u0026lt;Edge\u0026gt; G[MAXM]; bool used[MAXM]; ll dfs(int v, int t, ll f){ if(v==t) return f; used[v] = true; for(int i=0;i\u0026lt;G[v].size();i++){ Edge\u0026amp; e=G[v][i]; if(!used[e.to]\u0026amp;\u0026amp;e.cap\u0026gt;0){ ll d = dfs(e.to, t, min(f,e.cap)); if(d\u0026gt;0){ e.cap-=d; G[e.to][e.rev].cap+=d; return d; } } } return 0; } ll max_flow(int s, int t){ ll flow = 0; for(;;){ memset(used,0,sizeof(used)); ll f = dfs(s,t,INF); if(f==0) return flow; flow+=f; } } int main(){ int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int s,t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; for(int i=1;i\u0026lt;=m;i++){ int a,b; ll c; scanf(\u0026#34;%d%d%ld\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c); //cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c;  G[a].push_back(Edge(b,c,G[b].size()));//这里第三个参数实际上是反向边的编号  G[b].push_back(Edge(a,0,G[a].size()-1)); } ll ans = max_flow(s,t); printf(\u0026#34;%ld\u0026#34;,ans); //cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;  return 0; } /* 4 5 4 3 4 2 30 4 3 20 2 3 20 2 1 30 1 3 40 */ EdmondsKarp #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;cstring\u0026gt;#define MAXN 50005 #define INF 0x3f3f3f3f  using namespace std; struct Edge{ int from, to, cap, flow; Edge(int u, int v, int c, int f):from(u),to(v),cap(c),flow(f){} }; struct EdmondKarp{ int n,m; vector\u0026lt;Edge\u0026gt; edges; vector\u0026lt;int\u0026gt; G[MAXN]; //邻接表  int a[MAXN]; int p[MAXN]; void init(int n){ for(int i=0;i\u0026lt;n;i++){ G[i].clear(); } edges.clear(); } void AddEdge(int from, int to, int cap){ edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } int Maxflow(int s, int t){ int flow = 0; for(;;){ memset(a, 0 ,sizeof(a)); queue\u0026lt;int\u0026gt; Q; Q.push(s); a[s] = INF; while(!Q.empty()){ int x=Q.front(); Q.pop(); for(int i=0;i\u0026lt;G[x].size();i++){ Edge\u0026amp; e = edges[G[x][i]]; if(!a[e.to]\u0026amp;\u0026amp;e.cap\u0026gt;e.flow){ p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap-e.flow); Q.push(e.to); } } if(a[t]) break; } if(!a[t]) break; for(int u=t;u!=s;u=edges[p[u]].from){ edges[p[u]].flow+=a[t]; edges[p[u]^1].flow -= a[t]; } flow += a[t]; } return flow; } }; int main(){ EdmondKarp EK; cin\u0026gt;\u0026gt;EK.n; int s,t; int m; cin\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; for(int i=1;i\u0026lt;=m;i++){ int tmp1,tmp2,tmp3; cin\u0026gt;\u0026gt;tmp1\u0026gt;\u0026gt;tmp2\u0026gt;\u0026gt;tmp3; EK.AddEdge(tmp1,tmp2,tmp3); } cout\u0026lt;\u0026lt;EK.Maxflow(s,t)\u0026lt;\u0026lt;endl; return 0; } 计算几何 二维凸包 Andrew扫描法 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; #define MAXN 50005  using namespace std; struct Point{ double x,y; Point()=default; Point(double x, double y):x(x),y(y){} Point operator + (Point p){ return Point(x+p.x, y+p.y); } Point operator - (Point p){ return Point(x-p.x, y-p.y); } Point operator * (double d){ return Point(x*d, y*d); } double dot(Point p){//点积  return x*p.x+y*p.y; } double det(Point p){//叉积  return x*(p.y)-(p.x)*y; } }; int n; Point po[MAXN*2]; bool cmp(Point\u0026amp; a, Point\u0026amp; b){ if(a.x!=b.x) return a.x\u0026lt;b.x; return a.y\u0026lt;b.y; } vector\u0026lt;Point\u0026gt; convexHull(){ int k = 0; vector\u0026lt;Point\u0026gt; qs; for(int i=0;i\u0026lt;n;i++){ while(k\u0026gt;1\u0026amp;\u0026amp;(qs[k-1]-qs[k-2]).det(po[i]-qs[k-1])\u0026lt;=0){ qs.erase(qs.end()-1); k--; } qs.push_back(po[i]); k++; } for(int i=n-2,t=k;i\u0026gt;=0;i--){ while(k\u0026gt;t\u0026amp;\u0026amp;(qs[k-1]-qs[k-2]).det(po[i]-qs[k-1])\u0026lt;=0) { qs.erase(qs.end()-1); k--; } qs.push_back(po[i]); k++; } qs.erase(qs.end()-1); return qs; } int main(){ cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;po[i].x\u0026gt;\u0026gt;po[i].y; } sort(po,po+n,cmp); for(auto p:convexHull()){ cout\u0026lt;\u0026lt;p.x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;p.y\u0026lt;\u0026lt;endl; } return 0; } 旋转卡壳求最远点对 //旋转卡壳和凸包 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; #define MAXN 50005  using namespace std; struct Point{ int x,y; Point()=default; Point(int x, int y):x(x),y(y){} Point operator - (Point p){ return Point(x-p.x, y-p.y); } Point operator + (Point p){ return Point(x+p.x, y+p.y); } Point operator * (int d){ return Point(x*d, y*d); } int dot(Point p){ return x*p.x+y*p.y; } int det(Point p){ return x*(p.y)-y*(p.x); } }; bool cmp(Point\u0026amp; a, Point\u0026amp; b){ if(a.x!=b.x) return a.x\u0026lt;b.x; return a.y\u0026lt;b.y; } int n; Point po[MAXN]; vector\u0026lt;Point\u0026gt; convexHull(){ vector\u0026lt;Point\u0026gt; ans; int k = 0; for(int i=0;i\u0026lt;n;i++){ while(k\u0026gt;1\u0026amp;\u0026amp;(ans[k-1]-ans[k-2]).det(po[i]-ans[k-1])\u0026lt;=0){ ans.erase(ans.end()-1); k--; } ans.push_back(po[i]); k++; } for(int i=n-2,t=k;i\u0026gt;=0;i--){ while(k\u0026gt;t\u0026amp;\u0026amp;(ans[k-1]-ans[k-2]).det(po[i]-ans[k-1])\u0026lt;=0){ ans.erase(ans.end()-1); k--; } ans.push_back(po[i]); k++; } ans.erase(ans.end()-1); return ans; } inline long long dist(Point a, Point b){//计算距离的平方  return (a-b).dot(a-b); } void rc(vector\u0026lt;Point\u0026gt; ans){ int tn = ans.size(); int cnt=0; if(tn==2){ cout\u0026lt;\u0026lt;dist(ans[0],ans[1])\u0026lt;\u0026lt;endl; return; } int i=0,j=0; for(int k=0;k\u0026lt;tn;k++){ if(!cmp(ans[i],ans[k])) i=k; if(cmp(ans[j],ans[k])) j=k; } long long res = 0; int si=i,sj=j; while(i!=sj||j!=si){ res = max(res,dist(ans[i],ans[j])); //cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl;  if((ans[(i+1)%tn]-ans[i]).det(ans[(j+1)%tn]-ans[j])\u0026lt;0){ i = (i+1)%tn; }else{ j = (j+1)%tn; } cnt++; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } int main(){ cin\u0026gt;\u0026gt;n; vector\u0026lt;Point\u0026gt; qs; for(int i=0;i\u0026lt;n;i++){ cin\u0026gt;\u0026gt;po[i].x\u0026gt;\u0026gt;po[i].y; } sort(po,po+n,cmp); qs = convexHull(); rc(qs); return 0; } 组合数学 卡特兰数 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; const int MAXN = 3005; ll h[MAXN]; ll comb(int a,int b){ ll ans=1; for(int i=1;i\u0026lt;=b;i++){ ans*=a;//数字太大会爆  a--; } for(int i=1;i\u0026lt;=b;i++){ ans/=i; } return ans; } int main(){ int n; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ cout\u0026lt;\u0026lt;comb(2*i,i)/(i+1)\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;\u0026#34;###\u0026#34;\u0026lt;\u0026lt;endl; //下面是递推求法，不容易爆  h[1]=1; cout\u0026lt;\u0026lt;h[1]\u0026lt;\u0026lt;endl; for(int i=2;i\u0026lt;=n;i++){ h[i] = h[i-1]*(4*i-2)/(i+1); cout\u0026lt;\u0026lt;h[i]\u0026lt;\u0026lt;endl; } return 0; } 稳定婚姻问题 Gale-Shapley算法 #include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; const int N = 30; const int inf = 1\u0026lt;\u0026lt;29; const int MOD = 2007; typedef long long ll; int couple; int maleLike[N][N], femaleLike[N][N]; int maleChoice[N], femaleChoice[N]; int maleName[N], femaleName[N]; char str[N]; queue\u0026lt;int\u0026gt;freemale; int main(){ int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); while(t--){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;couple); while(!freemale.empty()){ freemale.pop(); } for(int i=0;i\u0026lt;couple;i++){ scanf(\u0026#34;%s\u0026#34;,str); maleName[i]=str[0]-\u0026#39;a\u0026#39;; freemale.push(maleName[i]); } sort(maleName, maleName+couple); for(int i=0;i\u0026lt;couple;i++){ scanf(\u0026#34;%s\u0026#34;,str); femaleName[i]=str[0]-\u0026#39;A\u0026#39;; } for(int i=0;i\u0026lt;couple;i++){ scanf(\u0026#34;%s\u0026#34;,str); for(int j=0;j\u0026lt;couple;j++){ maleLike[i][j]=str[j+2]-\u0026#39;A\u0026#39;; } } for(int i=0;i\u0026lt;couple;i++){ scanf(\u0026#34;%s\u0026#34;,str); for(int j=0;j\u0026lt;couple;j++){ femaleLike[i][str[j+2]-\u0026#39;a\u0026#39;]=couple-j; } femaleLike[i][couple]=0; } memset(maleChoice,0,sizeof(maleChoice)); for(int i=0;i\u0026lt;couple;i++){ femaleChoice[i]=couple; } while(!freemale.empty()){ int male=freemale.front(); int female=maleLike[male][maleChoice[male]]; if(femaleLike[female][male]\u0026gt;femaleLike[female][femaleChoice[female]]){ freemale.pop(); if(femaleChoice[female]!=couple){ freemale.push(femaleChoice[female]); maleChoice[femaleChoice[female]]++; } femaleChoice[female]=male; } else maleChoice[male]++; } for(int i=0;i\u0026lt;couple;i++){ printf(\u0026#34;%c %c\\n\u0026#34;,maleName[i]+\u0026#39;a\u0026#39;, maleLike[maleName[i]][maleChoice[maleName[i]]]+\u0026#39;A\u0026#39;); } if(t) puts(\u0026#34;\u0026#34;); } return 0; } 树 树状数组 //树状数组  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;#define MAXN 500005  using namespace std; int arr[MAXN]; int bit[MAXN]; int n,m; inline int lowbit(int n){ return n\u0026amp;(-n); } void update(int p, int k){ for(;p\u0026lt;=n;p+=lowbit(p)){ bit[p]+=k; } } long long query(int p){ int ans=0; for(;p;p-=lowbit(p)){ ans+=bit[p]; } return ans; } int main(){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;arr[i]); update(i,arr[i]); } for(int i=1;i\u0026lt;=m;i++){ int op; int x,y,k; scanf(\u0026#34;%d\u0026#34;,\u0026amp;op); scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); if(op==1){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;k); update(x,k); } else{ scanf(\u0026#34;%d\u0026#34;,\u0026amp;y); cout\u0026lt;\u0026lt;query(y)-query(x-1)\u0026lt;\u0026lt;endl; } } return 0; } 并查集 //并查集  #include \u0026lt;iostream\u0026gt;using namespace std; const int MAXN = 1005; int find_sets[MAXN]; int findf(int x){ return find_sets[x]==x ? x : find_sets[x] = findf(find_sets[x]); } void unionSet(int x, int y){ x = findf(x); y = findf(y); find_sets[x] = y; } int main(){ int n; cin\u0026gt;\u0026gt;n; for(int i=1;i\u0026lt;=n;i++){ find_sets[i]=i; } int m; cin\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++){ int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; find_sets[b] = a; } cout\u0026lt;\u0026lt;findf(5)\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;findf(8)\u0026lt;\u0026lt;endl; unionSet(5,8); cout\u0026lt;\u0026lt;findf(5)\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;findf(8)\u0026lt;\u0026lt;endl; return 0; } /* 8 6 1 2 1 3 3 4 3 5 6 7 7 8 */ 线段树 //luogu 3372 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt; using namespace std; typedef long long ll; const int MAXN = 100005; ll st[MAXN*4+2];//对于一颗线段树，n个数所组成的树最多有4n-5个节点，开大了一点 ll tag[MAXN*4+2]; ll arr[MAXN]; void build(int s, int t, int p){//区间左端点、右端点、区间编号  if(s==t){ st[p] = arr[s]; return; } int m = s+((t-s)\u0026gt;\u0026gt;1);//写成(s+t)\u0026gt;\u0026gt;1可能会爆  build(s,m,p*2); build(m+1,t,p*2+1); st[p] = st[p*2]+st[p*2+1]; } void update(int l, int r, int s, int t, int p, ll c){//c表示加减的数值  if(l\u0026lt;=s\u0026amp;\u0026amp;t\u0026lt;=r){ st[p]+=(t-s+1)*c; tag[p]+=c; return; } ll m = s + ((t-s)\u0026gt;\u0026gt;1); if(tag[p]\u0026amp;\u0026amp;s!=t){ st[p*2] += (m-s+1)*tag[p]; st[p*2+1] += (t-m)*tag[p]; tag[p*2] += tag[p]; tag[p*2+1]+= tag[p]; tag[p]=0; } if(l\u0026lt;=m) update(l, r, s, m, p*2, c); if(r\u0026gt;m) update(l, r, m+1, t, p*2+1, c); st[p] = st[p*2] + st[p*2+1]; } ll query(int l, int r, int s, int t, int p){ if(l\u0026lt;=s\u0026amp;\u0026amp;t\u0026lt;=r){ return st[p]; } ll sum=0; ll m = s+((t-s)\u0026gt;\u0026gt;1); if(tag[p]){ st[p*2] += (m-s+1)*tag[p]; st[p*2+1] += (t-m)*tag[p]; tag[p*2] += tag[p]; tag[p*2+1]+= tag[p]; tag[p]=0; } if(l\u0026lt;=m) sum+=query(l,r,s,m,p*2); if(r\u0026gt;m) sum+=query(l,r,m+1,t,p*2+1); return sum; } int main(){ int n,m; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1;i\u0026lt;=n;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;arr[i]); } build(1,n,1); for(int i=1;i\u0026lt;=m;i++){ int ope; cin\u0026gt;\u0026gt;ope; if(ope==1){ int x,y,z; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;z); update(x, y, 1, n, 1, z); } else{ int x,y; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;x,\u0026amp;y); cout\u0026lt;\u0026lt;query(x, y, 1, n, 1)\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2021-12-18T15:57:37+08:00","permalink":"https://kegalas.top/p/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/","title":"算法竞赛常用模板整理"},{"content":"网络设备管理 题目描述 ​\t叮叮叮！网络设备管理员欢欢在行动\n​\t欢欢就职于一家庞大的数据管理分析公司\n​\t公司有一个存储数据的庞大网络，把每个数据存储器看做一个节点，这个存储网络可以看做是一个树型结构，每天有庞大的数据流在节点之间穿梭\n​\t随着公司的发展，这个网络越来越庞大，数据的传输速度也越来越慢，通过研究，欢欢发现，每个节点的传输速度，只与与这个节点连接的节点数量有关，比如仅和一个节点连接的节点传输数据会很快，而和 100 个节点连接的节点传输数据会很慢\n​\t欢欢准备提交一份研究报告，报告将会指出，若对于网络中的所有节点，与该节点相连的节点数量不超过 d，那么网络的整体传输速度将会大幅提高。\n​\t欢欢准备通过添加新的网络设备来降低与某节点相连的节点的数量\n​\t简而言之，对于网络设备a，我们可以添加新的设备b，使得原来与a相连的若干节点断开与a的连接并与b连接，并且使a,b连接，显然，添加新的网络设备后，这个网络仍旧是一个树形结构这样通过添加若干新的网络设备，我们可以把所有网络设备的相连网络设备数量降低到不超过d台 (包括与新添加的网络设备相接的网络设备数量不超过 d)\n​\t欢欢发现，有很多种解决方案\n​\t聪明的你知道欢欢最少添加多少台网络设备吗？\n​\t注意: 欢欢添加新的设备后，网络的结构仍保持为树形结构\n输入 ​\t单组输入 ​\t第一行两个正整数 $n$, $d$ $(1\\le n\\le 10^5,3\\le d\\le n)$ ​\t接下来$n-1$行，每行两个正整数$a$,$b$ $(1\\le a, b\\le n)$，说明设备$a$与设备$b$相连接，数据保证设备网络为树形结构。\n输出 ​\t一个正整数，最小添加的网络设备数量，注意欢欢可以添加0台设备。\n样例    样例输入 样例输出     10 32 13 14 15 26 17 68 59 710 6 1    AC代码 #include \u0026lt;iostream\u0026gt;#define MAXN 100005  using namespace std; int arr[MAXN]; int main(){ int n,d; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;d; for(int i=1;i\u0026lt;n;i++){ int a,b; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a,\u0026amp;b); arr[a]+=1; arr[b]+=1; } int ans=0; for(int i=1;i\u0026lt;=n;i++){ if(arr[i]\u0026gt;d){ int tmp = (d-1)*2; if(arr[i]-tmp\u0026lt;=0){ ans+=1; } else if((arr[i]-tmp)%(d-2)==0) ans += 1 + (arr[i]-tmp)/(d-2); else ans += 1 + (arr[i]-tmp)/(d-2)+1; } } cout\u0026lt;\u0026lt;ans; return 0; } 正确性证明 先给出样例的示意图\n 样例图 \n其中红色数字表示与这个节点直接相连的节点的个数。显然只有1号节点连了大于3个节点，我们可以新增一个节点A，将2、3号与A相连，4、6号不变，然后将1与A相连，现在1与A连了三个节点，符合要求。不过这不是唯一的连法。\n这种有最大连接节点的结构，很容易让人回想起烷烃。显然的，饱和烷烃的碳链无论怎么排布，所连的氢原子的数目不会改变。每个碳原子也都会连四个原子。\n类比到这道题，我们要做的，就是将形如下图的点（假设上限为连3个）\n 2 \n变为如下的一些点，当然这里的点怎么排布都不影响，只要他最大的利用了链接上限，就是答案。\n 3 \n解释一下核心代码\nfor(int i=1;i\u0026lt;=n;i++){ if(arr[i]\u0026gt;d){//枚举超过链接上限的节点  int tmp = (d-1)*2; //点链两端，能“向外”链接d-1个点，必须要向“内部”链接一个点，才能构成点链，这个arr[i]-tmp得到的是还需要“向外”链接的数量。  if(arr[i]-tmp\u0026lt;=0){//特判一下，如果只用新增一个节点，并且有一个节点没有占满上限  ans+=1; } else if((arr[i]-tmp)%(d-2)==0)//内部每个节点都只能“向外”链接d-2个节点，如果能全部占满每个内部节点的上限，ans如下  ans += 1 + (arr[i]-tmp)/(d-2); else//不能占满则ans如下  ans += 1 + (arr[i]-tmp)/(d-2)+1; } ","date":"2021-11-21T14:53:54+08:00","image":"https://kegalas.top/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/1_hue13a31d22502e6414becf06d466eec8f_119570_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/","title":"算法题-网络设备管理"},{"content":"向量 题目描述 ​ 给你n个向量，请问是否可以通过旋转异或伸缩任意一个向量，使得这n个向量相加等于0向量。 ​\n​ 注意，在本题中，我们认为0向量只能伸缩为0向量，非0向量可以伸缩为0向量、方向相同长度任意的向量、方向相反长度任意的向量。\n输入 ​ 单组输入\n​ 第一行一个正整数 $n(1\\le n\\le 10^5)$，即向量的个数。\n​ 接下来$n$行，每行两个整数$x_i$, $y_i$ $(0\\le |x_i|,|y_i|\\le 10^9)$，分别代表第$i$个向量$x$轴与$y$轴的大小方向。\n数据保证\n$$\\sum_{i=1}^{n}(|x_i|+|y_i|)\\le 10^9$$\n输出 ​ 若存在满足要求的操作输出 “yes”，反之输出 “no”。\n样例    样例输入 样例输出     3\n0 0\n1 2\n4 2 no    AC代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;typedef long long ll; #define MAXN 100005  using namespace std; struct Vec { ll x; ll y; }; Vec vec[MAXN]; int main(){ int n; cin\u0026gt;\u0026gt;n; Vec allSum; allSum.x=0;allSum.y=0; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;vec[i].x\u0026gt;\u0026gt;vec[i].y; allSum.x+=vec[i].x; allSum.y+=vec[i].y; } ll ans = 0; for(int i=1;i\u0026lt;=n;i++){ if(vec[i].x==0\u0026amp;\u0026amp;vec[i].y==0) continue; Vec tmpSum = allSum; tmpSum.x-=vec[i].x; tmpSum.y-=vec[i].y; ll dis1 = tmpSum.x*tmpSum.x+tmpSum.y*tmpSum.y; ll dis2 = vec[i].x*vec[i].x+vec[i].y*vec[i].y; if(dis1==dis2) { ans=1; break; } if(vec[i].y*tmpSum.x-tmpSum.y*vec[i].x==0) { ans=1; break; } } if(ans) cout\u0026lt;\u0026lt;\u0026#34;yes\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;no\u0026#34;; return 0; } 正确性证明 首先分析题目，出题人的表达和数据结果并不一致。“是否可以通过旋转异或伸缩任意一个向量”实际上应该是“是否可以通过旋转异或伸缩某一个向量”，从而“使得这n个向量相加等于0向量”。\n数据也就$10^5$，直接枚举就行。先将所有向量加到一起记为allSum，然后建立一个tmpSum = allSum-我们当前枚举的向量，记为v。\n然后判断这个tmpSum向量是否和v长度平方相等，是则可以通过旋转v，再相加得到0向量。判断tmpSum向量终点是否和$(0,0)$和v的终点在同一直线上,是则可以通过伸缩v来达到目的。这里判断三点共线的方法是求外积。若都为否，则不可以只对v伸缩或者旋转达到目的，枚举下一个。这里注意，我上述写的代码要将0向量略过，否则0向量总是可以通过三点共线的判断，达不到目的。\n如果枚举出一个向量可以达到目的，就输出yes。如果所有向量都达不到目的，就输出no。\n","date":"2021-11-15T22:30:41+08:00","permalink":"https://kegalas.top/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%90%91%E9%87%8F/","title":"算法题-向量"},{"content":"有限小数 题目描述 ​\t现在有一个正整数n,可以证明存在若干个正整数d使得1/n在d进制下为有限小数，输出最小的d。\n输入 ​\t单组输入 ​\t第一行一个正整数$n(2\\le n\\le 10^{12})$\n输出 ​\t一个正整数d\n样例    输入 输出     9 3   999 111    AC代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cmath\u0026gt; using namespace std; int main(){ long long n; cin\u0026gt;\u0026gt;n; long long ans=1; long long tmp=n; //求n的质因数的乘积  for(long long i=2;i*i\u0026lt;=tmp;i++){ if(tmp%i==0){ ans*=i; while(tmp%i==0){ tmp/=i; } } } if(tmp\u0026gt;1) ans*=tmp; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } 正确性证明 ​\t若$1/n$可以在d进制表达为有限小数，那么一定有：\n​\t$$\\frac{1}{n}=\\frac{a_1}{d}+\\frac{a_2}{d^2}+\\dots+\\frac{a_m}{d^m}$$\n​\t其中$a_i\u0026lt;d(1\\le i\\le m)$，且$a$为正整数，$m$是一个正整数。将两边同乘$nd^m$得：\n​\t$$d^m=n(a_1d^{m-1}+\\dots+a_md^0)$$\n故只要$d^m$是n的倍数，$1/n$在d进制下就为有限小数。\n将n进行质因数分解，由唯一分解定理知只能分解为一种形式，设d为n的质因数的乘积，易知此时总存在m使得n|$d^m$，并且显然，这个d是最小的。\n","date":"2021-11-15T16:26:01+08:00","permalink":"https://kegalas.top/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%9C%89%E9%99%90%E5%B0%8F%E6%95%B0/","title":"算法题-有限小数"},{"content":"各种主义整理 哲学、政治、社会 绝对主义 绝对主义认为在任何一种学说里，某种观点必定是绝对正确或者绝对错误的。\n荒诞主义 “荒诞主义”是对人生的极端反叛，认为人生的意义并不存在，所以可以活得很无厘头都无所谓。\n唯美主义 唯美主义者的人生目的就是去创造和享受一切美的东西。\n利他主义 利他主义者是一种随时都在无私地为他人福利着想的人，在道德判断上，认为别人的幸福快乐比自己的来得重要。利他主义在许多思想和文化中是一种美德。\n无政府主义（安那其主义） “无政府”一词并不代表混乱、虚无或道德沦丧的状态，而是一种由自由的个体自愿结合，以建立互助、自治、反独裁主义的和谐社会。庄子被认为是最早的无政府主义者。\n人类中心主义（以人为本） 人类中心主义认为人类是地球上最核心或者最重要的物种，评价现实的真实与否依靠人类的视角。人类中心主义是环境伦理学和环境哲学的主要概念，被认为是人类为何与自然环境发生冲突的根本原因，但这种理念已经根植在大多数人类的心中。\n无神论 无神论并没有统一的哲学思想，一些无神论者可能完全否定超自然事物，但另一些无神论者可能相信诸如占星术等伪科学。无神论经常同不可知论、反神论或反有神论相混淆。无神论者是认为没有神，不可知论者是认为神的存在是不可知，而反神论者是直接明确反对有神论。\n资本主义 资本主义的特色是私人拥有生产资料，且投资活动是由个人决策左右，而非由国家所控制，经济行为则以追求利润为目标。资本主义的主要经济模式包括了自由的资本和雇佣流动、市场竞争以及价格机制的运行。\n集体主义 集体主义是主张个人从属于社会，个人利益应当服从集体、民族、阶级和国家利益的一种思想理论。\n建构主义 建构主义者认为，任何一个社会人的行为都被约定俗成的社会传统、社会习惯和个人身份来制约或改变，因此现实和我们理解现实的方式都是人造的、主观的。\n犬儒主义 犬儒主义本意是指人不应被一切世俗的事物，包括宗教、礼节、惯常的衣食住行等习俗束缚，提倡对道德的无限追求，同时过着极简朴而非物质的生活。\n现代社会中“犬儒主义”一词常被误用作比喻一些否定利他主义、自私而且毫无道德的人。\n演绎主义 科学知识的产生是通过提出假设，然后通过实验和观察到的现象和数据来证明这样一个过程。\n决定论（determinism） 决定论是哲学的一种命题，认为每个事件的发生，包括人类的认知、举止、决定和行动，都是因为先前的事而有原因地发生。\n教条主义 指那些我们所相信的、不容质疑的观念。宗教上指那些具有权威性的团体所确立的教理，信徒以此作为应该学习的真理课程。\n二元论 二元论认为世界由两种力量统治：善与恶。善是精神，是灵魂，是善的力量创造的一切东西;而恶是物质，是肉体，是恶的力量创造的一切。这两种力量对抗着，共同支配世界。\n折衷主义 折衷主义是指操作运用不同的理论、方法、风格，拣选其中最佳要素，应用在新的创作中。在艺术或建筑批评等特定领域，指挪借多种视觉资源来创作新作品。\n平均主义 平均主义要求平均分享一切社会财富，对人人应该予以同样、平等对待。\n情感主义 情感主义是 20 世纪 30 年代，英美等国最流行的一种元伦理学，它否认伦理学的科学地位，主张道德是个人情感的表达，否认道德的客观性，认为道德判断没有合理的或有效的根据，没有真假之别，不过是表示某种情感、某种愿望。\n经验主义 经验主义指相信现代科学方法，认为理论应建立于对于事物的观察，通过实验研究而后进行理论归纳，优于单纯的逻辑推理、直觉或者先入为主的概念。\n副现象论（epiphenomenalism） 副现象论认为物理世界可以影响内心世界，但是反过来却不行。\n永恒论 永恒论认为时间不过是另外一个维度，明天已经存在了，只是你还没到那里而已。过去、现在、未来都一样真实。\n幸福主义 以幸福作为人生目的和理想的人生哲学。认为幸福包括物质生活和精神生活两个方面，人有追求幸福的权利，这是人的天性，人生的意义即在对于幸福的追求。\n存在主义 存在主义认为人存在的意义无法经由理性思考而得到答案，强调个人的主观经验。\n有序主义（extropy） 有序主义是相信科技进步可以解决人类问题的超人类主义思想之一。它认为随着科技的进步，总有一天人类可以得到永生。有序主义者愿意为了这个目的而努力，比如进行调查研究，志愿测试新技术等。\n女性主义 女性主义是指主要以女性经验为来源与动机的社会理论与政治运动。在对社会关系进行批判之外，许多女性主义的支持者也着重于性别不平等的分析以及推动妇女的权利、利益与议题。\n因果论（finalism） 因果论认为任何事物的发展都由预设好的既定结果来决定。\n自由意志 自由意志是指在社会、道德、政治的限制下，人们依照其拥有的条件去自主决定是否做一件事的能力。\n快乐主义 又称享乐主义。它倾向于用纯粹生物学的或心理学的观点来解释人的行为与需要，认为人们以求得快乐为生活目的，包括肉体与心灵的快乐。\n历史论 历史论认为去理解一个历史事件，我们必须考虑到当时的大环境和历史的上下文，而不是抽象地用概念去解释。\n唯心主义 唯心主义反对现实主义的哲学观，认为在人类的认知中，我们对物体的理解与感知，独立于物体的实际存在。\n个人主义 个人主义是一种道德的、政治的和社会的哲学，认为个人利益应是决定行为的最主要因素，强调个人自由和个人权利的重要性，超越集体如国家、种族、社会组织之上。\n神秘主义 也译作密契主义，包含人类与神明或某种超自然力量结合为一的各种形式、经验、体验，并且强调这是一切宗教共有的现象。神秘主义者的基本信条是世界上存在超自然的力量或隐藏的自然力量，这种力量可以通过特殊教育或者宗教仪式获得。\n自然主义 自然主义者认为自然的和超自然的都是一回事，可以用同一套方法来研究和解释。\n虚无主义 虚无主义作为哲学主义，为怀疑主义的极致形式，认为世界、生命(特别是人类)的存在是没有客观意义、目的以及可以理解的真相的。\n客观主义 在伦理学中，客观主义认为有些事情的对错是客观存在的。\n乐观主义 乐观主义是指一种对一切事物采与正面看法的观念。乐观的人不会想到一件事的缺点与瑕疵，永远以正面的想法对待身边的一切。\n泛神论 泛神论是一种将自然界与神等同起来，以强调自然界的至高无上的哲学观点。泛神论认为神就存在于自然界一切事物之中，并没有另外的超自然的主宰或精神力量。\n观点主义 观点主义认为人思想和价值判断来自不同的内心驱动和个人视角，并没有绝对的真理，只能去融合不同的观点。\n厌世主义 厌世主义，亦即悲观主义和虚无主义，是特定人群中所形成的一种无可奈何的悲观心理的反映。\n理性主义 理性主义是建立在承认人的理性可以作为知识来源的理论基础上的一种哲学方法，认为理性高于并独立于感官感知。\n相对主义 相对主义不是一个单一的学说，而是一系列观点，其共同的主题是，经验、思想、价值总是相对于其他东西而成立的，没有什么绝对的真理或评判标准。\n怀疑论 怀疑论是一种认识论，是认识问题的一种态度，它拒绝对问题作随意的不够严格的定论，对事物的看法采取一种类于“中立”的立场，既怀疑“是”也怀疑“不是”。怀疑论的反面是迷信，或更确切地说是独断论。\n斯多葛主义 斯多葛主义认为，重要的是在任何情况下都必须保持沉着，学会情感和生理的自我控制，以求得内心的平和与力量，获得更好的生活。斯多葛主义认为它的对立面激情是“背离理性和违反自然的精神冲动”。\n结构主义 结构主义认为任何一个现象都必须在知道了语境和上下文和他们之间的相互关系后才能被真正理解。\n融合主义 融合主义倡导不同宗教信仰或哲学主张之间的融合。\n有神论 广义上的有神论认为至少存在一个神明。狭义上特指一神论信仰，认为世界有一位至高的神明，关注于宇宙与这位神明之间的关系。\n功利主义 功利主义提倡追求大多数人的最大幸福，如果需要牺牲少部分人的利益也没办法。\n生命力论（活力论） 生命力论在人类历史上存在长久的历史，现代版本是19世纪初由瑞典化学家贝采利乌斯提出的，认为生命的运作，不只依循物理及化学定律。生命有自我决定的能力。\n新柏拉图主义 新柏拉图主义认为，世界有两极，一端是被称为“上帝”的神圣之光，另一端则是完全的黑暗。但新柏拉图主义也相信，完全的黑暗并不存在，只是缺乏亮光而已。\n柏拉图主义 尤指宣称理念形式是绝对的和永恒的实在，而世界中实在的现象却是不完美的和暂时的反映。\n伊壁鸠鲁学派 伊壁鸠鲁派认为并宣扬人死魂灭，这是人类思想史上的一大进步，同时提倡寻求快乐和幸福。但他们所主张的快乐决非肉欲物质享受之乐，而是排除情感困扰后的心灵宁静之乐。伊壁鸠鲁派生活简朴而又节制，目的就是要抵制奢侈生活对一个人身心的侵袭。\n斯多亚主义 斯多葛派认为世界理性决定事物的发展变化。所谓\u0026quot;世界理性\u0026quot;，就是神性，它是世界的主宰，个人只不过是神的整体中的一分子。在社会生活中斯多葛派强调顺从天命,要安于自己在社会中所处的地位，要恬淡寡欲，只有这样才能得到幸福。\n工具主义 工具主义的实践理性观可以表达为：理性指导人们的实践，是并且只是通过告诉人们采用何种必要的手段以达到既定目的来完成的，但是这些既定目的是否合适则不受理性的批判。\n世界主义 世界主义相信所有的人类都属于一个基于同样道德观念的社群，。世界主义的社群包括一个包容性的道德规范，共享的经济体制，和一个包含所有国家的政治结构。社群之中来自世界各地的人通过彼此的敬意来建立关系。\n加速主义 指一种政治与社会理论，认为资本主义制度或历史上某种技术相关的社会进程应该被加速以产生巨大社会变革。\n国际主义 国际主义是指各国无产阶级在反对剥削制度，争取自身解放斗争中，在政治、经济、道义等方面互相支持，互相援助，坚持国际团结的思想和政治原则。国际主义体现了无产阶级的民族观，是无产阶级处理民族问题的基本原则，也是无产阶级认识和处理各国无产阶级之间、各国无产阶级政党之间以及社会主义国家之间相互关系的行为准则。资本压迫和统治的国际性，决定了无产阶级反对资产阶级的斗争，从形式上看，首先是在一国范围内进行，但从内容上看，从来就是国际性的:无产阶级只有解放全人类，才能最后解放自己。\n沙文主义 沙文主义是资产阶级侵略性的民族主义。18世纪末、19世纪初产生于法国，因法国士兵沙文（Nicolas Chauvin）狂热拥护拿破仑一世的侵略扩张政策，主张用暴力建立法兰西帝国而得名。它鼓吹法兰西民族是世界上最优秀的民族，宣扬本民族利益高于一切，煽动民族之间的仇恨，主张征服和奴役其他民族。在帝国主义时代，沙文主义是帝国主义侵略和压迫其他国家和民族的舆论工具。\n民族主义 民族主义，即指以自我民族的利益为基础而进行的思想或运动。在近代以来，民族主义推动了民族解放与平等，是现代国际社会的源泉。美国学者汉斯·科恩认为：“民族主义首先而且最重要的是应该被看作是一种思想状态。”英国学者爱德华·卡尔认为：“民族主义通常被用来表示个人、群体和一个民族内部成员的一种意识，或者是增进自我民族的力量、自由或财富的一种愿望”。民族主义通常是指以维护本民族利益和尊严为出发点的思想与行为\n民粹主义 民粹主义（populism），又译平民主义，是在19世纪的俄国兴起的一股社会思潮。民粹主义的基本理论包括：强调平民群众的价值和理想，把平民化和大众化作为政治运动和政治制度合法性的最终来源；依靠平民大众对社会进行改革，并把普通群众当作政治改革的决定性力量；通过强调诸如平民的统一、全民公决、人民的创制权等民粹主义价值，对平民大众从整体上实施有效的控制和操纵。\n法西斯主义 法西斯主义（英语：Fascism；俄语：фашизм；意大利语：Fascismo；德语：Faschismus；西班牙语：Fascismo）是一种结合了社团主义、工团主义、独裁主义、极端民族主义、中央集权形式的军国主义、反无政府主义、反自由放任的资本主义、和反共产主义政治哲学；《大英百科全书》对法西斯主义的定义：“个人的地位被压制于集体—例如：某个国家、民族、种族、或社会阶级之下的社会组织。”\n纳粹主义 纳粹主义，是德文“Nationalsozialismus”缩写“Nazismus”的音译，意译为“民族社会主义”。\n纳粹主义意识形态的精神是“属于一个民族”，纳粹主义的基本理论包括：种族优秀论，“优等种族”至上；一切领域的“领袖”原则，“领袖”是国家整体意志的代表；反对英法资本主义体系以及共产主义思想体系，抵制共产主义理论。\n种族主义 种族主义是一种自我为中心的态度，认为种族差异决定人类社会历史和文化发展，认为自己所属的团体，例如人种、民族或国家，优越于其他的团体。\n修正主义 修正主义是在共产主义运动之中歪曲、篡改、否定马克思主义的一类资产阶级思潮和政治势力，是国际工人运动中打着马克思主义旗号反对马克思主义的机会主义思潮。“修正“一词来源于拉丁文reisio，意思是“修改、重新审查”。 修正主义产生于十九世纪九十年代。其社会基础是资本主义“和平”发展时期逐步形成起来的工人贵族阶层以及补充到工人阶级队伍中的小资产阶级。\n改良主义 改良主义是一种试图以非革命手段解决资本主义社会矛盾的资产阶级和小资产阶级思潮。这种思潮宣扬阶级合作，主张在保存资本主义制度的前提下，实行局部的微小的社会改良; 反对暴力革命和无产阶级专政，主张通过法令和立法途径实行社会改革，变资本主义为“普遍福利”社会。\n社会民主主义 社会民主主义是社会思潮和社会运动。它反映和代表了各国社会党 (包括社会民主党、工党) 及其国际联合组织“社会党国际” 解决社会矛盾问题、处理政治问题的共同的基本主张、基本观点、基本理论和方法，是各国社会党思想体系的统称。\n社会民主主义思潮最初于19世纪中叶诞生于欧洲，作为对资本剥削和侮辱劳动阶级的反抗运动，迄今已存在了一个半世纪之久。在一百五十余年的风风雨雨中，社会民主主义已经历了由理论到实践，由欧洲到世界的发展过程，愈益发展壮大。\n孤立主义 孤立主义，是一种外交政策。它通常由防务和经济上的两方面政策组成。在防务上，孤立主义采取不干涉原则，即除自卫战争外不主动卷入任何外部军事冲突；在经济文化上，通过立法最大程度限制与国外的贸易和文化交流。\n单边主义 所谓单边主义是指举足轻重的特定大国，不考虑大多数国家和民众的愿望，单独或带头退出或挑战已制订或商议好了的维护国际性、地区性、集体性和平、发展、进步的规则和制度，并对全局或局部的和平、发展、进步有破坏性的影响和后果的行为与倾向。\n多边主义 多边主义原是指不完全依赖俄罗斯或者独联体内部来解决问题而是谋求多边发展利用外部世界一切可能利用的因素和机会既为自己吸收更多的发展动力又可避免单方面依赖而受制于俄罗斯。现指三个或三个以上国家之间发生联系的方式。\n实用主义 冯友兰总结的实用主义主要观点最为简洁明了。在《三松堂自序》中冯说：“实用主义的特点在于它的真理论。它的真理论实际是一种不可知论。认识来源于经验，人们所能认识的，只限于经验，至于经验的背后还有什么东西，那是不可知的，也不必问这个问题。这个问题是没有意义的，因为无论怎么说，人们总是不能走出经验范围之外而有什么认识。要解决这个问题，还得靠经验。所谓真理，无非就是对于经验的一种解释，对于复杂的经验解释得通。如果解释得通，它就是真理，对于我们有用，即有用就是真理，忽略所谓客观的真理。”如此说得之，实用二字昭然若揭。\n计算机科学 符号主义 符号主义（Symbolism）是一种基于逻辑推理的智能模拟方法，又称为逻辑主义(Logicism)、心理学派(Psychlogism)或计算机学派(Computerism)，其原理主要为物理符号系统（即符号操作系统）假设和有限合理性原理，长期以来，一直在人工智能中处于主导地位，其代表人物是纽威尔、肖、西蒙和尼尔森。\n连接主义 连接主义(connectionism)，又称为仿生学派或生理学派，其主要原理为神经网络及神经网络间的连接机制与学习算法。\n行为主义 行为主义(actionism)，又称为进化主义或控制论学派，其原理为控制论及感知-动作型控制系统。\n文艺 文学 都合主义 剧情、人物、设定等为主角服务而无视因果、设定，这就是都合主义。\n魔幻现实主义 魔幻现实主义作为拉丁美洲所特有的文学样式，它具有与众不同的鲜明而独特的特征。将新闻报道般的写实与神奇的幻想结合起来，采用模糊化技巧和神话模式，表现拉丁美洲的历史文化和现实生活。这是魔幻现实主义突出的艺术特征。\n美术 浪漫主义 这一画派摆脱了当时学院派和古典主义的羁绊，偏重于发挥艺术家自己的想象和创造，创作题材取自现实生活，中世纪传说和文学名著（如莎士比亚、但丁、歌德、拜伦的作品）等，有一定的进步性。\n印象派 不依据可靠的知识，以瞬间的印象作画。画家们是抓住一个具有特点的侧面去作画，所以他们必须疾飞画笔把颜色直接涂在画布上，他们只能多考虑画的总体效果，较少的顾及枝节细部。印象主义的以粗放的笔法作画，作品缺乏修饰，是一种对笔法较草率的画法。\n印象主义采取在户外阳光下直接描绘景物，追求以思维来揣摩光与色的变化，并将瞬间的光感依据自己脑海中的处理附之于画布之上，这种对光线和色彩的揣摩也是达到了色彩和光感美的极致。\n画家：莫奈、马奈、毕沙罗、雷诺阿、 西斯莱、德加、科罗、莫里索、巴齐约\n点彩派（新印象派） 他们不用轮廓线划分形象，而用点状的小笔触，通过合乎科学的光色规律的并置，让无数小色点在观者视觉中混合，从而构成色点组成的形象，被一些艺术评论家称作“点彩派”。\n画家：乔治·修拉、保罗·西涅克、卡米尔·毕沙罗、M. 吕斯、H.-E.克罗斯\n新艺术派 简单讲就是喜欢画些清新脱俗的花草纹样，而且喜欢勾线，还经常画得扁扁平平的。女人头上长花是常有的事，当然，驴头上也可以长。\n画家：慕夏\n野兽派 顾名思义，就是像野兽一样狂放，这一派画家基本是不调色的，颜料挤出来就直接用，而且形状也是粗矿得很。国内的幼儿园墙画深得这种风格的真传。\n画家：马蒂斯\n风格派 风格派完全拒绝使用任何的具象元素，主张用纯粹几何形的抽象来表现纯粹的精神。认为抛开具体描绘,抛开细节，才能避免个别性和特殊性，获得人类共通的纯粹精神表现。\n画家：蒙德里安\n构成主义 简单讲，这个派别特备喜欢画立体块块和几何图形，而且喜欢乱摆。\n画家：里茨斯基\n超现实主义 简单讲就是觉得现实不重要，专门画现实里没有的东西。比如，为什么驴就不能长得像鱼呢？\n画家：达利\n表现主义 表现主义是艺术家通过作品着重表现内心的情感，而忽视对描写对象形式的摹写，因此往往表现为对现实的扭曲和抽象化，这个做法尤其用来表达恐惧的情感，因此，主题欢快的表现主义作品很少见。\n画家：席勒\n抽象表现主义 抽象表现主义是指一种结合了抽象形式和表现主义画家情感价值取向的非写实性绘画风格。\n该运动存在着多样的绘画风格，画风多半大胆粗犷、尖锐且尺幅巨大。画作色彩强烈，并经常出现偶然效果，例如让油彩自然流淌而不加以限制。\n画家：波洛克\n立体派 主要目的是追求一种几何形体的美，在形式的排列组合所产生的美感。 它否定了从一个视点观察事物和表现事物的传统方法，把三度空间的画面归结成平面。因为把不同视点所观察和理解的形诉诸于画面，从而表现出时间的持续性。\n画家：毕加索\n未来派 未来派全盘否定传统文艺的价值，认为人类的文化遗产和现存的文化都是腐朽、僵死，与现时代的精神不相容的。他们的口号是“摒弃一切博物馆、图书馆和学院”，反对一切模仿的形式，反抗和谐和趣味高雅，否定艺术批评的作用。未来派的美学主张与表现主义、立体主义有相同的地方，只是他们特别强调表现运动和力量，口号更激烈，纲领更明确，虚无主义的色彩更浓郁。\n他们觉得不能只表现静态的东西，画什么都要动起来、嗨起来，所以一个驴子可能带着七八个形状各异的残影。\n画家：波丘尼\n达达主义 达达主义是20世纪初期在欧洲兴起的虚无主义运动，是一种无政府主义的艺术运动，其艺术特点如下:\n1.反传统观念，公开蔑视文学艺术的一切现有形式，反秩序，反系统化\n2.运用理性的方法抨击人类，将人性化的内容与机械原理结合起来，并使用现成品作为艺术创作\n3.艺术手法抽象怪异，完全突破了已有的艺术观念和形式的束缚，被认为是后现代主义的创作者\n4.代表画家 杜尚，法国艺术家，被誉为\u0026quot;现代艺术的守护神\u0026quot;，其代表作是《下楼梯的裸女二号》，《泉》\n波普艺术 波普艺术，一种主要源于商业美术形式的艺术风格，其特点是将大众文化的一些细节，如连环画、快餐及印有商标的包装进行放大复制。\n画家：安迪·沃霍尔\n极简主义 顾名思义就是能省就省，企图以最少的东西表达最多的含义，能用一双眼睛搞定何必要画一整头驴呢？\n画家：纽曼\n概念艺术 概念艺术就是在20世纪60年代中后期出现，其基本概念源于马塞尔·杜尚的思想：一件艺术品从根本上说是艺术家的思想，而不是有形的实物，即绘画和雕塑；有形的实物出自那种思想。这种艺术导致以观念取代实物、是艺术摆脱物质的艺术品。\n画家：杜尚\n后现代主义 是一种对现代表达方式甚至思维方式以及价值观的颠覆和反叛。\n音乐 巴洛克时期 音乐领域中的巴洛克时期，如同其他艺术领域一样，也体现了各种不同的风格。 这段时期的音乐中没有太多的思想，讲究韵律的优美。歌剧、清唱剧和大合唱是声乐方面最重要的一些新形式，而奏鸣曲、协奏曲和前奏曲则是为器乐而创作的。\n古典主义时期 其特点是：理智和情感的高度统一，深刻的思想内容与完美的艺术形式的高度统一。创作技法上，继承欧洲传统的复调与主调音乐的成就，并确立了近代奏鸣曲曲式的结构以及交响曲、协奏曲、各类室内乐的体裁和形式，对西洋音乐的发展有深远影响。\n浪漫主义时期 这个时期艺术家的创作上则表现为对主观感情的崇尚，对自然的热爱和对未来的幻想。艺术表现形式也较以前有了新的变化，出现了浪漫主义思潮与风格的形成与发展。\n   注：本文有许多内容搜集自互联网，若有侵权请联系删除。\n","date":"2021-01-17T23:25:28Z","permalink":"https://kegalas.top/p/%E5%90%84%E7%A7%8D%E4%B8%BB%E4%B9%89%E6%95%B4%E7%90%86/","title":"各种主义整理"},{"content":"系统：Ubuntu 20.10\n今天使用Ubuntu，想安装一下deepin的qq，在网上找到以下方法：\nwget -O- https://deepin-wine.i-m.dev/setup.sh | sh 正常执行\nsudo apt-get install com.qq.im.deepin 报错：\n下列软件包有未满足的依赖关系： libgirepository-1.0-1 : 破坏: python-gi (\u0026lt; 3.34.0-4~) 但是 3.30.4-1 正要被安装 E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。 我试着安装python-gi，同样报错，我又试着删了libgirepository-1.0-1，但是他是很多包的依赖，不敢删。\n百度搜索无果，bing搜索外国也没找到解决办法，倒是有人遇到了同样的问题。\n在ubuntu搜集信息后，发现libgirepository-1.0-1依赖于libffi7，但是apt下载不到他，只能去https://packages.ubuntu.com/zh-cn/focal/libffi7手动下载。安装完后又去https://packages.ubuntu.com/zh-cn/focal/python-gi手动下载python-gi，先后安装成功。\n再次安装qq，重启，安装成功。\n但是发现字体显示不全。找了个网站下载了simsun.ttc，放到~/.deepinwine/Deepin-QQ/drive_c/windows/Fonts/\n问题解决。\n 图片 1 \n","date":"2021-01-03T12:16:26Z","image":"https://kegalas.top/p/ubuntu%E5%AE%89%E8%A3%85deepin-qq%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/cover_huadd5fdafa4a185a8686ebe054dd413b9_24301_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/ubuntu%E5%AE%89%E8%A3%85deepin-qq%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/","title":"ubuntu安装deepin-qq时遇到的问题与解决"},{"content":"[TOC]\n不等式 均值不等式 ​ $H_n$ 为调和平均数、 ​ $G_n$ 为几何平均数、 ​ $A_n$ 为算数平均数、 ​ $Q_n$ 为平方平均数。 ​ 任意$x_i\u0026gt; 0$都成立时，有 ​ $$H_n=\\frac{n}{\\sum\\limits_{i=1}^n\\frac{1}{x_i}}=\\frac{n}{\\frac{1}{x_1}+\\frac{1}{x_2}+\\dots+\\frac{1}{x_n}}$$ ​ $$G_n=\\sqrt[n]{\\prod_{i=1}^{n}x_i}=\\sqrt[n]{x_1 x_2 \\dots x_n}$$ ​ $$A_n=\\frac{\\sum\\limits_{i=1}^{n}x_i}{n}=\\frac{x_1+x_2+\\dots+x_n}{n}$$ ​ $$Q_n=\\sqrt{\\frac{\\sum\\limits_{i=1}^{n}x_i^{2}}{n}}=\\sqrt{\\frac{x_1^{2}+x_2^{2}+\\dots+x_n^{2}}{n}}$$ ​ $$H_n\\leq G_n\\leq A_n\\leq Q_n$$ ​ 当且仅当$x_1=x_2=\\dots =x_n$时取等号\n对数平均不等式 ​ $a\\neq b$时，有 ​ $$\\sqrt{ab}\u0026lt;\\frac{a-b}{lna-lnb}\u0026lt;\\frac{a+b}{2}$$\n柯西不等式 ​ $$\\sum\\limits_{i=1}^{n}a_i^{2}\\sum\\limits_{i=1}^{n}b_i^{2}\\geq (\\sum\\limits_{i=1}^{n}a_i b_i)^2$$ ​ 当且仅当$\\frac{a_1}{b_1}=\\frac{a_2}{b_2}=\\dots =\\frac{a_n}{b_n}$时取等号 ​ 其中二维形式如下 ​ $$(a^2+b^2)(c^2+d^2)\\geq (ac+bd)^2$$ ​ 当且仅当$ad=bc$即$\\frac{a}{c}=\\frac{b}{d}$时取等\n排序不等式 ​ 排序不等式表示如下 ​ 设有两组数$a_1,a_2,\\dots,a_n$和$b_1,b_2,\\dots,b_n$，满足$a_1\\leq a_2\\leq \\dots \\leq a_n$且$b_1\\leq b_2\\leq \\dots \\leq b_n$ ​ $c_1,c_2,\\dots,c_n$是$b_1,b_2,\\dots,b_n$的乱序排列，则有： ​ ​ $$a_1 b_n+a_2 b_{n-1}+\\dots+a_n b_1\\leq a_1 c_1+a_2 c_2+\\dots+a_n c_n\\leq a_1 b_1+a_2 b_2+\\dots+a_n b_n$$ ​ ​ 当且仅当$a_1=a_2=\\dots=a_n$或$b_1=b_2=\\dots=b_n$时取等号。 ​ 便于记忆，常记为： ​ 反序和$\\leq$乱序和$\\leq$顺序和\n权方和不等式 ​ 若$a_i\u0026gt;0$，$b_i\u0026gt;0$，$m\u0026gt;0$，则有 ​ $$\\sum\\limits_{i=1}^{n}\\frac{a_i^{m+1}}{b_i^{m}}\\geq \\frac{\\left (\\sum\\limits_{i=1}^{n}a_i\\right) ^{m+1}}{\\left (\\sum\\limits_{i=1}^{n}b_i\\right) ^m}$$ ​ 即为 ​ $$\\frac{a_1^{m+1}}{b_1^{m}}+\\frac{a_2^{m+1}}{b_2^{m}}+\\dots+\\frac{a_n^{m+1}}{b_n^{m}}\\geq \\frac{(a_1+a_2+\\dots+a_n)^{m+1}}{(b_1+b_2+\\dots+b_n)^{m}}$$ ​ 当且仅当$a_i=\\lambda b_i$时取等号 ​ 其中二维形式如下 ​ 对于正数$a$，$b$，$x$，$y$，有 ​ $$\\frac{a^2}{x}+\\frac{b^2}{y}\\geq \\frac{(a+b)^2}{x+y}$$ ​ 当且仅当$a:b=x:y$时取等号 ​ 也有 ​ $$\\frac{a^2}{ax}+\\frac{b^2}{by}=\\frac{a}{x}+\\frac{b}{y}\\geq \\frac{(a+b)^2}{ax+by}$$ ​ 当且仅当$x=y$时取等号\n舒尔不等式 ​ $a,b,c\\geq 0\\quad t\\in R$时，有 ​ $$a^t (a-b)(a-c)+b^t (b-a)(b-c)+c^t (c-a)(c-b)\\geq 0$$ ​ 当且仅当$a=b=c$，或其中两个数相等且另一个等于零时，取等号。 ​ 特别的，当$t$为非负偶数时，此不等式对任意实数$a,b,c$成立。\n琴生不等式 ​ 设$f(x)$在区间$I$上是下凸函数，则对任意$x_i\\in I$及$p_i\u0026gt;0\\quad (i=1,2,\\dots,n)$，有 ​ $$ \\frac{\\sum\\limits_{i=1}^{n}p_i\\cdot f(x_i)}{\\sum\\limits_{i=1}^{n}p_i}\\geq f \\left (\\frac{\\sum\\limits_{i=1}^{n}p_i\\cdot x_i}{\\sum\\limits_{i=1}^{n}p_i} \\right ) $$ ​ 其中等号当且仅当$x_1=x_2=\\dots=x_n$时成立，若$f(x)$在区间$I$上是上凸函数，则不等号反向。\n绝对值不等式 ​ $$||a|-|b|| \\leq |a\\pm b| \\leq |a|+|b|$$\n糖水不等式 $$\\frac{b+c}{a+c}\u0026gt;\\frac{b}{a}(a\u0026gt;b\u0026gt;0,c\u0026gt;0)$$ $$\\frac{b+c}{a+c}\u0026lt;\\frac{b}{a}(b\u0026gt;a\u0026gt;0,c\u0026gt;0)$$\n函数 拉格朗日中值定理 ​ 设$y=f(x)$在$[a,b]$上连续，在$(a,b)$上可导，则存在$\\xi \\in (a,b)$使得 ​ $$f^{'}(\\xi)=\\frac{f(b)-f(a)}{b-a}$$\n拉格朗日乘数法 ​ 【例题】若正数$a,b$满足$2a+b=1$，则$\\frac{a}{2-2a}+\\frac{b}{2-b}$的最小值为? ​ 解：构造拉格朗日函数 ​ $$L(a,b,\\lambda)=\\frac{a}{2-2a}+\\frac{b}{2-b}-\\lambda(2a+b-1)$$ ​ 令 ​ $$\\frac{\\partial L}{\\partial a}=L_a=\\frac{1}{2(1-a)^2}-2\\lambda=0$$ ​ $$\\frac{\\partial L}{\\partial b}=L_b=\\frac{2}{(2-b)^2}-\\lambda=0$$ ​ $$\\frac{\\partial L}{\\partial \\lambda}=L_\\lambda=-(2a+b-1)=0$$ ​ 联立解得 ​ $$a=\\frac{5-3\\sqrt{2}}{2},b=3\\sqrt{2}-4,\\lambda=\\frac{1}{27-18\\sqrt{2}}$$ ​ 从而 ​ $$\\frac{a}{2-2a}+\\frac{b}{2-b}=\\frac{2\\sqrt{2}}{3}-\\frac{1}{2}$$ ​ 此即为所求的最小值。\n高次韦达定理 ​ 设$x_1,x_2,\\dots,x_n$为如下方程的根 ​ $$a_n x^n+a_{n-1} x^{n-1}+\\dots+a_1 x+a_0=0$$ ​ 则有 ​ $$x_1+x_2+\\dots+x_n=-\\frac{a_{n-1}}{a_n}$$ ​ $$x_1 x_2+x_1 x_3+\\dots+x_n x_{n-1}=\\frac{a_{n-2}}{a_n}$$ ​ $$\\dots$$ ​ $$x_1 x_2\\dots x_n=(-1)^n \\frac{a_0}{a_n}$$ ​ 其中三次的形式如下 ​ 若$ax^3+bx^2+cx+d=0\\ (a\\neq 0)$的3个根分别为$x_1,x_2,x_3$则有 ​ $$x_1+x_2+x_3=-\\frac{b}{a}$$ ​ $$x_1 x_2+x_1 x_3+x_2 x_3=\\frac{c}{a}$$ ​ $$x_1\\cdot x_2\\cdot x_3=-\\frac{d}{a}$$\n泰勒展开 ​ 若函数$f(x)$在$x_0$存在$n$阶导数，则有 ​ $$f(x)=f(x_0)+\\frac{f'(x_0)}{1!}(x-x_0)+\\frac{f''(x_0)}{2!}(x-x_0)^2+\\dots+\\frac{f^{(n)} (x_0)}{n!}(x-x_0)^n+R_{n+1}$$ ​ 上式即为函数$f(x)$在$x_0$处的泰勒展开式，其中$R_{n+1}=\\frac{f^{(n+1)} (\\xi)}{(n+1)!}(x-x_0)^{n+1}$（其中$\\xi$介于$x$和$x_0$间）叫做拉格朗日余项。 ​ 拉格朗日余项可用于证明不等式。如： ​ $-1\u0026lt;x\u0026lt;1$时 ​ $$\\ln(1+x)=x-\\frac{x^2}{2}+\\frac{x^3}{3}-\\frac{x^4}{4(1+\\xi)^4} (-1\u0026lt;\\xi\u0026lt;1)$$ ​ 因为$-\\frac{x^4}{4(1+\\xi)^4}\\leq 0$，所以$\\ln(1+x)\\leq x-\\frac{x^2}{2}+\\frac{x^3}{3}$\n极值点偏移 ​ 【例题】已知函数$f(x)=e^x-ax$有两个零点$x_1$和$x_2$，证明：$x_1 +x_2 \u0026gt;2$ ​ $$f(x)=e^x-ax=0\\Leftrightarrow \\frac{e^x}{x}=a$$ ​ 令$$\\varphi(x)=\\frac{e^x}{x}$$ ​ 则$$f(x_1)=f(x_2)\\Leftrightarrow\\varphi(x_1)=\\varphi(x_2),\\quad \\varphi'(x)=\\frac{(x-1)e^x}{x^2}$$ ​ 因此$\\varphi(x)$在$(0,1)$单减，$(1,+\\infty)$单增，不妨设$0\u0026lt;x_1\u0026lt;1\u0026lt;x_2$ ​ 则$x_1+x_2\u0026gt;2\\Leftrightarrow x_2\u0026gt;2-x_1$，注意到$2-x_1\u0026gt;1$ ​ $\\Leftrightarrow\\varphi(x_2)\u0026gt;\\varphi(2-x_1)$，注意到$\\varphi(x_1)=\\varphi(x_2)$ ​ 则$\\varphi(x_1)\u0026gt;\\varphi(2-x_1)$，其中$0\u0026lt;x_1\u0026lt;1$ ​ 令$$g(x)=\\varphi(x)-\\varphi(2-x), \\quad 0\u0026lt;x\u0026lt;1$$ ​ 易知 ​ $$g'(x)\u0026lt;0$$ ​ 所以$g(x)$在$(0,1)$上单减，$g(x)\u0026gt;g(1)=\\varphi(1)-\\varphi(1)=0$ ​ 即$\\varphi(x)-\\varphi(2-x)\u0026gt;0$，令$x=x_1$，Q.E.D.\n最值函数基本定理 ​ 定理一: ​ $$min{a,b } \\leq \\frac{a+b}{2} \\leq max{a,b } $$ ​ $$min{a,b}\\leq\\sqrt{ab}\\leq max{a,b}.(a\u0026gt;0,b\u0026gt;0)$$ ​ 定理二： ​ $$max{\\left|a+b\\right|,\\left|a-b\\right| }=|a|+|b|$$ ​ $$min{\\left|a+b\\right|,\\left|a-b\\right| }=||a|-|b||$$ ​ 定理三： ​ $$max{|a|,|b|}=\\frac{|a+b|}{2}+\\frac{|a-b|}{2}$$ ​ $$min{|a|,|b|}=\\left|\\frac{|a+b|}{2}-\\frac{|a-b|}{2}\\right|$$\n数列 不动点原理 ​ 【例题】求$a_1 = 1 , a_{n+1}=2a_n +1$的通项公式 ​ 其特征函数为$f(x)=2x+1$，令$f(x)=x$,解得$x=-1$ ​ 带入得$a_{n+1}-(-1)=2(a_n-(-1))$，即$a_{n+1}+1=2(a_n+1)$，之后根据等比数列可得$a_n=2^n -1$\n组合数学 容斥原理 ​ 建议根据韦恩图解题\n伯努利装错信封问题 ​ n封信与n个信封全部错位的组合数为 ​ $$f(n)=n!\\left[ \\frac{1}{2!}-\\frac{1}{3!}+\\frac{1}{4!}-\\dots +(-1)^n \\frac{1}{n!} \\right] $$\n向量 极化恒等式 ​ 重要恒等式:$4ab=(a+b)^2-(a-b)^2$ ​ 极化恒等式:$4\\boldsymbol{a}\\cdot \\boldsymbol{b}=(\\boldsymbol{a}+\\boldsymbol{b})^2-(\\boldsymbol{a}-\\boldsymbol{b})^2$\n分点恒等式 ​ 在$\\triangle ABC$中，M为BC上一等分点 ​ \\indent 当$\\overrightarrow{BM}=\\lambda \\overrightarrow{MC}时$，有 ​ $$\\overrightarrow{AM}=\\frac{1}{1+\\lambda}\\overrightarrow{AB}+\\frac{\\lambda}{1+\\lambda}\\overrightarrow{AC}$$\n三点共线定理 ​ 在平面中A、B、P三点共线的充要条件是：对于该平面内任意一点O，存在唯一的实数$x,y$使得： ​ $$\\overrightarrow{OP}=x\\overrightarrow{OA}+y\\overrightarrow{OB} $$ ​ 且 ​ $$x+y=1$$ ​ 特别的有：当P在线段AB上时，$x\u0026gt;0,y\u0026gt;0$ ​ P在线段AB之外时,$xy\u0026lt;0$\n向量中值定理 ​ 在$\\triangle ABC$中，M为BC的中点，则 ​ $$AB^2+AC^2=2(AM^2+BM^2)$$ ​ 对应的向量公式有: ​ $$\\boldsymbol{a}^2+\\boldsymbol{b}^2=2\\left[\\left(\\frac{\\boldsymbol{a}+\\boldsymbol{b}}{2}\\right)^2 + \\left(\\frac{\\boldsymbol{a}-\\boldsymbol{b}}{2}\\right)^2 \\right] $$\n向量数乘余弦定理 ​ 在$\\triangle ABC$中,有 ​ $$\\overrightarrow{AB}\\cdot \\overrightarrow{AC}=\\frac{AB^2+AC^2-BC^2}{2}$$\n三角 和差化积 ​ $$sin\\alpha+sin\\beta=2sin\\frac{\\alpha+\\beta}{2}\\cdot cos\\frac{\\alpha-\\beta}{2}$$ ​ $$sin\\alpha-sin\\beta=2cos\\frac{\\alpha+\\beta}{2}\\cdot sin\\frac{\\alpha-\\beta}{2}$$ ​ $$cos\\alpha+cos\\beta=2cos\\frac{\\alpha+\\beta}{2}\\cdot cos\\frac{\\alpha-\\beta}{2}$$ ​ $$cos\\alpha-cos\\beta=-2sin\\frac{\\alpha+\\beta}{2}\\cdot sin\\frac{\\alpha-\\beta}{2}$$\n积化和差 ​ $$sin\\alpha cos\\beta=\\frac{1}{2}\\left[sin(\\alpha+\\beta)+sin(\\alpha-\\beta)\\right]$$ ​ $$cos\\alpha sin\\beta=\\frac{1}{2}\\left[sin(\\alpha+\\beta)-sin(\\alpha-\\beta)\\right]$$ ​ $$cos\\alpha cos\\beta=\\frac{1}{2}\\left[cos(\\alpha+\\beta)+cos(\\alpha-\\beta)\\right]$$ ​ $$sin\\alpha sin\\beta=-\\frac{1}{2}\\left[cos(\\alpha+\\beta)-cos(\\alpha-\\beta)\\right]$$\n半角公式 ​ $$sin\\frac{\\theta}{2}=\\pm \\sqrt{\\frac{1-cos\\alpha}{2}}$$ ​ $$sin\\frac{\\theta}{2}=\\pm \\sqrt{\\frac{1+cos\\alpha}{2}}$$ ​ $$tan\\frac{\\theta}{2}=\\pm \\sqrt{\\frac{1-cos\\alpha}{1+cos\\alpha}}=\\frac{sin\\alpha}{1+cos\\alpha}=\\frac{1-cos\\alpha}{sin\\alpha}$$\n辅助角公式 ​ $$asin\\theta\\pm bcos\\theta=\\sqrt{a^2+b^2}sin(\\theta\\pm\\varphi),\\quad tan\\varphi=\\frac{b}{a}$$\n统计、概率、分布 期望、方差、标准差 ​ 数学期望：我们称$E\\xi = x_1 p_1+x_2 p_2+\\dots+x_n p_n$为离散型随机变量$\\xi$的数学期望 ​ 方差和标准差：我们称$D\\xi = \\sum_{i=1}^{n}(x_i-E\\xi)^2 p_i$为离散型随机变量$\\xi$的方差，其算数平方根$\\sqrt{D\\xi}=\\sigma\\xi$叫做离散型随机变量$\\xi$的标准差 ​ ​ 定理一： ​ $$E(a\\xi+b)=aE\\xi+b$$ ​ $$D(a\\xi+b)=a^2 D\\xi$$ ​ 定理二： ​ $$E(a\\xi _1+b\\xi _2)=aE\\xi _1+bE\\xi _2$$\n二项分布 ​ n次试验中事件A恰好发生k次 ​ $$P(E) ={n \\choose k}p^k (1-p)^{n-k}\\quad k=1,2,3,\\dots$$ ​ 我们称$\\xi$服从二项分布，记作$\\xi \\sim B(n,p)$ ​ 定理：$E\\xi = np$, $D\\xi = np(1-p)$\n正态分布 ​ $$f_\\xi (x)=\\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{(x-\\mu)^2}{2\\sigma ^2}} \\quad x\\in R,\\sigma\u0026gt;0$$ ​ 记作$\\xi \\sim N(\\mu,\\sigma ^2)$ ​ 性质：1.其正态曲线关于$x=\\mu$对称，最高点为$\\frac{1}{\\sigma\\sqrt{2\\pi}}$ ​ 2.$E\\xi=\\mu,D\\xi=\\sigma ^2$ ​ 3.$\\sigma$越大，正态曲线越“矮胖”，表示分布越分散，$\\sigma$越小，正态曲线越“瘦高”，表示分布越集中\n几何分布 ​ 在n次伯努利试验中，试验k次才得到第一次成功的机率。 ​ 记为$P(\\xi=k)=g(k,p)=q^{k-1}p$,其中$q=1-p$，也记为$\\xi \\sim GE(p)$ ​ 定理：$E\\xi=\\frac{1}{p},D\\xi=\\frac{q}{p^2}$\n超几何分布 ​ 它描述了从有限N个物件（其中包含M个指定种类的物件）中抽出n个物件，成功抽出该指定种类的物件的次数（不放回） ​ 记为$\\eta \\sim H(n,M,N)$ ​ $$P ( \\eta=m ) = \\frac{\\binom{M}{m}\\cdot \\binom{N-M}{n-m}}{\\binom{N}{n}}\\quad m=0,1,2,\\dots,min { n,M }$$\n其中有：\n​ $$E(X)=\\frac{nM}{N}$$\n​ $$D(X)=\\frac{nM}{N}\\left(1-\\frac{M}{N}\\right)\\frac{N-n}{N-1}$$\n方程 立方和分解 ​ $$a^3+b^3=(a+b)(a^2-ab+b^2)$$\n立方差分解 ​ $$a^3-b^3=(a-b)(a^2+ab+b^2)$$\n比例性质 ​ 若$\\frac{a}{b}=\\frac{c}{d}$则有：\n​ 合比性质\n​ $$\\frac{a+b}{b}=\\frac{c+d}{d}$$\n​ 分比性质\n​ $$\\frac{a-b}{b}=\\frac{c-d}{d}$$\n​ 合分比性质\n​ $$\\frac{a+b}{a-b}=\\frac{c+d}{c-d}$$\n​ 等比性质\n​ $$\\frac{a}{b}=\\frac{c}{d}=\\frac{a+c}{b+d}=\\frac{ma+nc}{mb+nd}$$\n几何 射影定理 ​ 射影定理，又称“欧几里德定理”：在直角三角形中，斜边上的高是两条直角边在斜边射影的比例中项，每一条直角边又是这条直角边在斜边上的射影和斜边的比例中项。 ​ ​ 在$Rt\\bigtriangleup ABC$中,$\\angle ABC=90^\\circ$,$BD$为斜边$AC$上的高，则有射影定理如下： ​ $$BD^2=AD\\cdot CD$$ ​ $$AB^2=AC\\cdot AD$$ ​ $$BC^2=CD\\cdot AC$$\n阿波罗尼斯圆 ​ 平面内到两个定点的距离之比为常数$k(k\\neq1)$的点的轨迹是圆\n角平分线定理 ​ 在$\\bigtriangleup ABC$中，$AM$为$\\angle BAC$的角平分线，$M$在$BC$上，则有： ​ $$\\frac{AB}{AC}=\\frac{MB}{MC}$$\n三角形五心 重心 ​ 三角形的三条边的中线交于一点，该点叫三角形的重心 ​ 重心的性质： ​ 1、重心到顶点的距离与重心到对边中点的距离之比为2:1。 ​ 2、重心和三角形任意两个顶点组成的3个三角形面积相等。即重心到三条边的距离与三条边的长成反比。 ​ 3、重心到三角形3个顶点距离的平方和最小。 ​ 4、在平面直角坐标系中，重心的坐标是顶点坐标的算术平均数，即其重心坐标为 ​ $$P_1= ​ \\begin{bmatrix} ​ x_1\\\n​ y_1 ​ \\end{bmatrix} ​ P_2= ​ \\begin{bmatrix} ​ x_2\\\n​ y_2 ​ \\end{bmatrix} ​ p_3= ​ \\begin{bmatrix} ​ x_3\\\n​ y_3 ​ \\end{bmatrix} ​ $$ ​ $$ ​ \\begin{bmatrix} ​ x\\\n​ y ​ \\end{bmatrix} ​ =\\frac{1}{3}(P_1+P_2+P_3)=\\frac{1}{3} ​ \\begin{bmatrix} ​ x_1+x_2+x_3\\\n​ y_1+y_2+y_3 ​ \\end{bmatrix} ​ $$ ​ 5. 以重心为起点，以三角形三顶点为终点的三条向量之和等于零向量。\n外心 ​ 三角形外接圆的圆心，叫做三角形的外心。 ​ 外心的性质： ​ 1、三角形的三条边的垂直平分线交于一点，该点即为该三角形的外心。 ​ 2、若O是$\\bigtriangleup$ABC的外心，则$\\angle$BOC=2$\\angle$A（$\\angle$A为锐角或直角）或$\\angle$BOC=360°-2$\\angle$A（$\\angle$A为钝角）。 ​ 3、当三角形为锐角三角形时，外心在三角形内部；当三角形为钝角三角形时，外心在三角形外部；当三角形为直角三角形时，外心在斜边上，与斜边的中点重合。 ​ 4、外心到三顶点的距离相等\n垂心 ​ 三角形的三条高（所在直线）交于一点，该点叫做三角形的垂心。 ​ 垂心的性质： ​ 1、三角形三个顶点，三个垂足，垂心这7个点可以得到6个四点圆。 ​ 2、三角形外心O、重心G和垂心H三点共线，且OG:GH=1:2。（此直线称为三角形的欧拉线（Euler line））（除正三角形） ​ 3、垂心到三角形一顶点距离为此三角形外心到此顶点对边距离的2倍。 ​ 4、垂心分每条高线的两部分乘积相等\n内心 ​ 三角形内切圆的圆心，叫做三角形的内心。 ​ 内心的性质： ​ 1、三角形的三条内角平分线交于一点。该点即为三角形的内心。 ​ 2、直角三角形的内心到边的距离等于两直角边的和与斜边的差的二分之一。 ​ 3、P为$\\bigtriangleup$ABC所在空间中任意一点，点O是ΔABC内心的充要条件是：$\\overrightarrow{PO}=(a×\\overrightarrow{PA} +b×\\overrightarrow{PB} +c×\\overrightarrow{PC} )/(a+b+c)$. ​ 4、O为三角形的内心，A、B、C分别为三角形的三个顶点，延长AO交BC边于N，则有AO:ON=AB:BN=AC:CN=(AB+AC):BC ​ 5、(欧拉定理)⊿ABC中，R和r分别为外接圆为和内切圆的半径，O和I分别为其外心和内心，则$OI^2=R^2-2Rr$． ​ 6、（内角平分线分三边长度关系） ​ △ABC中，0为内心，∠A 、∠B、 ∠C的内角平分线分别交BC、AC、AB于Q、P、R，　则BQ/QC=c/b, CP/PA=a/c, BR/RA=a/b. ​ 7、内心到三角形三边距离相等。\n旁心 ​ 三角形的旁切圆（与三角形的一边和其他两边的延长线相切的圆）的圆心，叫做三角形的旁心。 ​ 旁心的性质： ​ 1、三角形一内角平分线和另外两顶点处的外角平分线交于一点，该点即为三角形的旁心。 ​ 2、每个三角形都有三个旁心。 ​ 3、旁心到三边的距离相等。\n法向量叉乘求法 ​ 已知不共线的两个向量$\\boldsymbol{a}=(x_1,y_1,z_1)$,$\\boldsymbol{b}=(x_2,y_2,z_2)$\n​ 则它们所确定的平面的法向量为：\n​ $$\\boldsymbol{n}=(y_1 z_2-z_1 y_2,z_1 x_2-x_1 z_2,x_1 y_2-y_1 x_2)$$\n方法 主元法 ​ 【例题】对任意$m\\in [-1,1]$,函数$f(x)=x^2+(m-4)x+4-2m$的值恒大于零，求$x$的取值范围。 ​ $$f(x)=x^2+(m-4)x+4-2m=(x-2)m+x^2-4x+4$$ ​ 令 ​ $$g(m)=(x-2)m+x^2-4x+4$$ ​ 所以有 ​ $$\\begin{cases} ​ g(-1)=(x-2)(-1)+x^2-4x+4\u0026gt;0 ​ \\\n​ g(1)=(x-2)\\cdot 1+x^2-4x+4\u0026gt;0 ​ \\end{cases}$$ ​ 解得$x\u0026lt;1 $或 $x\u0026gt;3$\n裂项 ​ $$\\frac{1}{n(n+1)}=\\frac{1}{n}-\\frac{1}{n+1}$$ ​ $$\\frac{1}{n(n+1)(n+2)}=\\frac{1}{2}\\left[\\frac{1}{n(n+1)}-\\frac{1}{(n+1)(n+2)}\\right] $$ ​ $$\\frac{1}{\\sqrt{n+1}+\\sqrt{n}}=\\sqrt{n+1}-\\sqrt{n}$$ ​ $$a_n=(a_n-a_{n-1})+(a_{n-1}-a_{n-2})+\\dots+(a_2-a_1)+a_1$$ ​ $$a_n=\\frac{a_n}{a_{n-1}}\\bullet\\frac{a_{n-1}}{a_{n-2}}\\bullet\\dots\\bullet\\frac{a_2}{a_1}\\bullet a_1$$ ​ $$n\\cdot n!=(n+1)!-n!$$ ​ $$C^{m}_{n}=C^{m}_{n+1}-C^{m-1}_{n}$$ ​ $$n(n+1)=\\frac{1}{3}\\left[n(n+1)(n+2)-(n-1)n(n+1)\\right]$$ ​ $$\\frac{1}{C^{1}_{n+1}C^{2}_{n}}=\\frac{2}{(n+1)n(n-1)}=\\frac{1}{n(n-1)}-\\frac{1}{(n+1)n}$$ ​ $$\\frac{1}{2^n(2^n-1)}=\\frac{1}{2^n-1}-\\frac{1}{2^n}$$ ​ $$\\frac{n}{(n+1)!}=\\frac{1}{n!}-\\frac{1}{(n+1)!}$$\n放缩 ​ $$\\frac{1}{n^2}=\\frac{4}{4n^2}\u0026lt;\\frac{4}{4n^2 -1}=2\\left(\\frac{1}{2n-1}-\\frac{1}{2n+1}\\right)$$ ​ $$\\left(1+\\frac{1}{n}\\right)^n\u0026lt;1+1+\\frac{1}{2\\times 1}+\\frac{1}{3\\times 2}+\\dots+\\frac{1}{n(n-1)}\u0026lt;\\frac{5}{2}$$ ​ $$\\frac{1}{\\sqrt{n+2}}\u0026lt;\\frac{1}{\\sqrt{n+2}}-\\frac{1}{\\sqrt{n}}$$ ​ $$2(\\sqrt{n+1}-\\sqrt{n})\u0026lt;\\frac{1}{\\sqrt{n}}\u0026lt;2(\\sqrt{n}-\\sqrt{n-1})$$ ​ $$\\frac{2^n}{(2^n-1)^2}\u0026lt;\\frac{2^n}{(2^n-1)(2^n-2)}=\\frac{2^{n-1}}{(2^n-1)(2^{n-1}-1)}=\\frac{1}{2^{n-1}-1}-\\frac{1}{2^n-1}$$\n​ $$\\frac{1}{\\sqrt{n^3}}=\\frac{1}{\\sqrt{n\\cdot n^2}}\u0026lt;\\frac{1}{\\sqrt{n(n-1)(n+1)}}=\\left(\\frac{1}{\\sqrt{n(n-1)}}\n​ -\\frac{1}{\\sqrt{n(n+1)}}\\right)\\frac{1}{\\sqrt{n+1}-\\sqrt{n-1}}$$ ​ $$=\\left(\\frac{1}{\\sqrt{n-1}}-\\frac{1}{\\sqrt{n+1}}\n​ \\right)\\frac{\\sqrt{n+1}+\\sqrt{n-1}}{2\\sqrt{n}}\u0026lt;\\frac{1}{\\sqrt{n-1}}-\\frac{1}{\\sqrt{n+1}}$$\n​ $$\\frac{1}{\\sqrt{n(n+1)}}\u0026lt;\\sqrt{n}-\\sqrt{n-1}$$\n​ $$e^x\\geq x+1$$ ​ $$e^x\\leq \\frac{1}{1-x}$$ ​ $$ln(x+1)\\leq x$$ ​ $$ln(x+1)\\geq \\frac{x}{x+1}$$ ​ $$ln(x+1)\\geq x-\\frac{x^2}{2}$$ ​ $$e^x\\geq 1+x+\\frac{x^2}{2}$$ ​ $$tanx\\geq x+\\frac{x^2}{3}$$ ​ $$sinx\\geq x-\\frac{x^3}{6}$$ ​ $$sinx\\leq x$$ ​ $$cosx\\geq 1-\\frac{x^2}{2}$$\n","date":"2020-12-13T13:10:39Z","permalink":"https://kegalas.top/p/%E6%88%91%E7%9A%84%E9%AB%98%E4%B8%AD%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/","title":"我的高中资料整理"},{"content":"这是一个测试文档\n","date":"2020-12-13T12:30:53Z","permalink":"https://kegalas.top/p/%E6%B5%8B%E8%AF%95/","title":"测试"}]
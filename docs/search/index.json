[{"content":" 导航页面\nTGA格式介绍 具体可以参考http://paulbourke.net/dataformats/tga/\n这里将部分重要的介绍一下。\n首先为了简单起见，我们使用没有颜色表，也没有压缩的TGA格式。\n文件头 首先是文件头。\n  字节数 内容    1 图像信息长度  1 颜色表类型  1 图像类型  5 颜色表规范  10 图像规范    图像信息长度\n我们并不会使用这个部分，所以我们定为0.\n颜色表类型\n0代表不使用颜色表，1代表使用，我们定为0.\n图像类型\n0代表没有图像数据，2代表未压缩的真彩色图像，3代表未压缩的彩色图像，其他类型可以参照原文。\n颜色表规范\n前两个字节为颜色表首地址，然后的两个字节为颜色表长度，最后一个字节是颜色表位数。我们不会使用颜色表，所以全部设置为0.\n图形规范\n十个字节分为\n  字节数 内容    2 图像x坐标起始位置  2 图像y坐标起始位置  2 图像宽度  2 图像高度  1 每个像素占用的位数  1 图像描述字节    和一些图像格式不同，TGA的坐标原点是左下角。不过这不影响我们选择xy坐标起始位置为(0,0)。\n图像宽度和高度也不难理解，唯一需要注意的是，数据是以小端序来存储的，也就是说800在用两个字节表示，16进制的形式是，0x0320。但是实际上写入文件时，由低到高，第一个字节是20，第二个字节是03，连起来是2003。\n每个像素占用的位数，如果是黑白图像，只有一个颜色，也就是0~255，只需要一个字节，也就是8位，所以会显示为8. 如果是RGB图像，就会是24，RGBA图像，就会是32. 值得注意的一点是，写入到文件的顺序是BGR和BGRA。\n图像描述字节，占一个字节，从低到高，\n0-3位 TGA 16位图像设为0或1，TGA 24位设为0，TGA 32位设为8. 原文并没有说8位图像设置为多少，我设置为0没有问题。\n4位 必须为0\n5位 设置原点在左下角还是左上角，0为左下角，1为左上角，实际上就是垂直翻转图像，不过TGA默认为0.\n6-7位 我们不考虑这个，直接设置为0，原文有详细解释\n图像信息 如果没有颜色表，那么在文件头的十八个字节之后就进入图像信息。\n很简单，如果是黑白图像，每个字节表示一个像素。如果是RGB图像，每三个字节表示一个像素，并且在文件中是以BGR的顺序放置的。如果是RGBA图像，每四个字节表示一个像素，并且在文件中是以BGRA的顺序放置的。\n总共有“宽\\(\\times\\)高\\(\\times\\)每个像素占用的字节数”个字节\n文件尾 在写完图像信息之后是文件尾，内容包含\n  字节数 内容    2 扩展区域  2 开发者自定义区域  8 签名  2 结束    扩展区域和开发者自定义区域我们不用，直接设置为0.\n签名是TRUEVISION-XFILE的ASCII码表示，注意小端序。如果我们用两个uint64表示，就是0x4953495645555254和0x454C4946582D4E4F\n最后的结束是ASCII中的.符号和eof符号，分别是0x2E和0x00，写成一个uint16就是0x002E（考虑小端序）。\n整个TGA文件到此结束。\ntga_image.h 首先我们根据文件头的描述设定一个结构体\nstruct TGAHeader{  std::uint8_t length{}; //TGA图像信息的长度  std::uint8_t colorMapType{}; //0：不使用颜色表，1：使用颜色表  std::uint8_t imageType{}; //图像类型  std::uint16_tcMapStart{}; //颜色表首地址  std::uint16_tcMapLength{}; //颜色表长度  std::uint8_t cMapDepth{}; //颜色表位数  std::uint16_txOffset{}; //x坐标的起始位置  std::uint16_tyOffset{}; //y坐标的起始位置  std::uint16_twidth{}; //图形宽度  std::uint16_theight{}; //图像高度  std::uint8_t pixelDepth{}; //图像每一个像素占用的位数  std::uint8_t descriptor{}; //图像描述信息   TGAHeader(){} }; 然后是文件尾的结构体\nstruct TGAFooter{  std::uint32_textend{}; //扩展区域  std::uint32_tcustom{}; //开发者自定义区域  std::uint64_tsig1{}; //签名1  std::uint64_tsig2{}; //签名2  std::uint16_tend; //结束   TGAFooter(){  sig1 = 0x4953495645555254; //TRUEVISI  sig2 = 0x454C4946582D4E4F; //ON-XFILE  end = 0x002E;   } }; 注意，内存默认是以4字节对齐的，我们需要使用如下语句来保证对齐到1个字节，防止写入错误。\n#pragma pack(push) #pragma pack(1)  //...这里放入刚刚的两个结构体。  #pragma pack(pop) 方便起见，我们定义\nnamespace TGAType{  const unsigned int rgb = 0;  const unsigned int rgba = 1;  const unsigned int grey = 2;  const unsigned int pixelSize[] = {3,4,1}; } 来帮助我们定义颜色的编号和颜色格式占用的字节数，这可能并不是最好的写法，并且可能会暴露我的C++水平。\n然后我们给文件头一个新的构造函数\nTGAHeader(unsigned int type, std::uint16_twidth_, std::uint16_theight_){  if(type == TGAType::rgb){  imageType = 2;  pixelDepth = 24;  }  else if(type == TGAType::rgba){  imageType = 2;  pixelDepth = 32;  }  else if(type == TGAType::grey){  imageType = 3;  pixelDepth = 8;  }  else{  std::cerr\u0026lt;\u0026lt;\u0026#34;Error! Wrong TGA Type!\\n\u0026#34;;  }   width = width_;  height = height_;   if(type == TGAType::grey || type == TGAType::rgb){  descriptor = 0;  }  else if(type == TGAType::rgba){  descriptor = 8;  } } 这不难理解，如果我们要写入到一个新的文件中，我们定义它的颜色类型和宽度高度，然后修改内容。\n之后我们定义一个图片类\nclass TGAImage{ private:  std::uint16_t width;  std::uint16_t height;  std::uint8_t *data;  unsigned int type;  bool isFlipVertically;  public:  TGAImage(std::uint16_tconst width_, std::uint16_tconst height_, unsigned int const type_);  TGAImage(std::stringconst \u0026amp; dir);  ~TGAImage();   bool readFromFile(std::stringconst \u0026amp; dir);  bool writeToFile(std::stringconst \u0026amp; dir);  bool setFragment(std::uint16_tconst x, std::uint16_tconst y, geo::vec3i const \u0026amp; color);  bool setFragment(std::uint16_tconst x, std::uint16_tconst y, geo::vec4i const \u0026amp; color);  bool flipVertically();  }; 赋予了它少量功能，包括读写图片文件，图像翻转，以及设置某个像素的颜色值。\n完整的代码在这里\ntga_image.cpp TGAImage::TGAImage(std::uint16_tconst width_, std::uint16_tconst height_, unsigned int const type_){  width = width_;  height = height_;  type = type_;  data = new std::uint8_t[width*height*TGAType::pixelSize[type]];  isFlipVertically = 0; } 首先是一个构造函数，也不难理解，只是设定了图像自身的属性以及分配了图像数据的内存。\n注意我们分配图像数据内存的时候，要乘以每个像素占用的字节数。\nTGAImage::TGAImage(std::stringconst \u0026amp; dir){  readFromFile(dir); } 如果要从文件中定义个新图像，则我们直接调用读取文件的功能。\nTGAImage::~TGAImage(){  delete[] data; } 析构函数，释放内存。\n读取文件\nbool TGAImage::readFromFile(std::stringconst \u0026amp; dir){ //...  } std::ifstreamifs; ifs.open(dir, std::ios::binary);  if(!ifs.is_open()){  std::cerr\u0026lt;\u0026lt; \u0026#34;Error! Can\u0026#39;t open file: \u0026#34; \u0026lt;\u0026lt; dir \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  ifs.close();  return false; } 首先我们以二进制形式打开文件，并且检查错误\nTGAHeader header; ifs.read(reinterpret_cast\u0026lt;char *\u0026gt;(\u0026amp;header), sizeof(header)); if(!ifs.good()){  std::cerr\u0026lt;\u0026lt; \u0026#34;An error occured while reading the header. File: \u0026#34; \u0026lt;\u0026lt; dir \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  ifs.close();  return false; }  if(header.descriptor\u0026amp;0x20){  isFlipVertically = 1; }  width = header.width; height = header.height; if(width\u0026lt;=0||height\u0026lt;=0){  std::cerr\u0026lt;\u0026lt; \u0026#34;Error! Bad image width/height. File: \u0026#34; \u0026lt;\u0026lt; dir \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  ifs.close();  return false; } 然后我们读取文件头，并且检查是否成功读取以及数据是否有误。\nif(header.imageType == 2){  if(header.pixelDepth == 24){  type = TGAType::rgb;  }  else if(header.pixelDepth == 32){  type = TGAType::rgba;  }  else{  std::cerr\u0026lt;\u0026lt; \u0026#34;Error! Unknown pixel depth. File: \u0026#34; \u0026lt;\u0026lt; dir \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  ifs.close();  return false;  } }  else if(header.imageType == 3){  type = TGAType::grey;  if(header.pixelDepth != 8){  std::cerr\u0026lt;\u0026lt; \u0026#34;Error! Unknown pixel depth. File: \u0026#34; \u0026lt;\u0026lt; dir \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  ifs.close();  return false;  } } else{  std::cerr\u0026lt;\u0026lt; \u0026#34;Error! Unknown image type. File: \u0026#34; \u0026lt;\u0026lt; dir \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  ifs.close();  return false; } 根据图像信息来设置图像信息。\nint pixelSize = TGAType::pixelSize[type];  data = new std::uint8_t[width * height * pixelSize];  ifs.read(reinterpret_cast\u0026lt;char *\u0026gt;(data), pixelSize*width*height); if(!ifs.good()){  std::cerr\u0026lt;\u0026lt; \u0026#34;An error occured while reading the data. File: \u0026#34; \u0026lt;\u0026lt; dir \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;;  ifs.close();  return false; } 分配内存并读入图像数据，之后检查错误。\nif(isFlipVertically){  flipVertically(); } 如果图像有翻转那么进行翻转。\n文件写入\n和文件读取大同小异，不再详细说明。\n翻转图像\nbool TGAImage::flipVertically(){  int pixelSize = TGAType::pixelSize[type];  int half = height/2;  isFlipVertically = isFlipVertically^1;   for(int i=0;i\u0026lt;width;i++){  for(int j=0;j\u0026lt;half;j++){  for(int k=0;k\u0026lt;pixelSize;k++){  std::swap(data[(i+j*width)*pixelSize+k], data[(i+(height-1-j)*width)*pixelSize+k]);  }  }  }   return true; } 如上，我们将isFlipVertically取反，并且将图像数据按height/2位轴做翻转。不过我们这里虽然叫图像翻转，但是最后输出的图像和原图不会有区别，因为我们翻转图像的时候同时改变了坐标原点的位置。这样做只是方便将两个坐标系下的图像数据统一到一起去计算。\n设置像素颜色\nbool TGAImage::setFragment(std::uint16_tconst x, std::uint16_tconst y, geo::OARColor const \u0026amp; color){  assert(x\u0026gt;=0 \u0026amp;\u0026amp; x\u0026lt;width \u0026amp;\u0026amp; y\u0026gt;=0 \u0026amp;\u0026amp; y\u0026lt;height);  assert(color.r\u0026gt;=0 \u0026amp;\u0026amp; color.r\u0026lt;=255);  assert(color.g\u0026gt;=0 \u0026amp;\u0026amp; color.g\u0026lt;=255);  assert(color.b\u0026gt;=0 \u0026amp;\u0026amp; color.b\u0026lt;=255);  assert(color.a\u0026gt;=0 \u0026amp;\u0026amp; color.a\u0026lt;=255);   int pixelSize = TGAType::pixelSize[type];  size_t index = (y*width + x)*pixelSize;   if(type==TGAType::grey){  data[index] = (color.r+color.g+color.b)/3;  }  else if(type==TGAType::rgb || type==TGAType::rgba){  data[index] = color.b;  data[index+1] = color.g;  data[index+2] = color.r;   if(type==TGAType::rgba){  data[index+3] = color.a;  }  }  else{  std::cerr\u0026lt;\u0026lt;\u0026#34;An error occured while set fragment\\n\u0026#34;;  return false;  }   return true; } 主要注意下标要乘以像素占用的字节大小，以及颜色顺序为BGRA。\n完整的代码在这里\n","date":"2022-11-01T14:24:29+08:00","image":"https://kegalas.top/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E5%BA%93/cover_hu2fa2362891bfb402ec26ffe12b2b88a0_64078_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E5%BA%93/","title":"从零开始的软渲染器 图片处理库"},{"content":" 一些概念解释 弱人工智能与强人工智能 弱人工智能是指不能真正实现推理和解决问题的智能机器，这些机器表面看像是智能的，但是并不真正拥有智能，也不会有自主意识。\n强人工智能是指真正能思维的智能机器，并且认为这样的机器是有知觉的和自我意识的，这类机器可分为类人（机器的思考和推理类似人的思维）与非类人（机器产生了和人完全不一样的知觉和意识，使用和人完全不一样的推理方式）两大类。\n符号处理系统 六种功能 输入符号 输出符号 存储符号 复制符号 建立符号结构：在符号系统中形成符号结构 条件性迁移：根据已有符号，继续完成活动的过程  可以把人看作是一个物理符号系统。如果一个物理符号系统具有上述全部6种功能，能够完成这个全过程，那么它就是一个完整的物理符号系统。人具有上述6种功能；现代计算机也具备物理符号系统的这6种功能。\n有一个假设：任何一个系统，如果它能表现出智能，那么它就必定能够执行上述6种功能。反之，任何系统如果具有这6种功能，那么它就能够表现出智能；这种智能指的是人类所具有的那种智能。把这个假设称为物理符号系统的假设。\n这个假设有很多局限性，许多乐观预言都成了泡影。90年代之后人工智能领域形成了很多新的研究模式\n人工智能的学派 符号主义 又称：逻辑主义、心理学派或计算机学派\n原理：物理符号系统（即符号操作系统）假设和有限合理性原理\n符号主义认为人的认知基元是符号，认知过程即符号操作过程。认为人是一个物理符号系统，计算机也是一个物理符号系统，因此能够用计算机来模拟人的智能行为。人工智能的核心问题是知识表示、知识推理和知识运用。\n连接主义 又称：仿生学派或生理学派\n原理：神经网络及神经网络间的连接机制与学习算法。\n连接主义认为思维基元是神经元，而不是符号处理过程。认为人脑不同于电脑，并提出连接主义的大脑工作模式，用于取代符号操作的电脑工作模式。\n行为主义 又称：进化主义或控制论学派\n原理：控制论及感知—动作型控制系统\n行为主义认为智能取决于感知和行动（所以被称为行为主义），提出智能行为的“感知—动作”模式。认为智能不需要知识、不需要表示、不需要推理；人工智能可以象人类智能一样逐步进化(所以称为进化主义)；智能行为只能在现实世界中与周围环境交互作用而表现出来。\n研究领域 自然语言理解 是计算机对人类的书面和口头形式的自然语言信息进行处理加工的技术,涉及语言学,数学和计算机科学等多学科知识领域.其主要任务是建立各种自然语言处理系统,如:文字(语音)自动识别系统,电子词典,机器翻译,自动索引系统等.\n模式识别 模式识别是指用计算机代替人类或帮助人类感知模式，是对人类感知外界功能的模拟，研究的是计算机模式识别系统，也就是使一个计算机系统具有模拟人类通过感官接受外界信息、识别和理解周围环境的感知能力。\n其已在医学图象,指纹识别,天气预报,汽车牌照识别中广泛应用。\n计算机视觉 机器视觉或计算机视觉是一种用计算机实现(或模拟)人的视觉功能，对客观外界进行感知和理解的技术。它是在图像处理和模式识别技术基础上发展起来的一门新兴的学科分支，其主要目的就是用机器识别客观外界景物，即从外界获得二维图像，抽取其特征(如形状、位置、大小、灰度、颜色、纹理等)构成本征描述，然后与已知物体的描述相匹配，从而辨认出所描述的物体。\n专家系统 专家系统是一个具有大量专门知识和经验的程序系统，它应用于人工智能技术，根据某个领域中一个或多个人类专家提供的知识和经验进行推理和判断，模拟人类专家的决策过程，以解决那些需要专家决定的复杂问题。\n机器学习 所谓机器学习，就是要使计算机能模拟人的学习行为，自动地通过学习获取知识和技能，不断改善性能，实现自我完善。机器学习就是计算机自动获取知识，它是知识工程的三个分支（使用知识、知识表示、获取知识）之一 。\n神经网络 也称神经计算,是指一类计算模型,其工作原理模仿了人类大脑的某些工作机制,其利用大量人工神经元组成一个大网络,来实现大规模并行运算。\n状态空间知识表示及其搜索技术 知识 知识是人们在改造客观世界的实践中积累起来的认识和经验。\n一般来说，我们把有关信息关联在一起所形成的信息结构称为知识。\n知识表示就是对知识的一种描述，一种计算机可以 接受的用于描述知识的数据结构。\n知识的要素，一般而言，人工智能系统的知识包含事实、规则、控制和元知识。\n事实：事物的分类、属性、事物间关系、科学事实、客观事实等。\n规则：事物的行动、动作和联系的因果关系知识。\n控制：是有关问题的求解步骤、规划、求解策略等技巧性知识，告诉怎么做一件事。\n元知识：怎样使用规则、解释规则、校验规则、解释程序结构等知识。是有关知识的知识，是知识库中的高层知识。\n知识表示的一般方法 一般有：状态空间法、问题归约法、谓词逻辑法、语义网络、框架表示、剧本表示、过程表示等。\n状态空间法 问题求解(problem solving)是个大课题，它涉及归约、推断、决策、规划、常识推理、定理证明和相关过程的核心概念。在分析了人工智能研究中运用的问题求解方法之后，就会发现许多问题求解方法是采用试探搜索方法的。也就是说，这些方法是通过在某个可能的解空间内寻找一个解来求解问题的。这种基于解答空间的问题表示和求解方法就是状态空间法，它是以状态和算符(operator)为基础来表示和求解问题的。\n状态\n为描述某类不同事物间的差别而引入的一组最少变量\\(q_0,q_1,\\cdots,q_n\\)的有序集合\n可用矢量来表示：\\(Q=[q_0,q_1,\\cdots,q_n]^T\\)\n其中的每一个元素为集合的分量，称为状态变量。\n给定每个分量的一组值就得到一个具体的状态。\n算符\n把问题从一种状态变换为另一种状态的手段。\n问题的状态空间\n是一个表示该问题全部可能状态及其关系的图。\n它包含三种说明的集合,即三元状态（S，F，G），S-初始状态集合，F-操作符集合，G-目标状态集合。\n状态图示法\n用有向带权图来表示，图上的节点代表状态，边代表状态转移的路径以及转移的代价。这个路径通常也和算符有关。\n搜索推理技术 知识表示是问题求解所必须的，从问题表示到问题的解决，有一个求解过程，也就是搜索推理过程。\n搜索 根据问题的实际情况不断寻找可利用的知识,构造出一条代价较少的推理路线,使问题得到圆满解决的过程称为搜索\n要求，找到一条从初始事实到问题的最终答案的一条推理路径、找到的这条路在时间和空间复杂度上最优。\n在状态空间中搜索时，我们通常会用：图搜索策略、盲目搜索、启发式搜索等方法。\n图搜索策略 这是一种在图中寻找路径的方法。\n图中每个节点对应一个状态，每条连线对应一个操作符。\n搜索方法有很多，例如深度优先搜索等，可以看算法竞赛整理。\n在这里我们通常需要\n必须记住下一步可以走哪些点。OPEN表，记录还没有扩展的节点，用于存放刚生成的节点。 必须记住哪些点走过了。CLOSED表，记录已经扩展过的节点，用于存放已经扩展或将要扩展的节点 必须记住从目标返回的路径  其基本思想是，先把问题的初始状态作为当前扩展节点对其进行扩展，生成一组子节点，然后检查问题的目标状态是否出现在这些子节点中。\n若出现，则找到问题的解。\n若没有出现，则按照某种策略继续扩展。\n重复上述过程，直到找到解或者没有可以操作的节点为止。\n总结如下\n 1.jpg  其中第七步的排序可以是任意的即盲目的（属于盲目搜索），也可以用之后讨论的各种启发性思想或其他准则为依据（属于启发式搜索）。\n盲目搜索 这是没有启发信息的一种搜索形式，搜索过程中获得的信息不会用来改进策略。\n一般只适用于求解比较简单的问题。\n不需要重排OPEN表。\n种类主要分为：宽度优先、深度优先、等代价搜索。\nDFS和BFS不再介绍，介绍一个有界深度优先搜索。\n有界深度优先搜索\n对深度优先搜索引入搜索深度的界限（设为\\(d_m\\)），当搜索深度达到了深度界限，而仍未出现目标节点时，就换一个分支进行搜索。\n等代价搜索\n它宽度优先搜索的一种推广。不是沿着等长度路径断层进行扩展，而是沿着等代价路径断层进行扩展。\n代价树的广度优先搜索\n每次从OPEN表中选择节点往CLOSED表传送时，总是选择其中代价最小的节点。\n换句话说就是用二叉堆去维护OPEN表的节点。\n启发式搜索 特点是重排OPEN表,选择最有希望的节点加以扩展。种类有：有序搜索、\\(A^*\\)算法等等。\n启发式搜索的估价函数\n估价函数(evaluation function)，是估算节点希望程度的量度，用\\(f(n)\\)表示节点\\(n\\)的估价函数值。\n建立估价函数的一般方法是：提出任意节点与目标集之间的距离量度或差别量度\n有序搜索\n有序搜索，也称最好优先搜索，选择OPEN表上具有最小\\(f\\)值的节点作为下一个要扩展的节点。\n\\(A^*\\)算法\n它是有序搜索的一种，其特点在于对估价函数的定义上。\n用\\(k(n_i,n_j)\\)表示任意两个节点\\(n_i\\)和\\(n_j\\)之间最小代价路径的实际代价。\n如果两个节点没有通路，则\\(k\\)没有定义。\n对于一个具体的目标节点\\(t_i\\)，用\\(h^*(n)\\)表示整个目标节点集合\\(\\{t_i\\}\\)上所有\\(k(n,t_i)\\)中最小的一个，此时\\(h^*(n)\\)就是从\\(n\\)到目标节点最小代价路径的代价，从\\(n\\)到目标节点的代价为\\(h^*(n)\\)的任一路径就是一条最佳路径。\n估价函数设计如下(S是初始状态)\n\\[ g^*(n) = k(S,n) \\]\n\\[ f^*(n) = g^*(n)+h^*(n) \\]\n\\(f^*(n)\\)就是从\\(S\\)开始约束通过节点\\(n\\)的一条最佳路径的代价。\n希望估价函数\\(f\\)是\\(f^*\\)的一个估计，\\(g\\)是\\(g^*\\)的一个估计，\\(h\\)是\\(h^*\\)的一个估计，\\(h\\)叫做启发函数\n\\[ f(n) = g(n)+h(n) \\]\n在图搜索中，如果OPEN表的重排是根据\\(f(n) = g(n)+h(n)\\)来进行的，那么称为\\(A\\)算法。\n在\\(A\\)算法中,如果对所有的\\(n\\)存在\\(h(n)\\leq h^*(n)\\) ,则称\\(h(n)\\)为\\(h^*(n)\\)的下界,它表示某种偏于保守的估计;\n采用\\(h^*(n)\\)的下界\\(h(n)\\)为启发函数的\\(A\\)算法，称为\\(A^*\\)算法。\n问题归约知识表示及其搜索技术 已知问题的描述，通过一系列变换把此问题最终变为一个子问题集合；这些子问题的解可以直接得到，从而解决了初始问题。\n该方法也就是从目标(要解决的问题)出发逆向推理，建立子问题以及子问题的子问题，直至最后把初始问题归约为一个平凡的本原问题集合。这就是问题归约的实质。\n问题归约法的组成部分：\n一个初始问题描述 一套把问题变为子问题的操作符 一套本原问题描述  举个例子\n 2.jpg  与或图表示  3.jpg  或节点：只要解决某个问题就可以解决其父节点的问题\n与节点：只有解决所有子问题才可以解决其父节点的问题\n终叶节点：对应本原问题的节点\n可解节点：如下定义\n终叶节点是可解节点 如果某个非终叶节点含有或后继节点，那么只有当其后继节点至少有一个是可解的时，此非终叶节点才是可解的。 如果某个非终叶节点含有与后继节点，那么只要当其后继节点全部为可解时，此非终叶节点才是可解的  不可解节点：如下定义\n没有后裔的非终叶节点为不可解节点 如果某个非终叶节点含有或后继节点，那么只有当其全部后裔为不可解时，此非终叶节点才是不可解的。 如果某个非终叶节点含有与后继节点，那么只要当其后裔至少有一个为不可解时，此非终叶节点才是不可解的。  与或图搜索 整体与之前提到的图搜索基础没有差别，只是要去记录节点的可解性。如果最终初始节点可解，原问题就有解，否则就无解。\nMax-Min搜索  目的是为博弈的双方中的一方寻找一个最优行动方案 要寻找这个最优方案，就要通过计算当前所有可能的方案来进行比较； 方案的比较是根据问题的特征来定义一个估价函数，用来估算当前博弈树端节点的得分； 当计算出端节点的估值后，再推算出父节点的得分（即计算倒推值）；  对或节点，选其子节点中一个最大得分作为父节点的得分   对与节点，选其子节点中一个最小得分作为父节点的得分  如果一个行动方案能获得较大的倒推值，则它就是当前最好的行动方案。  假设Max是机器人下棋，Min是人类对手下棋，搜索的步骤是\n以\\(c(o)\\)为根，生成\\(k\\)-步博弈树； 评估博弈树叶节点对应的博弈状态(棋局)； 进行极大极小运算 (Max-Min 运算)； 等待 Min 行棋，产生新的 c(o)，返回 step1.  其实和人类思考差不多，往下多想\\(k\\)步可能的局面，选择自己最优，对方最差的局面。但是机器暴力地枚举了所有可能。\n\\(\\alpha-\\beta\\)剪枝 之前说的暴力算法，先生成一棵博弈树，然后再计算其倒推值，效率非常低。\n而\\(\\alpha-\\beta\\)剪枝技术的基本思想是，边生成博弈树边计算评估各节点的倒推值并且根据评估出的倒推值范围，及时停止扩展那些已无必要再扩展的子节点，即相当于剪去了博弈树上的一些分枝，从而节约了机器开销，提高了搜索效率。\n谓词逻辑表示与推理技术 谓词逻辑的概念和离散数学中讲授的一样，不再重复。具体可见离散数学整理\n谓词逻辑法 谓词逻辑法采用谓词合式公式和一阶谓词演算把要解决的问题变为一个有待证明的问题,然后采用消解原理和消解反演来证明一个新语句是从已知的正确语句导出的,从而证明新语句也是正确的.\n利用谓词公式进行知识表示的步骤 定义谓词及个体，确定其含义 根据要表达的事物或概念,为每个谓词中的变元赋值 根据表达的知识的含义,用适当的连接符号将各个谓词连接起来,形成谓词公式。  置换与合一 置换 介绍一下在离散数学中不是很详细的部分。\n一个表达式的置换就是在该表达式中用置换项置换变量。\n置换是形如\n\\[ \\{t_1/x_1,t_2/x_2,\\cdots,t_n/x_n\\} \\]\n的有限集合。其中，\\(t_i\\)是不同于\\(x_i\\)的项（常量、变量、函数）；\\(x_1,x_2,\\cdots,x_n\\)是互不相同的变量；\\(t_i/x_i\\)表示用\\(t_i\\)代换\\(x_i\\)\n令置换\\(s=\\{t_1/x_1,t_2/x_2,\\cdots,t_n/x_n\\}\\)，而\\(E\\)是一个谓词公式，那么\\(s\\)作用于\\(E\\)，就是将\\(E\\)中出现的\\(x_i\\)都以\\(t_i\\)代入。结果以\\(Es\\)表示，并称为\\(E\\)的一个例\n而合成，也称为置换乘法，是置换之间的一种运算，若\n\\[ \\theta = \\{t_1/x_1,\\cdots,t_n/x_n\\} \\]\n\\[ \\lambda = \\{u_1/y_1,\\cdots,u_m/y_m\\} \\]\n置换的乘积\\(\\theta\\cdot\\lambda\\)是个新的置换，作用于\\(E\\)相当于先\\(\\theta\\)后\\(\\lambda\\)对\\(E\\)的作用。\n先作置换\n\\[ \\{t_1\\cdot\\lambda/x_1,\\cdots,t_n\\cdot\\lambda/x_n,u_1/y_1,\\cdots,u_m/y_m\\} \\]\n若\\(y_i\\in\\{x_1,\\cdots,x_n\\}\\)时，先从中删除\\(u_i/y_i\\)；\\(t_i\\cdot\\lambda=x_i\\)时，再从中删除\\(t_i\\cdot\\lambda/x_i\\)\n所得的置换称为\\(\\theta\\)与\\(\\lambda\\)的乘积，记作\\(\\theta\\cdot\\lambda\\)\n置换的乘法是有结合律的，但没有交换率。\n合一 合一是寻找项对变量的置换，以使两表达式一致。\n如果一个置换\\(s\\)作用于表达式集\\(\\{E_i\\}\\)的每个元素，则我们用\\(\\{E_i\\}s\\)来表示置换例的集。\n称表达式集\\(\\{E_i\\}\\)是可合一的。如果存在一个置换\\(s\\)，使得：\n\\[ E_1s=E_2s=E_3s=\\cdots \\]\n那么我们称此\\(s\\)为\\(\\{E_i\\}\\)的合一者，因为\\(s\\)的作用是使 集合\\(\\{E_i\\}\\)成为单一形式。\n通过置换最少的变量以使表达式一致，这个置换就叫最一般合一者,记为mgu。\n消解原理 消解原理又称为归结原理。该原理是Robinson提出的一种基于逻辑的、采用反证法的推理方法。\n消解法的基本原理是采用反证法或者称为反演推理方法，将待证明的表达式（定理）转换成为逻辑公式（谓词公式），然后再进行归结，归结能够顺利完成，则证明原公式(定理）是正确性的。\n子句集的求解 先给出一些定义\n文字\n一个原子公式和原子公式的否定都叫做文字\n子句\n由文字的析取组成的公式\n空子句\n不包含任何文字的子句\n子句集\n由子句构成的集合\n任一谓词演算公式可以化成一个子句集。由九个步骤组成\n消去蕴涵符号（使用蕴含律）\n 减少否定符号的辖域，应用德摩根定律等使得每个否定符号都只结合一个谓词符号\n 对变量标准化。在任一量词辖域内，受该量词约束的变量为一哑元(虚构变量)，它可以在该辖域内处处统一地被另一个没有出现过的任意变量所代替，而不改变公式的真值。\n 消去存在量词\n如果要消去的存在量词在某些全称量词的辖域内，例如\\((\\forall y)[(\\exists x)P(x,y)]\\)中，中，存在量词是在全称量词的辖域内，我们允许所存在的\\(x\\)可能依赖于\\(y\\)值。令这种依赖关系明显地由函数\\(g(y)\\)所定义，它把每个\\(y\\)值映射到存在的那个\\(x\\)。这种函数叫做Skolem函数。如果用Skolem函数代替存在的\\(x\\),我们就可以消去全部存在量词，并写成：\\((\\forall y)P(g(y),y)\\) 如果不再全称量词的辖域内，直接用一个新的常量符号来替代即可。  化为前束形。把所有全称量词移到公式的左边，并使每个量词的辖域包括这个量词后面公式的整个部分。所得公式称为前束形。前束形公式由前缀和母式组成，前缀由全称量词串组成，母式由没有量词的公式组成。\n 把母式化为合取范式\n 消去全称量词\n 消去连词符号\\(\\wedge\\)。用\\(\\{(A\\vee B),(A\\vee C)\\}\\)替代\\((A\\vee B)\\wedge(A\\vee C)\\)\n 更换变量名称，把每个子句中重复变量的名称换成不同的。\n  消解反演 一般过程\n建立子句集\\(S\\) 从子句集\\(S\\)出发,仅对\\(S\\)的子句间使用归结推理规则（也即反证法） 如果得出空子句, 则结束;否则转下一步 将所得归结式仍放入\\(S\\)中 对新的子句集使用归结推理规则 转3.  空子句不含有文字,它不能被任何解释满足,所以空子句是永假的,不可满足的。\n归结过程出现空子句,说明出现互补文字,说明S中有矛盾,因此S是不可满足的。\n语义网络法 语义网络是知识的一种结构化图解表示，它由节点和弧线组成。节点用于表示实体、概念和情况等，节点之间的弧线用于表示节点间的关系。\n框架表示 框架是一种结构化表示法，通常采用语义网络中的节点-槽-值表示结构。\n规则演绎系统 基于规则的演绎推理是一种直接的推理方法，它不像消解反演把知识转化为子句集，而是把有关问题的知识和信息划分为规则和事实两种类型。\n规则由包含蕴含形式的表达式表示，事实由无蕴含形式的表达式表示，并画出相应的与或图，然后通过规则进行演绎推理。\n规则演绎系统可以分为规则正向演绎推理、规则逆向演绎系统和规则双向演绎系统。\n基于规则的问题求解系统运用下述规则来建立：\n\\[ If\\to Then \\]\n其中，If部分可能由几个if组成，而Then部分可能由一个或一个以上的then组成。\n在这种系统中，通常称每个if部分为前项，称每个then部分为后项。\n规则正向演绎系统 规则正向演绎系统是从事实到目标进行操作的，即从状况条件到动作进行推理的，也就是从if到then的方向进行推理的。\n过程\n事实表达式的与或形变换。把事实表示为非蕴涵形式的与或形，作为系统的总数据库。具体变换步骤与前述化为子句形类似。 事实表达式的与或图表示，即用与或图来表达事实表达式。 与或图的F规则变换   这些规则是建立在某个问题辖域中普通陈述性知识的蕴涵公式基础上的。我们把允许用作规则的公式类型限制为下列形式：\n  \\[ L\\Rightarrow W \\]\n  式中：\\(L\\)是单文字；\\(W\\)为与或形的公式。\n 作为终止条件的目标公式   基于规则的正向演绎推理的基本原理是：应用F规则作 用于表示事实的与或图，改变与或图的结构，从而产生 新的事实，直到推出目标公式，则推理成功结束。\n  其推理过程为\n  首先用与或图把已知事实表示出来。 用F规则的左部和与或图的叶节点进行匹配，并将匹配成功的F规则加入到与或图中，即利用F规则转换与或图。 重复第（2）步，直到产生一个含有以目标节点作为终止节点的解图为止。   规则逆向演绎系统 规则逆向演绎系统是从then向if进行推理的，即从目标或动作向事实或状况条件进行推理的。\n逆向演绎系统能够处理任意形式的目标表达式。采用和变换事实表达式类似的过程，把目标公式化成与或形。\n与或图的B规则变换\n这个B规则是建立在确定的蕴涵式基础上的，正如正向系统的F规则一样。不过，我们现在把这些B规则限制为: \\(W\\Rightarrow L\\)形式的表达式。\n其中，W为任一与或形公式，L为文字，而且蕴涵式中任何变量的量词辖域为整个蕴涵式。其次，把B规则限制为这种形式的蕴涵式还可以简化匹配，使之不会引起重大的实际困难。\n此外，可以把像\\(W\\Rightarrow(L1\\wedge L2)\\)这样的蕴涵式化为两个规则\\(W\\Rightarrow L1\\)和\\(W\\Rightarrow L2\\)。\n作为终止条件的事实节点的一致解图\n逆向系统中的事实表达式均限制为文字合取形，它可以表示为一个文字集。当一个事实文字和标在该图文字节点上的文字相匹配时，就可把相应的后裔事实节点添加到该与或图中去。这个事实节点通过标有mgu的匹配弧与匹配的子目标文字节点连接起来。同一个事实文字可以多次重复使用(每次用不同变量)，以便建立多重事实节点。逆向系统成功的终止条件是与或图包含有某个终止在事实节点上的一致解图。\n规则双向演绎系统 正向和逆向组合系统是建立在两个系统相结合的基础上的。此组合系统的总数据库由表示目标和表示事实的两个与或图结构组成，并分别用F规则和B规则来修正。\n双向演绎系统的主要复杂之处在于其终止条件，终止涉及两个图结构之间的适当交接处。这些结构可由标有合一文字的节点上的匹配棱线来连接。\n产生式系统 用来描述若干个不同的以一个基本概念为基础的系统。这个基本概念就是产生式规则或产生式条件和操作对的概念。\n在产生式系统中，论域的知识分为两部分：用事实表示静态知识，如事物、事件和它们之间的关系；用产生式规则表示推理过程和行为。由于这类系统的知识库主要用于存储规则，因此又把此类系统称为基于规则的系统。\n不确定性推理 模糊计算和模糊推理 与二值逻辑这样的非真即假的概念不同，模糊概念中，从属于该概念到不属于该概念之间无明显分界线。\n比如快慢、大小、软硬、强弱等。\n其基本思想是，用属于程度替代属于或不属于。\n经典集合 设\\(A\\)是论域\\(U\\)上的一个集合，对任意\\(u\\in U\\)，令\n\\[ C_A(u) = \\left\\{\\begin{matrix} 1,u\\in A\\\\ 0,u\\notin A \\end{matrix}\\right. \\]\n则称\\(C_A(u)\\)为集合\\(A\\)的特征函数。\n模糊理论基本概念 模糊集合\n论域\\(U\\)中的模糊集\\(F\\)用一个在区间\\([0,1]\\)的取值的隶属函数\\(\\mu_F\\)来表示，即：\n\\[ \\mu_F:U\\to[0,1] \\]\n\\(\\mu_F\\)称为\\(F\\)的隶属函数，\\(\\mu_F(u)\\)称为\\(u\\)对\\(A\\)的隶属度。\n直观上来说，就是将一些元素属于某个集合的程度映射到连续的\\([0,1]\\)上。\n模糊集的表示方法 若\\(U\\)为离散域且为有限集合时，模糊集合可以表示为：\n扎德表示法\n\\[ F = \\sum^n_{i=1}\\mu_F(u_i)/u_i \\]\n其中“\\(/\\)”符号表示的意思是，分母是论域中的元素，分子是该元素对模糊子集\\(F\\)的隶属度。\\(\\sum\\)也不是表示相加，只是一个记号。\n序偶表示法\n\\[ F=\\{(u_1,\\mu(u_1)),(u_2,\\mu(u_2)),\\cdots,(u_n,\\mu(u_n))\\} \\]\n向量表示法\n\\[ F = \\{\\mu(u_1),\\mu(u_2),\\cdots,\\mu(u_n)\\} \\]\n无论论域是有限的还是无限的，连续的还是离散的，扎德都用如下记号作为模糊子集的一般表示形式：\n\\[ F = \\int_U\\frac{\\mu_F}{u} \\]\n这里的积分号不是数学中的积分，也不是求和，只是表示论域中各元素与其隶属度对应关系的总括，是一个记号。\n集合运算 定义1\n设\\(A,B\\)是论域\\(U\\)的模糊集，即\\(A,B\\in F(U)\\)，若对于任一\\(u\\in U\\)都有\\(\\mu_B(u)\\leq\\mu_A(A)\\)，则称\\(B\\)包含于\\(A\\)，或者说\\(B\\)是\\(A\\)的一个子集，记作\\(B\\subseteq A\\)。若对于任一\\(u\\in U\\)都有\\(\\mu_B(u)=\\mu_A(A)\\)，则称\\(B\\)等于\\(A\\)，记作\\(B=A\\)\n定义2\n并运算（\\(A\\bigcup B\\)）的隶属度函数\\(\\mu_{A\\bigcup B}\\)对所有的\\(u\\in U\\)被逐点定义为取大运算，即\n\\[ \\mu_{A\\bigcup B} = \\mu_A(u)\\vee\\mu_B(u) \\]\n式中，\\(\\vee\\)符号取极大值运算。\n定义3\n交运算（\\(A\\bigcap B\\)）的隶属度函数\\(\\mu_{A\\bigcap B}\\)对所有的\\(u\\in U\\)被逐点定义为取小运算，即\n\\[ \\mu_{A\\bigcap B} = \\mu_A(u)\\wedge\\mu_B(u) \\]\n式中，\\(\\wedge\\)符号取极小值运算。\n定义4\n补，隶属度函数\\(\\mu_{\\bar A}\\)，对所有的\\(u\\in U\\)，被逐点定义为\\(\\mu_{\\bar A}(u) = 1-\\mu_{A}(u)\\)\n定理\n集合运算的定理和经典的集合没有区别，例如结合、分配律，德摩根律等等。\n模糊集的截集 定义1\n设\\(A\\in F(u),\\lambda\\in[0,1]\\)，则\n\\(A_\\lambda=\\{u|u\\in U,\\mu_A(u)\\geq\\lambda\\}\\)，称\\(A_\\lambda\\)为\\(A\\)的一个\\(\\lambda\\)截集，称\\(\\lambda\\)为阈值（置信水平） \\(A_\\lambda=\\{u|u\\in U,\\mu_A(u)\u0026gt;\\lambda\\}\\)，称\\(A_\\lambda\\)为\\(A\\)的一个\\(\\lambda\\)强截集 \\(SuppA=\\{u|u\\in U,\\mu_A(u)\u0026gt;0\\}\\)为\\(A\\)的支集 \\(KerA=\\{u|u\\in U,\\mu_A(u)=1\\}\\)为\\(A\\)的核  当\\(A\\)的核不为空，则称\\(A\\)为正规\\(F\\)集。\n","date":"2022-10-31T09:56:28+08:00","image":"https://kegalas.top/p/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/cover_hu729735102c3c060f4a29b2f0df39e169_86954_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A6%82%E8%AE%BA%E7%AC%94%E8%AE%B0/","title":"人工智能概论笔记"},{"content":" 导航页面\n图形学中最基础的数学涉及到线性代数，我们需要自己先写一个能处理简单的向量、矩阵运算的库。\ngeometry.h 向量的定义 首先构造一个一般化的向量类\ntemplate\u0026lt;class T, size_t dim\u0026gt; class Vec{ public:  Vec(){  for(size_t i=0;i\u0026lt;dim;i++){  data_[i] = T();  }  }   Vec(Vec\u0026lt;T,dim\u0026gt; const \u0026amp; v){  for(size_t i=0;i\u0026lt;dim;i++){  data_[i] = v[i];  }  }   T\u0026amp; operator[](const size_t i){  assert(i\u0026lt;dim \u0026amp;\u0026amp; i\u0026gt;=0);  return data_[i];  }   const T\u0026amp; operator[](const size_t i) const {  assert(i\u0026lt;dim \u0026amp;\u0026amp; i\u0026gt;=0);  return data_[i];  }   Vec\u0026lt;T, dim\u0026gt;\u0026amp; operator=(const Vec\u0026lt;T,dim\u0026gt; vec){  if(this==\u0026amp;vec){  return *this;  }   for(size_t i=0;i\u0026lt;dim;i++){  this-\u0026gt;data_[i] = vec[i];  }    return *this;  }  private:  T data_[dim]; }; 首先template\u0026lt;class T, size_t dim\u0026gt;指的是让它的向量元素的数据类型为T，然后有dim维\nVec()这个默认构造函数不难理解，Vec(Vec\u0026lt;T,dim\u0026gt; const \u0026amp; v)是一个复制构造函数，而相应的Vec\u0026lt;T, dim\u0026gt;\u0026amp; operator=(const Vec\u0026lt;T,dim\u0026gt; vec)是一个复制赋值运算符。\nT\u0026amp; operator[]是为了方便取向量的某一个元素，并且同时提供了const的版本，这是一个经常可以见到的设计。并且我们检查数组越界。\n下面对其进行模板特殊化\ntemplate\u0026lt;class T\u0026gt; class Vec\u0026lt;T,2\u0026gt;{ public:  union{  struct {T x,y;};  struct {T s,t;};  struct {T u,v;};  T raw[2];  };   Vec\u0026lt;T,2\u0026gt;():x(),y(){}   Vec\u0026lt;T,2\u0026gt;(T x_, T y_):x(x_),y(y_){}   Vec\u0026lt;T,2\u0026gt;(Vec\u0026lt;T,2\u0026gt; const \u0026amp; v):x(v.x),y(v.y){}   template\u0026lt;class U\u0026gt; Vec\u0026lt;T,2\u0026gt;(Vec\u0026lt;U,2\u0026gt; const \u0026amp;);  template\u0026lt;class U\u0026gt; Vec\u0026lt;T,2\u0026gt;(Vec\u0026lt;U,3\u0026gt; const \u0026amp;);  template\u0026lt;class U\u0026gt; Vec\u0026lt;T,2\u0026gt;(Vec\u0026lt;U,4\u0026gt; const \u0026amp;);   T\u0026amp; operator[](const size_t i){  assert(i\u0026lt;2 \u0026amp;\u0026amp; i\u0026gt;=0);  return raw[i];  }   const T\u0026amp; operator[](const size_t i) const{  assert(i\u0026lt;2 \u0026amp;\u0026amp; i\u0026gt;=0);  return raw[i];  }   Vec\u0026lt;T, 2\u0026gt;\u0026amp; operator=(const Vec\u0026lt;T,2\u0026gt;\u0026amp; vec){  if(this==\u0026amp;vec){  return *this;  }  for(size_t i=0;i\u0026lt;2;i++){  this-\u0026gt;raw[i] = vec[i];  }    return *this;  }  }; 如上，我们定义了一个二维的向量，这个叫做模板特殊化，当我们声明Vec\u0026lt;float,2\u0026gt;时，会首先调用最特殊的那个，在此处会调用Vec\u0026lt;T,2\u0026gt;，而不是更一般的Vec\u0026lt;T,dim\u0026gt;\n另外需要注意的是，模板特殊化并不是继承，特殊的模板不会继承一般的模板的成员。所以我们需要重新地定义整个Vec\u0026lt;T,2\u0026gt;\nunion{  struct {T x,y;};  struct {T s,t;};  struct {T u,v;};  T raw[2]; }; 这是一个联合，但实际上只用了两个sizeof(T)的内存，其中x、s、u和raw[0]表示的都是第一维，而y、t、v、raw[1]表示的是第二维\nVec\u0026lt;T,2\u0026gt;():x(),y(){}  Vec\u0026lt;T,2\u0026gt;(T x_, T y_):x(x_),y(y_){}  Vec\u0026lt;T,2\u0026gt;(Vec\u0026lt;T,2\u0026gt; const \u0026amp; v):x(v.x),y(v.y){} 这是三个构造函数，有时我们可能会写成\nVec\u0026lt;T,2\u0026gt;(T x_, T y_){  x = x_;  y = y_; } 这效果是相同的，但是如果T是一个类，而不是一个int、float这样的类型，那会导致性能问题。\n此时会先调用x的默认构造函数，然后再将x_赋值给x，调用复制赋值运算符，这是两步。而我们用成员初始化列表就直接调用了赋值构造函数，只有一步。\n虽然你可能会想为什么会有人给向量除了int和float之外的类型，我觉得你最好不要推断用户的想法。\ntemplate\u0026lt;class U\u0026gt; Vec\u0026lt;T,2\u0026gt;(Vec\u0026lt;U,2\u0026gt; const \u0026amp;); template\u0026lt;class U\u0026gt; Vec\u0026lt;T,2\u0026gt;(Vec\u0026lt;U,3\u0026gt; const \u0026amp;); template\u0026lt;class U\u0026gt; Vec\u0026lt;T,2\u0026gt;(Vec\u0026lt;U,4\u0026gt; const \u0026amp;); 这是我们之后要让float类型和int类型互相转化而提前声明的模板。\n对三维和四维的向量基本相同，目前我们要学的图形学不会用到更高维的向量了。\n下面开始定义向量的各种运算\ntemplate\u0026lt;class T, size_t dim\u0026gt; Vec\u0026lt;T, dim\u0026gt; operator+(Vec\u0026lt;T, dim\u0026gt; const \u0026amp; lhs, Vec\u0026lt;T, dim\u0026gt; const \u0026amp; rhs){  Vec\u0026lt;T,dim\u0026gt; ret;  for(size_t i=0;i\u0026lt;dim;i++){  ret[i] = lhs[i] + rhs[i];  }  return ret; } 代码不难理解，我们选择在全局定义这个运算符，而不是在类内部定义成员函数。这是为了更好的泛用性。以及缩短码量。\n其他的加减乘除类似，不过我们这里的乘法和除法指的是各个元素对应的乘除，并且我们还要定义向量和的数乘，数除。数除还应该注意左右操作数。\n然后再定义点乘和叉乘\ntemplate\u0026lt;class T, size_t dim\u0026gt; T dot(Vec\u0026lt;T, dim\u0026gt; const \u0026amp; lhs, Vec\u0026lt;T, dim\u0026gt; const \u0026amp; rhs){  T ret = T();   for(int i=0;i\u0026lt;dim;i++){  ret += lhs[i] * rhs[i];  }   return ret; }  template\u0026lt;class T\u0026gt; Vec\u0026lt;T, 3\u0026gt; cross(Vec\u0026lt;T, 3\u0026gt; const \u0026amp; lhs, Vec\u0026lt;T, 3\u0026gt; const \u0026amp; rhs){  Vec\u0026lt;T, 3\u0026gt; ret;   ret.x = lhs.y*rhs.z - lhs.z*rhs.y;  ret.y = lhs.z*rhs.x - lhs.x*rhs.z;  ret.z = lhs.x*rhs.y - lhs.y*rhs.x;   return ret; } 不把*设计为点乘，主要是考虑到OpenGL也是用dot表示点乘，而*表示元素对应相乘。\n代码并不困难，数学也是高中知识，值得注意的是，叉乘只有三维向量才有定义。\ntemplate\u0026lt;class T, size_t dim\u0026gt; T norm(Vec\u0026lt;T, dim\u0026gt; const \u0026amp; vec){  T ret = dot(vec,vec);  ret = std::sqrt(ret);  return ret; } 定义向量的2-范数，也就是\\(\\sqrt{x_1^2+x_2^2+\\cdots}\\)，这可以方便我们计算长度。1-范数和无穷范数暂时用不上。\ntemplate\u0026lt;class T, size_t dim\u0026gt; void normalize(Vec\u0026lt;T, dim\u0026gt; \u0026amp; vec){  T vnorm = (static_cast\u0026lt;T\u0026gt; (1))/norm(vec);  for(size_t i=0;i\u0026lt;dim;i++){  vec[i] *= vnorm;  } }  template\u0026lt;class T, size_t dim\u0026gt; Vec\u0026lt;T, dim\u0026gt; normalized(Vec\u0026lt;T, dim\u0026gt; const \u0026amp; vec){  Vec\u0026lt;T, dim\u0026gt; ret;  T vnorm = (static_cast\u0026lt;T\u0026gt; (1))/norm(vec);  for(size_t i=0;i\u0026lt;dim;i++){  ret[i] = vec[i] * vnorm;  }  return ret; } 分别定义了，将一个向量标准化，和返回一个向量的标准化。后者是可以对const变量使用的。\n值得注意的一点是，我们使用vnorm这个变量，是因为除法比乘法慢，我们通过预先计算倒数，来加速这个过程。\ntemplate\u0026lt;class T, size_t dim\u0026gt; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, const Vec\u0026lt;T, dim\u0026gt;\u0026amp; vec){  for(size_t i=0;i\u0026lt;dim;i++){  out\u0026lt;\u0026lt;vec[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  }  return out; } 我们重载了输出流，方便直接打印出来调试。\nVec\u0026lt;int,3\u0026gt; toRGB(Vec\u0026lt;int,3\u0026gt; const \u0026amp; v); Vec\u0026lt;int,3\u0026gt; toRGB(Vec\u0026lt;float,3\u0026gt; const \u0026amp; v); Vec\u0026lt;int,4\u0026gt; toRGBA(Vec\u0026lt;int,4\u0026gt; const \u0026amp; v); Vec\u0026lt;int,4\u0026gt; toRGBA(Vec\u0026lt;float,4\u0026gt; const \u0026amp; v); 在计算机图形学中，颜色也可以表示为一个向量，为此我们声明几个函数将其他的向量转变为RGB或RGBA颜色值。\n矩阵的定义 template\u0026lt;class T, size_t nRow, size_t nCol\u0026gt; class Mat{ private:  Vec\u0026lt;T, nCol\u0026gt; rowVec[nRow];  public:  Mat\u0026lt;T, nRow, nCol\u0026gt;(){  size_t minDim = std::min(nRow, nCol);  for(size_t i=0 ; i\u0026lt;minDim ; i++){  rowVec[i][i] = static_cast\u0026lt;T\u0026gt; (1);  }  }   Mat\u0026lt;T, nRow, nCol\u0026gt;(T const value){  size_t minDim = std::min(nRow, nCol);  for(size_t i=0 ; i\u0026lt;minDim ; i++){  rowVec[i][i] = value;  }  }   Mat\u0026lt;T, nRow, nCol\u0026gt;(Mat\u0026lt;T, nRow, nCol\u0026gt; const \u0026amp; m){  for(size_t i=0 ; i\u0026lt;nRow ; i++){  rowVec[i] = m[i];  }  }   Vec\u0026lt;T, nCol\u0026gt;\u0026amp; operator[](size_t const i){  assert(i\u0026gt;=0 \u0026amp;\u0026amp; i\u0026lt;nRow);  return rowVec[i];  }   const Vec\u0026lt;T, nCol\u0026gt;\u0026amp; operator[](size_t const i) const {  assert(i\u0026gt;=0 \u0026amp;\u0026amp; i\u0026lt;nRow);  return rowVec[i];  }   Mat\u0026lt;T, nRow, nCol\u0026gt;\u0026amp; operator=(Mat\u0026lt;T, nRow, nCol\u0026gt; const \u0026amp; mat){  if(this==\u0026amp;mat){  return *this;  }  for(size_t i=0 ; i\u0026lt;nRow ; i++){  this-\u0026gt;rowVec[i] = mat[i];  }  return *this;  }   Vec\u0026lt;T, nRow\u0026gt; getColVec(size_t const index) const {  assert(index\u0026gt;=0 \u0026amp;\u0026amp; index\u0026lt;nCol);  Vec\u0026lt;T, nRow\u0026gt; ret;  for(size_t i=0 ; i\u0026lt;nRow ; i++){  ret[i] = rowVec[i][index];  }  return ret;  }   void setColVec(size_t const index, Vec\u0026lt;T, nRow\u0026gt; const \u0026amp; vec){  assert(index\u0026gt;=0 \u0026amp;\u0026amp; index\u0026lt;nCol);  for(size_t i=0 ; i\u0026lt;nRow ; i++){  rowVec[i][index] = vec[i];  }  } }; Vec\u0026lt;T, nCol\u0026gt; rowVec[nRow] 这一句，意味着我们采取了行先序，我们将一个矩阵看成了n个行向量。意味着mat[1][2]代表着第1行的第2个元素。行先序和matlab一致，也和glm库一致。\n我们的默认构造函数默认地构造了一个单位矩阵，即主对角线上的元素都是1，而Mat\u0026lt;T, nRow, nCol\u0026gt;(T const value)这个构造函数将主对角线上的元素设置为value。\nMat\u0026lt;T, nRow, nCol\u0026gt;\u0026amp; operator=(Mat\u0026lt;T, nRow, nCol\u0026gt; const \u0026amp; mat){ if(this==\u0026amp;mat){  return *this; } for(size_t i=0 ; i\u0026lt;nRow ; i++){  this-\u0026gt;rowVec[i] = mat[i]; } return *this; } 另外我们提供了复制构造函数以及复制赋值运算符，后者是很有必要的，否则默认的赋值运算，将会把rowVec这个指针指向右值中对应的地址，此时两个矩阵实际上用的是同一份数据，为了避免这个，我们有必要重新设计复制赋值运算符。\nVec\u0026lt;T, nRow\u0026gt; getColVec(size_t const index) const {  assert(index\u0026gt;=0 \u0026amp;\u0026amp; index\u0026lt;nCol);  Vec\u0026lt;T, nRow\u0026gt; ret;  for(size_t i=0 ; i\u0026lt;nRow ; i++){  ret[i] = rowVec[i][index];  }  return ret; }  void setColVec(size_t const index, Vec\u0026lt;T, nRow\u0026gt; const \u0026amp; vec){  assert(index\u0026gt;=0 \u0026amp;\u0026amp; index\u0026lt;nCol);  for(size_t i=0 ; i\u0026lt;nRow ; i++){  rowVec[i][index] = vec[i];  } } 我们也提供了获取和修改列向量的函数。\n接下来同样是提供全局的运算符重载。\n矩阵的相加、相减、数乘、数除和向量的代码基本一致。但同样为了和OpenGL着色器语言保持一致，我们矩阵乘以向量和向量相乘用的是*符号。\ntemplate\u0026lt;class T, size_t nRow, size_t nCol\u0026gt; Vec\u0026lt;T, nRow\u0026gt; operator*(Mat\u0026lt;T, nRow, nCol\u0026gt; const \u0026amp; lhs, Vec\u0026lt;T, nCol\u0026gt; const \u0026amp; rhs){  Vec\u0026lt;T, nRow\u0026gt; ret;  for(size_t i=0 ; i\u0026lt;nRow ; i++){  ret[i] = dot(lhs[i] , rhs);  }  return ret; }  template\u0026lt;class T, size_t nRow, size_t nCol, size_t sameDim\u0026gt; Mat\u0026lt;T, nRow, nCol\u0026gt; operator*(Mat\u0026lt;T, nRow, sameDim\u0026gt; const \u0026amp; lhs, Mat\u0026lt;T, sameDim, nCol\u0026gt; const \u0026amp; rhs){  Mat\u0026lt;T, nRow, nCol\u0026gt; ret;  for(size_t i=0 ; i\u0026lt;nRow ; i++){  for(size_t j=0 ; j\u0026lt;nCol ; j++){  ret[i][j] = dot(lhs[i] , rhs.getColVec(j));  }  }  return ret; } 这里我们默认向量都是列向量，所以矩阵*向量要求向量的维数和矩阵的列数相同。\n而矩阵乘以矩阵要求前者的列数等于后者的行数。\n用模板可以很好地实现上述内容。\ntemplate\u0026lt;class T, size_t nRow, size_t nCol\u0026gt; Mat\u0026lt;T, nCol, nRow\u0026gt; transpose(Mat\u0026lt;T, nRow, nCol\u0026gt; const \u0026amp; mat){  Mat\u0026lt;T, nCol, nRow\u0026gt; ret;  for(size_t i=0 ; i\u0026lt;nRow ; i++){  ret.setColVec(i, mat[i]);  }  return ret; } 矩阵转置很简单，将原来的行向量设置给新的列向量即可。\ntemplate\u0026lt;class T, size_t dim\u0026gt; Mat\u0026lt;T, dim-1, dim-1\u0026gt; getMinor(Mat\u0026lt;T, dim, dim\u0026gt; const \u0026amp; mat, size_t x, size_t y){  assert(dim\u0026gt;0);  Mat\u0026lt;T, dim-1, dim-1\u0026gt; ret;  for(size_t i=0;i\u0026lt;dim-1;i++){  for(size_t j=0;j\u0026lt;dim-1;j++){  ret[i][j] = mat[i\u0026lt;x?i:i+1][j\u0026lt;y?j:j+1];  }  }  return ret; } 这是在计算一个矩阵，去除某个元素的所在行和所在列得到的子矩阵。\ntemplate\u0026lt;class T, size_t dim\u0026gt; T det(Mat\u0026lt;T, dim, dim\u0026gt; const \u0026amp; mat){  assert(dim\u0026gt;0);   T ret = T();   for(size_t i=0;i\u0026lt;dim;i++){   ret += cofactor(mat, 0, i) * mat[0][i];  }   return ret; }  template\u0026lt;class T\u0026gt; T det(Mat\u0026lt;T,2,2\u0026gt; const \u0026amp; mat){  return mat[0][0]*mat[1][1] - mat[0][1]*mat[1][0]; }  template\u0026lt;class T\u0026gt; T det(Mat\u0026lt;T,1,1\u0026gt; const \u0026amp; mat){  return mat[0][0]; }  template\u0026lt;class T\u0026gt; T det(Mat\u0026lt;T,0,0\u0026gt; const \u0026amp; mat){  return static_cast\u0026lt;T\u0026gt;(0); }  template\u0026lt;class T, size_t dim\u0026gt; T cofactor(Mat\u0026lt;T, dim, dim\u0026gt; const \u0026amp; mat, size_t x, size_t y){  return det(getMinor(mat,x,y)) * static_cast\u0026lt;T\u0026gt;((x+y)%2?-1:1); } 这是计算行列式与代数余子式的代码。\n计算大于2阶的行列式，需要用到代数余子式的方法，可以参考线性代数笔记。\n值得注意的是，det中我们每次计算都会减少dim一阶，但是你并不能使用if(dim==2);if(dim==1);if(dim\u0026lt;=0)这样的语句来在模板内部定义特例，这是无法编译通过的。你需要做的是将模板特殊化，这样才能通过编译。\ntemplate\u0026lt;class T, size_t dim\u0026gt; Mat\u0026lt;T,dim,dim\u0026gt; adjugate(Mat\u0026lt;T, dim, dim\u0026gt; const \u0026amp; mat){  Mat\u0026lt;T, dim, dim\u0026gt; ret;  for(size_t i=0;i\u0026lt;dim;i++){  for(size_t j=0;j\u0026lt;dim;j++){  ret[j][i] = cofactor(mat,i,j);  }  }  return ret; }  template\u0026lt;class T, size_t dim\u0026gt; Mat\u0026lt;T,dim,dim\u0026gt; inverse(Mat\u0026lt;T, dim, dim\u0026gt; const \u0026amp; mat){  Mat\u0026lt;T, dim, dim\u0026gt; ret;  ret = adjugate(mat)/det(mat);  return ret; } 这是计算伴随矩阵和逆矩阵的代码，有一点值得注意，就是伴随矩阵的下标相当于进行了转置。\ntypedef Vec\u0026lt;float,2\u0026gt; vec2f; typedef Vec\u0026lt;float,3\u0026gt; vec3f; typedef Vec\u0026lt;float,4\u0026gt; vec4f; typedef Vec\u0026lt;int,2\u0026gt; vec2i; typedef Vec\u0026lt;int,3\u0026gt; vec3i; typedef Vec\u0026lt;int,4\u0026gt; vec4i;  typedef Mat\u0026lt;float, 4, 4\u0026gt; mat4f; typedef Mat\u0026lt;int, 4, 4\u0026gt; mat3f; 最后声明一下变量的别名方便使用。\n另外这些全部都是在geo命名空间中，方便辨别。\n完整的代码在这里\ngeometry.cpp 这个文件里大部分都是涉及向量类型转换的。唯一需要注意的是四舍五入。以三维为例\ntemplate\u0026lt;\u0026gt; template\u0026lt;\u0026gt; geo::Vec\u0026lt;int,3\u0026gt;::Vec(geo::Vec\u0026lt;float, 2\u0026gt; const \u0026amp; v, float const z_){  x = static_cast\u0026lt;int\u0026gt;(v.x + 0.5f);  y = static_cast\u0026lt;int\u0026gt;(v.y + 0.5f);  z = static_cast\u0026lt;int\u0026gt;(z_ + 0.5f); } 这段代码将二维的float向量转为三维的int向量，+0.5f即是四舍五入。\n然后就是转化为RGBA颜色格式，为了简单起见，我们假设所有的颜色都用RGBA表示，所以我们需要将RGB和灰度图像转化为RGBA，然后在写入图像时再具体分析写入什么颜色数据。举例将float的RGB和int的灰度转换为RGBA：\ngeo::Vec\u0026lt;int,4\u0026gt; geo::toOARColor(geo::Vec\u0026lt;float,3\u0026gt; const \u0026amp; v){  OARColor ret;  for(int i=0;i\u0026lt;3;i++){  ret[i] = static_cast\u0026lt;int\u0026gt;(v[i]*255.f+0.5f);  if (ret[i]\u0026lt;0) ret[i] = 0;  else if(ret[i]\u0026gt;255) ret[i] = 255;  }  ret[3] = 255;   return ret; }  geo::Vec\u0026lt;int,4\u0026gt; geo::toOARColor(int const \u0026amp; v){  OARColor ret;  for(int i=0;i\u0026lt;3;i++){  if(v\u0026lt;0) ret[i] = 0;  else if(v\u0026gt;255) ret[i] = 255;  else ret[i] = v;  }  ret[3] = 255;   return ret; } 其将连续的[0,1]映射到离散的[0,255]（或者本来就是离散的），并且超出的部分映射到边界上，同时也计算了四舍五入。\n完整的代码在这里\n","date":"2022-10-28T15:34:04+08:00","image":"https://kegalas.top/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7%E5%BA%93/cover_huc0107afa81d973e7d87fe5de99d27181_24753_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%99%A8-%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7%E5%BA%93/","title":"从零开始的软渲染器 数学工具库"},{"content":" 目录 1. 从零开始的软渲染器-数学工具库\n2. 从零开始的软渲染器-图片处理库\n","date":"2022-10-28T15:33:42+08:00","image":"https://kegalas.top/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%AF%BC%E8%88%AA/cover_huef498dd5cf38693b5a441291f5d52b83_173498_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E8%BD%AF%E6%B8%B2%E6%9F%93%E5%99%A8-%E5%AF%BC%E8%88%AA/","title":"从零开始的软渲染器 导航"},{"content":" 基础知识 多项式求值 对于形如下式的多项式\n\\[ P(x)=2x^4+3x^3-3x^2+5x-1 \\]\n如果我们普通地代入计算，则会需要计算10次乘法，以及4次加法。这显然不是最优的，更优的方法例如秦九韶算法，将多项式重写为\n\\[ P(x)=-1+x*(5+x*(-3+x*(3+x*2))) \\]\n此时再代入值计算，则只用4次乘法和4次加法。一般来说\\(d\\)阶多项式可以通过\\(d\\)次乘法和\\(d\\)次加法求值。\n标准形式的多项式\n\\[ P(x) = c_1+c_2x+c_3x^2+c_4x^3+c_5x^4 \\]\n可以写成\n\\[ P(x)=c_1+x(c_2+x(c_3+x(c_4+x(c_5)))) \\]\n或者也有更一般的形式，可以用于之后的插值计算\n\\[ P(x)=c_1+(x-r_1)(c_2+(x-r_2)(c_3+(x-r_3)(c_4+(x-r_4)(c_5)))) \\]\n其中称\\(r1,r2,r3,r4\\)为基点。\n二进制数字 二进制数字可以表示为：\n\\[ \\cdots b_2b_1b_0b_{-1}b_{-2}\\cdots \\]\n其等价于十进制下的\n\\[ \\cdots b_22^2+b_12^1+b_02^0+b_{-1}2^{-1}+b_{-2}2^{-2}\\cdots \\]\n十进制转化为二进制 例如\\(53.7\\)转化为二进制，可以拆分为整数部分和小数部分，分别转化，然后在拼接起来。\n整数部分\n将整数连续除以\\(2\\)，记录余数，直到整数最后变为\\(0\\)，余数反过来排列在一起就是二进制表示。例如\n\\[ 53\\div 2 = 26\\cdots1 \\]\n\\[ 26\\div 2 = 13\\cdots0 \\]\n\\[ 13\\div 2 = 6\\cdots1 \\]\n\\[ 6\\div 2 = 3\\cdots0 \\]\n\\[ 3\\div 2 = 1\\cdots1 \\]\n\\[ 1\\div 2 = 0\\cdots1 \\]\n那么二进制表示就是\\(110101\\)\n小数部分\n将小数部分不断乘以\\(2\\)，得到的结果保留整数部分，直到小数部分为\\(0\\)，整数部分顺序排列即为小数部分的二进制表示\n例如\n\\[ 0.7*2 = 0.4+1 \\]\n\\[ 0.4*2 = 0.8+0 \\]\n\\[ 0.8*2 = 0.6+1 \\]\n\\[ 0.6*2 = 0.2+1 \\]\n\\[ 0.2*2 = 0.4+0 \\]\n\\[ 0.4*2 = 0.8+0 \\]\n\\[ \\vdots \\]\n后面重复，代表在二进制中是无限循环小数。有\\((0.7)_{10}=(0.1\\overline{0110})_2\\)\n最后有\\((53.7)_{10} = (110101.1\\overline{0110})_2\\)。\n二进制转化为十进制 开头已经介绍过一般情况，对于有限小数是容易计算的。\n无限小数时，例如\\(x=(0.\\overline{1011})_2\\)，先左移\\(4\\)位，再减去原始的\\(x\\)，有\n\\[ 2^4x = 1011.\\overline{1011}\\\\ x=0000.\\overline{1011} \\]\n相减得\n\\[ (2^4-1)x = (1101)_2 = (11)_{10} \\]\n求解\\(x\\)可得，\\(x=(0.\\overline{1011})_2=11/15\\)。\n实数的浮点表示 本节按照IEEE754标准。\n浮点格式 一个浮点数字包含三个部分：符号（正负）、尾数（包含一串有效数位）和一个指数，这些部分都在一个计算机字(WORD)里。\n浮点数常用三种精度级别：单精度、双精度、扩展精度。它们分配的数位分别是32、64、80。具体如下\n  精度 符号 指数 尾数    单精度 1 8 23  双精度 1 11 52  扩展精度 1 15 64    三种精度以相同的方式运行。标准化的IEEE浮点数表示为\n\\[ \\pm 1.bbb\\cdots b\\times 2^p \\]\n其中\\(N\\)个\\(b\\)或0或1，\\(p\\)是一个\\(M\\)位的二进制数表示指数。最左边的一位（主导数位）必须是\\(1\\)。\n当一个二进制数用一个标准浮点数字表示的时候，它被称为“左对齐”，意味着其中最左边的一个数位\\(1\\)被平移到小数点的左边，平移通过指数的变化来补偿，例如，十进制数\\(9\\)，对应的二进制数\\(1001\\)保存为\n\\[ +1.001\\times 2^3 \\]\n以双精度（\\(M=11,N=52\\)）为例，1的双精度表示为\n\\[ +1.0000000000000000000000000000000000000000000000000000\\times 2^0 \\]\n其中有52位尾数，下一个比\\(1\\)大的浮点数是\n\\[ +1.0000000000000000000000000000000000000000000000000001\\times 2^0 \\]\n或者说是\\(1+2^{-52}\\)\n定义1\n机器精度对应的数字，记作\\(\\varepsilon_{math}\\)，是\\(1\\)和比\\(1\\)大的最小浮点数之间的距离。对于双精度来说就是\\(2^{-52}\\)\n如果一个小数是无限小数，或者是超过了52位的小数，IEEE规定，如果在第53位为0，则52位以后的全部社区，如果53位为1，则在52位上加1。特别的，如果第53位为1，其后所有已知位为0，那么当且仅当52位是1时在52位上加1。\n上述方法称为IEEE舍入最近法则。\n定义2\n将IEEE双精度浮点数字记做\\(x\\)，利用舍入最近法则记做\\(fl(x)\\)\n在计算机算术中，实数\\(x\\)用一串数位\\(fl(x)\\)替换。根据这个定义，\\(9.4\\)在二进制中表示如下\n\\[ +1.0010110011001100110011001100110011001100110011001100|110\\cdots\\times 2^3 \\]\n则\\(fl(9.4)\\)表示为\n\\[ +1.0010110011001100110011001100110011001100110011001101\\cdots\\times 2^3 \\]\n我们通过去掉最右边无穷长的数字尾巴\\(0.\\overline{1100}\\times 2^{-52}\\times 2^3=\\overline{0.0110}\\times 2^{-51}\\times 2^3=0.4\\times 2^{-48}\\)得到浮点表达。并在舍入过程中加上\\(2^{-52}\\times 2^3=2^{-49}\\)。因而\n\\[ fl(9.4) = 9.4+2^{-49}-0.4\\times 2^{-48}\\\\ =9.4+(1-0.8)2^{-49}\\\\ =9.4+0.2\\times 2^{-49} \\]\n换句话说，将\\(9.4\\)保存为双精度浮点数时可能产生了\\(0.2\\times 2^{-49}\\)的误差，我们把它称作舍入误差。\n定义3\n令\\(x_c\\)是计算版本\\(x\\)的精确度量，则\n\\[ 绝对误差=|x_c-x| \\]\n\\[ 相对误差=\\frac{|x_c-x|}{|x|}(x\\neq 0) \\]\n相对舍入误差\n在IEEE机器算术模型中，\\(fl(x)\\)的相对舍入误差不会比机器精度的一半大：\n\\[ \\frac{|fl(x)-x|}{|x|}\\leq \\frac{1}{2}\\varepsilon_{math} \\]\n浮点数的机器表示 每个双精度浮点数字被分配了8字节，或者说64位，来存储对应的三个部分。每个字都有如下形式\n\\[ se_1e_2\\cdots e_{11}b_1b_2\\cdots b_{52} \\]\n其中第1位保存了符号位，后面11位用于保存指数，再后面小数点后的52位保存尾数。符号位0是正数，1是负数。11位指数表示的正二进制整数，这些正数通过往指数上叠加\\(2^10-1=1023\\)得到，指数范围在\\(-1022\\)和\\(1023\\)之间，\\(e_1\\cdots e_{11}\\)覆盖了从\\(1\\)到\\(2046\\)之间对应的指数，由于特殊目的，没有使用\\(0\\)和\\(2047\\)。\n数字\\(1023\\)称为双精度格式的指数偏差。它被用于把正和负指数转化为正的二进制数保存在指数位中，对于单精度和扩展精度，指数偏差位分别是127和16383.\n也就是说，指数位上的数字，减去1023才是浮点数中所应该是的指数。\n再来看特殊值\\(2047\\)。如果尾数位串都是0，则用于表示\\(\\infty\\)（其符号取决于第一位），否则表示\\(NaN\\)，意为不是一个数字。\n例如\\(1/0\\)是\\(+\\inf\\)，前\\(12\\)位用十六进制表示为7FF，后面全是0.\n\\(-1/0\\)是\\(-\\inf\\)，前\\(12\\)位用十六进制表示为FFF，后面全是0.\n\\(0/0\\)是\\(NaN\\)，前\\(12\\)位用十六进制表示为FFF，后面不全是0.\n再来看特殊值\\(0\\)，意味着\\(e_1e_2\\cdots e_{11}=(000 0000 0000)_2\\)。其表示一个非标准浮点数\n\\[ \\pm 0.b_1b_2\\cdots b_{52}\\times 2^{-1022} \\]\n由上可见，第一位不再假设为1.这样的非标准化数字称作异常浮点数字。这样就扩展了数字的表示范围，因而，最小的可表达的双精度数字是\\(2^{-52}\\times 2^{-1022}\\)。\n另外\\(+0,-0\\)也是一个异常数字。计算中它们被看作是相同的两个实数。\n浮点数加法 首先对齐进行加法的两个数字的小数点位，接着相加，然后把结果保存为浮点数字。\n在加法寄存器中，可以进行超过52位的加法，但是在相加之后必须舍入变回52位。\n有效数字缺失 有一个主要问题以多种形式出现，该问题是由于对近似相等的两个数字相减造成有效数字的位数减少。\n例如\\(123.4567-123.4566=0.0001\\)，有效数字从原来的七位减少到一位。\n很多情况下我们可以通过重新构造计算来解决这个问题。\n例1\n在三位小数的计算机上计算\\(\\sqrt{9.01}-3\\)\n正确的结果接近\\(1.6662\\times 10^{-3}\\)，但当我们使用三位有效数字时，由于\\(\\sqrt{9.01}\\approx 3.0016662\\)，保存三位有效数字时得到\\(3.00\\)。再减去\\(3.00\\)，得到\\(0.00\\)，没有一个有效数位是正确的。\n但是我们可以用以下方法挽救\n\\[ \\sqrt{9.01}-3 = \\frac{(\\sqrt{9.01}-3)(\\sqrt{9.01}+3)}{\\sqrt{9.01}+3}=\\frac{9.01-9}{\\sqrt{9.01}+3} \\]\n\\[ =\\frac{0.01}{3.00+3.00}=\\frac{0.01}{6}=0.00167\\approx 1.67\\times 10^{-3} \\]\n这种方法本质上是一个窍门。称作“共轭等式”。通常会使用一些特定的恒等式，例如三角恒等式。\n例如\n\\[ E_1=\\frac{1-cosx}{sin^2x},E_2=\\frac{1}{1+cosx} \\]\n两个式子虽然等价，但是在数值计算上，输入一个较为靠近0的数，则第二个比第一个精度高。\n例2\n解方程\\(ax^2+bx+c=0\\)\n对于最基础的求根公式\n\\[ x=\\frac{-b\\pm \\sqrt{b^2-4ac}}{2a} \\]\n其中间取负号问题可能不大，但是取正号时，如果\\(ac\\)相对于\\(b^2\\)非常小，则分式上面会直接舍入等于0，造成整个结果等于0.\n为了解决这个问题，可以在\\(b\\)是正数时\n\\[ x_1=-\\frac{b+\\sqrt{b^2-4ac}}{2a},x_1=-\\frac{2c}{b+\\sqrt{b^2-4ac}} \\]\n\\(b\\)是负数时\n\\[ x_1=\\frac{-b+\\sqrt{b^2-4ac}}{2a},x_1=\\frac{2c}{-b+\\sqrt{b^2-4ac}} \\]\n微积分回顾 书中回顾了函数的连续性、罗尔定理、拉格朗日中值定理、泰勒展开、积分中值定理等。\n求解方程 二分法 方法 定义1\n如果\\(f(r)=0\\)，函数\\(f(x)\\)在\\(x=r\\)时有一个根。\n定理1\n根据函数的连续性，我们知道，如果一个函数是连续的（在[a,b]上），并且在\\(a\u0026lt;b\\)时有\\(f(a)f(b)\u0026lt;0\\)，那么函数在\\((a,b)\\)之间至少有一个根\\(r\\)使得\\(f(r)=0\\)\n显然，我们可以判断\\(c=(b+a)/2\\)时\\(f(a)f(c)\\)的符号来判断根具体在\\([a,c]\\)还是\\([c,b]\\)之中\n由此我们就可以得到一个求出根的伪代码\n二分法 给定初始区间[a,b]使得f(a)f(b)\u0026lt;0 while (b-a)/2\u0026gt;TOL c = (a+b)/2 if f(c)=0,stop,end if f(a)f(c)\u0026lt;0 b = c else a = c end end 最终的区间[a,b]中包含一个根 近似根为(a+b)/2 显然我们求出的是一个区间\\([a,b]\\)，有一个根在其中，我们只能估计一个值。另外代码中的TOL指的是精度，即这个根在\\((a+b)/2\\pm TOL\\)这个范围内。\n分析 现在来分析二分法的精确度和收敛速度。\n假设\\([a,b]\\)是初始区间，在\\(n\\)次二分之后，得到的最终区间\\([a_n,b_n]\\)的长度为\\((b-a)/2^n\\)。选择中点\\(x_c=(a_n+b_n)/2\\)为解的最优估计值，与真实值的误差不会超过区间长度的一般。总之，n步二分法之后，我们得到\n\\[ 求解误差=|x_c-r|\u0026lt;\\frac{b-a}{2^{n+1}} \\]\n\\[ 函数计算次数=n+2 \\]\n对于其精度，每一次函数计算后，解的不确定性都会减少一半。\n定义2\n如果误差小于\\(0.5\\times 10^{-p}\\)，解精确到小数点后\\(p\\)位。\n不动点迭代 举一个例子，以弧度制计算\\(\\cos\\)。以任意值代入，比如我们代入\\(1\\).有\\(cos1=0.5403\\cdots\\)，再将结果代入，有\\(cos(cos1)=0.85755\\cdots\\)，以此类推，多次代入后，我们发现无论初始值是多少，最后都会收敛到\\(0.7390851332\\cdots\\)\n函数的不动点 定义1\n当\\(g(r)=r\\)，实数\\(r\\)是函数\\(g\\)的不动点。\n例如，我们求解\\(\\cos x-x=0\\)的方程，用不动点的视角来看，就是求解\\(\\cos x=x\\)，或者说求解\\(\\cos x\\)的不动点。\n一旦方程写做\\(g(x)=x\\)，从一个初始估计\\(x_0\\)开始进行不动点迭代过程，对函数\\(g\\)进行迭代，\n\\[ x_1=g(x_0)\\\\ x_2=g(x_1)\\\\ x_3=g(x_2)\\\\ \\vdots \\]\n依此下去。当进行无穷多步迭代后序列\\(x_i\\)可能收敛，也可能不收敛。但是，如果函数\\(g\\)是一个连续函数并且\\(x_i\\)收敛，收敛到一个数字\\(r\\)，那么\\(r\\)就是对应的不动点。意味着\n\\[ g(r) = g(\\lim_{i\\to\\infty}x_i)=\\lim_{i\\to\\infty}g(x_i) = \\lim_{i\\to\\infty}x_{i+1}=r \\]\n所有方程\\(f(x)=0\\)都能转化为\\(g(x)=x\\)来不动点迭代吗？答案是肯定的。\n虽然都能迭代，但不总是能收敛的。\n例如\\(x^3+x-1=0\\)换成\\(x=1-x^3\\)来迭代，最后结果就会在\\(1,0\\)之间摆动，这是因为\\(g(0)=1,g(1)=0\\)。\n但是，如果使用\\(x=\\sqrt[3]{1-x}\\)来迭代，就可以求出正确的不动点\\(x=0.6823\\cdots\\)。迭代了大概25次。\n如果使用\\(x=(1+2x^3)/(1+3x^2)\\)，也可以收敛，并且只需要迭代4次就可以得到\\(x=0.6823\\cdots\\)。\n不动点迭代几何 我们要解释出现上述差异的原因。\n如下图，将\\(g(x),x\\)画在同一坐标系下，其中交点就是不动点，图中的箭头代表迭代过程。这种表示又被称作cobweb图。\n 1.jpg  图\\(a\\)中迭代逐渐远离了不动点，而\\(b,c\\)两图，迭代都在不断靠近不动点。\n由图我们猜测迭代收敛与否和\\(g(x)\\)在不动点附近的斜率有关。\n不动点迭代的线性收敛 以\\(g_1(x)=-\\frac{3}{2}x+\\frac{5}{2},g_2(x)=-\\frac{1}{2}x+\\frac{3}{2}\\)为例。它们的不动点都是\\(x=1\\)。\n我们把\\(g(x)\\)写作\\(x-r\\)的形式，其中\\(r=1\\)：\n\\[ g_1(x)=-\\frac{3}{2}(x-1)+1\\\\ g_1(x)-1=-\\frac{3}{2}(x-1)\\\\ x_{i+1}-1=-\\frac{3}{2}(x_i-1) \\]\n如果我们把\\(e_i=|r-x_i|\\)作为第\\(i\\)步时的误差，可以看到上式的误差是\\(e_{i+1}=3e_i/2\\)，意味着误差越来越大，也就是发散。\n对于\\(g_2(x)\\)有\n\\[ x_{i+1}-1=-\\frac{1}{2}(x_i-1) \\]\n\\(e_{i+1}=e_i/2\\)，误差越来越小，就是收敛。\n定义2\n令\\(e_i\\)表示迭代过程中第\\(i\\)步时的误差，如果\n\\[ \\lim_{i\\to\\infty}\\frac{e_{i+1}}{e_i}=S\u0026lt;1 \\]\n该方法被称为满足线性收敛，收敛速度为\\(S\\)。\n这样的推理过程也可以适用于更加一般的连续可微函数\n定理1\n假设函数\\(g\\)是连续可微函数，\\(g(r)=r,S=|g\u0026#39;(r)|\u0026lt;1\\)，则不动点迭代对于一个足够接近\\(r\\)的初始估计，以速度\\(S\\)线性收敛到不动点\\(r\\)。\n定义3\n如果迭代方法对于一个足够接近\\(r\\)的初值能收敛到\\(r\\)，该迭代方法称为局部收敛到\\(r\\)。\n终止条件 同二分法不同，FPI没有误差与迭代次数的关系公式，必须决定何时终止算法，这称为终止条件。\n对于一组容差\\(TOL\\)，我们可能使用绝对终止条件\n\\[ |x_{i+1}-x_i|\u0026lt;TOL \\]\n当解不在\\(0\\)附件时可以使用相对误差条件\n\\[ \\frac{|x_{i+1}-x_i|}{|x_{i+1}|}\u0026lt;TOL \\]\n还有混合绝对/相对误差终止条件\n\\[ \\frac{|x_{i+1}-x_i|}{max(|x_{i+1}|,\\theta)}\u0026lt;TOL \\]\n其中\\(\\theta\u0026gt;0\\)，常常用于\\(0\\)附近的解。此外，如果收敛失败，一个好的FPI也应该设置迭代次数上限。\n二分法可以保证线性收敛，不动点迭代仅仅是局部收敛。不动点迭代收敛时，是线性收敛。二分法每次可以去掉\\(1/2\\)的不确定性，而FPI的不确定性每次会乘上\\(S=|g\u0026#39;(r)|\\)，因此可能比二分法更快或更慢，依赖于\\(S\\)比\\(1/2\\)更大还是更小。\n精度的极限 前向与后向误差 定义1\n假设\\(f\\)是一个函数，\\(r\\)是一个根，意味着满足\\(f(r)=0\\)。假设\\(x_a\\)是\\(r\\)的近似值。对于根求解问题，近似\\(x_a\\)的后向误差是\\(|f(x_a)|\\)，前向误差是\\(|r-x_a|\\)。\n举个例子，求解以下函数的根\n\\[ f(x) = x^3-2x^2+\\frac{4}{3}x-\\frac{8}{27} \\]\n我们可以通过手算验证\\(2/3\\)是它的根。\n当我们使用双精度浮点数去二分法求解时，最后可能解出\\(r=0.6666641\\)，并且到此结束，因为此时\\(f(r)=0\\)，意味着其等于机器\\(0\\)。在这\\(2/3\\pm 10^{-5}\\)的范围上，其函数值都等于机器\\(0\\)。\n事实上，\\(r\\)的后向误差接近\\(\\varepsilon_{math}=2.2\\times 10^{-16}\\)，而前向误差在大约\\(10^{-5}\\)。双精度不能在机器精度的相对误差下可靠计算，从而导致了一个范围内的数最终都等于机器\\(0\\)。\n事实上\\(2/3\\)是这个函数的三重根\n定义2\n假设\\(r\\)是可微函数\\(f\\)的根，如果\\(0=f(r)=f\u0026#39;(r)=f\u0026#39;\u0026#39;(r)=\\cdots=f^{(m-1)}(r)\\)，但是\\(f^{(m)}(r)\\neq 0\\)，就说\\(f\\)在\\(r\\)点具有\\(m\\)重根。多于一个根的叫重根，只有一个根的叫单根。\n由于函数在多根附近十分平缓，前向和后向误差之间在近似解的附近存在很大的不一致。后向误差在垂直方向进行度量，通常比在水平方向度量的前向误差小得多。\n前向和后向误差的讨论和方程求解器的终止条件有关。我们有两种方法更加接近方程的根\n使得\\(|x_a-r|\\)足够小 使得\\(|f(x_a)|\\)足够小  具体选择使用哪一种，取决于问题所处的环境。对于二分法，两种误差都可以观察到。而FPI只能知道后向误差，而不可能知道前向误差。\n威尔金森多项式 一个难以进行数值求解的单根例子在威尔金森的论著中进行了讨论，威尔金森多项式是\n\\[ W(x) = (x-1)(x-2)\\cdots(x-20) \\]\n但当我们把它展开，并用二分法等方法却很难求出正确的解，精确度甚至不到第二个小数。\n这主要是因为其展开式的每一项的常数太大，例如常数项是\\(2432902008176640000\\)，这导致在求值计算中会由于近似相等、大数字的消去而有损失。\n但是若不展开，代入求根器中却能算出精确根。当然如果已经分解好了，也就没有求解的必要了。\n根搜索的敏感性 威尔金森多项式和多重根的问题，其本质都是方程中小的求解误差造成求解根中的大误差。\n如果在输入中是一个小误差，在这种情况下对问题进行求解，造成输出中的大问题，这样的问题被称作敏感性问题。\n假设问题是找到\\(f(x)=0\\)的根\\(r\\)，但是对输入做了一个小变化\\(\\varepsilon g(x)\\)，其中\\(\\varepsilon\\)很小。令\\(\\Delta r\\)是对应根中的变化，因而\n\\[ f(r+\\Delta r)+\\varepsilon g(r+\\Delta r)=0 \\]\n将\\(f\\)和\\(g\\)一阶泰勒展开，有\n\\[ f(r)+(\\Delta r)f\u0026#39;(r)+\\varepsilon g(r)+\\varepsilon(\\Delta r)g\u0026#39;(r)+O((\\Delta r)^2) \\]\n对于小的\\(\\Delta r\\)，直接忽略掉\\(O((\\Delta r)^2)\\)，有\n\\[ (\\Delta r)(f\u0026#39;(r)+\\varepsilon g\u0026#39;(r))\\approx-f(r)-\\varepsilon g(r)=-\\varepsilon g(r) \\]\n假设和\\(f\u0026#39;(r)\\)相比，\\(\\varepsilon\\)很小，则又有\n\\[ \\Delta r\\approx\\frac{-\\varepsilon g(r)}{f\u0026#39;(r)+\\varepsilon g\u0026#39;(r)}\\approx -\\varepsilon\\frac{g(r)}{f\u0026#39;(r)} \\]\n上式就叫做根的敏感公式。（假设\\(r\\)是\\(f(x)\\)的根，并且\\(r+\\Delta r\\)是\\(f(x)+\\varepsilon g(x)\\)的根，则当\\(\\varepsilon \u0026lt;\u0026lt;f\u0026#39;(r)\\)时有上式）\n对于一个一般算法生成的近似\\(x_c\\)，我们定义\n\\[ 误差放大因子=\\frac{相对前向误差}{相对后向误差} \\]\n条件\n条件数也是误差放大度量的一种方式。数值分析是对算法的研究，算法把定义问题的数据作为输入，对应的结果作为输出。条件数指的是理论问题本身所带来的的误差放大部分，和用于求解问题的特定算法无关。\n问题的条件数定义为所有输入变化，或者至少规定类型的变化所造成的最大误差放大。\n条件数高的问题称为病态问题，条件数在\\(1\\)附件的问题称为良态问题。\n牛顿方法 为了找到\\(f(x)=0\\)的根，给定一个初始估计\\(x_0\\)，画出函数\\(f\\)在\\(x_0\\)的切线。用切线来近似函数\\(f\\)，求出其与\\(x\\)轴的交点作为\\(f\\)的根。由于函数\\(f\\)的弯曲，该交点可能不是精确解，因而该步骤要迭代进行。\n\\[ x_0=初始估计 \\]\n\\[ x_{i+1}=x_i-\\frac{f(x_i)}{f\u0026#39;(x_i)},\\quad i=0,1,2,\\cdots \\]\n牛顿方法的二次收敛 定义1\n令\\(e_i\\)表示一个迭代方法第\\(i\\)步后得到的误差。该迭代是二次收敛，如果满足下式\n\\[ M=\\lim_{i\\to\\infty}\\frac{e_{i+1}}{e^2_i}\u0026lt;\\infty \\]\n定理1\n令\\(f\\)是二阶连续可微函数，\\(f(r)=0\\)。如果\\(f\u0026#39;(r)\\neq 0\\)，则牛顿方法局部二次收敛到\\(r\\)。第\\(i\\)步的误差\\(e_i\\)满足\n\\[ \\lim_{i\\to\\infty}\\frac{e_i}{e_i^2}=M \\]\n其中\n\\[ M=\\frac{f\u0026#39;\u0026#39;(r)}{2f\u0026#39;(r)} \\]\n也可被看作\n\\[ e_{i+1}\\approx M e_i^2 \\]\n对于线性收敛方法，这个误差公式应该和\\(e_{i+1}\\approx Se_i\\)进行比较，FPI方法中\\(S=|g\u0026#39;(r)|\\)，二分法中\\(S=1/2\\)\n尽管\\(S\\)对线性收敛很关键，但是\\(M\\)的值并不是很重要，这是由于其包含了平方，只要\\(M\\)不太大，误差就会进一步下降。\n牛顿方法的线性收敛 上面的定理并不意味着牛顿方法总能二次收敛。\n例如求\\(f(x)=x^2\\)的实根，牛顿法如下\n\\[ x_{i+1}=x_i-\\frac{f(x_i)}{f\u0026#39;(x_i)}=\\frac{x_i}{2} \\]\n仅仅每步除以\\(2\\).对于其他幂函数也有类似的结果。\n定理1\n假设在区间\\([a,b]\\)上，\\((m+1)\\)阶连续可微函数\\(f\\)在\\(r\\)点有一个\\(m\\)阶多重根，则牛顿方法局部收敛到\\(r\\)，第\\(i\\)步误差\\(e_i\\)满足\n\\[ \\lim_{i\\to \\infty}\\frac{e_{i+1}}{e_i}=S \\]\n其中\\(S=(m-1)/m\\)\n事实上，牛顿法在单根位置上，\\(f\u0026#39;(r)\\neq 0\\)，具有二次收敛速度，在多根位置上\\(f\u0026#39;(r)=0\\)，收敛式线性的。\n定理2\n如果在\\([a,b]\\)区间上\\(f\\)是\\((m+1)\\)阶连续函数，包含\\(m\u0026gt;1\\)的多重根，则改进的牛顿方法\n\\[ x_{i+1}=x_i-\\frac{mf(x_i)}{f\u0026#39;(x_i)} \\]\n收敛到\\(r\\)，并具有二次收敛速度。\n牛顿法如同FPI，也可能不会收敛到根。例如两个数循环出现、某一步\\(f\u0026#39;(x_i)=0\\)等。\n不需要导数的根求解 虽然牛顿法在非重根时表现的比二分法和FPI更好，因为它获取了“导数”这个额外信息。但有时候我们可能难以计算导数。\n这种情况下，割线方法就是一个好的替代。它使用近似值割线替代了切线，并且收敛速度差不多快。\n割线方法及其变体 不难想到，直接用差商\n\\[ \\frac{f(x_i)-f(x_{i-1})}{x_i-x_{i-1}} \\]\n去近似替换牛顿法中的\\(f\u0026#39;(x_i)\\)，就得到了割线方法\n\\[ x_0,x_1=初始估计 \\]\n\\[ x_{i+1}=x_i-\\frac{f(x_i)(x_i-x_{i-1})}{f(x_i)-f(x_{i-1})},i=1,2,3,\\cdots \\]\n假设割线方法收敛到函数\\(f\\)的根\\(r\\)，且\\(f\u0026#39;(r)\\neq 0\\)，近似误差关系\n\\[ e_{i+1}\\approx \\bigg|\\frac{f\u0026#39;\u0026#39;(r)}{2f\u0026#39;(r)}\\bigg|e_ie_{i-1} \\]\n成立并且\n\\[ e_{i+1}\\approx \\bigg|\\frac{f\u0026#39;\u0026#39;(r)}{2f\u0026#39;(r)}\\bigg|^{\\alpha-1}e_i^\\alpha \\]\n其中\\(\\alpha = (1+\\sqrt 5)/2\\approx 1.62\\)。割线方法1️以超线性的速度收敛到一个单根，意味着它在线性和二次收敛方法之间。\n割线方法有三种推广形式，它们也很重要。\n试位方法（Regula Falsi）\n和二分法相似，但是其中的中点被类似割线方法的近似所替换，给定区间\\([a,b]\\)，该区间包含根（假设\\(f(a)f(b)\u0026lt;0\\)），使用割线方法定义下一个点为\n\\[ c = a-\\frac{f(a)(a-b)}{f(a)-f(b)}=\\frac{bf(a)-af(b)}{f(a)-f(b)} \\]\n根据\\(f(a)f(c)\u0026lt;0\\)或者\\(f(c)f(b)\u0026lt;0\\)，分别选择新的区间\\([a,c]\\)或\\([c,b]\\)，新的区间仍然可以括住根。\n通常试位方法会表现地比二分法和割线方法都好，但是试位方法不能包子每一步都消除一半的不确定性，有时收敛会很慢。\nMuller方法\n该方法不是计算经过先前两个点的直线和\\(x\\)轴的交点，而是使用桑耳前面生成的点\\(x_0,x_1,x_2\\)，画出通过它们的抛物线\\(y=p(x)\\)，并计算抛物线和\\(x\\)轴的交点。\n书上并没有详细介绍这个方法。\n逆二次插值（IQI）\n是割线方法到抛物线的一种相近的泛化方法。但是使用形如\\(x=p(y)\\)的抛物线，而不是Muller方法中的\\(y=p(x)\\)。\n我们的问题可以立刻求解：这个抛物线和\\(x\\)轴只有一个交点，所以从上一步中的三个估计\\(x_i,x_{i+1},x_{i+2}\\)寻找\\(x_{i+3}\\)，这个过程中没有混淆。\n经过三点\\((a,A),(b,B),(c,C)\\)的二阶多项式\\(x=P(y)\\)为\n\\[ P(y) = a\\frac{(y-B)(y-C)}{(A-B)(A-C)}+b\\frac{(y-A)(y-C)}{(B-A)(B-C)}+c\\frac{(y-A)(y-B)}{(C-A)(C-B)} \\]\n这是一个拉格朗日插值的例子，用\\(y=0\\)代入，得到和\\(x\\)轴的交点，经过重新组合与替代，我们得到\n\\[ P(0)=c-\\frac{r(r-q)(c-b)+(1-r)s(c-a)}{(q-1)(r-1)(s-1)} \\]\n其中\\(q=f(a)/f(b),r=f(c)/f(b),s=f(c)/f(a)\\)\n对于IQI，设置\n\\[ a=x_i,b=x_{i+1},c=x_{i+2},A=f(x_i),B=f(x_{i+1}),C=f(x_{i+2}) \\]\n下一步的估计\\(x_{i+3}=P(0)\\)为\n\\[ x_{i+3}=x_{i+2}-\\frac{r(r-q)(x_{i+2}-x_{i+1})+(1-r)s(x_{i+2}-x_{i})}{(q-1)(r-1)(s-1)} \\]\n其中\\(q=f(x_{i})/f(x_{i+1}),r=f(x_{i+2})/f(x_{i+1}),s=f(x_{i+2})/f(x_{i})\\)\nBrent方法 这是一种混合方法，该方法使用前面介绍的迭代技术，推出一个新的方法。\n该方法用于连续函数\\(f\\)，区间的边界是\\(a\\)和\\(b\\)，同时\\(f(a)f(b)\u0026lt;0\\)。Brent方法记录当前点\\(x_i\\)，该点具有最优的后向误差，同时有包含根的区间\\([a_i,b_i]\\)。简单来讲，尝试使用逆二次方法，并在下述情况下，使用结果来替代\\(x_i,a_i,b_i\\)中的一个\n后向误差得到改进 包含根的区间至少减小一半  否则，尝试使用割线方法以实现相同的目的，如果割线方法也失败了，则使用二分法，保证至少减少一半的不确定性。\n方程组 高斯消元法 朴素的高斯消元法 和线性代数中介绍的一致\n对于一个线性方程组可以进行三种操作\n两个方程彼此交换位置 在一个方程上加上或减去另外一个方程的倍数 对于一个方程乘以非零的常数  通常我们也会使用增广矩阵来替代方程组。\n操作次数 引理1\n对于任何正整数\\(n\\)\n\\(1+2+3+\\cdots+n = n*(n+1)/2\\) \\(1^2+2^2+\\cdots+n^2 = n(n+1)(2n+1)/6\\)  消去某一列在主对角线下的元素，以第一列为例，将第二行变为如下形式\n\\[ \\begin{matrix} a_{11} \u0026amp; a_{12} \u0026amp; \\cdots \u0026amp; a_{1n} \u0026amp; | \u0026amp; b_1\\\\ 0 \u0026amp; a_{22}-\\frac{a_{21}}{a_{11}}a_{12} \u0026amp; \\cdots \u0026amp; a_{2n}-\\frac{a_{21}}{a_{11}}a_{1n} \u0026amp; | \u0026amp;b_2-\\frac{a_{21}}{a_{11}}b_1 \\end{matrix} \\]\n其他行同理，其中\\(a_{11}\\)在操作中作为除数，这样的数字称为主元。不难得知，如果主元为\\(0\\)，算法会终止，这是朴素办法的一个问题。\n高斯消元法中消去步骤的操作次数\n\\(n\\)个方程\\(n\\)个未知数的消去计算（下三角除了对角线的部分转换为\\(0\\)），可以在\\(2n^3/3+n^2/2-7n/6\\)次操作后完成\n消去之后，矩阵变成上三角形式，之后从最后一个未知数往回带进行求解。\n高斯消元法中回代过程的操作次数\n\\(n\\)个方程\\(n\\)个未知数的三角形系统的回代过程，可以在\\(n^2\\)次操作后完成\n综上，消去的事件复杂度为\\(O(n^3)\\)，回代是\\(O(n^2)\\)，总的是\\(O(n^3)\\)\nLU分解 高斯消元法的矩阵形式 继续同线性代数，我们可以把方程组写成一个矩阵和一个向量相乘的形式，即\\(\\bm A\\bm x=\\bm b\\)\n吧方程组写成矩阵的形式的优势在于可以使用矩阵运算。LU分解是高斯消元法的矩阵形式。它包含把系数矩阵\\(A\\)写做下三角矩阵\\(L\\)和上三角矩阵\\(U\\)的乘积\n我们有关于LU分解的三个事实\n令\\(L_{ij}(-c)\\)表示下三角矩阵，其主对角线上的元素为\\(1\\)，在\\((i,j)\\)位置上的元素为\\(-c\\)。则\\(A\\to L_{ij}(-c)A\\)表示行运算“从第\\(i\\)行中减去第\\(j\\)行的\\(c\\)倍”。  例如\\(L_{21}(-c)\\)\n\\[ A= \\begin{bmatrix} a_{11} \u0026amp; a_{12} \u0026amp; a_{13}\\\\ a_{21} \u0026amp; a_{22} \u0026amp; a_{23}\\\\ a_{31} \u0026amp; a_{32} \u0026amp; a_{33} \\end{bmatrix}\\to \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0\\\\ -c \u0026amp; 1 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} a_{11} \u0026amp; a_{12} \u0026amp; a_{13}\\\\ a_{21} \u0026amp; a_{22} \u0026amp; a_{23}\\\\ a_{31} \u0026amp; a_{32} \u0026amp; a_{33} \\end{bmatrix} \\]\n\\[ =\\begin{bmatrix} a_{11} \u0026amp; a_{12} \u0026amp; a_{13}\\\\ a_{21}-ca_{11} \u0026amp; a_{22}-ca_{12} \u0026amp; a_{23}-ca_{13}\\\\ a_{31} \u0026amp; a_{32} \u0026amp; a_{33} \\end{bmatrix} \\]\n\\(L_{ij}(-c)^{-1}=L_{ij}(c)\\) 下面的矩阵乘积成立  \\[ \\begin{bmatrix} 1 \u0026amp; \u0026amp; 0\\\\ c_1 \u0026amp; 1 \u0026amp; \\\\ \u0026amp; \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; \u0026amp; \\\\ \u0026amp; 1 \u0026amp; \\\\ c_2 \u0026amp; \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; \u0026amp; \\\\ \u0026amp; 1 \u0026amp; \\\\ \u0026amp; c_3 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; \u0026amp; \\\\ c_1 \u0026amp; 1 \u0026amp; \\\\ c_2 \u0026amp; c_3 \u0026amp; 1 \\end{bmatrix} \\]\n根据以上事实，我们可以把系数矩阵\\(A\\)表示为\\(A=LU\\)，其中\\(U\\)和高斯消元得到的上三角矩阵相同，而\\(L\\)矩阵就是所进行的操作乘起来的矩阵。\n使用LU分解回代 一旦知道\\(L,U\\)，问题\\(Ax=b\\)就可以转化为\\(LUx=b\\)。定义\\(c=Ux\\)，则回代有两个步骤\n对于方程\\(Lc=b\\)，求解\\(c\\) 对于方程\\(Ux=c\\)，求解\\(x\\)  其中\\(Lc=b\\)因为\\(L\\)是下三角矩阵，从上往下回代，\\(Ux=c\\)因为\\(U\\)是上三角矩阵，从下往上回代。\nLU分解的复杂度 如果只有一个方程组，那么和高斯消元法没有区别\n但是，如果我们遇到的问题是\n\\[ Ax=b_1\\\\ Ax=b_2\\\\ \\cdots\\\\ Ax=b_k \\]\n这样的。那LU分解会比高斯消元一个一个去计算要来得快。\n但是，并不是所有的矩阵都可以进行\\(LU\\)分解\n例如分解\n\\[ \\begin{bmatrix} 0 \u0026amp; 1\\\\ 1 \u0026amp; 1 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0\\\\ a \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} b \u0026amp; c\\\\ 0 \u0026amp; d \\end{bmatrix}= \\begin{bmatrix} b \u0026amp; c\\\\ ab \u0026amp; ac+d \\end{bmatrix} \\]\n由于\\(ab=1,b=0\\)不可能同时成立，所以反证法得知不能分解。\n误差来源 误差放大和条件数 定义1\n向量\\(x=(x_1,\\cdots,x_n)\\)的无穷范数或者最大范数为\\(||x||_\\infty=max|x_i|\\)，即\\(x\\)所有元素中的最大绝对值。\n定义2\n令\\(x_a\\)是线性方程组\\(Ax=b\\)的近似解。余项是向量\\(r=b-Ax_a\\)，后向误差是余项的范数\\(||b-Ax_a||_\\infty\\)，前向误差是\\(||x-x_a||_\\infty\\)\n同时也定义相对后向误差为\n\\[ \\frac{||r||_\\infty}{||b||_\\infty} \\]\n相对前向误差定义为\n\\[ \\frac{||x-x_a||_\\infty}{||x||_\\infty} \\]\n这个方程的误差放大因子是二者的比率，即\n\\[ 误差放大因子=\\frac{相对前向误差}{相对后向误差} \\]\n定义3\n方阵\\(A\\)的条件数\\(cond(A)\\)为求解\\(Ax=b\\)时，对于所有右侧向量\\(b\\)，可能出现的最大误差放大因子。\n和向量范数类似，定义\\(n\\times n\\)矩阵\\(A\\)的矩阵（无穷）范数为\n\\[ ||A||_\\infty = 每行元素绝对值之和的最大值 \\]\n定理1\n\\(n\\times n\\)矩阵\\(A\\)的条件数是\n\\[ cond(A) = ||A||\\cdot||A^{-1}|| \\]\n依据误差放大因子，在求解\\(Ax=b\\)可能出现的相关前向误差是\\(\\varepsilon_{math}\\cdot cond(A)\\)。换句话说，如果\\(cond(A)\\approx 10^k\\)，我们在计算\\(x\\)时，将丢掉\\(k\\)位数字精度。\n向量范数和矩阵范数的性质\n对于向量无穷范数\n\\(||x||\\geq 0\\)，当且仅当\\(x=[0,\\cdots,0]\\)时等号成立 对于每个标量\\(\\alpha\\)和向量\\(x\\)，\\(||\\alpha x||=|\\alpha|\\cdot ||x||\\) 对于向量\\(x,y\\)有\\(||x+y||\\leq||x||+||y||\\)  对于矩阵无穷范数\n\\(||A||\\geq 0\\)，当且仅当\\(A=0\\)时等号成立 对于每个标量\\(\\alpha\\)和向量\\(x\\)，\\(||\\alpha A||=|\\alpha|\\cdot ||A||\\) 对于矩阵\\(A,B\\)有\\(||A+B||\\leq||A||+||B||\\)  被称为算子范数的矩阵范数，也可以使用特定的向量范数进行定义\n\\[ ||A||=\\max \\frac{||Ax||}{||x||} \\]\n对于任意矩阵\\(A\\)和向量\\(x\\)满足\n\\[ ||Ax||\\leq ||A||\\cdot||x|| \\]\n淹没 考虑如下方程组\n\\[ 10^{-20}x_1+x_2=1\\\\ x_1+2x_2=4 \\]\n高斯消元如下\n\\[ \\begin{bmatrix} 10^{-20} \u0026amp; 1 \u0026amp; | \u0026amp; 1\\\\ 1 \u0026amp; 2 \u0026amp; | \u0026amp; 4 \\end{bmatrix}\\to \\begin{bmatrix} 10^{-20} \u0026amp; 1 \u0026amp; | \u0026amp; 1\\\\ 0 \u0026amp; 2-10^{20} \u0026amp; | \u0026amp; 4-10^{20} \\end{bmatrix} \\]\n然后解出\n\\[ [x_1,x_2]=\\bigg [\\frac{2\\times 10^{20}}{10^{20}-2},\\frac{4-10^{20}}{2-10^{20}}\\bigg]\\approx[2,1] \\]\n我们手算是可以这样的，但是当我们使用IEEE双精度的时候，\n\\[ \\begin{bmatrix} 10^{-20} \u0026amp; 1 \u0026amp; | \u0026amp; 1\\\\ 0 \u0026amp; 2-10^{20} \u0026amp; | \u0026amp; 4-10^{20} \\end{bmatrix} \\]\n舍入得\n\\[ \\begin{bmatrix} 10^{-20} \u0026amp; 1 \u0026amp; | \u0026amp; 1\\\\ 0 \u0026amp; -10^{20} \u0026amp; | \u0026amp; -10^{20} \\end{bmatrix} \\]\n然后首先解出\\(x_2=1\\)，然后\\(x_1=0\\)，与精确解相比相差巨大。\n我们的解决办法是，更换行顺序，\n\\[ \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; | \u0026amp; 4\\\\ 10^{-20} \u0026amp; 1 \u0026amp; | \u0026amp; 1 \\end{bmatrix}\\to \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; | \u0026amp; 4\\\\ 0 \u0026amp; 1-2\\times 10^{-20} \u0026amp; | \u0026amp; 1-4\\times 10^{-20} \\end{bmatrix} \\]\n舍入后也可以得到\\(x_2=1\\)，然后\\(x_1=2\\)。\n上述例子告诉我们，高斯消去的过程中要尽可能保证乘子比较小。\nPA=LU分解 部分主元 部分主元要求，在每一次选择主元时，找到这一列中绝对值最大的一个元素，其对应行与主元行进行交换。交换之后作为新的主元。这样我们就能完全避免淹没问题。\n同样，这样可以避免\\(0\\)主元问题。如果这一列没有非零元素，则矩阵是奇异矩阵，此时高斯消元怎样都不能得到正确解。\n置换矩阵 定义1\n置换矩阵是一个\\(n\\times n\\)矩阵，其在每一行、每一列仅有一个\\(1\\)，其他全部为\\(0\\)\n置换矩阵基础定理\n令\\(P\\)是通过对单位矩阵实施一组特定的行交换后得到的一个\\(n\\times n\\)的置换矩阵，则对于任意的\\(n\\times n\\)矩阵\\(A\\)，\\(PA\\)对应于对矩阵\\(A\\)实施同样的行变换得到的结果。\n例如\n\\[ \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 1 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} \\]\n是由单位矩阵交换二三行得到的，则\n\\[ \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 1 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} a \u0026amp; b \u0026amp; c\\\\ d \u0026amp; e \u0026amp; f \\\\ g \u0026amp; h \u0026amp; i \\end{bmatrix}= \\begin{bmatrix} a \u0026amp; b \u0026amp; c \\\\ g \u0026amp; h \u0026amp; i \\\\ d \u0026amp; e \u0026amp; f \\end{bmatrix} \\]\n即把后面那个矩阵也交换了二三行。\n","date":"2022-10-02T16:42:53+08:00","image":"https://kegalas.top/p/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cover_hu6778f7153b0100018882cd949f083bca_49831_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"数值分析学习笔记"},{"content":" 电路的基本规律 集中（或集总）参数电路 实际电路的几何尺寸远小于工作波长时，我们用能足够精确反映其电磁性质的一些理想电路元件或他们的组合来模拟实际元件，这种理想化的电路元件称为集中参数元件。由其连接组成的电路称为集中参数电路。\n而一些远距离输电线就不能看做集中参数电路，称作分布参数电路，要用其他理论来研究。\n电流 单位时间内通过导体横截面的电荷量\\(q\\)定义为电流强度，简称电流，用\\(i,i(t)\\)表示，即\n\\[ i(t)=\\frac{dq(t)}{dt} \\]\n电荷量的单位是库伦，时间的单位是秒，电流的单位是安培。\n方向，一般把正电荷运动的方向定义为电流的实际方向。但在具体电路中，电流的实际方向常常随时间变化。通常在分析电路时会指定某一方向为电流方向，称为电流的参考方向。如果参考方向和实际方向一致，则电流\\(i\u0026gt;0\\)，否则\\(i\u0026lt;0\\)。\n电流的参考方向是任意指定的，一般用箭头和双下标表示，如\\(i_{ab}\\)指\\(a\\)到\\(b\\)的电流。\n电压 电路中，电场力将单位正电荷从某点移到另一点所作的功定义为该两点之间的电压，也称电位差，用\\(u,u(t)\\)表示，即\n\\[ u(t)=\\frac{dw(t)}{dq(t)} \\]\n功的单位是焦耳，电压的单位是伏特。\n通常，高电位为正极，低电位为负极。\n和电路的参考方向一样，我们也可以为电压指定参考极性。在分析电路问题时，先指定电压的参考极性，\\(+\\)表示高电位，\\(-\\)表示低电位。如果电压的参考极性和实际极性一致，则\\(u\u0026gt;0\\)，否则\\(u\u0026lt;0\\)。\n电流参考方向给定，若电流流入的方向是电压的高电位，流出的方向是电压的低电位，则称此时电流、电压是关联参考方向。反之为非关联参考方向。\n能量 正电荷从电路元件上电压的正极经元件移动到负极是电场力对电荷做功的结果，此时元件吸收能量。反之发出能量。\n若某元件两端的电压为\\(u\\)，在\\(dt\\)时间内流过该元件的电荷量为\\(dq\\)，那么，根据电压的定义式，电场力做的功\\(dw(t)=u(t)dq(t)\\)。\n在关联参考方向时，\\(dw(t)=u(t)i(t)dt\\)\n功率 能量对时间的变化率称为电功率。\n\\[ p(t)=u(t)i(t) \\]\n基尔霍夫定律 电路图\n如果仅研究各元件的连接关系，暂不关心元件本身的特性，则可用一条线段来代表元件。\n支路\n电路图中的每一个元件，即图中的每一条线段，称为支路。\n节点\n支路的连接点称为节点。\n路径\n在图中，从某一节点出发。连续地经过一些支路和节点（只能各经过一次），到达另一节点，就构成路径。\n回路\n如果路径的最后到达点就是出发点，则这样的闭合路径称为回路。\n基尔霍夫 电流定律 对于集中参数电路中的任一节点，在任意时刻，流出该节点电流的和等于流入该节点电流的和。\n\\[ \\sum_{流出} i(t) = \\sum_{流入} i(t)\\quad \\forall t \\]\n基尔霍夫电压定律 在集中参数电路中，任意时刻沿任一回路绕行，回路中所有支路电压的代数和恒为零\n\\[ \\sum u(t) = 0\\quad\\forall t \\]\n注意，上式在计算时，需要任意指定一个回路的绕行方向，凡是之路电压的参考方向与回路的绕行方向一致者，该电压前面去+号；否则取-号。\n电阻元件 二端电阻 二端电阻元件可以定义为：一个二端元件，如果在任意时刻\\(t\\)，其两端电压\\(u\\)与流经它的电流\\(i\\)之间的关系(VCR)能用\\(u-i\\)平面上通过原点的曲线所确定，就称其为二端电阻元件，简称电阻元件。\n由于电压和电流的单位是V和A，因而电阻元件的特性称为伏安特性或伏安关系。\n如果电阻元件的伏安特性不随时间变化，则称其为非时变的。否则就是时变的。\n如果伏安特性是通过原点的直线，则称为线性的，否则是非线性的。\n欧姆定律\n在电压、电流参考方向相关联时，其电压与电流的关系就是熟知的欧姆定律\n\\[ u(t)=Ri(t)\\quad\\forall t \\]\n或者\n\\[ i(t) = Gu(t)\\quad\\forall t \\]\n其中电阻\\(R\\)的单位是欧姆\\(\\Omega\\)，电导\\(G\\)的单位是西\\(S\\)。对于线性非时变电阻元件，\\(R\\)和\\(G\\)都是常实数，他们的关系是\n\\[ G=\\frac{1}{R} \\]\n分立电阻与集成电阻 任何材料都有电阻。导体、半导体和绝缘体三者的区别是材料的电阻率\\(\\rho\\)。通常\\(\\rho\u0026lt;10^{-4}\\Omega\\cdot m\\)的材料称为导体，\\(\\rho\u0026gt;10^4\\Omega\\cdot m\\)的材料称为绝缘体，介于其中的称为半导体。\n一段长度为\\(L\\)、截面积为\\(S\\)、电阻率为\\(\\rho\\)的材料，其电阻值为\n\\[ R = \\rho\\frac{L}{S} \\]\n分立电阻器的主要参数\n电子电路中单个使用的具有电阻特性的元件，称为分立电阻器。电阻元件是由实际电阻器抽象出来的理想化模型。\n电阻元件和电阻器不是一个概念。电阻元件的参数只有一个电阻值，而电阻器的元件参数包括标称值、容差、额定功率、温度系数等。\n集成电阻\n集成电阻又称扩散电阻、薄层电阻。\n通过复杂的扩散工艺在硅片上生成一定尺寸的薄层而制成的电阻，称为扩散电阻。\n无论是分离电阻器还是集成电阻，分析时都应该抽象为电阻元件。\n电源 电压源 一个二端元件，如果其端口电压总能保持为给定的电压\\(u_s(t)\\)，而与通过它的电流无关，则称其为电压源。\n如果\\(u_s(t)\\)为恒定值，则称其为直流电压源或恒定电压源。\n电压源具有如下特点：\n无论通过它的电流为何值，电压源的端口电压\\(u\\)总保持\\(u(t)=u_s(t)\\) 电压源的电流由电压源和与它相连的外电路共同决定。  电流源 一个二端元件，如其端口电流值总能保持为给定的电流\\(i_s(t)\\)，而与其端口电压无关，则称其为电流源。\n如果\\(i_s(t)\\)为恒定值，则称其为直流电流源或恒定电流源。\n电流源具有如下特点：\n无论其端口电压\\(u\\)为何值，电流源的电流\\(i\\)总保持\\(i(t)=i_s(t)\\) 电流源的端口电压源由电流源和与它相连的外电路共同决定。  电路中的参考点 在电路分析中，常常指定电路中的某点为参考点，计算或测量其它各节点对参考点的电位差，称其为各节点的电位，或各节点的电压。\n受控源 非独立电源是指电压源的电压或电流源的电流不是给定的时间函数，而是受电路中某支路电压或电流控制的，因此常称为受控源。\n受控源的符号通常用菱形，而不是圆形。\n电路等效 概念 对于两部分结构、元件参数完全不同的电路，若它们具有完全相同的端口电压电流关系，就称它们是等效的。\n电阻的串联和并联 串联\n\\[ R_{eq}=R_1+R_2+\\cdots \\]\n串联时，电流相等；各电阻的电压如下\n\\[ u_k=R_k i =\\frac{R_k}{R_{eq}}u \\]\n并联\n电导有\n\\[ G_{eq}=G_1+G_2+\\cdots \\]\n电阻有\n\\[ \\frac{1}{R_{eq}}=\\frac{1}{R_{1}}+\\frac{1}{R_{2}}+\\cdots \\]\n并联时，电压相同，各电阻的电流如下\n\\[ i_k=G_iu=\\frac{G_k}{G_{eq}}i \\]\n电阻Y型和三角形电路的等效变换  1.jpg  含独立源电路的等效 独立源的串联和并联 电压源串联\n电压源串联时，得到的净电压等于电压极性相同的各个电源电压总和，减去极性相反的各电源电压总和。净电压方向与大的那个相同。\n电压源并联\n只有两端电压是相同的电压源才可以并联。可以增加输出电流的能力。\n电流源串联\n只有电流大小相同的电流源能串联。\n电流源并联\n电流源并联时，得到的等效电流源电流大小等于极性相同的各个电源流总和，减去极性相反的各电源电流总和。净电流方向与大的那个相同。\n实际电源的等效变换\n实际电源，比如电池，我们在高中通常会说它含有一个内阻。也就是等价为一个理想电压源+一个电阻的串联。我们也可以将其等价为一个理想电流源+一个电阻的并联。如下图\n 2.jpg  电压源的等效转移\n电流源可以转移到各并联支路上，如下图\n 3.jpg  可以证明，此时电路中的KVL仍然保持不变。\n电流源的等效转移\n电流源可以转移成如下形式\n 4.jpg  电阻电路分析 图与电路方程 图的基本概念\n图的定义和离散数学、算法竞赛图论部分没有什么差别。\n主要介绍基本回路：仅包含一条连支（其余为树枝，即树加了任意一条连支）的回路称为单连支回路或基本回路\n基本割集：仅包含一条树枝（其余为连支）的割集称为单树支割集或基本割集。\nKCL与KVL的独立方程\n根据我们的朴素想法，我们会把每一个节点的KCL方程和每一个回路的KVL方程列出来，试图求解电路中的所有未知量。这的确是可行的，但是，我们会发现我们有一些方程是可以由其他方程推出的，这就导致了不是所有方程都是独立的。\n可以证明，对于有\\(n\\)个节点的连通图，任选\\(n-1\\)个节点所列的\\(KCL\\)方程是独立的。这些对应的节点叫独立节点，另外一个节点叫参考节点。\n对于\\(n\\)个节点、\\(b\\)条支路的连通图，有\\(L=b-n+1\\)个基本回路，可以列出\\(L\\)个独立的KVL方程。\n或者说，对于平面图，有\\(L\\)个网孔，可以根据这\\(L\\)个网孔列出独立的KVL方程。\n在平面图中，网孔就是内部不包含边的回路。\n2b法和支路法 2b法 对一个具有\\(b\\)条支路和\\(n\\)个节点的电路，当以支路电压和支路电流为变量列写方程时，共有\\(2b\\)个未知变量，根据KCL可列出\\(n-1\\)个独立方程，根据KVL可列出\\(b-n+1\\)个独立方程；根据元件的伏安关系，每条支路可以列出\\(b\\)个支路电压和电流关系的方程。于是总共列出了\\(2b\\)个方程。\n这个方法称为\\(2b\\)法，可行，但是对于手算不方便\n支路法 如果以支路电流（或支路电压）为电路变量列出方程，求解支路电流（或支路电压），则称为支路电流（支路电压）法。\n步骤如下\n选定各支路电流的参考方向 对\\(n-1\\)个独立节点，列出KCL方程 对所有的网孔，按指定回路绕行方向，根据KVL，列出电压方程  总共列出了\\(b\\)个方程。\n例如：\n 5.jpg  任一回路内，电阻上电压的代数和等于电压源电压的代数和，其中支路电流参考方向与回路方向一致者，\\(R_ki_k\\)前取\\(+\\)号，否则取\\(-\\)号，电压源\\(u_{sk}\\)的参考方向与回路方向相反者取\\(+\\)号，否则取\\(-\\)号。（当然在本例中电压源写在了方程等号左边，上面说的符号是写在右边时的符号）\n回路法和网孔法 以独立回路电流为未知变量列出并求解方程的方法称为回路法。若选平面电路的网孔作独立回路，则这样的回路法又常称为网孔法。\n回路电流实际上并不存在，只是为了方便分析而引入的概念。\n回路法的步骤归纳如下\n选定一组独立回路，并指定各回路电流的参考方向 列出回路方程（注意电阻和电压源的符号） 解方程  例如：\n 6.jpg  节点法 以节点电压为未知变量列出并求解方程的方法称为节点法\n在电路中任选一个节点为参考节点，其余节点与参考节点之间的电压称为节点电压或节点电位。\n 7.jpg   8.jpg  但以上方程不需要推导，可以直观的列出\n规律如下：\n\\(G_{ii}\\)称为节点\\(i\\)的自电导，等于与节点\\(i\\)相连的所有支路的电导之和，恒取\\(+\\) \\(G_{ij}(i\\neq j)\\)称为节点\\(i,j\\)之间的互电导，等于两节点之间的电导之和，恒取\\(-\\) \\((\\sum I_s)_i\\)称为节点\\(i\\)的等效电流源，等于流入节点\\(i\\)的所有电流源电流的代数和。流入为\\(+\\)，流出为\\(-\\)  齐次定理和叠加定理 首先介绍齐次性和叠加性，对于线性映射\\(f\\)，它满足\n齐次性（比例性），即  \\[ f(ax)=af(x) \\]\n可加性（叠加性）  \\[ f(x_1+x_2) = f(x_1)+f(x_2) \\]\n两者也可以结合使用。\n例如\\(f(x)=ax\\)是线性的，但\\(f(x)=ax+b\\)就不是线性的。\n齐次定理 对于有唯一解的线性电路，当只有一个激励源（独立电压源或独立电流源，必须是独立的）x(t)作用时，其响应y(t)（电路任意处的电压或电流）与激励成齐次关系。例如\n 9.jpg  注意：\n只能用于有唯一解的线性电路，不能用于非线性电路 响应也称为输出，指电路中任意处的电流或电压；功率与激励源之间不存在线性关系 激励也称为输入，指电路中的独立源，受控源不是激励源  叠加定理 对于有唯一解的线性电路，多个激励源共同作用时引起的响应（电路中各处的电流、电压）等于各个激励源单独作用时（其他激励源置零，具体表现为电压源变成导线，电流源变成开路）所引起的响应之和\n替代定理 对于有唯一解的线性或非线性电路，若某支路的电压\\(u\\)或电流\\(i\\)已知，则该支路可用方向和大小与\\(u\\)相同的电压源替代，或用方向和大小与\\(i\\)相同的电流源替代，而不会影响其他点的电流和电压。\n注意，替换成电流源后电压不变，替换成电压源后电流也不变。\n等效电源定理 戴维南定理 任意一个线性二端含源电路\\(N\\)，对其外部而言，可以用一个电压源和电阻的串联组合来等效。该电压源的电压值\\(U_{OC}\\)等于电路\\(N\\)二端子间的开路电压，其串联电阻值\\(R_0\\)等于电路N内部所有独立源置零时二端子的等效电阻。\n例如\n 10.jpg  求其等效电源，先将\\(ab\\)断开，计算等效电压\n\\[ U_{OC}=\\frac{6}{6+3}\\times 24-\\frac{4}{4+4}\\times 24 = 4V \\]\n将电压源置零，得到一根导线，计算等效电阻为\n\\[ R_0=\\frac{18}{9}+\\frac{16}{8}=4\\Omega \\]\n得到的等效电源为\n 11.jpg  诺顿定理 诺顿定理与戴维南不同的地方是，诺顿定理等效为一个电流源和一个电阻并联。本质上是等效的。\n我们可以选择先计算戴维南等效，再电源等效为电流源。\n也可以选择将两个端子短路来计算等效电流源，将独立源置零来计算等效并联电阻。\n计算技巧 等效的电流源和电压源是容易计算的，电流源将两个端子短路，电压源将两个端子开路。\n没有受控源时，将独立源置零，根据串并联关系，等效电阻也是容易计算的。\n当有受控源时\n外加电源法\n开路短路法\n即计算开路电压\\(u_{oc}\\)和短路电流\\(i_{sc}\\)，得到\\(R_0=u_{oc}/i_{sc}\\)\n伏安关系法\n直接对二端线性电路\\(N\\)，推导出两端子上的电压\\(u\\)和电流\\(i\\)之间的一次关系式，通常是以下形式\n\\[ u=u_{oc}-R_0i \\]\n就可以得到开路电压和等效内阻。\n最大传输功率电源定理 在电子技术中，常要求负载从给定电源（或给定电路）获得最大功率，即最大功率传输问题。\n实际应用常遇到这样的问题：一个有源二端电路，向负载电阻\\(R_L\\)供电。问\\(R_L\\)为何值时其上获得最大功率？\n由于电路\\(N\\)给定，可以将其等效为戴维南等效电路来分析。\n设等效电压为\\(u_{oc}\\)，电源内阻为\\(R_0\\)，则\n\\[ P_L = \\bigg(\\frac{u_{oc}}{R_0+R_L}\\bigg)^2R_L \\]\n可以用求导等方式证明，\\(R_L=R_0\\)时，其\\(P_L\\)最大。这称为最大功率匹配条件。\n特勒根定理和互易定理 特勒根定理 定理1\n对于任意一个具有\\(b\\)条支路\\(n\\)个节点的集总参数电路，设支路电压、支路电流分别为\\(u_k,i_k\\)，且各支路电压和电流取关联参考方向，对任何时间\\(t\\)，有\n\\[ \\sum^b_{k=1}u_ki_k=0 \\]\n定理2\n对于任意两个拓扑结构完全相同（即图完全相同，各支路组成元件性质任意）的集中参数电路\\(N\\)和\\(N\u0026#39;\\)。设它们具有\\(b\\)条支路\\(n\\)个节点，其相对应的各支路和各节点的编号相同。设它们的支路电压分别为\\(u_k\\)和\\(u\u0026#39;_k\\)，支路电流分别为\\(i_k\\)和\\(i\u0026#39;_k(k=1,2,\\cdots,b)\\)，且各支路电压和电流取关联参考方向，则对任意时刻\\(t\\)，有\n\\[ \\sum^b_{k=1}u_ki\u0026#39;_k=0 \\] \\[ \\sum^b_{k=1}u\u0026#39;_ki_k=0 \\]\n互易定理 互易定理表明: 对于一个仅含线性电阻的二端口电路\\(N_R\\)，在只有一个激励源的情况下，当激励与响应互换位置时，同一激励所产生的响应相同。\n有三个形式\n动态电路 动态元件 电容 一个二端元件，若在任一时刻\\(t\\)，其电荷\\(q(t)\\)与电压\\(u(t)\\)之间的关系能用\\(q\\sim u\\)平面上的曲线表征，即具有代数关系\\(f(u,q)=0\\)，则称该元件为电容元件，简称电容。\n电容分为时变的和非时变的、线性的和非线性的，我们主要讨论线性非时变电容。\n此时电容的库伏特性是\n\\[ q(t) = Cu(t) \\]\n其中\\(C\\)与时间无关，是电容的大小，单位为法拉（电量单位为库伦时）。\n电容的VAR\n当电容两端的电压变化时，聚集在电容上的电荷也相应发生变化，表明连接电容的导线上电荷移动，即电流流过；若电容上电压不变化，电荷也不变化，即电流为零。\n微分关系\n若电容上电压与电流参考方向关联，则有\n\\[ i(t) = C\\frac{du(t)}{dt} \\]\n积分关系\n\\[ u(t) = \\frac{1}{C}\\int^t_{-\\infty}i(\\xi)d\\xi \\]\n设\\(t=t_0\\)为初始观察时刻，上式可改写为\n\\[ u(t) = \\frac{1}{C}\\int^{t_0}_{-\\infty}i(\\xi)d\\xi+\\frac{1}{C}\\int^{t}_{t_0}i(\\xi)d\\xi=u(t_0)+\\frac{1}{C}\\int^{t}_{t_0}i(\\xi)d\\xi,t\\geq t_0 \\]\n其中\n\\[ u(t_0)=\\frac{1}{C}\\int^{t_0}_{-\\infty}i(\\xi)d\\xi \\]\n称电容电压在\\(t_0\\)时刻的初始值，或初始状态，它包含了在\\(t_0\\)以前电流的“全部历史”信息。一般取\\(t_0=0\\)。\n注意\n电容的伏安关系是微积分关系，因此电容元件是动态元件。而电阻元件的伏安关系是代数关系，电阻是一个即时(瞬时)元件。 任意时刻，通过电容的电流与该时刻电压的变化率成正比。当电容电流\\(i\\)为有限值时，其\\(du/dt\\)也为有限值，则电压\\(u\\)必定是连续函数，此时电容电压不会跃变。 当电容电压为直流电压时，则电流\\(i = 0\\)，此时电容相当于开路，故电容有隔直流的作用。  由电容VAR的积分形式可知:在任意时刻t，电容电压u是此时刻以前的电流作用的结果，它“记载”了以前电流的“全部历史”。即电容电压具有“记忆”电流的作用，故电容是一个记忆元件，而电阻是无记忆元件。  电容的功率和储能\n功率\n当电压和电流为关联方向时，电容吸收的瞬时功率为\n\\[ p(t) = u(t)i(t) = Cu(t)\\frac{du(t)}{dt} \\]\n电容是储能元件，它不消耗能量。释放的能量不会超过吸收的能量。电容不能产生能量，因此为无源元件。\n储能\n对功率从\\(-\\infty\\)到\\(t\\)进行积分，即得\\(t\\)时刻电容上的储能：\n\\[ w_c(t)=\\int^t_{-\\infty}p(\\xi)d\\xi=\\int^{u(t)}_{u(-\\infty)}Cu(\\xi)du(\\xi)=\\frac{1}{2}Cu^2(t)-\\frac{1}{2}Cu^2(-\\infty) \\]\n而未充电时应有\\(u(-\\infty)=0\\)，所以\n\\[ w_c(t) = \\frac{1}{2}Cu^2(t) \\]\n电容在某一时刻\\(t\\)的储能仅取决于此时刻的电压，而与电流无关，并且大于等于零。\n电感 一个二端元件，若在任一时刻\\(t\\)，其磁链\\(\\varPsi(t)\\)与电流\\(i(t)\\)之间的关系能用\\(\\varPsi\\sim i\\)平面上的曲线表征，即具有代数关系\\(f (\\varPsi, i ) = 0\\)，则称该元件为电感元件，简称电感。\n电感也分为时变的和非时变的、线性的和非线性的。\n主要讨论的是线性非时变电感。\n线性时不变电感的外特性（韦安特性）是\\(\\varPsi\\sim i\\)平面上一条过原点的直线，且其斜率\\(L\\)不随时间变化，\n\\[ \\varPsi(t) = Li(t) \\]\n磁链单位是韦伯，电感单位是亨利。\n电感的VAR\n电感中，当电流变化时，磁链也发生变化，从而产生感应电压。在电流与电压参考方向关联时，若电压参考方向与磁通的方向符合右手法则，根据法拉第电磁感应定律，感应电压\\(u_L(t)\\)与磁链的变化率成正比，即：\n微分关系\n\\[ u_L(t)=\\frac{d\\varPsi(t)}{dt}=L\\frac{di(t)}{dt} \\]\n积分关系\n\\[ i(t) = \\frac{1}{L}\\int^t_{-\\infty}u(\\xi)d\\xi \\]\n设\\(t=t_0\\)为初始观察时刻，上式可改写为\n\\[ i(t) = \\frac{1}{L}\\int^{t_0}_{-\\infty}u(\\xi)d\\xi+\\frac{1}{L}\\int^{t}_{t_0}u(\\xi)d\\xi=i(t_0)+\\frac{1}{L}\\int^{t}_{t_0}u(\\xi)d\\xi,t\\geq t_0 \\]\n其中\n\\[ i(t_0)=\\frac{1}{L}\\int^{t_0}_{-\\infty}u(\\xi)d\\xi \\]\n称电感电流在\\(t_0\\)时刻的初始值，或初始状态，它包含了在\\(t_0\\)以前电压的“全部历史”信息。一般取\\(t_0=0\\)。\n注意\n电感元件是动态元件。 电感的电压与该时刻电流的变化率成正比 电流\\(i\\)是连续函数，电感电流不会跃变 电感对直流相当于短路。 电感电流\\(i\\)是此时刻以前的电压作用的结果，它“记载” 了以前电压的“全部历史”。即电感也是一个记忆元件。 电感是一个储能元件，它从外部电路吸收的能量，以磁场能量的形式储存于自身的磁场中。电感\\(L\\)在某一时刻的储能只与该时刻\\(t\\)电感电流有关。  电感的功率与储能\n功率\n当电压和电流为关联方向时，电感吸收的瞬时功率为\n\\[ p(t) = u(t)i(t) = Li(t)\\frac{di(t)}{dt} \\]\n电感是储能元件，它不消耗能量。释放的能量不会超过吸收的能量。电感不能产生能量，因此为无源元件。\n储能\n对功率从\\(-\\infty\\)到\\(t\\)进行积分，即得\\(t\\)时刻电感上的储能：\n\\[ w_c(t)=\\int^t_{-\\infty}p(\\xi)d\\xi=\\int^{i(t)}_{i(-\\infty)}Li(\\xi)di(\\xi)=\\frac{1}{2}Li^2(t)-\\frac{1}{2}Li^2(-\\infty) \\]\n而未充电时应有\\(i(-\\infty)=0\\)，所以\n\\[ w_c(t) = \\frac{1}{2}Li^2(t) \\]\n电感在某一时刻\\(t\\)的储能仅取决于此时刻的电流，而与电压无关，并且大于等于零。\n电容的串并联 串联\n\\[ \\frac{1}{C_{eq}}=\\frac{1}{C_1}+\\frac{1}{C_2}+\\cdots+\\frac{1}{C_n} \\]\n并联\n\\[ C_{eq}=C_1+C_2+\\cdots+C_n \\]\n电感的串并联 串联\n\\[ L_{eq}=L_1+L_2+\\cdots+L_n \\]\n并联\n\\[ \\frac{1}{L_{eq}}=\\frac{1}{L_1}+\\frac{1}{L_2}+\\cdots+\\frac{1}{L_n} \\]\n","date":"2022-09-02T11:22:59+08:00","image":"https://kegalas.top/p/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/cover_hu0536c6b8cad2f38cd8d175ab5c2d8577_29925_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/","title":"电路基础整理"},{"content":" 复数与复变函数 复数的定义及其运算 把负数定义为一堆有序的实数\\((a,b)\\)，如果用\\(\\bm R\\)作为实数集，\\(\\bm C\\)为复数集，则\n\\[ \\bm C = \\{(a,b):a\\in\\bm R,b\\in\\bm R\\} \\]\n定义加法和乘法如下\n\\[ (a,b)+(c,d)=(a+c,b+d) \\]\n\\[ (a,b)(c,d)=(ac-bd,ad+bc) \\]\n易知，加法和乘法满足交换率和结合律。\n\\((0,0)\\)是零元素，\\((-a,-b)\\)是\\((a,b)\\)的负元素，\\((1,0)\\)是乘法的单位元素。每个非零元素\\((a,b)\\)的逆元素是\\((\\frac{a}{a^2+b^2},-\\frac{b}{a^2+b^2})\\)\n此外还满足分配律\n\\[ [(a,b)+(c,d)](e,f) = (a,b)(e,f)+(c,d)(e,f) \\]\n可以直接记\\((a,0)=a\\)。\n对于\\((0,1)\\)有\n\\[ (0,1)^2=(-1,0)=-1 \\]\n记为\\((0,1)=i\\)\n同样有\\((0,b)=(b,0)(0,1)=bi\\)\n于是每一个复数都可以写成\n\\[ (a,b)=(a,0)+(0,b)=a+bi \\]\n定理1\n复数域不是有序域，换句话说，不可以比较大小。\n出于方便和其他一些原因，用\\(z=a+bi\\)来描述复数，\\(a\\)称为\\(z\\)的实部，\\(b\\)称为\\(z\\)的虚部。可以记为\\(a=Rez,b=Imz\\)。\n四则运算\n加法\n\\[ (a+bi)+(c+di)=(a+c)+(b+d)i \\]\n乘法\n\\[ (a+bi)(c+di)=(ac-bd)+(ad+bc)i \\]\n减法\n\\[ (a+bi)-(c+di)=(a-c)+(b-d)i \\]\n除法\n\\[ \\frac{a+bi}{c+di}=(a+bi)\\left(\\frac{c-di}{c^2+d^2}\\right)=\\frac{ac+bd}{c^2+d^2}+\\frac{bc-ad}{c^2+d^2}i \\]\n模\n\\[ |z|=\\sqrt{a^2+b^2} \\]\n共轭\n\\[ \\overline{z}=a-bi \\]\n定理2\n\\(Rez=(z+\\overline{z})/2,Imz=(z-\\overline z)/2i\\) \\(z\\overline z=|z|^2\\) \\(\\overline{z+w}=\\overline z+\\overline w,\\overline{zw}=\\overline z\\cdot\\overline w\\) \\(|zw|=|z||w|,|z/w|=|z|/|w|\\) \\(|z|=|\\overline z|\\) \\(|Rez|\\leq |z|,|Imz|\\leq|z|\\) \\(|z+w|\\leq|z|+|w|\\)当且仅当存在一个\\(t\\geq 0,z=tw\\)时取等。 \\(|z-w|\\geq||z|-|w||\\)  复数的几何表示 三角表示法\n复数能用上一节提到的实数对\\((a,b)\\)表示，同时就可以看成平面上的一个点。同样的，也可以用极坐标\\((r,\\theta)\\)表示，那么有，\n\\[ a=rcos\\theta,b=rsin\\theta \\]\n所以复数也可以表示为\n\\[ z=r(cos\\theta+isin\\theta) \\]\n其中\\(r=|z|\\)，\\(\\theta\\)称为辐角，记为\\(\\theta=Argz\\)。显然若\\(\\theta\\)是辐角，那么\\(\\theta+2k\\pi\\)也是辐角。但在\\(Argz\\)中，只有一个辐角满足\\(-\\pi\u0026lt;\\theta\\leq\\pi\\)，称为辐角的主值，记为\\(argz\\)，所以有\n\\[ Argz=argz+2k\\pi,\\quad k\\in Z \\]\n特别注意，模为0的复数的辐角没有意义。\n指数表示法\n由欧拉公式\n\\[ e^{i\\theta}=cos\\theta+isin\\theta \\]\n得到\n\\[ z=re^{i\\theta} \\]\nde Moivre公式\n设\\(z_1=r_1(cos\\theta_1+isin\\theta_1),\\cdots,z_n=r_n(cos\\theta_n+isin\\theta_n)\\)是给定的n个复数，数学归纳法可知\n\\[ z_1\\cdots z_n=r_1\\cdots r_n[cos(\\theta_1+\\cdots+\\theta_n)+isin(\\theta_1+\\cdots+\\theta_n)] \\]\n作为特殊情况，有\n\\[ z^n=r^n(\\cos n\\theta+i\\sin n\\theta) \\]\n同样对于负整数也是成立的\n\\[ z^{-n}=r^{-n}(\\cos(-n\\theta)+i\\sin(-n\\theta)) \\]\n现在设\\(\\omega=r(\\cos\\theta+i\\sin\\theta)\\)是给定的，要求的\\(z=\\rho(\\cos\\varphi+i\\sin\\varphi)\\).由de Moivre公式，\\(z^n=\\omega\\)等价为\n\\[ \\rho^n(\\cos n\\varphi+i\\sin n\\varphi)=r(\\cos\\theta+i\\sin\\theta) \\]\n所以\\(\\rho=\\sqrt[n]{r},n\\varphi=\\theta+2k\\pi,k=0,1,\\cdots,n-1\\).共有\\(n\\)个复数满足\\(z^n=w\\)，即\n\\[ z=\\sqrt[n]{|\\omega |}\\left(\\cos\\frac{\\theta+2k\\pi}{n}+i\\sin\\frac{\\theta+2k\\pi}{n}\\right),k=0,1,\\cdots,n-1 \\]\n这\\(n\\)个复数恰好是以原点为中心，\\(\\sqrt[n]{|\\omega |}\\)为半径的圆的内接正\\(n\\)边形的顶点。\n\\(\\omega=1\\)时，若记\\(w=\\cos\\frac{2\\pi}{n}+i\\sin\\frac{2\\pi}{n}\\)，则\\(\\sqrt[n]{1}\\)的\\(n\\)个值为\n\\[ 1,w,w^2,\\cdots,w^{n-1} \\]\n称为\\(n\\)个单位根，如果用\\(\\sqrt[n]{\\omega}\\)的任一\\(n\\)次根，那么\\(\\omega\\)的\\(n\\)个\\(n\\)次根又可以表示为\n\\[ \\sqrt[n]{\\omega}, \\sqrt[n]{\\omega}w,\\cdots,\\sqrt[n]{\\omega}w^{n-1} \\]\n扩充平面和复数的球面表示 因为需要，在\\(\\bm C\\)中引入一个新的数\\(\\infty\\)，其模是\\(\\infty\\)，辐角没有意义，运算规则如下\n\\[ z\\pm\\infty = \\infty, z\\cdot \\infty = \\infty(z\\neq 0) \\]\n\\[ \\frac{z}{\\infty} = 0, \\frac{z}{0} = \\infty(z\\neq 0) \\]\n而\\(0\\cdot \\infty\\)和\\(\\infty\\pm\\infty\\)不规定意义。引入之后的复数系记为\\(\\bm C_\\infty\\)。在复平面上，没有一个点和\\(\\infty\\)对应，但是我们想象有一个无穷远点和\\(\\infty\\)对应，加上无穷远点的复平面称为扩充平面或闭平面。否则是开平面。\n在复平面上，无穷远点和普通点是不一样的。但在黎曼引入的球面表示中没有什么区别。\n设\\(S\\)是\\(\\bm R^3\\)中的单位球面，即\n\\[ S = \\{(x_1,x_2,x_3)\\in \\bm R^3:x_1^2+x_2^2+x_3^2=1\\} \\]\n把\\(\\bm C\\)等同于平面\n\\[ \\bm C = \\{(x_1,x_2,0):x_1,x_2\\in \\bm R\\} \\]\n称\\(N=(0,0,1)\\)为北极点。在\\(\\bm C\\)上的任一一点\\(z\\)，连接\\(N,z\\)的直线必然和\\(S\\)交于一点\\(P\\)。若\\(|z|\u0026gt;1\\)，则\\(P\\)在北半球；若\\(|z|\u0026lt;1\\)，则\\(P\\)在南半球；若\\(|z|=1\\)，则\\(z\\)就是\\(P\\)。\n当\\(z\\)趋向\\(\\infty\\)时，球面上的点就会趋向于\\(N\\)，所以就可以把\\(\\infty\\)对应于\\(N\\)。这样一来\\(\\bm C_\\infty\\)中的所有点都可以被移植到球面上去了，并且所有的点一视同仁。\n设\\(z=x+iy\\)，则\\(P\\)的坐标为\n\\[ x_1=\\frac{2x}{x^2+y^2+1},x_2=\\frac{2y}{x^2+y^2+1},x_3=\\frac{x^2+y^2-1}{x^2+y^2+1} \\]\n或者用复数表示为\n\\[ x_1=\\frac{z+\\bar z}{1+|z|^2},x_2=\\frac{z-\\bar z}{i(1+|z|^2)},x_3=\\frac{|z|^2-1}{|z|^2+1} \\]\n同样也就可以用球面上的点来表示复数\n\\[ z=\\frac{x_1+ix_2}{1-x_3} \\]\n复数列的极限 极限\n复数列\\(\\{z_n\\}\\)收敛到点\\(z_0\\)，指的是对于任给的\\(\\varepsilon\u0026gt;0\\)，存在正整数\\(N\\)，当\\(n\u0026gt;N\\)时，\\(|z_n-z_0|\u0026lt;\\varepsilon\\)，记作\\(\\lim_{n\\to \\infty}z_n=z_0\\)\n复数列\\(\\{z_n\\}\\)收敛到\\(\\infty\\)，指的是对于任意正数\\(M\u0026gt;0\\)，存在正整数\\(N\\)，当\\(n\u0026gt;N\\)时，\\(|z_n|\u0026gt;M\\)，记为\\(\\lim_{n\\to\\infty}z_n=\\infty\\)\n邻域\n对于\\(a\\in\\bm C,r\u0026gt;0\\)，称\n\\[ B(a,r)=\\{z\\in C:|z-a|\u0026lt;r\\} \\]\n为以\\(a\\)为中心、以\\(r\\)为半径的圆盘，特别当\\(a=0,r=1\\)时称为单位圆盘。\\(B(a,r)\\)也称为\\(a\\)点的一个\\(r\\)邻域，或简称邻域。无穷远点的邻域是指集合\\(\\{z\\in \\bm C:|z|\u0026gt;R\\}\\)，记为\\(B(\\infty, R)\\)\n此时极限有可以表示为：\n\\(\\lim_{n\\to \\infty}z_n=z_0\\)可以说成对任意\\(\\varepsilon\u0026gt;0\\)，当\\(n\\)充分大时，\\(z_n\\in B(z_0,\\varepsilon)\\)\n\\(\\lim_{n\\to\\infty}z_n=\\infty\\)可以说成对任意\\(M\u0026gt;0\\)，当\\(n\\)充分大时，\\(z_n\\in B(\\infty, M)\\)\n同时马上就可以得到，\\(\\lim_{n\\to \\infty}z_n=z_0\\)的充要条件是，其实部和虚部分别有\\(\\lim_{n\\to \\infty}x_n=x_0\\)和\\(\\lim_{n\\to \\infty}y_n=y_0\\)。\n开集、闭集和紧集 内点\n如果存在\\(r\u0026gt;0\\)，使得\\(B(a,r)\\subset E\\)，就称\\(a\\)为\\(E\\)的内点\n外点\n如果存在\\(r\u0026gt;0\\)使得\\(B(a,r)\\subset E^c\\)，就称\\(a\\)为\\(E\\)的外点。其中\\(E^c\\)是补集。\n边界点\n如果对于任意\\(r\u0026gt;0\\),\\(B(a,r)\\)中既有\\(E\\)的点，也有\\(E^c\\)的点，就称\\(a\\)为\\(E\\)的边界点。\n内部\n\\(E\\)的内点的全体称为\\(E\\)的内部，记为\\(E\\degree\\)\n外部\n\\(E\\)的外点的全体称为\\(E\\)的外部，记为\\((E^c)\\degree\\)\n边界\n\\(E\\)的边界点的全体称为\\(E\\)的边界，记为\\(\\partial E\\)\n开集\n如果\\(E\\)的所有点都是他的内点，即\\(E=E\\degree\\)，就称\\(E\\)是开集。\n另外，空集是开集。\n闭集\n如果\\(E^c\\)是开集，就称\\(E\\)为闭集。\n另外，无限集是闭集。\n极限点、聚点\n如果对任意\\(r\u0026gt;0\\)，\\(B(a,r)\\)中除\\(a\\)外总有\\(E\\)中的点，则称\\(a\\)为极限点或聚点。\n导集\n集\\(E\\)的所有极限点构成的集称为\\(E\\)的导集，记为\\(E\u0026#39;\\)。\n孤立点\n\\(E\\)中不属于\\(E\u0026#39;\\)的点称为孤立点。\n闭包\n\\(E\\)和它的导集的并称为\\(E\\)的闭包，记为\\(\\bar E=E\\cup E\u0026#39;\\)\n直径\n点集\\(E\\)的直径定义为\\(E\\)中任意两点间距离的上确界，记为\\(diamE\\)，即\n\\[ diamE=sup\\{|z_1-z_2|:z_1,z_2\\in E\\} \\]\nCantor定理\n若非空闭集序列\\(\\{F_n\\}\\)满足\n\\(F_1\\supset F_2\\supset\\cdots\\supset F_n\\supset\\cdots\\) \\(diamF_n\\to 0\\)（当\\(n\\to \\infty\\)时）  那么\\(\\bigcap^\\infty_{n=1}F_n\\)是一个独点集（只有一个点的集）。\n开集族、开覆盖\n设\\(E\\)是一个集，\\(\\mathscr{F}=\\{G\\}\\)是一个开集族，即\\(\\mathscr{F}\\)中的每一个元素都是开集。如果\\(E\\)中每一点至少属于\\(\\mathscr{F}\\)中的一个开集，就说\\(\\mathscr{F}\\)是\\(E\\)的一个开覆盖。\n有限覆盖性质\n点集\\(E\\)具有有限覆盖性质，是指从\\(E\\)的任一个开覆盖中必能选出有限个开集\\(G_1,\\cdots,G_n\\)，使得这有限个开集的并就能覆盖\\(E\\)，即\n\\[ E\\subset\\bigcup^n_{j=1}G_j \\]\n紧集\n具有有限覆盖性质的集称为紧集。\n有界\n集\\(E\\)称为是有界的，如果存在\\(R\u0026gt;0\\)，使得\\(E\\subset B(0,R)\\)\nHeine-Borel定理\n在\\(C\\)中，\\(E\\)是紧集的充要条件为\\(E\\)是有界闭集；在\\(C_\\infty\\)中，\\(E\\)是紧集的充要条件为\\(E\\)是闭集。\n定理\n设\\(E\\)是紧集，\\(F\\)是闭集，且\\(E\\cap F=\\empty\\)，则\n\\[ d(E,F) \u0026gt; 0 \\]\n其中\n\\[ d(E,F) = \\inf\\{|z_1-z_2|:z_1\\in E, z_2\\in F\\} \\]\nBolzano-Weierstrass定理\n任一无穷点集至少有一个极限点。\n曲线和域 连续曲线\n定义在闭区间\\([a,b]\\)上的一个复值连续函数\\(\\gamma:[a,b]\\to \\bm C\\)，写为\n\\[ z = \\gamma(t)=x(t)+iy(t),\\quad a\\leq t\\leq b \\]\n这里\\(x(t),y(t)\\)都是\\([a,b]\\)上的连续函数。\n如果用\\(\\gamma^*\\)记\\(\\gamma\\)的像点所成的集合\n\\[ \\gamma^* = \\{\\gamma(t):a\\leq t\\leq b\\} \\]\n那么\\(\\gamma^*\\)是\\(\\bm C\\)上的紧集。\n曲线\\(\\gamma\\)的方向就是\\(t\\)增加的方向。此时\\(\\gamma(a)\\)为起点，\\(\\gamma(b)\\)为终点。\n闭曲线\n如果\\(\\gamma(a)=\\gamma(b)\\)，则称为闭曲线。\n简单曲线\n如果当且仅当\\(t_1=t_2\\)时才有\\(\\gamma(t_1)=\\gamma(t_2)\\)，则称为简单曲线或Jordan曲线。\n简单闭曲线\n如果当且仅当如果当且仅当\\(t_1=a,t_2=b\\)时才有\\(\\gamma(t_1)=\\gamma(t_2)\\)，则称为简单闭曲线或Jordan闭曲线，或简称围道。\n可求长的\n设\\(z=\\gamma(t)\\)是一条曲线，对区间\\([a,b]\\)做分割\\(a=t_0\u0026lt;t_1\u0026lt;\\cdots\u0026lt;t_n=b\\)，得到以\\(z_k=\\gamma(t_k)\\)为顶点的折线\\(P\\)，那么\\(P\\)的长度为\n\\[ |P|=\\sum_{k=1}^n|\\gamma(t_k)-\\gamma(t_{k-1})| \\]\n如果不论如何分割区间\\([a,b]\\)，所得折线的长度都是有界的，就称曲线\\(\\gamma\\)是可求长的，其长度定义为\\(\\gamma\\)的上确界。\n光滑曲线\n如果\\(\\gamma\u0026#39;(t)=x\u0026#39;(t)+iy\u0026#39;(t)\\)存在，且\\(y\u0026#39;(t)\\neq 0\\)，那么\\(\\gamma\\)在每一点都有切线，\\(\\gamma\u0026#39;(t)\\)就是曲线\\(\\gamma\\)在\\(\\gamma(t)\\)处的切向量，它与正实轴的夹角为\\(Arg\\gamma\u0026#39;(t)\\)，\n如果\\(\\gamma\u0026#39;(t)\\)是连续函数，那么\\(\\gamma\\)的切线随\\(t\\)而连续变动，这时称\\(\\gamma\\)为光滑曲线。\n此时\\(\\gamma\\)的长度为\n\\[ \\int^b_a \\sqrt{(x\u0026#39;(t))^2+(y\u0026#39;(t))^2}dt = \\int^b_a|\\gamma\u0026#39;(t)|dt \\]\n曲线\\(\\gamma\\)称为逐段光滑的。\n如果存在\\(t_0,t_1,\\cdots,t_n\\)，使得\\(a=t_0\u0026lt;t_1\u0026lt;\\cdots\u0026lt;t_n=b\\)，\\(\\gamma\\)在每个参数区间\\([t_{j-1},t_j]\\)上是光滑的，那么在每个分点\\(t_1,\\cdots,t_{n-1}\\)处\\(\\gamma\\)的左右导数存在。\n连通性\n平面点集\\(E\\)称为是联通的，如果对任意两个不相交的非空集\\(E_1\\)和\\(E_2\\)满足\n\\[ E = E_1\\bigcup E_2 \\]\n那么\\(E_1\\)必含有\\(E_2\\)的极限点，或者\\(E_2\\)必含有\\(E_1\\)的极限点，也就是说，\\(E_1\\cap\\bar E_2\\)和\\(E_2\\cap\\bar E_1\\)至少有一个非空。\n定理1\n平面上的非空开集\\(E\\)是连通的充分必要条件是：\\(E\\)中任意两点可用位于\\(E\\)中的折线连接起来。\n域\n非空的连通开集称为域\nJordan定理\n一条简单闭曲线\\(\\gamma\\)吧复平面分成两个域，其中一个是有界的，称为\\(\\gamma\\)的内部；另一个是无界的，称为\\(\\gamma\\)的外部，而\\(\\gamma\\)是这两个域的共同的边界。\n单连通与多连通\n域\\(D\\)称为是单连通的，如果\\(D\\)内任意简单闭曲线的内部仍在\\(D\\)内。\n不是单连通的域称为多连通的。\n如果域\\(D\\)是由\\(n\\)跳简单闭曲线围成的，就称\\(D\\)是\\(n\\)连通的，简单闭曲线中也可以有退化成一条简单曲线或一点的。\n复变函数的极限和连续性 设\\(E\\)是复平面上一点集，如果对每一个\\(z\\in E\\)，按照某一规则有一确定复数\\(\\omega\\)与之对应，我们就说在\\(E\\)上确定了一个单值复变函数，记为\\(\\omega=f(z)\\)或\\(f:E\\to C\\)。\n\\(E\\)称为\\(f\\)的定义域，点集\\(\\{f(z):z\\in E\\}\\)称为\\(f\\)的值域。\n如果对于\\(z\\in E\\)，对应的\\(\\omega\\)有几个或无穷多个，则称在\\(E\\)上确定了一个多值函数。\n复变函数是定义在平面点集上的，而它的值域也是一个平面点集，因此复变函数也称为映射，它把一个平面点集映成另一个平面点集。\n设\\(z=x+iy\\)，用\\(u\\)和\\(v\\)记\\(\\omega=f(z)\\)的实部和虚部，则有\n\\[ \\omega=f(z)=u(z)+iv(z)=u(x,y)+iv(x,y) \\]\n这就是说，一个复变函数等价于两个二元的实变函数。\n极限\n设\\(f\\)是定义在点集\\(E\\)上的一个复变函数，\\(z_0\\)是\\(E\\)的一个极限点，\\(a\\)是给定的一个复数。如果对任意的\\(\\varepsilon\u0026gt;0\\)，存在于\\(\\varepsilon\\)有关的\\(\\delta\u0026gt;0\\)，使得当\\(z\\in E\\)且\\(0\u0026lt;|z-z_0|\u0026lt;\\delta\\)时有\\(|f(z)-a|\u0026lt;\\varepsilon\\)，就说当\\(z\\to z_0\\)时\\(f(z)\\)有极限\\(a\\)，记作\\(\\lim_{z\\to z_0}f(z)=a\\)。\n\\(\\lim_{z\\to z_0}f(z)=a\\)的充分必要条件是\n\\[ \\lim_{x\\to x_0,y\\to y_0}u(x,y)=\\alpha,\\lim_{x\\to x_0,y\\to y_0}v(x,y)=\\beta \\]\n连续\n我们说\\(f\\)在点\\(z_0\\in E\\)连续，如果\n\\[ \\lim_{z\\to z_0}f(z)=f(z_0) \\]\n如果\\(f\\)在集\\(E\\)中每点都连续，就说\\(f\\)在集\\(E\\)上连续。\n定理\n设\\(E\\)是\\(\\bm C\\)中的紧集，\\(f:E\\to\\bm C\\)在\\(E\\)上连续，那么\n\\(f\\)在\\(E\\)上有界 \\(|f|\\)在\\(E\\)上能取得最大值和最小值，即存在\\(a,b\\in E\\)使得对于每个\\(z\\in E\\)都有  \\[ |f(z)|\\leq |f(a)|，|f(z)|\\geq|f(b)| \\]\n\\(f\\)在\\(E\\)上一致连续。即对任意\\(\\varepsilon\u0026gt;0\\)，存在只与\\(\\varepsilon\\)有关的\\(\\delta\u0026gt;0\\)，对\\(E\\)上任意的\\(z_1,z_2\\)，只要\\(|z_1-z_2|\u0026lt;\\delta\\)，就有\\(|f(z_1)-f(z_2)|\u0026lt;\\varepsilon\\)  全纯函数/解析函数 复变函数的导数 设\\(f:D\\to\\bm C\\)是定义在域\\(D\\)上的函数，\\(z_0\\in D\\)，如果极限\n\\[ \\lim_{z\\to z_0}\\frac{f(z)-f(z_0)}{z-z_0} \\]\n存在，就说\\(f\\)在\\(z_0\\)处复可导或可微，这个极限称为在此处的导数或微商。\n如果\\(f\\)在\\(D\\)中每点都可微，就称\\(f\\)是域\\(D\\)中的全纯函数或解析函数。\n如果\\(f\\)在\\(z_0\\)的一个邻域中全纯，就称\\(f\\)在\\(z_0\\)处全纯。\n定理1\n如果\\(f\\)在\\(z_0\\)处可微，则必在\\(z_0\\)处连续。反过来说则不一定成立。\n求复变函数的导数时，跟一元实变函数几乎没有什么区别，例如\\(f(z)=z^3, f\u0026#39;(z)=3z^2\\)。但是更加严格的一点时，在复平面上任何一个方向上的导数都要相等，而不是一元实变函数左右相等。\n实变函数的四则运算的求导法则在全纯函数中也成立。\n定理2\n设\\(D_1,D_2\\)是\\(\\bm C\\)中的两个域，且\n\\[ f:D_1\\to D_2\\\\ g:D_2\\to\\bm C \\]\n都是全纯函数，那么\\(h=g\\circ f\\)是\\(D_1\\to \\bm C\\)的全纯函数，并且\\(h\u0026#39;(z)=g\u0026#39;(f(z))f\u0026#39;(z)\\)\nCauchy-Riemann方程 实可微\n设\\(f(z)=u(x,y)+iv(x,y)\\)是定义在域\\(D\\)上的函数，\\(z_0=x_0+iy_0\\in D\\).我们说\\(f\\)在\\(z_0\\)处实可微，是指\\(u,v\\)作为\\(x,y\\)的二元函数在\\((x_0,y_0)\\)处可微。\n设\\(f:D\\to C\\)是定义在域\\(D\\)上的函数，\\(z_0\\in D\\)，那么\\(f\\)在\\(z_0\\)处实可微的充要条件是下式成立\n\\[ f(z_0+\\Delta z)-f(z_0)=\\frac{\\partial f}{\\partial z}(z_0)\\Delta z+\\frac{\\partial f}{\\partial \\bar z}(z_0)\\Delta z+o(|\\Delta z|) \\]\n其中算子定义如下\n\\[ \\frac{\\partial}{\\partial z}=\\frac{1}{2}\\left(\\frac{\\partial}{\\partial x}-i\\frac{\\partial}{\\partial y}\\right) \\]\n\\[ \\frac{\\partial}{\\partial \\bar z}=\\frac{1}{2}\\left(\\frac{\\partial}{\\partial x}+i\\frac{\\partial}{\\partial y}\\right) \\]\n在进行微分运算时，可以把\\(z,\\bar z\\)看成独立的变量。\n柯西-黎曼方程\n设\\(f\\)是定义在域\\(D\\)上的函数，\\(z_0\\in D\\)，那么\\(f\\)在\\(z_0\\)处可微的充要条件是\\(f\\)在\\(z_0\\)处实可微且\\(\\frac{\\partial f}{\\partial \\bar z}(z_0)=0\\).\n在可微的情况下，\\(f\u0026#39;(z_0)=\\frac{\\partial f}{\\partial z}(z_0)\\).\n其中\\(\\frac{\\partial f}{\\partial \\bar z}(z_0)=0\\)就称为柯西-黎曼方程。\n将\\(u,v\\)代入以及算子展开，可以得到其等价于\n\\[ \\left\\{\\begin{matrix} \\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y} \\\\ \\frac{\\partial u}{\\partial y}=-\\frac{\\partial v}{\\partial x} \\end{matrix}\\right. \\]\n调和函数\n设\\(u\\)是域\\(D\\)上的实值函数，如果\\(u\\in C^2(D)\\)，且对于任意\\(z\\in D\\)，有\n\\[ \\Delta u(z)=\\frac{\\partial^2u(z)}{\\partial x^2}+\\frac{\\partial^2u(z)}{\\partial y^2}=0 \\]\n就称\\(u\\)是\\(D\\)中的调和函数。\n\\[ \\Delta=\\frac{\\partial^2}{\\partial x^2}+\\frac{\\partial^2}{\\partial y^2} \\]\n称为拉普拉斯算子。\n设\\(D\\)是\\(\\bm C\\)中的域，用\\(C(D)\\)表示\\(D\\)上连续函数的全体，\\(H(D)\\)表示\\(D\\)上全纯函数的全体。\n用\\(C^1(D)\\)记\\(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y}\\)在\\(D\\)上连续的\\(f\\)的全体。\n有\n\\[ H(D)\\subset C^\\infty(D)\\subset C^k(D)\\subset C^1(D)\\subset C(D) \\]\n即域\\(D\\)上的全纯函数在\\(D\\)上有任意阶的连续偏导数。\n定理1\n设\\(f=u+iv\\in H(D)\\)，那么\\(u,v\\)都是\\(D\\)上的调和函数。\n共轭调和函数\n设\\(u,v\\)是\\(D\\)上的一堆调和函数，如果它们还满足柯西-黎曼方程，\n\\[ \\left\\{\\begin{matrix} \\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y} \\\\ \\frac{\\partial u}{\\partial y}=-\\frac{\\partial v}{\\partial x} \\end{matrix}\\right. \\]\n就称\\(v\\)为\\(u\\)的共轭调和函数。\n定理1\n设\\(u\\)是单连通域\\(D\\)上的调和函数，则必存在\\(u\\)的共轭函数\\(v\\)，使得\\(u+iv\\)是\\(D\\)上的全纯函数。\n导数的几何意义 过点\\(z_0\\)作两条光滑曲线\\(\\gamma_1,\\gamma_2\\)，它们的方程分别为\n\\[ z=\\gamma_1(t),a\\leq t\\leq b \\]\n和\n\\[ z=\\gamma_2(t),a\\leq t\\leq b \\]\n且\\(\\gamma_1(a)=\\gamma_2(a)=z_0\\)。映射\\(\\omega=f(z)\\)把它们分别映为过\\(\\omega_0\\)点的两条光滑曲线\\(\\sigma_1\\)和\\(\\sigma_2\\)，他们的方程分别为\n\\[ \\omega = \\sigma_1(t)=f(\\gamma_1(t)),a\\leq t\\leq b \\]\n\\[ \\omega = \\sigma_2(t)=f(\\gamma_2(t)),a\\leq t\\leq b \\]\n因为\\(\\sigma\u0026#39;(a)=f\u0026#39;(\\gamma(a))\\gamma\u0026#39;(a)=f\u0026#39;(z_0)\\gamma\u0026#39;(a)\\neq 0\\)，所以有\n\\[ Arg\\sigma\u0026#39;(a) = Argf\u0026#39;(z_0)+Arg\\gamma\u0026#39;(a) \\]\n或者写为\n\\[ Arg\\sigma\u0026#39;(a)-Arg\\gamma\u0026#39;(a) = Argf\u0026#39;(z_0) \\]\n由此就有\n\\[ Arg\\sigma_1\u0026#39;(a)-Arg\\gamma_1\u0026#39;(a) = Argf\u0026#39;(z_0) = Arg\\sigma_2\u0026#39;(a)-Arg\\gamma_2\u0026#39;(a) \\]\n上式说明，如果\\(f\u0026#39;(z_0)\\neq 0\\)，那么在映射\\(\\omega=f(z)\\)的作用下，过\\(z_0\\)点的任意两条光滑曲线的夹角的大小与旋转方向都是保持不变的。\n我们把这种性质的映射称为在\\(z_0\\)点是保角的。\n定理\n全纯函数在其导数不为零的点处是保角的。\n导数的模的几何意义，即\\(|f\u0026#39;(z_0)|\\)为\\(f\\)在\\(z_0\\)处的伸缩率。\n初等全纯函数 指数函数 设\\(z=x+iy\\)，定义\n\\[ e^z = e^x(\\cos y+i\\sin y) \\]\n具有如下性质\n\\((e^z)\u0026#39;=e^z\\) 复数的三角表示\\(z=r(\\cos\\theta+i\\sin\\theta)\\)可以表示为\\(z=re^{i\\theta}\\) 对于任意\\(z\\in \\bm C,e^z\\neq 0\\)，这是因为  \\[ |e^z|=e^x\u0026gt;0 \\]\n对于任意\\(z_1,z_2\\)，有  \\[ e^{z_1}e^{z_2}=e^{z_1+z_2} \\]\n\\(e^z\\)是以\\(2\\pi i\\)为周期的周期函数。  单叶\n设\\(f:D\\to \\bm C\\)是一个复变函数，如果对于\\(D\\)中的任意两点\\(z_1,z_2(z_1\\neq z_2)\\)，必有\\(f(z_1)\\neq f(z_2)\\)，就称\\(f\\)在\\(D\\)中是单叶的，\\(D\\)称为\\(f\\)的单叶性域。\n\\(\\omega=e^z\\)的单叶性域有\n\\[ \\{z=x+iy:2k\\pi\u0026lt;y\u0026lt;2(k+1)\\pi\\},k=0,\\pm1,\\cdots \\]\n对数函数 对于给定的\\(z\\in C\\)，满足方程\\(e^\\omega=z\\)的\\(\\omega\\)称为\\(z\\)的对数，记为\\(\\omega=Logz\\)。\n设\\(z=re^{i\\theta}\\)，\\(\\omega=u+iv\\)，则\\(e^{u+iv}=re^{i\\theta}\\)，所以\\(e^u=r,v=\\theta+2k\\pi\\)。所以有\n\\[ Logz=log|z|+iargz+2k\\pi=log|z|+iArgz \\]\n所以，\\(Logz\\)是一个多值函数，它的多值性是由\\(z\\)的辐角\\(Argz\\)的多值性产生的。\n定理1\n如果\\(D\\)是不包含原点和无穷远点的单连通域，则必在\\(D\\)上存在无穷多个单值全纯函数\\(\\varphi_k,k=0,\\pm1,\\cdots\\)，使得在\\(D\\)上成立\n\\[ e^{\\varphi_k(z)}=z,k=0,\\pm1,\\cdots; \\]\n而且对每一个\\(k\\)，有\\(\\varphi_k\u0026#39;(z)=\\frac{1}{z}\\).其中的每一个\\(\\varphi_k\\)都称为\\(Logz\\)在\\(D\\)上的单值全纯分支。\n至于为什么不包含原点和无穷远点：如果包含原点，那么\\(D\\)中就包含绕原点\\(z=0\\)的简单闭曲线\\(\\gamma\\)，当\\(z\\)从\\(\\gamma\\)上的一点\\(z_0\\)沿\\(\\gamma\\)的正方向（即逆时针）回到\\(z_0\\)时，\\(z\\)的辐角增加了\\(2\\pi\\)，\\(\\varphi_{k_0}(z_0)\\)的值连续地变为\\(\\varphi_{k_0+1}(z_0)\\)，而不再回到原来的\\(\\varphi_{k_0}(z_0)\\)。因此再这样的域中就不可能分出单值的全纯分支。无穷远点同理。\n定义1\n如果当\\(z\\)沿着\\(z_0\\)的充分小邻域中的任意简单闭曲线绕一圈时，多值函数的值就从一支变到另一支，那么称\\(z_0\\)为该多值函数的一个支点。\n以对数函数为例，\\(z=0,z=\\infty\\)就是\\(Logz\\)的支点。\n幂函数 \\(\\omega=z^\\mu\\)称为幂函数，这里\\(\\mu=a+bi\\)，分情况讨论\n1. \\(\\mu=n\\)，是一个自然数\n按照导数的定义，可以直接算出\n\\[ (z^n)\u0026#39;=nz^{n-1} \\]\n其在\\(C\\)上每一点都是全纯的。这种函数也称作整函数\n它的单叶性域是\n\\[ \\bigg\\{z:\\alpha\u0026lt;argz\u0026lt;\\beta,0\u0026lt;\\beta-\\alpha\\leq\\frac{2\\pi}{n}\\bigg\\} \\]\n2. \\(\\mu=\\frac{1}{n}\\)，n是一个自然数\n对于一个给定的\\(z\\)，\\(z^{1/n}\\)有\\(n\\)个值，所以它是一个多值函数。多值性由\\(Argz\\)产生，\\(0,\\infty\\)是其支点。\\(C\\)去掉正实轴后所成的域上可以分出\\(n\\)个单值的全纯分支，它们是\n\\[ \\omega = \\varphi_k(z) = \\sqrt[n]{|z|}\\bigg(\\cos\\frac{\\theta+2k\\pi}{n}+i\\sin\\frac{\\theta+2k\\pi}{n}\\bigg) \\]\n\\[ k=0,1,\\cdots,n-1 \\]\n其中\\(\\theta=argz\\)，变化范围在\\(0\u0026lt;argz\u0026lt;2\\pi\\)\n3. \\(\\mu = a+bi\\)，是一个负数\n一般的幂函数\\(\\omega=z^\\mu\\)定义为\n\\[ \\omega = z^\\mu=e^{\\mu Logz} \\]\n显然这也是个多值函数\n\\[ \\omega = exp(alog|z|-b(argz+2k\\pi))exp(i[blog|z|+a(argz+2k\\pi)]) \\]\n\\[ k=0,\\pm1,\\cdots \\]\n若\\(b=0,a=n\\)是一个整数，则\\(\\omega=z^n\\)是一个单值函数 若\\(b=0,a=p/q\\)是一个有理数，不妨设\\(p\u0026lt;q\\)，这时  \\[ \\omega=z^\\mu=z^{p/q}=|z|^{p/q}exp(i\\frac{p}{q}(argz+2k\\pi)) \\]\n当\\(k=0,1,\\cdots,q-1\\)时，\\(\\omega\\)有\\(q\\)个不同的值\n若\\(b=0,a\\)是一个无理数，这时  \\[ \\omega = z^\\mu = |z|^aexp(iaargz)exp(i2k\\pi a) \\]\n此时\\(z^a\\)是一个无穷值函数\n若\\(b\\neq 0\\)，则\\(\\omega=z^\\mu\\)是一无穷值函数。  三角函数 由欧拉公式知道\n\\[ e^{ix} = \\cos x+i\\sin x\\\\ e^{-ix} = \\cos x -i\\sin x \\]\n可以得到\n\\[ \\cos z = \\frac{1}{2}(e^{ix}+e^{-ix})\\\\ \\sin z = \\frac{1}{2i}(e^{ix}-e^{-ix}) \\]\n有如下性质\n正弦余弦都是整函数，并且  \\[ (\\cos z)\u0026#39; = -\\sin z\\\\ (\\sin z)\u0026#39; = \\cos z \\]\n以\\(2\\pi\\)为周期 \\(\\cos z\\)是偶函数，\\(\\sin z\\)是奇函数 对任意\\(z_1,z_2\\)  \\[ \\cos (z_1+z_2) = \\cos z_1\\cos z_2 - \\sin z_1\\sin z_2\\\\ \\sin (z_1+z_2) = \\sin z_1\\cos z_2 + \\cos z_1\\sin z_2\\\\ \\]\n\\(\\cos^2 z+\\sin^2 z=1,\\quad \\sin 2z = 2\\sin z\\cos z\\) \\(\\sin z\\)仅在\\(z=k\\pi\\)处为零，\\(\\cos z\\)仅在\\(k\\pi+\\pi/2\\)处为零，\\(k=0,\\pm1,\\cdots\\) \\(\\cos z,\\sin z\\)不是有界函数  同样我们就能定义正切余切\n\\[ \\tg z = \\frac{\\sin z}{\\cos z} \\]\n\\[ \\ctg z = \\frac{\\cos z}{\\sin z} \\]\n前者在除掉\\(z=\\pi/2+k\\pi\\)的开平面上全纯，后者在除掉\\(z=k\\pi\\)的开平面上全纯，\\(k=0,\\pm1,\\cdots\\)。\n之后我们也能定义双曲函数\n\\[ chz=\\frac{e^z+e^{-z}}{2},shz=\\frac{e^z-e^{-z}}{2} \\]\n并且有\n\\[ (chz)\u0026#39;=shz,(shz)\u0026#39;=chz \\]\n反三角函数有\n\\[ Arcsinz=-iLn(iz+\\sqrt{1-z^2}) \\]\n\\[ Arccosz=-iLn(z+\\sqrt{z^2-1}) \\]\n\\[ Arctanz=-\\frac{i}{2}Ln\\frac{1+iz}{1-iz} \\]\n反双曲函数有\n\\[ Arshz = Ln(z+\\sqrt{z^2+1}) \\]\n\\[ Archz = Ln(z+\\sqrt{z^2-1}) \\]\n\\[ Arthz = \\frac{1}{2}Ln\\frac{1+z}{1-z} \\]\n分式线性变换 形如\\(\\omega=T(z)=\\frac{az+b}{cz+d}\\)的映射称为分式线性变换或Mobius变换，其中\\(a,b,c,d\\)是复常数，且满足\\(ad-bc\\neq 0\\)，如果等于\\(0\\)原式就是常数或无意义，没有讨论价值。\n如果\\(c\\neq 0\\)，则除去点\\(z=-\\frac{d}{c}\\)外，\\(T(z)\\)在\\(\\bm C\\)上是全纯的，而且\n\\[ T\u0026#39;(z)=\\frac{ad-bc}{(cz+d)^2}\\neq 0 \\]\n所以分式线性变换在\\(z\\neq -\\frac{d}{c}\\)处是保角变换。\n若\\(c=0\\)，则必\\(d\\neq 0\\)，此时\\(T(z)=Az+B(A=a/d,B=b/d)\\)，称为整线性变换，它是一个整函数。\n从方程\\(\\omega=T(z)\\)中把\\(z\\)解出来，得\n\\[ z = T^{-1}(\\omega)=\\frac{-d\\omega+b}{c\\omega-a} \\]\n称为\\(\\omega=T(z)\\)的逆变换，它仍然是一个分式线性变换。由此可知\\(\\omega=T(z)\\)在\\(\\bm C\\)上是单叶的，当\\(c\\neq 0\\)时，规定\\(T(-\\frac{d}{c})=\\infty,T(\\infty)=\\frac{a}{c}\\)。当\\(c=0\\)时，规定\\(T(\\infty)=\\infty\\)，于是\\(\\omega=T(z)\\)把\\(\\bm C_\\infty\\)单叶地映射为\\(C_\\infty\\)。\n设\\(S,T\\)是两个分式线性变换，那么\\(S\\circ T\\)也是分式线性变换。且对每一个\\(T\\)，都有逆变换\\(T^{-1}\\)。\n分式线性变换有如下性质\n分式线性变换把圆周变成圆周 交比是分式线性变换的不变量  命题1\n分式线性变换\\(T\\)最多只有两个不动点，除非是恒等变换，即\\(T(z)\\equiv z\\)\n定义1\n设\\(z_1,z_2,z_3,z_4\\)是给定的四个点，其中至少有三个点是不相同的，称比值\n\\[ \\frac{z_1-z_3}{z_1-z_4}\\bigg /\\frac{z_2-z_3}{z_2-z_4} \\]\n为这四个点的交比，记为\\((z_1,z_2,z_3,z_4)\\)\n规定\n\\[ (\\infty,z_2,z_3,z_4)=\\frac{z_2-z_4}{z_2-z_3} \\]\n\\[ (z_1,\\infty,z_3,z_4)=\\frac{z_1-z_3}{z_1-z_4} \\]\n\\[ (z_1,z_2,\\infty,z_4)=\\frac{z_2-z_4}{z_1-z_4} \\]\n\\[ (z_1,z_2,z_3,\\infty)=\\frac{z_1-z_3}{z_2-z_3} \\]\n按照交比的定义，有\n\\[ (z,z_2,z_3,z_4)=\\frac{z-z_3}{z-z_4}\\cdot\\frac{z_2-z_4}{z_2-z_3} \\]\n它是一个分式线性变换，若把它记为\\(L(z)\\)，那么\n\\[ L(z_2)=1,\\\\ L(z_3)=0,\\\\ L(z_4)=\\infty. \\]\n定理1\n有且只有一个分式线性变换把\\(\\bm C_\\infty\\)上三个不同的点\\(z_2,z_3,z_4\\)映为事先给定的\\(\\bm C_\\infty\\)上的三个点\\(\\omega_2,\\omega_3,\\omega_4\\)\n定理2\n交比是分式线性变换的不变量。也就是说，如果分式线性变换\\(T\\)把\\(z_1,z_2,z_3,z_4\\)映为\\(T(z_1),T(z_2),T(z_3),T(z_4)\\)，那么\n\\[ (z_1,z_2,z_3,z_4)=(T(z_1),T(z_2),T(z_3),T(z_4)) \\]\n定理3\n如果\\(f(z_1,z_2,z_3,z_4)\\)是分式线性变换下的不变量，即对任意分式线性变换\\(T\\)都有\n\\[ f(z_1,z_2,z_3,z_4) = f(T(z_1),T(z_2),T(z_3),T(z_4)) \\]\n那么\\(f\\)只能是交比\\((z_1,z_2,z_3,z_4)\\)的函数。\n命题2\n四点\\(z_1,z_2,z_3,z_4\\)共圆的充要条件是\n\\[ Im(z_1,z_2,z_3,z_4)=0 \\]\n定义2\n设\\(\\bm C_\\infty\\)上的圆周\\(\\gamma\\)把平面分成\\(g_1\\)和\\(g_2\\)两个域，\\(z_1,z_2,z_3\\)是\\(\\gamma\\)上有序的三个点。如果当我们从\\(z_1\\)走到\\(z_2\\)再走到\\(z_3\\)时，\\(g_1\\)和\\(g_2\\)分别在我们的左边和右边，就分别称\\(g_1\\)和\\(g_2\\)为\\(\\gamma\\)关于走向\\(z_1,z_2,z_3\\)的左边和右边\n命题3\n\\(z_1,z_2,z_3\\)是\\(\\bm C_\\infty\\)上的圆周\\(\\gamma\\)上有序的三个点，那么\\(\\gamma\\)关于走向\\(z_1,z_2,z_3\\)的右边和左边的点\\(z\\)分别满足\n\\[ Im(z,z_1,z_2,z_3)\u0026gt;0\\\\ Im(z,z_1,z_2,z_3)\u0026lt;0 \\]\n定理4\n设\\(\\gamma_1\\)和\\(\\gamma_2\\)是\\(\\bm C_\\infty\\)中的两个圆周，\\(z_1,z_2,z_3\\)是\\(\\gamma_1\\)上有序的三个点，如果分式线性变换\\(T\\)把\\(\\gamma_1\\)映为\\(\\gamma_2\\)，那么它一定把\\(\\gamma_1\\)关于走向\\(z_1,z_2,z_3\\)的右边和左边分别变为\\(\\gamma_2\\)关于走向\\(T(z_1),T(z_2),T(z_3)\\)的右边和左边。\n对称点及其在分布线性变换下的不变性  命题1\n设\\(\\gamma\\)是\\(\\bm C_\\infty\\)中的圆周，那么\\(z,z^*\\)关于\\(\\gamma\\)对称的充要条件是对\\(\\gamma\\)上任意三点\\(z_1,z_2,z_3\\)，有\n\\[ (z^*,z_1,z_2,z_3)=\\overline{(z,z_1,z_2,z_3)} \\]\n对于直线的情形，可以看做无限半径的圆。\n定理1\n对称点在分式线性变换下不变。这就是说，设分式线性变换\\(T\\)把圆周\\(\\gamma\\)变为\\(\\Gamma\\)，如果\\(z,z^*\\)是关于\\(\\gamma\\)的对称点，那么\\(T(z),T(z^*)\\)是关于\\(\\Gamma\\)的对称点。\n全纯函数的积分表示 复变函数的积分 设\\(z=\\gamma(t)(a\\leq t\\leq b)\\)是一条可求长曲线，\\(f\\)是定义在\\(\\gamma\\)上的函数，沿\\(\\gamma\\)的正方向取分点\\(\\gamma(a)=z_0,z_1,z_2,\\cdots,z_n=\\gamma(b)\\)，在\\(\\gamma\\)中从\\(z_{k-1}\\)到\\(z_k\\)的弧段上任取点\\(\\zeta_k,k=1,\\cdots,n\\)，作Riemann和\n\\[ \\sum_{k=1}^n f(\\zeta_k)(z_k-z_{k-1}) \\]\n用\\(s_k\\)记弧段\\(z_{k-1}z_k\\)的长度，如果\\(\\lambda=max\\{s_k\\}\\to 0\\)时，不论\\(\\zeta_k\\)的取法，上式总有一确定的极限，就称次极限为\\(f\\)沿\\(\\gamma\\)的积分，记为\n\\[ \\int_{\\gamma}f(z)dz = \\lim_{\\lambda\\to 0}\\sum_{k=1}^n f(\\zeta_k)(z_k-z_{k-1}) \\]\n只要\\(f\\)在\\(\\gamma\\)上连续，上述积分、上述极限一定存在。\n命题1\n设\\(f=u+iv\\)在可求长曲线\\(\\gamma\\)上连续，则有\n\\[ \\int_{\\gamma}f(z)dz = \\int_{\\gamma}udx-vdy+i\\int_{\\gamma}vdx+udy \\]\n或者便于记忆\n\\[ f(z)dz = (u+iv)(dx+idy) = (udx-vdy)+i(vdx+udy) \\]\n如果曲线光滑，还可以通过曲线的参数方程来计算积分。\n命题2\n如果\\(z=\\gamma(t)(a\\leq t\\leq b)\\)是光滑曲线，\\(f\\)在\\(\\gamma\\)上连续，那么\n\\[ \\int_{\\gamma}f(z)dz = \\int^b_af(\\gamma(t))\\gamma\u0026#39;(t)dt \\]\n命题3\n如果\\(f,g\\)在可求长曲线\\(\\gamma\\)上连续，那么\n\\(\\int_{\\gamma^-}f(z)dz=-\\int_{\\gamma}f(z)dz\\)，\\(\\gamma^-\\)是与\\(\\gamma\\)反向的曲线 \\(\\int_{\\gamma}f(\\alpha f(z)+\\beta g(z))dz=\\alpha\\int_{\\gamma}f(z)dz+\\beta \\int_{\\gamma}g(z)dz\\)，\\(\\alpha,\\beta\\)是两个复常数 \\(\\int_{\\gamma}f(z)dz=\\int_{\\gamma_1}f(z)dz+\\int_{\\gamma_2}f(z)dz\\)，这里\\(\\gamma\\)是由\\(\\gamma_1\\)和\\(\\gamma_2\\)组成的曲线。  命题4\n如果\\(\\gamma\\)的长度为\\(L\\)，\\(M=\\sup|f(z)|\\)（即上确界），那么\n\\[ \\bigg |\\int_\\gamma f(z)dz\\bigg |\\leq ML \\]\nCauchy积分定理 Cauchy定理\n设\\(D\\)是\\(\\bm C\\)中的单连通域，\\(f\\in H(D)\\)（即全纯函数），且\\(f\u0026#39;\\)在\\(D\\)中连续，则对\\(D\\)中任意的可求长曲线\\(\\gamma\\)，均有\n\\[ \\int_\\gamma f(z)dz = 0 \\]\n注意，只要使得\\(f\\)的不全纯的点在\\(\\gamma\\)包围的区域中，而不是必须在\\(\\gamma\\)上，就不能使用这个定理。\n引理1\n设\\(f\\)是域\\(D\\)中的连续函数，\\(\\gamma\\)是\\(D\\)内的可求长曲线，对于任给的\\(\\varepsilon\u0026gt;0\\)，一定存在一条\\(D\\)中的折线\\(P\\)，使得\n\\(P\\)和\\(\\gamma\\)有相同的起点和终点，\\(P\\)中其他的顶点都在\\(\\gamma\\)上 \\(|\\int_\\gamma f(z)dz-\\int_P f(z)dz|\u0026lt;\\varepsilon\\)  Cauchy-Goursat定理\n设\\(D\\)是\\(\\bm C\\)中的单连通域，如果\\(f\\in H(D)\\)，那么对\\(D\\)中任意的可求长闭曲线\\(\\gamma\\)，均有\n\\[ \\int_\\gamma f(z)dz = 0 \\]\n注意点同上。\n这个定理也意味着积分和路径无关，只与始末位置有关。\n定理1\n设\\(D\\)是可求长简单闭曲线\\(\\gamma\\)的内部，若\\(f\\in H(D)\\bigcap C(\\bar D)\\)（即在\\(D\\)上全纯且在\\(\\bar D\\)（闭包）上连续），则\n\\[ \\int_\\gamma f(z)dz = 0 \\]\n定理2\n设\\(\\gamma_0,\\gamma_1,\\cdots,\\gamma_n\\)是\\(n+1\\)条可求长简单闭曲线，\\(\\gamma_1,\\cdots,\\gamma_n\\)都在\\(\\gamma_0\\)内部，\\(\\gamma_1,\\cdots,\\gamma_n\\)中的每一条都在其他\\(n-1\\)条的外部，\\(D\\)是由这\\(n+1\\)条曲线围成的域，用\\(\\gamma\\)记\\(D\\)的边界，如果\\(f\\in H(D)\\bigcap C(\\bar D)\\)，那么\n\\[ \\int_\\gamma f(z)dz = 0 \\]\n或者也可以写作\n\\[ \\int_{\\gamma_0} f(z)dz = \\int_{\\gamma_1} f(z)dz+\\cdots+\\int_{\\gamma_n} f(z)dz \\]\n全纯函数的原函数 定义1\n设\\(f:D\\to \\bm C\\)是定义在域\\(D\\)上的一个函数，如果存在\\(F\\in H(D)\\)，使得\\(F\u0026#39;(z)=f(z)\\)在\\(D\\)上成立，就称\\(F\\)是\\(f\\)的一个原函数\n定理1\n设\\(f\\)在\\(D\\)中连续，且对\\(D\\)中任意可求长闭曲线\\(\\gamma\\)均有\n\\[ \\int_\\gamma f(z)dz=0 \\]\n那么\n\\[ F(z) = \\int^z_{z_0}f(\\zeta)d\\zeta \\]\n是\\(D\\)中的全纯函数，且在\\(D\\)中有\\(F\u0026#39;(z)=f(z)\\)，这里\\(z_0\\)是\\(D\\)中一固定点。\n定理2\n设\\(D\\)是\\(\\bm C\\)中的单连通域，\\(f\\in H(D)\\)，那么\\(F(z)=\\int^z_{z_0}f(\\zeta)d\\zeta\\)是\\(f\\)在\\(D\\)中的一个原函数。\n定理3\n设\\(D\\)是\\(\\bm C\\)中的单连通域，\\(f\\in H(D)\\)，\\(\\varPhi\\)是\\(f\\)的任一原函数，那么\n\\[ \\int^z_{z_0}f(\\zeta)d\\zeta = \\varPhi(z)-\\varPhi(z_0) \\]\nCauchy积分公式 定理1\n设\\(D\\)是由可求长简单闭曲线\\(\\gamma\\)围成的域，如果\\(f\\in H(D)\\bigcap C(\\bar D)\\)，那么对任意\\(z\\in D\\)，均有\n\\[ f(z) = \\frac{1}{2\\pi i}\\int_\\gamma \\frac{f(\\zeta)}{\\zeta-z}d\\zeta \\]\n定理2\n设\\(\\gamma\\)是\\(C\\)中的可求长曲线，\\(g\\)是\\(\\gamma\\)上的连续函数，那么由Cauchy型积分确定的函数\n\\[ G(z) = \\frac{1}{2\\pi i}\\int_\\gamma \\frac{g(\\zeta)}{\\zeta-z}d\\zeta \\]\n在\\(C\\setminus y\\)（差集）上有任意阶导数，而且\n\\[ G^{(n)}(z)=\\frac{n!}{2\\pi i}\\int_\\gamma\\frac{g(\\zeta)}{(\\zeta-z)^{n+1}}d\\zeta,n=1,2,\\cdots \\]\n定理3\n设\\(D\\)是由可求长简单闭曲线\\(\\gamma\\)围成的域，如果\\(f\\in H(D)\\bigcap C(\\bar D)\\)，那么\\(f\\)在\\(D\\)上游任意阶导数，而且对任意\\(z\\in D\\)，有\n\\[ f^{(n)}(z)=\\frac{n!}{2\\pi i}\\int_\\gamma\\frac{f(\\zeta)}{(\\zeta-z)^{n+1}}d\\zeta,n=1,2,\\cdots \\]\n定理4\n如果\\(f\\)是域\\(D\\)上的全纯函数，那么\\(f\\)在\\(D\\)上有任意阶导数。\n定理5\n设\\(\\gamma_0,\\gamma_1,\\cdots,\\gamma_k\\)是\\(k+1\\)条可求长简单闭曲线，\\(\\gamma_1,\\cdots,\\gamma_k\\)都在\\(\\gamma_0\\)的内部，\\(\\gamma_1,\\cdots,\\gamma_k\\)中的每一条都在其他\\(k-1\\)条的外部，\\(D\\)是由这\\(k+1\\)条曲线围成的域，\\(D\\)的边界\\(\\gamma\\)由\\(\\gamma_0,\\gamma_1,\\cdots,\\gamma_k\\)所组成，如果\\(f\\in H(D)\\bigcap C(\\bar D)\\)，则对任意\\(z\\in D\\)，有\n\\[ f(z) = \\frac{1}{2\\pi i}\\int_\\gamma \\frac{f(\\zeta)}{\\zeta-z}d\\zeta \\]\n\\(f\\)在\\(D\\)内有任意阶导数，且\n\\[ f^{(n)}(z)=\\frac{n!}{2\\pi i}\\int_\\gamma\\frac{f(\\zeta)}{(\\zeta-z)^{n+1}}d\\zeta,n=1,2,\\cdots \\]\nCauchy积分公式的一些重要推论 Cauchy不等式\n设\\(f\\)在\\(B(a,R)\\)中全纯，且对任意\\(z\\in B(a,R)\\)，有\\(|f(z)|\\leq M\\)，那么\n\\[ |f^{(n)}(a)|\\leq\\frac{n!M}{R^n},n=1,2,\\cdots \\]\nLiouville定理\n有界整函数必为常数\n代数学基本定理\n任意复系数多项式\n\\[ P(z)=a_0z^n+a_1z^{n-1}+\\cdots+a_n,a_0\\neq 0 \\]\n在\\(\\bm C\\)中必有零点\nMorera定理\n如果\\(f\\)是域\\(D\\)上的连续函数，且沿\\(D\\)内任一可求长闭曲线的积分为零，那么\\(f\\)在\\(D\\)上全纯\n调和函数 如果二元实变函数\\(\\varphi(x,y)\\)在区域\\(D\\)内具有二阶连续偏导数并且满足拉普拉斯方程\n\\[ \\frac{\\partial^2 \\varphi}{\\partial x^2}+\\frac{\\partial^2 \\varphi}{\\partial y^2}=0 \\]\n那么称\\(\\varphi(x,y)\\)为区域\\(D\\)内的调和函数。\n定理\n任何在区域\\(D\\)内全纯的函数，它的实部和虚部都是\\(D\\)内的调和函数\n在\\(D\\)内满足柯西-黎曼方程\n\\[ \\frac{\\partial u}{\\partial x}=\\frac{\\partial v}{\\partial y}, \\frac{\\partial u}{\\partial y}=-\\frac{\\partial v}{\\partial x} \\]\n的两个调和函数中，\\(v\\)称为\\(u\\)的共轭调和函数。也就是说，区域\\(D\\)内的全纯函数的虚部为实部的共轭调和函数。\n非齐次Cauchy积分公式 TODO\n一维\\(\\bar\\partial\\)问题的解 TODO\n全纯函数的Taylor展开及其应用 Weierstrass定理 设\\(z_1,z_2,\\cdots\\)是\\(\\bm C\\)中的一列复数，称\n\\[ \\sum^\\infty_{n=1}z_n = z_1+z_2+\\cdots \\]\n为一个复数项级数。这个级数称为是收敛的，如果它的部分和数列\\(S_n=\\sum^n_{k=1}z_k\\)收敛，如果\\(\\{S_n\\}\\)的极限为\\(S\\)，就说这个级数的和为\\(S\\)，记为\\(\\sum^\\infty_{n=1}z_n = S\\)\n从数列的Cauchy收敛准则马上可得级数的Cauchy收敛准则：\n级数收敛的充要条件是对任意\\(\\varepsilon\u0026gt;0\\)，存在正整数\\(N\\)，使得当\\(n\u0026gt;N\\)时，不等式\n\\[ z_{n+1}+z_{n+2}+\\cdots+z_{n+p}\u0026lt;\\varepsilon \\]\n对任意自然数\\(p\\)成立\n从收敛准则即得\\(\\sum^\\infty_{n=1}z_n\\)收敛的必要条件是\\(\\lim_{n\\to \\infty}z_n=0\\)\n如果\\(\\sum^\\infty_{n=1}|z_n|\\)收敛，就说级数\\(\\sum^\\infty_{n=1}z_n\\)绝对收敛。同样，绝对收敛的级数一定收敛，反之不一定成立。并且有\\(\\sum^\\infty_{n=1}|z_n|\\geq|\\sum^\\infty_{n=1}z_n|\\)\n另外，\\(\\sum^\\infty_{n=1}z_n\\)收敛的充要条件是其实部和虚部构成的数列分别都收敛。\n设\\(E\\)是\\(\\bm C\\)中的一个点集，\\(f_n:E\\to \\bm C\\)是定义在\\(E\\)上的一个函数列，如果对于每一个\\(z\\in E\\)，级数\n\\[ \\sum^\\infty_{n=1}f_n(z)=f_1(z)+f_2(z)+\\cdots \\]\n收敛到\\(f(z)\\)，就说其在\\(E\\)上收敛，其和函数为\\(f\\)，记为\\(\\sum^\\infty_{n=1}f_n(z)=f(z)\\)\n一致连续\n设\\(\\sum^\\infty_{n=1}f_n(z)\\)是定义在点集\\(E\\)上的级数，我们说\\(\\sum^\\infty_{n=1}f_n(z)\\)在\\(E\\)上一致收敛到\\(f(z)\\)，是指对任意\\(\\varepsilon\u0026gt;0\\)，存在正整数\\(N\\)，当\\(n\u0026gt;N\\)时，不等式\n\\[ |S_n(z)-f(z)|\u0026lt;\\varepsilon \\]\n对所有的\\(z\\in E\\)成立，这里，\\(S_n(z)=\\sum^n_{k=1}f_k(z)\\)是级数的部分和。\nCauchy收敛准则\n级数\\(\\sum^\\infty_{n=1}f_n(z)\\)在\\(E\\)上一致收敛的充要条件是对任意\\(\\varepsilon\u0026gt;0\\)，存在正整数\\(N\\)，当\\(n\u0026gt;N\\)时，不等式\n\\[ |f_{n+1}(z)+f_{n+2}(z)+\\cdots+f_{n+p}(z)|\u0026lt;\\varepsilon \\]\n对所有\\(z\\in E\\)及任意自然数\\(p\\)成立。\nWeierstrass一致收敛判别法\n设\\(f_n:E\\to \\bm C\\)是定义在\\(E\\)上的函数列，且在\\(E\\)上满足\\(|f_n(z)|\\leq a_n,n=1,2,\\cdots\\)，如果\\(\\sum^\\infty_{n=1}a_n\\)收敛，那么\\(\\sum^\\infty_{n=1}f_n(z)\\)在\\(E\\)上一致收敛。\n定理1\n设级数\\(\\sum^\\infty_{n=1}f_n(z)\\)在点集\\(E\\)上一致收敛到\\(f(z)\\)，如果每个\\(f_n(n=1,2,\\cdots)\\)都是\\(E\\)上的连续函数，那么\\(f\\)也是\\(E\\)上的连续函数。\n定理2\n设级数\\(\\sum^\\infty_{n=1}f_n(z)\\)在可求长曲线\\(\\gamma\\)上一致收敛到\\(f(z)\\)，如果每个\\(f_n(n=1,2,\\cdots)\\)都在\\(\\gamma\\)上连续，那么\n\\[ \\int_\\gamma f(z)dz=\\sum^\\infty_{n=1}\\int_\\gamma f_n(z)dz \\]\n内闭一致收敛\n如果级数\\(\\sum^\\infty_{n=1}f_n(z)\\)在域\\(D\\)的任意紧子集上一致收敛，就称\\(\\sum^\\infty_{n=1}f_n(z)\\)在\\(D\\)中内闭一致收敛。\n定义1\n如果\\(D\\)的子集\\(G\\)满足\n\\(\\bar G\\subset D\\) \\(\\bar G\\)是紧的  就说\\(G\\)相对于\\(D\\)是紧的，记为\\(G\\subset\\subset D\\)\n引理1\n设\\(D\\)是\\(\\bm C\\)中的域，\\(K\\)是\\(D\\)中的紧子集，且包含在相对于\\(D\\)是紧的开集\\(G\\)中，即\\(K\\subset G\\subset\\subset D\\)，那么对任意\\(f\\in H(D)\\)，均有\n\\[ sup\\{|f^{(k)}|:z\\in K\\}\\leq Csup{|f(z)|:z\\in G} \\]\n这里，\\(k\\)是任意自然数，\\(C\\)是与\\(k,K,G\\)有关的常数。\nWeierstrass定理\n设\\(D\\)是\\(\\bm C\\)中的域，如果\n\\(f_n\\in H(D),n=1,2,\\cdots\\) \\(\\sum^\\infty_{n=1} f_n(z)\\)在\\(D\\)中内闭一致收敛到\\(f(z)\\)  那么\n\\(f\\in H(D)\\) 对任意自然数\\(k\\)，\\(\\sum^\\infty_{n=1} f_n^{(k)}(z)\\)在\\(D\\)中内闭一致收敛到\\(f^{(k)}(z)\\)  幂级数 幂级数，是指形如\n\\[ \\sum^\\infty_{n=0}a_n(z-z_0)^n = a_0+a_1(z-z_0)+a_2(z-z_0)^2+\\cdots \\]\n的级数，其中\\(a_n,z_0\\)都是复常数。\n定义1\n如果存在常数\\(R\\)，使得当\\(|z|\u0026lt;R\\)时，级数\\(\\sum^\\infty_{n=0}a_nz^n\\)收敛；当\\(|z|\u0026gt;R\\)时，级数发散，就称\\(R\\)为该级数的收敛半径，\\(\\{z:|z|\u0026lt;R\\}\\)称为该级数的收敛圈。\n定理1\n\\(\\sum^\\infty_{n=0}a_nz^n\\)的收敛半径为\n\\[ R=1\\bigg/\\overline{\\lim_{n\\to\\infty}}\\sqrt[n]{|a_n|} \\]\n其中\\(\\overline\\lim\\)是上极限\nAbel定理\n如果\\(\\sum^\\infty_{n=0}a_nz^n\\)在\\(z=z_0\\neq 0\\)处收敛，则必在\\(\\{z:|z|\u0026lt;|z_0|\\}\\)中内闭绝对之一收敛。\n定理2\n幂级数在其收敛圆内确定一个全纯函数。\n非切向极限\n设\\(g\\)是定义在单位圆中的函数，\\(e^{i\\theta_0}\\)是单位圆周上一点，\\(S_\\alpha(e^{i\\theta_0})\\)如下图所示，其中\\(\\alpha\u0026lt;\\frac{\\pi}{2}\\)，如果当\\(z\\)在\\(S_\\alpha(e^{i\\theta_0})\\)中趋于\\(e^{i\\theta_0}\\)时，\\(g(z)\\)有极限\\(l\\)，就称\\(g\\)在\\(e^{i\\theta_0}\\)处有非切向极限\\(l\\)，记为\n\\[ \\lim_{z\\to e^{i\\theta_0},z\\in S_\\alpha(e^{i\\theta_0})}g(z)=l \\]\n 1.jpg  Abel第二定理\n设\\(f(z)=\\sum^\\infty_{n=0}a_nz^n\\)的收敛半径\\(R=1\\)，且级数在\\(z=1\\)处收敛于\\(S\\)，那么\\(f\\)在\\(z=1\\)处有非切向极限\\(S\\)，即\n\\[ \\lim_{z\\to 1,z\\in S_\\alpha(1)}f(z)=S \\]\n其他一些求收敛半径的方法\n总体上和高等数学差别不大\n比值法\n如果\\(\\lim_{n\\to \\infty}|c_{n+1}/c_n|=\\lambda\\neq 0\\)，那么半径为\\(R=1/\\lambda\\)\n根值法\n如果\\(\\lim_{n\\to \\infty}\\sqrt[n]{|c_n|}=\\mu\\neq 0\\)，那么半径为\\(R=1/\\mu\\)\n定理3\n设幂级数\\(\\sum^\\infty_{n=0}c_n(z-z_0)^n\\)的收敛半径为\\(R\\)，那么\n它的和函数\\(f(z)\\)，即  \\[ f(z) = \\sum^\\infty_{n=0}c_n(z-a)^n \\]\n是收敛圆：\\(|z-a|\u0026lt;R\\)内的解析函数\n\\(f(z)\\)在收敛圆内的导数可将其幂级数逐项求导得到，即  \\[ f\u0026#39;(z) = \\sum^\\infty_{n=0}nc_n(z-a)^{n-1} \\]\n\\(f(z)\\)在收敛圆内可以逐项积分，即  \\[ \\int_C f(z)dz = \\sum^\\infty_{n=0}c_n\\int_C(z-a)^ndz, C\\in|z-a|\u0026lt;R \\]\n或\n\\[ \\int_0^zf(z)dz = \\sum^\\infty_{n=0}\\frac{c_n}{n+1}(z-a)^{n+1} \\]\n全纯函数的Taylor展开 前面已经证明，幂级数在它的收敛圆内表示一个全纯函数，而在一个圆内全纯的函数爷一定可以展开成幂级数。\n定理1\n若\\(f\\in H(B(z_0,R))\\)，则\\(f\\)可以在\\(B(z_0,R)\\)中展开成幂级数\n\\[ f(z)=\\sum_{n=0}^\\infty\\frac{f^{(n)}(z_0)}{n!}(z-z_0)^n,z\\in B(z_0,R) \\]\n右端的级数称为\\(f\\)的Taylor级数\n定理2\n\\(f\\)在点\\(z_0\\)处全纯的充要条件是\\(f\\)在\\(z_0\\)的邻域内可以展开成幂级数\n\\[ f(z)=\\sum_{n=0}^\\infty a_n(z-z_0)^n \\]\n定义1\n设\\(f\\)在\\(z_0\\)点全纯且不恒为零，如果\n\\[ f(z_0)=0,f\u0026#39;(z_0)=0,\\cdots,f^{(m-1)}(z_0)=0,f^{(m)}(z_0)\\neq 0 \\]\n则称\\(z_0\\)是\\(f\\)的\\(m\\)阶零点。\n命题1\n\\(z_0\\)为\\(f\\)的\\(m\\)阶零点的充要条件是\\(f\\)在\\(z_0\\)的邻域内可以表示为\n\\[ f(z)=(z-z_0)^mg(z) \\]\n这里，\\(g\\)在\\(z_0\\)点全纯，且\\(g(z_0)\\neq 0\\)\n命题2\n设\\(D\\)是\\(\\bm C\\)中的域，\\(f\\in H(D)\\)，如果\\(f\\)在\\(D\\)中的小圆盘\\(B(z_0,\\varepsilon)\\)上恒等于零，那么\\(f\\)在\\(D\\)上恒等于\\(0\\)。\n命题3\n设\\(D\\)是\\(\\bm C\\)中的域，\\(f\\in H(D), f(z)\\not\\equiv 0\\)，那么\\(f\\)在\\(D\\)中的零点是孤立的。即若\\(z_0\\)为\\(f\\)的零点，则必存在\\(z_0\\)的领域\\(B(z_0,\\varepsilon)\\)，使得\\(f\\)在\\(B(z_0,\\varepsilon)\\)中除了\\(z_0\\)外不再有其他的零点。\n唯一性定理\n设\\(D\\)是\\(\\bm C\\)中的域，\\(f_1,f_2\\in H(D)\\)，如果存在\\(D\\)中的点列\\(\\{z_n\\}\\)，使得\\(f_1(z_n)=f_2(z_n),n=1,2,\\cdots\\)，且\\(\\lim_{n\\to\\infty}z_n=a\\in D\\)，那么在\\(D\\)中有\\(f_1(z)=\\equiv f_2(z)\\)\n常见的泰勒展开\n以下都是在\\(z=0\\)处的展开式\n\\[ \\frac{1}{1-z}=\\sum^\\infty_{n=0}z^n,|z|\u0026lt;1 \\]\n\\[ \\frac{1}{1+z}=\\sum^\\infty_{n=0}(-1)^nz^n,|z|\u0026lt;1 \\]\n\\[ e^z = \\sum^\\infty_{n=0} \\frac{z^n}{n!},z\\in\\bm C \\]\n\\[ cosz = \\sum^\\infty_{n=0} (-1)^n\\frac{z^{2n}}{(2n)!},z\\in\\bm C \\]\n\\[ sinz = \\sum^\\infty_{n=0} (-1)^n\\frac{z^{2n+1}}{(2n+1)!},z\\in\\bm C \\]\n\\[ \\log(1+z) = \\sum^\\infty_{n=1} (-1)^{n-1}\\frac{z^n}{n},|z|\u0026lt;1 \\]\n\\[ exp[a\\log(1+z)] = \\sum^\\infty_{n=0}\\binom{a}{n}z^n,|z|\u0026lt;1 \\]\n辐角原理和Rouche定理 TODO\n最大模原理和Schwarz引理 TODO\n全纯函数的Laurent展开及其应用 前面证明了，圆盘中的全纯函数一定可以在圆盘中展开成幂级数。但圆环中的全纯函数不一定，但是一定可以展开成洛朗级数。\n全纯函数的Laurent展开 称级数\n\\[ \\sum^\\infty_{n=-\\infty}a_n(z-z_0)^n=\\sum^\\infty_{n=0}a_n(z-z_0)^n+\\sum^\\infty_{n=1}a_{-n}(z-z_0)^{-n} \\]\n为洛朗级数。由两部分组成，第一部分是幂级数，第二部分为负幂项的级数。如果这两个级数都收敛，则整个洛朗级数收敛。\n定理1\n如果洛朗级数\n\\[ \\sum^\\infty_{n=-\\infty}a_n(z-z_0)^n=\\sum^\\infty_{n=0}a_n(z-z_0)^n+\\sum^\\infty_{n=1}a_{-n}(z-z_0)^{-n} \\]\n的收敛域为圆环\\(D=\\{z:r\u0026lt;|z-z_0|\u0026lt;R\\}\\)，那么它在\\(D\\)中绝对收敛且内闭一致收敛，它的和函数在\\(D\\)中全纯。\n上述级数的幂级数部分称为全纯部分，负幂项级数部分称为主要部分。\n该定理的逆定理也成立。\n设\\(D=\\{z:r\u0026lt;|z-z_0|\u0026lt;R\\}\\)，如果\\(f\\in H(D)\\)，那么\\(f\\)在\\(D\\)上可以展开为洛朗级数\n\\[ f(z) = \\sum^\\infty_{n=-\\infty}a_n(z-z_0)^n \\]\n其中\n\\[ a_n = \\frac{1}{2\\pi i}\\int_{\\gamma_\\rho}\\frac{f(\\zeta)}{(\\zeta-z_0)^{n+1}}d\\zeta \\]\n\\[ \\gamma_\\rho = \\{\\zeta:|\\zeta-z_0|=\\rho\\}(r\u0026lt;\\rho\u0026lt;R) \\]\n并且这个展开式是唯一的。\n孤立奇点 如果\\(f\\)在无心圆盘\\(\\{z:0\u0026lt;|z-z_0|\u0026lt;R\\}\\)中全纯（而在圆心不全纯），就称\\(z_0\\)是\\(f\\)的孤立奇点。在奇点附近有三种情况\n\\(\\lim_{z\\to z_0}f(z)=a,a\\)是一有限数，这时称\\(z_0\\)是\\(f\\)的可去奇点 \\(\\lim_{z\\to z_0}f(z)=\\infty\\)，这时称\\(z_0\\)是\\(f\\)的极点 \\(\\lim_{z\\to z_0}f(z)\\)不存在，这时称\\(z_0\\)是\\(f\\)的本性奇点  定理1\n\\(z_0\\)是\\(f\\)的可去奇点的充要条件是\\(f\\)在\\(z_0\\)附近有界。\n命题1\n\\(z_0\\)是\\(f\\)的极点的充要条件是\\(z_0\\)为\\(1/f\\)的零点。\n定义1\n如果\\(z_0\\)是\\(1/f(z)\\)的\\(m\\)阶零点，就称\\(z_0\\)是\\(f\\)的\\(m\\)阶极点。\n定理2\n\\(z_0\\)是\\(f\\)的\\(m\\)阶极点的充要条件是\\(f\\)在\\(z_0\\)附近的洛朗级数为\n\\[ f(z) = \\frac{a_{-m}}{(z-z_0)^m}+\\cdots+\\frac{a_{-1}}{z-z_0}+a_0+a_1(z-z_0)+\\cdots \\]\n其中\\(a_{-m}\\neq 0\\)\n定理3\n\\(f\\)在可去奇点处的特征是洛朗级数没有主要部分，只有全纯部分\n\\(f\\)在奇点处的特征是洛朗级数的主要部分只有有限项。\n定理4\n设\\(z_0\\)是\\(f\\)的本性奇点，那么对任意\\(A\\in\\bm C_\\infty\\)，必存在趋于\\(z_0\\)的点列\\(\\{z_n\\}\\)，使得\\(\\lim_{n\\to\\infty}f(z_n)=A\\)\n定理5\n全纯函数在本性奇点的邻域内无穷多次地取到每个有穷复值，最多只有一个例外\n定义2\n我们讨论无穷远点。如果\\(f\\)在无穷远点的邻域（不包括无穷远点）\\(\\{z:0\\leq R\u0026lt;|z|\u0026lt;\\infty\\}\\)中全纯，\\(\\infty\\)就是\\(f\\)的孤立奇点。\n记\n\\[ g(\\zeta)=f(\\frac{1}{\\zeta}) \\]\n如果\\(\\zeta=0\\)是\\(g\\)的可去奇点、\\(m\\)阶极点或本性奇点，那么我们相应地称\\(z=\\infty\\)是\\(f\\)的可去奇点、\\(m\\)阶极点或本性奇点。\n整函数与亚纯函数 如果\\(f\\)在整个复平面\\(\\bm C\\)上全纯，就称\\(f\\)为整函数\n定理1\n在无穷远处全纯的整函数一定是常数。\n定理2\n如果无穷远点是整函数\\(f\\)的一个\\(m\\)阶极点，那么\\(f\\)是一个\\(m\\)次多项式。\n如果\\(f\\)在整个复平面\\(\\bm C\\)上除去极点外没有其他的奇点，就称\\(f\\)是一个亚纯函数。整函数显然是亚纯函数。\n此外有理函数\n\\[ f(z) = \\frac{P_n(z)}{Q_m(z)} \\]\n也是亚纯函数，这里，\\(P_n(z),Q_m(z)\\)是两个既约（分式最简）的多项式\n定理3\n若\\(z=\\infty\\)是亚纯函数\\(f\\)的可去奇点或极点，则\\(f\\)一定是有理函数。\n反过来也成立。\n残数定理 定义1\n设\\(a\\)是\\(f\\)的一个孤立奇点，\\(f\\)在\\(a\\)点的邻域\\(B(a,r)\\)中的洛朗级数为\\(f(z)=\\sum^\\infty_{n=-\\infty}c_n(z-a)^n\\)，称\\(c_{-1}\\)为\\(f\\)在\\(a\\)点的残数，记为\n\\[ Res(f,a) = c_{-1} \\]\n或\n\\[ \\underset{z=a}{Res}f = c_{-1} \\]\n根据洛朗级数的计算方法，我们知道\n\\[ c_{-1} = \\frac{1}{2\\pi i}\\int_\\gamma f(\\zeta)d\\zeta \\]\n结合上上式就有\n\\[ \\int_\\gamma f(z)dz = 2\\pi iRes(f,a) \\]\n这里，\\(\\gamma=\\{z:|z-a|=\\rho\\},0\u0026lt;\\rho\u0026lt;r\\)\n若\\(z=\\infty\\)是\\(f\\)的孤立奇点，即\\(f\\)在\\(R\u0026lt;|z|\u0026lt;\\infty\\)中全纯，我们定义\\(f\\)在\\(z=\\infty\\)处的残数为\n\\[ Res(f,\\infty) = -\\frac{1}{2\\pi i}\\int_\\gamma f(z)dz \\]\n这里，\\(\\gamma=\\{z:|z|=\\rho\\},R\u0026lt;\\rho\u0026lt;\\infty\\)\n命题1\n若\\(a\\)是\\(f\\)的\\(m\\)阶极点，则\n\\[ Res(f,a) = \\frac{1}{(m-1)!}\\lim_{z\\to a}\\frac{d^{m-1}}{dz^{m-1}}\\{(z-a)^mf(z)\\} \\]\n命题2\n若\\(a\\)是\\(f\\)的\\(1\\)阶极点，则\n\\[ Res(f,a) = \\lim_{z\\to a}(z-a)f(z) \\]\n命题3\n设\\(f=\\frac{g}{h}\\)，\\(g,h\\)都在\\(a\\)出全纯，且\\(g(a)\\neq 0\\)，\\(h(a)=0\\)，\\(h\u0026#39;(a)\\neq 0\\)，那么\n\\[ Res(f,a) = \\frac{g(a)}{h\u0026#39;(a)} \\]\n残数定理\n设\\(D\\)是复平面上的一个有界区域，它的边界\\(\\gamma\\)由一条或若干条简单闭曲线组成，如果\\(f\\)在\\(D\\)中除去孤立奇点\\(z_1,\\cdots,z_n\\)外是全纯的，在闭域\\(\\overline{D}\\)上除去\\(z_1,\\cdots,z_n\\)外是连续的，那么\n\\[ \\int_\\gamma f(z)dz = 2\\pi i\\sum^n_{k=1} Res(f,z_k) \\]\n定理1\n若\\(f\\)在\\(\\bm C\\)中除去\\(z_1,\\cdots,z_n\\)外是全纯的，则\\(f\\)在\\(z_1,\\cdots,z_n\\)及\\(z=\\infty\\)处的残数之和为零。\n","date":"2022-09-01T13:44:54+08:00","permalink":"https://kegalas.top/p/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/","title":"复变函数整理"},{"content":" 基本概念 随机试验E 针对随机现象的观察、记录、试验（广义）。\n特点：\n可以在相同的条件下重复进行 每次试验的可能结果不止一个，并且能事先明确试验的所有可能结果 但一次试验前不能确定哪个结果会出现  样本空间\\(\\Omega\\) 随机试验\\(E\\)的所有结果构成的集合为\\(E\\)的样本空间\\(\\Omega\\)，记为\\(\\Omega\\{\\omega\\}\\)，每个结果\\(\\omega\\)是\\(\\Omega\\)中的一个元素，称为样本点。\n频率 在相同的条件下，进行了\\(n\\)次试验，其中事件\\(A\\)发生的次数\\(n_A\\)称为事件\\(A\\)发生的频数，比值\\(n_A/n\\)称为事件\\(A\\)发生的频率，记为\\(f_n(A)\\)\n概率 定义1: 事件A发生频率的稳定值\\(p\\)称为它的概率\\(P(A)\\)，即\\(P(A)=p\\)\n定义2: 随机试验\\(E\\)，样本空间\\(\\Omega\\)，对于\\(E\\)的每一事件\\(A\\)赋予一个实数，记为\\(P(A)\\)，如果集合函数满足以下条件，P(A)称为事件A的概率 1. 非负性: 对于每一个事件\\(A\\)，有\\(P(A)\\geq0\\) 2. 规范性: 对于必然事件\\(\\Omega\\)，有\\(P(\\Omega)=1\\) 3. 可列可加性: 设\\(A_1,A_2,\\cdots\\)是两两不相容的事件，即对于\\(A_iA_j=\\empty,i\\neq j(i,j=1,2,\\cdots)\\)\n\\[ P(\\bigcup^\\infty_{i=1}A_i)=\\sum^\\infty_{i=1}P(A_i) \\]\n性质\n\\(P(\\empty)=0\\) 可列可加性（见上） 若\\(A\\subset B\\)，则\\(P(B-A)=P(B)-P(A)\\) 任意事件\\(A\\)，\\(P(A)\\leq 1\\) 任意事件\\(A\\)，\\(P(\\overline{A})=1-P(A)\\) 加法公式，对任意事件\\(A,B\\)，\\(P(A\\cup B)=P(A)+P(B)-P(AB)\\)，扩展情况同容斥原理。 极限性：设\\(A_1\\subset A_2\\subset\\cdots\\)，则\\(\\lim_{n\\to\\infty}P(A_n)=P(\\bigcup^{\\infty}_{i=1}A_i)\\)；设\\(A_1\\supset A_2\\supset\\cdots\\)，则\\(\\lim_{n\\to\\infty}P(A_n)=P(\\bigcap^{\\infty}_{i=1}A_i)\\)  注意，没有以下性质\n\\(P(A)=0\\)不能推出\\(A=\\empty\\) \\(P(A)=1\\)不能推出\\(A=\\Omega\\) \\(P(A)=P(B)\\)不能推出\\(A=B\\)  古典概率 定义 设一个试验有\\(N\\)个等可能的结果，而事件\\(E\\)恰包含其中的\\(M\\)个结果，则事件\\(E\\)的概率，记为\\(P(E)\\)，定义为\n\\[ P(E)=\\frac{M}{N} \\]\n一些有用的公式 n个相异物件取\\(r(1\\leq r\\leq n)\\)个的不同排列总数  \\[ P^n_r=n(n-1)(n-2)\\cdots(n-r+1) \\]\nn个相异物体取\\(r(1\\leq r\\leq n)\\)个的不同组合总数  \\[ C^n_r = \\frac{P^n_r}{r!}=\\frac{n!}{r!(n-r)!}=\\frac{n(n-1)(n-2)\\cdots(n-r+1)}{r!}=\\binom{n}{r} \\]\n另外，只要\\(r\\)为非负整数，不论\\(n\\)为任何实数，都有意义。例如\n\\[ \\binom{-1}{r} = \\frac{(-1)(-2)\\cdots(-r)}{r!}=(-1)^r \\]\n二项式系数  \\[ (a+b)^n=\\sum_{i=0}^n\\binom{n}{i}a^ib^{n-i} \\]\n令\\(a=b=1\\)\n\\[ \\binom{n}{0}+\\binom{n}{1}+\\cdots+\\binom{n}{n}=2^n \\]\n令\\(a=-1,b=1\\)\n\\[ \\binom{n}{0}-\\binom{n}{1}+\\binom{n}{2}+\\cdots+(-1)^n\\binom{n}{n}=0 \\]\n还有\n\\[ \\binom{m+n}{k}=\\sum_{i=0}^k\\binom{m}{i}\\binom{n}{k-i} \\]\n\\(n\\)个相异物件分成\\(k\\)堆，各堆物件数分别为\\(r_1,\\cdots,r_k\\)的分法是  \\[ \\frac{n!}{r_1!\\cdots r_n!} \\]\n以上是有序堆的情况，无序堆时\n\\[ \\frac{n!}{P^k_k(r_1!\\cdots r_n!)} \\]\n几何概率 古典概率的样本空间为有限集，如果样本空间是无限集，就应该使用几何概率。\n直线上的几何概率：设线段\\(l\\)是\\(L\\)的一部分，向\\(L\\)上随机投一点，投中\\(l\\)的概率为  \\[ P=\\frac{l的长度}{L的长度} \\]\n平面、体积上的概率：类似于直线上，通过总体的面积或体积，以及事件所代表的面积或体积来计算。  事件的运算 蕴含、包含和相等 在同一试验下的两个事件\\(A,B\\)，若\\(A\\)发生时\\(B\\)必发生，则称\\(A\\)蕴含\\(B\\)，或者说\\(B\\)包含\\(A\\)，记为\\(A\\subset B\\)，若它们互相蕴含，则称为相等，记为\\(A=B\\)\n互斥和对立 若\\(A,B\\)不能在同一次试验中都发生（但可以都不发生），则称他们是互斥的（不相容的）。\n对立事件是互斥事件的一种特殊情况。若\\(A\\)为一事件，则事件\n\\[ B=\\{A不发生\\} \\]\n称为\\(A\\)的对立事件，记为\\(\\bar{A}\\)\n事件的和 \\[ C=\\{A发生，或B发生\\}=\\{A，B至少发生一个\\}=A+B=A\\cup B \\]\n概率的加法定理 若干个互斥事件之和的概率，等于各事件的概率之和\n\\[ P(A_1+A_2+\\cdots)=P(A_1)+P(A_2)+\\cdots \\]\n若不是两两互斥的事件，则要考虑用容斥原理来计算。\n上式能推出\n\\[ P(\\bar A)=1-P(A) \\]\n事件的积 \\[ C=\\{A,B都发生\\}=AB=A\\cap B \\]\n事件的差 \\[ C=\\{A发生，B不发生\\}=A-B \\]\n显然有\n\\[ A-B = A\\bar B \\]\n两个重要公式 \\[ \\overline{A_1A_2\\cdots A_n}=\\sum_{i=1}^n\\bar{A_i} \\]\n\\[ \\overline{A_1+A_2+\\cdots+A_n}=\\prod_{i=1}^n\\bar{A_i} \\]\n条件概率 设有两个事件\\(A,B\\)，而\\(P(B)\\neq0\\)。则“在给定\\(B\\)发生的条件下\\(A\\)的条件概率”，记为\\(P(A|B)\\)，定义为\n\\[ P(A|B)=P(AB)/P(B) \\]\n但并不一定要用这个公式去计算，有时直接用加入了条件的情况去算会更为方便。\n事件的独立性、概率乘法定理 若\\(P(A)=P(A|B)\\)，则\\(B\\)的发生与否对\\(A\\)发生的可能性毫无影响。这时，在概率论上称\\(A,B\\)两事件独立。\n同时就有\n\\[ P(AB) = P(A)P(B) \\]\n若两事件\\(A,B\\)满足上式，则称\\(A,B\\)独立。反过来说独立的两个事件就有上式，也称为概率的乘法定理。\n将其推广，设\\(A_1,A_2,\\cdots\\)为有限或无限个事件。如果从其中任意取出有限个\\(A_{i_1},A_{i_2},\\cdots,A_{i_m}\\)，都有\n\\[ P(A_{i_1}A_{i_2}\\cdots A_{i_m})=P(A_{i_1})P(A_{i_2})\\cdots P(A_{i_m}) \\]\n则称\\(A_1,A_2,\\cdots\\)互相独立。互相独立的几个事件则具有以上的乘积性质。\n等价的来说也有\n\\[ P(A_{i_1}|A_{i_2}\\cdots A_{i_m})=P(A_{i_1}) \\]\n可以推出：独立事件的任一部分也独立。\n还有：若一列事件相互独立，则将其中任一部分改为对立事件时，所有事件仍然相互独立。\n全概率公式 设\\(B_1,B_2,\\cdots\\)为有限或无限个事件，它们两两互斥且在每次试验中至少发生一个。即\n\\[ B_iB_j=\\empty(i\\neq j) \\]\n\\[ B_1+B_2+\\cdots = \\Omega（必然事件） \\]\n有时，这样的一组事件称为完备事件群。\n现有任一事件\\(A\\)，有\\(A=A\\Omega=AB_1+AB_2+\\cdots\\)。而\\(B_1,B_2,\\cdots\\)两两互斥，则\\(AB_1,AB_2,\\cdots\\)也两两互斥，固有\n\\[ P(A) = P(AB_1)+P(AB_2)+\\cdots \\]\n再由条件概率\\(P(AB_i)=P(B_i)P(A|B_i)\\)，得\n\\[ P(A) = P(B_1)P(A|B_1) + P(B_2)P(A|B_2) + \\cdots \\]\n上式称为全概率公式。\n贝叶斯公式 由全概率公式，有\n\\[ P(B_i|A)=P(AB_i)/P(A)\\\\=P(B_i)P(A|B_i)/\\sum_jP(B_j)P(A|B_j) \\]\n随机变量及其分布 随机变量的概念 随机变量就是其值随机会而定的变量。例如从一大批产品中随机抽出100个，其中所含的废品数为\\(X\\)。这个\\(X\\)就是一个随机变量。\n随机变量区分为两大类\n离散型随机变量。其特征是只能取有限个值，或者虽然能取无限个，但可以一个一个地排列出来（类似于可数无限）。 连续性随机变量。不仅是无穷多的，而且类似于不可数无限，充满一个区间。  离散型随机变量 定义1\n设\\(X\\)为离散型随机变量，其全部可能值为\\(\\{a_1,a_2,\\cdots\\}\\)，则\n\\[ p_i=P(X=a_i)\\quad(i=1,2,\\cdots) \\]\n称为\\(X\\)的概率函数\n显然有\n\\[ p_i\\geq 0,\\quad p_1+p_2+\\cdots = 1 \\]\n定义2\n设\\(X\\)为一随机变量，则函数\n\\[ P(X\\leq x) = F(x)\\quad(-\\infty\u0026lt;x\u0026lt;\\infty) \\]\n称为\\(X\\)的分布函数。这里不限制\\(X\\)是离散型的。\n\\[ F(x) = P(X\\leq x) = \\sum_{\\{i|a_i\\leq x\\}}p_i \\]\n分布函数具有如下性质\n\\(F(x)\\)是单调非降的：\\(x_1\\leq x_2\\)时，有\\(F(x_1)\\leq F(x_2)\\) \\(x\\to \\infty\\)时，\\(F(x)\\to 1\\)。\\(x\\to -\\infty\\)时，\\(F(x)\\to 0\\)  连续型随机变量 与离散型的有限或可数无限不同，这是一种充满整个区间的随机变量，或者说不可数无限。\n刻画连续型随机变量可以用之前提到的概率分布函数，但是更常用概率密度函数。\n概率密度函数 设连续型随机变量\\(X\\)有概率分布函数\\(F(x)\\)，则\\(F(x)\\)的导数\\(f(x)=F\u0026#39;(x)\\)称为\\(X\\)的概率密度函数。\n具有如下性质\n\\(f(x)\\geq 0\\) \\(\\int^\\infty_{-\\infty}f(x)dx=1\\) 对于任何常数\\(a\u0026lt;b\\)，有  \\[ P(a\\leq X\\leq b)=F(b)-F(a) = \\int^b_af(x)dx \\]\n多维随机变量（随机向量） 离散型随机向量的分布 一般的，设\\(X=(X_1,X_2,\\cdots,X_n)\\)为一个\\(n\\)维向量，其每个分量，即\\(X_1,\\cdots,X_n\\)都是一维随机变量，则称\\(X\\)是一个\\(n\\)维随机向量或\\(n\\)维随机变量。\n如果一个随机向量\\(X\\)，其每一个分量\\(X_i\\)都是一维离散型随机变量，则称\\(X\\)是离散型的。\n以\\(\\{a_{i1},a_{i2},\\cdots\\}\\)记\\(X_i\\)的全部可能值，则事件\\(\\{X_1=a_{1j_1}, X_2=a_{2j_2},\\cdots,X_n=a_{nj_n}\\}\\)的概率\n\\[ p(j_1,j_2,\\cdots,j_n)=P(X_1=a_{1j_1}, X_2=a_{2j_2},\\cdots,X_n=a_{nj_n}) \\]\n称为随机向量\\(X\\)的概率函数或概率分布，其应该满足\n\\[ p(j_1,j_2,\\cdots,j_n)\\geq 0,\\sum_{j_n}\\cdots\\sum_{j_2}\\sum_{j_1}p(j_1,j_2,\\cdots,j_n) = 1 \\]\n连续型随机向量的分布 设\\(X\\)是一个\\(n\\)维随机向量，其取值可视为\\(n\\)维欧式空间\\(\\mathbb{R} ^n\\)中的一个点。如果\\(X\\)的全部取值能充满\\(\\mathbb{R} ^n\\)中某一区域，则称它是连续型的。\n若\\(f(x_1,\\cdots,x_n)\\)是定义在\\(\\mathbb{R} ^n\\)上的非负函数，使对\\(\\mathbb{R} ^n\\)中的任何集合\\(A\\)，有\n\\[ P(X\\in A) = \\int\\cdots\\int f(x_1,\\cdots,x_n)dx_1\\cdots dx_n \\]\n则称\\(f\\)是\\(X\\)的概率密度函数\n如果把\\(A\\)取成\\(\\mathbb{R} ^n\\)，则有\n\\[ \\int^\\infty_{-\\infty}\\cdots\\int^\\infty_{-\\infty} f(x_1,\\cdots,x_n)dx_1\\cdots dx_n = 1 \\]\n对于二维情况\n\\[ F(x,y) = \\int^y_{-\\infty}\\int^x_{-\\infty}f(u,v)dudv \\]\n\\[ \\frac{\\partial^2 F(x,y)}{\\partial x\\partial y}=f(x,y) \\]\n在\\(\\Delta x,\\Delta y\\)很小时，有\\(P(x\u0026lt;X\u0026lt;x+\\Delta x,y\u0026lt;Y\u0026lt;y+\\Delta y)\\approx f(x,y)\\Delta x\\Delta y\\)\n若\\(G\\)为\\(xOy\\)内的任意区域，点\\((x,y)\\)落在\\(G\\)内的概率为\n\\[ P\\{(X,Y)\\in G\\}=\\iint_G f(x,y)dxdy \\]\n与一维的情况一样，也可以用概率分布函数去描述多维随机向量的概率分布，其定义为\n\\[ F(x_1,x_2,\\cdots,x_n)=P(X_1\\leq x_1, X_2\\leq x_2,\\cdots,X_n\\leq x_n) \\]\n其基本性质，以二维为例，有\n\\(F(x,y)\\)是\\(x,y\\)的不减函数 \\(0\\leq F(x,y)\\leq 1,F(-\\infty,-\\infty) = 0,F(\\infty,\\infty)=1\\)  对于任意\\(x\\)，\\(F(x,-\\infty)=0\\)，对于任意\\(y\\)，\\(F(-\\infty,y)=0\\)\n\\(F(x,y)\\)关于\\(x,y\\)均为右连续，\\(F(x+0,y) = F(x,y)\\)，\\(F(x,y+0) = F(x,y)\\) 若\\(x_1\u0026lt;x_2,y_1\u0026lt;y_2\\)，则\\(F(x_2,y_2)+F(x_1,y_1)-F(x_2,y_1)-F(x_1,y_2)\\geq 0\\)  另外，有\n\\[ f(x,y) = \\frac{\\partial^2F(x,y)}{\\partial x\\partial y} \\]\n边缘分布 设\\(X=(X_1,\\cdots,X_n)\\)为一个\\(n\\)维随机向量。\\(X\\)有一定的分布\\(F\\)，这是一个\\(n\\)维分布，因为\\(X\\)的每个分量\\(X_i\\)都是一维随机变量，故它们都有各自的分布\\(F_i\\)，这些都是一维分布，称为随机向量\\(X\\)或其分布\\(F\\)的边缘分布。边缘分布完全由原分布\\(F\\)确定。\n例如，在离散型的情况下，边缘分布\\(P(X_1=a_{1k})\\)就等于\n\\[ P(X_1=a_{1k})=\\sum_{j_2,\\cdots,j_n}p(k,j_2,\\cdots,j_n) \\]\n对于连续型的情况，例如求\\(f_1(x_1)\\)\n\\[ f_1(x_1) = \\int^\\infty_{-\\infty}\\cdots \\int^\\infty_{-\\infty}f(x_1,x_2,\\cdots,x_n)dx_2\\cdots dx_n \\]\n当然，如果题目有要求变量的范围，则积分上下限要改成相应的值。\n直观上的理解，就是将其他变量的所有情况的概率全部加起来。\n联合分布 边缘分布指的是随机向量中的一个分量的分布。\n而相对应的联合分布，就是强调\\((X_1,\\cdots,X_n)\\)的分布是把\\(X_1,\\cdots,X_n\\)作为一个有联系的整体来考虑的。\n当然有些时候边缘分布也可以指众多分量中几个分量的分布。\n条件概率分布 概念同前面提到的条件概率。\n离散型 同之前计算条件概率相同，只不过通常此时要用到边缘分布等概念。\n例如设\n\\[ p_{ij}=P(X_1=a_i,X_2=b_j) \\]\n则\n\\[ P(X_1=a_i|X_2=b_j) = P(X_1=a_i,X_2=b_j)/P(X_2=b_j) = p_{ij}/P(X_2=b_j) \\]\n连续型 以二维情况为例\n\\[ P(X_1\\leq x_1|a\\leq X_2\\leq b)=P(X_1\\leq x_1,a\\leq X_2\\leq b)/P(a\\leq X_2\\leq b) \\]\n写成积分形式\n\\[ =\\int^{x_1}_{-\\infty}dt_1\\int^b_af(t_1,t_2)dt_2\\bigg/\\int^b_af_2(t_2)dt_2 \\]\n\\(a=b\\)的情况下，可以通过极限求出\n\\[ f_1(x_1|x_2) = f(x_1,x_2)/f_2(x_2) \\]\n可改写为\n\\[ f(x_1,x_2) = f_1(x_1|x_2)f_2(x_2) \\]\n可以推广到\n\\[ f(x_1,\\cdots,x_n) = g(x_1,\\cdots,x_k)h(x_{k+1},\\cdots,x_n|x_1,\\cdots,x_k) \\]\n随机变量的独立性 定义1\n设\\(n\\)维随机向量\\((X_1,\\cdots,X_n)\\)的联合密度函数为\\(f(x_1,x_2,\\cdots,x_n)\\)，而\\(X_i\\)的边缘密度函数为\\(f_i(x_i)\\)，如果\n\\[ f(x_1,\\cdots,x_n) = f_1(x_1)\\cdots f_n(x_n) \\]\n则称随机变量\\(X_1,\\cdots,X_n\\)相互独立。\n定理1\n如果连续变量\\(X_1,\\cdots,X_n\\)相互独立，则对任何\\(a_i\u0026lt;b_i\\)，则由下式定义的\\(n\\)个事件也独立\n\\[ A_1=\\{a_1\\leq X_1\\leq b_1\\},\\cdots,A_n=\\{a_n\\leq X_n\\leq b_n\\} \\]\n反之，若对任何\\(a_i\u0026lt;b_i\\)，事件\\(A_1,\\cdots,A_n\\)独立，则变量\\(X_1,\\cdots,X_n\\)独立。\n定理2\n若随机向量\\((X_1,\\cdots,X_n)\\)的概率密度函数\\(f(x_1,x_2,\\cdots,x_n)\\)可表示为\\(n\\)个函数\\(g_1,\\cdots,g_n\\)之积，其中\\(g_i\\)只依赖于\\(x_i\\)，即\n\\[ f(x_1,x_2,\\cdots,x_n) = g_1(x_1)\\cdots g_n(x_n) \\]\n则\\(X_1,\\cdots,X_n\\)相互独立，且\\(X_i\\)的边缘密度函数\\(f_i(x_i)\\)与\\(g_i(x_i)\\)只相差一个常数因子。\n定理3\n若\\(X_1,\\cdots,X_n\\)相互独立，而\n\\[ Y_1=g_1(X_1,\\cdots,X_m), Y_2 = g_2(X_{m+1},\\cdots,X_n) \\]\n则\\(Y_1,Y_2\\)独立。\n定义2\n设\\(X_1,\\cdots,X_n\\)是离散型随机变量，弱队任何常数\\(a_1,\\cdots,a_n\\)都有\n\\[ P(X_1=a_1,\\cdots,X_n=a_n) = P(X_1=a_1)\\cdots P(X_n=a_n) \\]\n则称\\(X_1,\\cdots, X_n\\)相互独立。\n随机变量的函数的概率分布 在理论和应用上，经常碰到这种情况：已知某个或某些随机变量\\(X_1,\\cdots,X_n\\)的分布，现另有一些随机变量\\(Y_1,\\cdots,Y_m\\)，它们都是\\(X_1,\\cdots,X_n\\)的函数：\n\\[ Y_i=g_i(X_1,\\cdots,X_n) \\]\n要求\\((Y_1,\\cdots,Y_m)\\)的概率分布。\n离散型分布的情况 离散分布的情况比较简单，只需要列举\\(Y_i=y_i\\)时的所有\\(X\\)的可能就可以了。\n连续型分布的情况的一般讨论 先考虑一个变量的情况，设\\(X\\)有密度函数\\(f(x)\\). 设\\(Y=g(x)\\)。\\(g\\)严格上升或下降。所以\\(g\u0026#39;\\)存在，反函数\\(X=g^{-1}(Y)\\)存在，且\\((g^{-1})\u0026#39;\\)也存在。\n则\\(Y\\)的密度函数为\n\\[ f_Y(y)=f(g^{-1}(y))|(g^{-1}(y))\u0026#39;| \\]\n现在考虑多个变量，以两个变量为例，设\\((X_1,X_2)\\)的密度函数为\\(f(x_1,x_2)\\)，以及\n\\[ Y_1=g_1(X_1,X_2),\\quad Y_2=g_2(X_1,X_2) \\]\n要求\\(f_Y(y_1,y_2)\\)，假定上式是一一对应变换，则有逆变换\n\\[ X_1=g^{-1}_1(Y_1,Y_2),\\quad X_2=g^{-1}_2(Y_1,Y_2) \\]\n假设\\(g_1,g_2\\)都有一阶连续偏导数，则其反函数也有一阶连续偏导数，且雅克比行列式\n\\[ J(y_1,y_2)= \\begin{vmatrix} \\partial g^{-1}_1/\\partial y_1 \u0026amp; \\partial g^{-1}_1/\\partial y_2\\\\ \\partial g^{-1}_2/\\partial y_1 \u0026amp; \\partial g^{-1}_2/\\partial y_2 \\end{vmatrix} \\]\n不为\\(0\\). 有\n\\[ f_Y(y_1,y_2) = f(g^{-1}_1(y_1,y_2),g^{-1}_2(y_1,y_2))|J(y_1,y_2)| \\]\n随机变量和的密度函数 设\\((X_1,X_2)\\)的联合密度函数为\\(f(x_1,x_2)\\)，要求\n\\[ Y=X_1+X_2 \\]\n的密度函数。\n有\n\\[ f_Y(y) = \\int^\\infty_{-\\infty}f(x_1,y-x_1)dx_1=\\int^\\infty_{-\\infty}f(x,y-x)dx \\]\n或者作变量代换也有\n\\[ f_Y(y) = \\int^\\infty_{-\\infty}f(y-x,x)dx \\]\n如果\\(X_1,X_2\\)独立，则\\(f(x_1,x_2)=f_1(x_1)f_2(x_2)\\)，有\n\\[ f_Y(y) = \\int^\\infty_{-\\infty}f_1(x)f_2(y-x)dx = \\int^\\infty_{-\\infty}f_1(y-x)f_2(x)dx \\]\n随机变量商的密度函数 设\\((X_1,X_2)\\)有密度函数\\(f(x_1,x_2)\\)，\\(Y=X_2/X_1\\)，要求\\(Y\\)的密度函数\n\\[ f_Y(y) = \\int^\\infty_0 |x_1|f(x_1,x_1y)dx_1 \\]\n若\\(X_1,X_2\\)独立，则\n\\[ f_Y(y) = \\int^\\infty_0 |x_1|f_1(x_1)f_2(x_1y)dx_1 \\]\n随机变量积的密度函数 设\\((X_1,X_2)\\)有密度函数\\(f(x_1,x_2)\\)，\\(Y=X_1X_2\\)，要求\\(Y\\)的密度函数\n\\[ f_Y(y) = \\int^\\infty_0 \\frac{1}{|x_1|}f(x_1,\\frac{y}{x_1})dx_1 \\]\n若\\(X_1,X_2\\)独立，则\n\\[ f_Y(y) = \\int^\\infty_0 \\frac{1}{|x_1|}f_1(x_1)f_2(\\frac{y}{x_1})dx_1 \\]\n常见的分布 0-1分布 设某个事件\\(A\\)在一次试验中发生的概率为\\(p\\)，重复试验\\(1\\)次，以\\(X\\)记\\(A\\)在\\(1\\)次试验中发生的次数，则\n\\[ P(X=i)=p^i(1-p)^{1-i}\\quad (i=0,1) \\]\n数学期望 \\[p\\]\n方差 \\[p(1-p)\\]\n二项分布 设某个事件\\(A\\)在一次试验中发生的概率为\\(p\\)，重复试验\\(n\\)次，以\\(X\\)记\\(A\\)在\\(n\\)次试验中发生的次数，则\n\\[ p_i=b(i;n,p)=\\binom{n}{i}p^i(1-p)^{n-i}\\quad (n=0,1,\\cdots,n) \\]\n服从有两个条件\n各次试验的条件是稳定的 各次试验的独立性  如果抽检后放回，则每次抽出废品的概率是相等的。如果抽检后不放回，则废品率发生了变化，试验条件不稳定，不符合二项分布。但是如果总数远大于抽出的数量，则不放回也几乎不影响，可以近似地作为二项分布。\n通常也会记作，\\(B(n,p)\\)\n数学期望 \\[np\\]\n方差 \\[np(1-p)\\]\n泊松分布 若随机变量\\(X\\)的可能取值为\\(0,1,2,\\cdots\\)，且概率分布为\n\\[ P(X=i)=e^{-\\lambda}\\lambda^i/i! \\]\n则称\\(X\\)服从泊松分布。记为\\(X\\sim P(\\lambda)\\)。\\(\\lambda\u0026gt;0\\)是某一常数。式子右边对\\(i=0,1,\\cdots\\)求和的结果为\\(1\\)。可以从\\(e^\\lambda=\\sum^\\infty_{i=0}\\lambda^i/i!\\)得出。\n这个分布多出现在当\\(X\\)表示在一定时间或空间内出现的事件个数的场合。比如一定时间内某交通路口所发生的事故个数。\n泊松分布可以看做二项分布的极限。若\\(X\\sim B(n,p)\\)中\\(n\\)很大，\\(p\\)很小，而\\(np=\\lambda\\)不太大时，\\(X\\)的分布接近与泊松分布\\(P(\\lambda)\\)。推导如下：\n\\[ P(X=i)=\\binom{n}{i}\\left(\\frac{\\lambda}{n}\\right)^i\\left(1-\\frac{\\lambda}{n}\\right)^{n-i} \\]\n当\\(n\\to\\infty\\)时\n\\[ \\binom{n}{i}/n^i\\to 1/i!,\\quad \\left(1-\\frac{\\lambda}{n}\\right)^{n-i}\\to e^{-\\lambda} \\]\n则有\n\\[ P(X=i)=e^{-\\lambda}\\lambda^i/i! \\]\n显然通常我们不会遇到\\(n\\)无限的情况，只会遇到\\(n\\)较大的情况，所以只能说接近泊松分布。\n数学期望 \\[\\lambda\\]\n我们可以证明\\(X\\)服从泊松分布时\n\\[ E(X) = \\sum^\\infty_{i=0}i\\frac{\\lambda^i}{i!}e^{-\\lambda}=\\lambda \\]\n方差 \\[\\lambda\\]\n超几何分布 以\\(X\\)记从含\\(M\\)个废品的\\(N\\)个产品中随机抽出\\(n\\)个里面所含有的废品数，\\(X\\)的分布为\n\\[ P(X=m)=\\binom{M}{n}\\binom{N-M}{n-m}\\bigg/\\binom{N}{n} \\]\n这是一种抽检不放回的试验，如果\\(N\\)特别大，\\(n\\)不够大时，放回与不放回差别不大。可以当作二项分布来看。或者说，若\\(X\\)服从超几何分布，则当\\(n\\)固定时，\\(M/N=p\\)固定；\\(N\\to \\infty\\)时，\\(X\\)近似服从二项分布\\(B(n,p)\\)。\n数学期望 \\[\\frac{nM}{N}\\]\n方差 \\[\\frac{nM(N-M)(N-n)}{N^2(N-1)}\\]\n负二项分布 先指定一个自然数\\(r\\)，一个一个地从一批产品中抽样检查，直到发现第\\(r\\)个废品，以\\(X\\)记此时已经抽出的合格产品个数。\n显然\\(\\{X=i\\}\\)这个事件发生时，需要满足\n在前\\(i+r-1\\)次抽取中，正好有\\(r-1\\)个废品 第\\(i+r\\)次抽出废品  所以有\n\\[ P(X=i) = b(r-1;i+r-1,p)p \\]\n\\[ =\\binom{i+r-1}{r-1}p^r(1-p)^i \\]\n负二项分布的名称来源于\n\\[ (1-x)^{-r}=\\sum_{i=0}^{\\infty}\\binom{-r}{i}(-x)^i=\\sum_{i=0}^{\\infty}\\binom{i+r-1}{i}x^i \\]\n\\[ =\\sum_{i=0}^{\\infty}\\binom{i+r-1}{r-1}x^i \\]\n其中令\\(x=1-p\\)，两边乘以\\(p^r\\)，得\n\\[ 1 = p^r[1-(1-p)]^{-r}=\\sum_{i=0}^{\\infty}\\binom{i+r-1}{r-1}p^r(1-p)^i \\]\n几何分布 当负二项分布中的\\(r=1\\)时，有\n\\[ P(X=i) = p(1-p)^i \\]\n数学期望 \\[\\frac{1}{p}\\]\n方差 \\[\\frac{1-p}{p^2}\\]\n多项分布 设\\(A_1,A_2,\\cdots,A_n\\)是某一试验之下的完备事件群，即事件\\(A_1,\\cdots,A_n\\)两两互斥，其和为必然事件。分别以\\(p_1,p_2,\\cdots,p_n\\)记每个事件对应的概率。\n现将试验独立重复\\(N\\)次，而以\\(X_i\\)记载着\\(N\\)次试验中事件\\(A_i\\)出现的次数。\\(X\\)的概率分布就叫做多项分布，有时记为\\(M(N;p_1,\\cdots,p_n)\\)。其概率有\n\\[ P(X_1=k_1,X_2=k_2,\\cdots,X_n=k_n)=\\frac{N!}{k_1!k_2!\\cdots k_n!}p_1^{k_1}p_2^{k_2}\\cdots p_n^{k_n} \\]\n正态分布 如果一个随机变量具有概率密度函数\n\\[ f(x)=(\\sqrt{2\\pi}\\sigma)^{-1}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}\\quad (-\\infty\u0026lt;x\u0026lt;+\\infty) \\]\n则称\\(X\\)为正态随机变量，并记为\\(X\\sim N(\\mu,\\sigma^2)\\)。\\(\\mu,\\sigma^2\\)是常数，\\(\\mu\\in R,0\u0026lt;\\sigma^2\u0026lt;\\infty\\)，它们称为这个分布的参数。由后续的方差一节，\\(Var(X)=\\sigma^2\\)，就是分布的方差。\n正态分布的概率密度函数的图像关于\\(x=\\mu\\)对称，中间高两边低。\n当\\(\\mu=0,\\sigma^2=1\\)时，称为标准正态分布\\(N(0,1)\\)\n\\[ f(x)=e^{-x^2/2}/\\sqrt{2\\pi} \\]\n通常\\(N(0,1)\\)的密度函数和分布函数也会记为\\(\\varphi(x)\\)和\\(\\varPhi(x)\\)。\n任意一个正态分布都可以转化为标准正态分布，便于查表。\n\\[ if\\quad X\\sim N(\\mu,\\sigma^2),then\\quad Y=(X-\\mu)/\\sigma\\sim N(0,1) \\]\n例如\\(X\\sim N(1.5,2^2)\\)，要计算\\(P(-1\\leq X\\leq 2)\\)，则因\\((X-1.5)/2\\sim N(0,1)\\)，有\n\\[ P(-1\\leq X\\leq 2) = P\\left(\\frac{-1-1.5}{2}\\leq\\frac{X-1.5}{2}\\leq\\frac{2-1.5}{2}\\right) \\]\n\\[ =P(-1.25\\leq(X-1.5)/2\\leq 0.25) \\]\n\\[ =\\varPhi(0.25)-\\varPhi(-1.25) \\]\n可以查表代入。但是通常只有非负数的值，对于负数，有\n\\[ \\varPhi = 1-\\varPhi(-x) \\]\n正态分布的线性组合性质 对于正态分布，设\\(X_1,X_2\\)分别服从正态分布\\(N(\\mu_1,\\sigma_1^2),N(\\mu_2,\\sigma_2^2)\\)，对于\\(Y=X_1+X_2\\)\n\\(X_1,X_2\\)独立，则\\(Y\\sim N(\\mu_1+\\mu_2, \\sigma_1^2+\\sigma_2^2)\\)。并且反过来说\\(Y\\)符合正态分布，而\\(Y\\)可以表示为两个独立变量的和\\(Y=X_1+X_2\\)，则\\(X_1,X_2\\)必须服从正态分布。 \\(X_1,X_2\\)不独立，但其联合分布为二维正态分布\\(N(\\mu_1,\\mu_2, \\sigma_1^2,\\sigma_2^2,\\rho)\\)，则\\(Y\\)仍然服从正态分布\\(Y\\sim N(\\mu_1+\\mu_2, \\sigma_1^2+\\sigma_2^2+2\\rho\\sigma_1\\sigma_2)\\)  同样可以推广到多维情况，\\(X_1,\\cdots,X_n\\)相互独立，分别服从\\(N(\\mu_1,\\sigma_1^2),\\cdots,N(\\mu_n,\\sigma_n^2)\\)，则\\(X_1+\\cdots+X_n\\)服从\\(N(\\mu_1+\\cdots+\\mu_n,\\sigma_1^2+\\cdots+\\sigma_n^2)\\)\n对于不全为\\(0\\)的常数\\(C_0,C_1,\\cdots,C_n\\)，线性组合\n\\[ C_0+C_1X_1+\\cdots+C_nX_n\\sim N(C_0+C_1\\mu_1+\\cdots+C_n\\mu_n,C_1^2\\sigma_1^2+\\cdots+C_n^2\\sigma_n^2) \\]\n数学期望 \\[\\mu\\]\n方差 \\[\\sigma^2\\]\n二维正态分布 \\[ f(x_1,x_2)=(2\\pi\\sigma_1\\sigma_2\\sqrt{1-\\rho^2})^{-1}\\exp\\left[-\\frac{1}{2(1-\\rho^2)}\\left(\\frac{(x_1-a)^2}{\\sigma_1^2}-\\frac{2\\rho(x_1-a)(x_2-b)}{\\sigma_1\\sigma_2}+ \\\\ \\frac{(x_2-b)^2}{\\sigma_2^2}\\right)\\right] \\]\n常把这个分布记为\\(N(a,b,\\sigma_1^2,\\sigma_2^2,\\rho)\\)\nn维正态随机变量 定义1\n设\\((X_1,X_2)\\)的四个二阶中心矩都存在，把\n\\[ \\begin{bmatrix} Cov(X_1) \u0026amp; Corr(X_1,X_2) \\\\ Corr(X_2,X_1) \u0026amp; Cov(X_2) \\end{bmatrix} \\]\n称为随机变量\\((X_1,X_2)\\)的协方差矩阵。\n扩展到\\(n\\)维就是\n\\[ \\begin{bmatrix} Cov(X_1) \u0026amp; Corr(X_1,X_2) \u0026amp; \\cdots \u0026amp; Corr(X_1,X_n)\\\\ Corr(X_2,X_1) \u0026amp; Cov(X_2) \u0026amp; \\cdots \u0026amp; Corr(X_2,X_n)\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ Corr(X_n,X_1) \u0026amp; Corr(X_n,X_2) \u0026amp; \\cdots \u0026amp; Cov(X_n) \\end{bmatrix} \\]\n当然所有的协方差必须存在。\n对于二维正态分布\n\\[ f(x_1,x_2)=(2\\pi\\sigma_1\\sigma_2\\sqrt{1-\\rho^2})^{-1}\\exp\\left[-\\frac{1}{2(1-\\rho^2)}\\left(\\frac{(x_1-\\mu_1)^2}{\\sigma_1^2}-\\frac{2\\rho(x_1-\\mu_1)(x_2-\\mu_2)}{\\sigma_1\\sigma_2}+ \\\\ \\frac{(x_2-\\mu_2)^2}{\\sigma_2^2}\\right)\\right] \\]\n其中\\(\\rho\\)是\\(X,Y\\)的相关系数\n所以\\((X_1,X_2)\\)的协方差矩阵是\n\\[ B = \\begin{bmatrix} \\sigma_1^2 \u0026amp; \\rho\\sigma_1\\sigma_2 \\\\ \\rho\\sigma_1\\sigma_2 \u0026amp; \\sigma_2^2 \\end{bmatrix} \\]\n定义\n\\[ X=\\begin{bmatrix} X_1 \\\\ X_2 \\end{bmatrix}, \\mu = \\begin{bmatrix} \\mu_1 \\\\ \\mu_2 \\end{bmatrix} \\]\n则\\(f(x_1,x_2)\\)也可以写为\n\\[ f(x_1,x_2)=(2\\pi|B|^{1/2})exp\\bigg[-\\frac{1}{2}(X-\\mu)^TB^{-1}(X-\\mu)\\bigg] \\]\n扩展到\\(n\\)维，则有\n\\[ f(x_1,x_2,\\cdots,x_n)=[(2\\pi)^{n/2}|B|^{1/2}]exp\\bigg[-\\frac{1}{2}(X-\\mu)^TB^{-1}(X-\\mu)\\bigg] \\]\nn维正态变量的性质\n\\(n\\)维正态随机变量\\((X_1,X_2,\\cdots,X_n)\\)的每一个分量\\(X_i\\)都是正态随机变量；反之若\\(X_1,X_2,\\cdots,X_n\\)都是正态随机变量且相互独立，则\\((X_1,X_2,\\cdots,X_n)\\)是\\(n\\)维正态随机变量 \\((X_1,X_2,\\cdots,X_n)\\)是\\(n\\)维正态随机变量的充要条件是\\(X_1,X_2,\\cdots,X_n\\)的任意线性组合\\(l_1X_1,l_2X_2,\\cdots,l_nX_n\\)服从一维正态分布（其中\\(l_1,l_2,\\cdots,l_n\\)不全为\\(0\\)） 若\\((X_1,X_2,\\cdots,X_n)\\)服从\\(n\\)维正态分布，设\\(Y_1,Y_2,\\cdots,Y_k\\)是\\(X_i\\)的线性变换，则\\((Y_1,Y_2,\\cdots,Y_k)\\)也服从\\(k\\)维正态分布 若\\((X_1,X_2,\\cdots,X_n)\\)是\\(n\\)维正态随机变量，\\(m\u0026lt;n\\)，则\\((X_1,X_2,\\cdots,X_n)\\)的任意\\(m\\)个分量是\\(m\\)维正态随机变量 设\\((X_1,X_2,\\cdots,X_n)\\)是\\(n\\)维正态随机变量，则“\\(X_1,X_2,\\cdots,X_n\\)相互独立”与“\\(X_1,X_2,\\cdots,X_n\\)两两不相关”等价。  指数分布 若随机变量\\(X\\)有概率密度函数\n\\[ f(x)=\\left\\{\\begin{matrix} \\lambda e^{-\\lambda x},\\quad x\u0026gt;0\\\\ 0,\\quad x\\leq 0 \\end{matrix}\\right. \\]\n则\\(X\\)服从指数分布，其中\\(\\lambda\u0026gt;0\\)是参数。通常记作\\(E(\\lambda)\\)\n其概率分布函数为\n\\[ F(x)=\\left\\{\\begin{matrix} 1-e^{-\\lambda x},\\quad x\u0026gt;0\\\\ 0,\\quad x\\leq 0 \\end{matrix}\\right. \\]\n数学期望 \\[\\frac{1}{\\lambda}\\]\n方差 \\[\\frac{1}{\\lambda^2}\\]\n威布尔分布 满足\n\\[ f(x)=\\left\\{\\begin{matrix} \\lambda\\alpha x^{\\alpha-1} e^{-\\lambda x^\\alpha},\\quad x\u0026gt;0\\\\ 0,\\quad x\\leq 0 \\end{matrix}\\right. \\]\n其概率分布函数是\n\\[ F(x)=\\left\\{\\begin{matrix} 1-e^{-\\lambda x^\\alpha},\\quad x\u0026gt;0\\\\ 0,\\quad x\\leq 0 \\end{matrix}\\right. \\]\n可见，指数分布是威布尔分布的一个特例。\n均匀分布 满足\n\\[ f(x)=\\left\\{\\begin{matrix} 1/(b-a),\\quad a\\leq x\\leq b\\\\ 0,\\quad else \\end{matrix}\\right. \\]\n其概率分布函数是\n\\[ F(x)=\\left\\{\\begin{matrix} 0,\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad x\\leq a\\\\ (x-a)/(b-a),\\quad a\u0026lt;x\u0026lt;b\\\\ 1,\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad x\\geq b \\end{matrix}\\right. \\]\n常记作\\(R(a,b),U(a,b)\\)\n数学期望 \\[\\frac{a+b}{2}\\]\n方差 \\[\\frac{(b-a)^2}{12}\\]\n二维随机向量的均匀分布 \\[ f(x_1,x_2)= \\left\\{\\begin{matrix} 1/[(b-a)(d-c)],\\quad a\\leq x_1\\leq b, c\\leq x_2\\leq d\\\\ 0,\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad other\\quad\\quad\\quad\\quad\\quad\\quad \\end{matrix}\\right. \\]\n以上是矩形情况的密度函数\n如果扩展到任意形状的图形，只要求出来其面积，那么密度函数在图形内部就是\\(1/S\\)，图形外部是\\(0\\)\n最大值分布 设\\(M=max\\{X,Y\\}\\)，\\(X,Y\\)相互独立，则\n\\[ F_{max}(z)=P(M\\leq z)=P(X\\leq z, Y\\leq z)=P(X\\leq z)P(Y\\leq z) \\]\n\\[ F_{max}(z) = F_X(z)F_Y(z) \\]\n扩展到多维情况\n\\[ F_{max}(z) = F_{X_1}(z)F_{X_2}(z)\\cdots F_{X_n}(z) \\]\n最小值分布 设\\(N=min\\{X,Y\\}\\)，\\(X,Y\\)相互独立，则\n\\[ F_{min}(z)=P(N\\leq z)=1-P(N\u0026gt;z)=1-P(X\u0026gt;z, Y\u0026gt;z)=1-P(X\u0026gt;z)P(Y\u0026gt;z) \\]\n\\[ F_{min}(z) = 1-[1-F_X(z)][1-F_Y(z)] \\]\n扩展到多维情况\n\\[ F_{min}(z) = 1-[1-F_{X_1}(z)][1-F_{X_2}(z)]\\cdots [1-F_{X_n}(z)] \\]\n卡方分布 \\(\\Gamma\\)函数\n通过积分\n\\[ \\Gamma(x) = \\int^\\infty_0 e^{-t}t^{x-1}dt(x\u0026gt;0)\\]\n来定义\n\\(\\Beta\\)（Beta）函数\n通过积分\n\\[ \\Gamma(x) = \\int^1_0 t^{x-1}(1-t)^{y-1}dt(x\u0026gt;0 ,y\u0026gt;0)\\]\n来定义\n\\(\\Gamma\\)函数的性质\n\\(\\Gamma(1)=1\\) \\(\\Gamma(1/2)=\\sqrt{\\pi}\\) \\(\\Gamma(x+1)=x\\Gamma(x)\\)  因此可知，\\(n\\)为正整数时\n\\[ \\Gamma(n) = (n-1)! \\]\n\\(n\\)为正奇数时\n\\[ \\Gamma(n/2) = 1\\cdot 3\\cdot 5\\cdots(n-2)2^{-(n-1)/2}\\sqrt{\\pi} \\]\n其中\\(\\Gamma\\)与\\(\\Beta\\)函数之间有重要的关系式\n\\[ \\Beta(x,y)=\\Gamma(x)\\Gamma(y)/\\Gamma(x+y) \\]\n卡方分布\n由\\(\\Gamma\\)函数的定义可知，若\\(n\u0026gt;0\\)，则函数\n$$ k_n(x)= {\\[\\begin{align} \u0026amp;\\frac{1}{\\Gamma(n/2)2^{n/2}}e^{-x/2}x^{(n-2)/2} \u0026amp;,\\quad x\u0026gt;0\\\\ \u0026amp;0 \u0026amp;,\\quad x\\leq 0 \\end{align}\\]. $$\n是概率密度函数。它称为“自由度为\\(n\\)的皮尔逊卡方密度”，常记为\\(\\mathcal{X}{}_n^2\\)\n定理1\n若\\(X_1,\\cdots,X_n\\)相互独立，都服从正态分布\\(N(0,1)\\)，则\\(Y=X_1^2+\\cdots+X_n^2\\)服从自由度为\\(n\\)的卡方分布\\(\\mathcal{X}{}_n^2\\)\n卡方分布有如下性质\n设\\(X_1,X_2\\)独立，\\(X_1\\sim \\mathcal{X}_m^2,X_2\\sim \\mathcal{X}_n^2\\)，则\\(X_1+X_2\\sim \\mathcal{X}_{m+n}^2\\) 若\\(X_1,\\cdots,X_n\\)独立，且都服从指数分布，则  \\[ X=2\\lambda(X_1+\\cdots+X_n)\\sim \\mathcal{X}_{2n}^2 \\]\n期望\n若\\(X\\sim\\mathcal{X}_n^2\\)，\\(E(X)=n\\)\n方差\n若\\(X\\sim\\mathcal{X}_n^2\\)，\\(D(X)=2n\\)\nt分布 若\\(X\\sim N(0,1),Y\\sim\\mathcal{X}_n^2\\)，且\\(X,Y\\)相互独立\n\\(t=X/\\sqrt{Y/n}\\)的密度函数为\n\\[ t_n(y)=\\frac{\\Gamma((n+1)/2)}{\\sqrt{n\\pi}\\Gamma(n/2)}\\bigg(1+\\frac{y^2}{n}\\bigg)^{-\\frac{n+1}{2}} \\]\n这个密度函数称为“自由度为\\(n\\)的\\(t\\)分布”的密度函数，常简记为\\(t_n\\)\n\\(n\\)充分大时\n\\[ \\lim_{n\\to\\infty}t_n(y)=\\frac{1}{\\sqrt{2\\pi}}e^{-t^2/2} \\]\nF分布 设\\(U\\sim\\mathcal{X}_{n_1}^2,V\\sim\\mathcal{X}_{n_2}^2\\)，且\\(U,V\\)相互独立，则称随机变量\n\\[ F = \\frac{U/n_1}{V/n_2} \\]\n服从自由度为\\((n_1,n_2)\\)的\\(F\\)分布，概率密度为\n\\[ f_{n_1,n_2}(y) = n_1^{n_1/2}n_2^{n_2/2}\\frac{\\Gamma(\\frac{n_1+n_2}{2})}{\\Gamma(\\frac{n_1}{2})\\Gamma(\\frac{n_2}{2})}y^{n_1/2-1}(n_1y+n_2)^{-(n_1+n_2)/2} \\]\n性质\n若\\(F\\sim F(n_1,n_2)\\)，则\\(\\frac{1}{F}\\sim F(n_2,n_1)\\)\n随机变量的数字特征 数学期望与中位数 定义 定义1\n设随机变量\\(X\\)只取有限个可能值\\(a_1,\\cdots,a_m\\)，其概率分布为\\(P(X=a_i)=p_i(i=1,\\cdots,m)\\)，则\\(X\\)的数学期望，记为\\(E(X)\\)或\\(EX\\)，定义为\n\\[ E(X) = a_1p_1+a_2p_2+\\cdots+a_mp_m \\]\n如果取无穷个值\\(a_1,a_2,\\cdots\\)，而概率分布为\\(P(X=a_i)=p_i(i=1,\\cdots)\\)，则有其数学期望为\n\\[ E(X) = \\sum^\\infty_{i=1}a_ip_i（式1） \\]\n这个期望存在，必须要求这个级数收敛，并且是绝对收敛。\n定义2\n如果\n\\[ \\sum^\\infty_{i=1}|a_i|p_i\u0026lt;\\infty \\]\n则称式1的右边的级数之和为\\(X\\)的数学期望\n定义3\n设\\(X\\)有概率密度函数\\(f(x)\\)，如果\n\\[ \\int^\\infty_{-\\infty}|x|f(x)dx\u0026lt;\\infty \\]\n则称\n\\[ E(X) = \\int^\\infty_{-\\infty}xf(x)dx \\]\n为\\(X\\)的数学期望。\n性质 定理1\n若干个随机变量之和的期望等于各变量的期望之和\n\\[ E(X_1+X_2+\\cdots+X_n) = E(X_1)+E(X_2)+\\cdots+E(X_n) \\]\n定理2\n若干个独立（注意独立）随机变量之积的期望等于各变量期望之积\n\\[ E(X_1X_2\\cdots X_n) = E(X_1)E(X_2)\\cdots E(X_n) \\]\n随机变量函数的期望\n设随机变量\\(X\\)为离散型，有分布\\(P(X=a_i)=p_i(i=1,2,\\cdots)\\)；或者为连续型，有概率密度函数\\(f(x)\\)，则\n\\[ E(g(x)) = \\sum_i g(a_i)p_i（要求绝对收敛） \\]\n或\n\\[ E(g(x)) = \\int^\\infty_{-\\infty}g(x)f(x)dx（要求\\int^\\infty_{-\\infty}|g(x)|f(x)dx\u0026lt;\\infty） \\]\n有一个特例是，若\\(c\\)为常数，则\n\\[ E(cX) = cE(X) \\]\n多维情况 以二维为例\n设\\(Z\\)是随机变量\\(X,Y\\)的函数，\\(Z=g(X,Y)\\)，\\(g\\)是连续函数，\\(Z\\)是一维随机变量\n离散情况\n设\\((X,Y)\\)的分布律为\\(P(X=x_i,Y=y_j)=p_{ij}\\)\n\\[ E(Z) = E[g(X,Y)] = \\sum_j\\sum_i g(x_i,y_j)p_{ij} \\]\n连续情况\n设\\((X,Y)\\)的概率密度是\\(f(x,y)\\)，则有\n\\[ E(Z)=E[g(X,Y)]=\\int^{+\\infty}_{-\\infty}\\int^{+\\infty}_{-\\infty}g(x,y)f(x,y)dxdy \\]\n更高维可以同理推出。\n条件数学期望 \\[ E(Y|x) = \\int^\\infty_{-\\infty}yf(y|x)dy \\]\n类似于全概率公式，我们可以求得无条件的数学期望的一个重要公式\n\\[ E(Y) = \\int^\\infty_{-\\infty}E(Y|x)f_1(x)dx \\]\n其中\n\\[ f_1 = \\int^\\infty_{-\\infty}f(x,y)dy \\]\n如果将\\(g(x)=E(Y|x)\\)，则\n\\[ E(Y) = \\int^\\infty_{-\\infty}g(x)f_1(x)dx=E(g(X))=E(E(Y|X)) \\]\n整理得到\n\\[ E(Y) = E[E(Y|X)] \\]\n如果是多维的，也有\n\\[ E(Y) = \\int^\\infty_{-\\infty}\\cdots\\int^\\infty_{-\\infty}E(Y|x_1,\\cdots,x_n)f(x_1,\\cdots,x_n)dx_1\\cdots dx_n \\]\n如果是离散的，有\\(P(X=a_i)=p_i\\)，则\n\\[ E(Y) = \\sum^\\infty_{i=1}p_iE(Y|a_i) \\]\n中位数 定义1\n设连续型随机变量\\(X\\)的分布函数为\\(F(x)\\)，则满足条件\n\\[ P(X\\leq m)=F(m)=1/2 \\]\n的数\\(m\\)称为\\(X\\)或分布\\(F\\)的中位数。\n而连续的时候，有\n\\[ P(X\\leq m) = P(X\u0026lt;m) = P(X\u0026gt;m) = P(X\\geq m) = 1/2 \\]\n方差与矩 方差与标准差 定义1\n设\\(X\\)为随机变量，分布为\\(F\\)，则\n\\[ Var(X) = E(X-EX)^2 \\]\n称为\\(X\\)的方差，有时会记为\\(DX\\)，其算术平方根称为标准差。\n将其展开得\n\\[ Var(X)=E(X^2)-(EX)^2 \\]\n定理1\n常数的方差为\\(0\\) 若\\(c\\)为常数，则\\(Var(X+c)=Var(X)\\) 若\\(c\\)为常数，则\\(Var(cX)=c^2Var(X)\\) \\(Var(X)=0\\)的充要条件为，\\(P(X=E(X))=1\\)  定理2\n独立（注意独立）随机变量之和的方差等于各变量的方差之和，即\n\\[ Var(X_1+X_2+\\cdots+X_n) = Var(X_1)+Var(X_2)+\\cdots+Var(X_n) \\]\n如果不要求独立，二维有\n\\[ Var(X+Y)=Var(X)+Var(Y)+2E\\{[X-E(X)][Y-E(Y)]\\} \\]\n矩 定义1\n设\\(X\\)为随机变量，\\(c\\)为常数，\\(k\\)为正整数，则量\\(E[(X-c)^k]\\)称为\\(X\\)关于\\(c\\)点的\\(k\\)阶矩\n\\(c=0\\)时称为\\(X\\)的\\(k\\)阶原点矩，记作\\(\\mu_k\\) \\(c=E(X)\\)时称为\\(X\\)的\\(k\\)阶中心矩，记作\\(v_k\\)。  另外\n\\(\\mu_{kl}=E(X^kY^l)\\)称为\\(X,Y\\)的\\(k+l\\)阶混合原点矩，简称\\(k+l\\)混合矩 \\(v_{kl}=E[(X-E(X))^k(Y-E(Y))^l]\\)称为\\(X,Y\\)的\\(k+l\\)阶混合中心矩  协方差与相关系数 对于二维随机向量\\((X,Y)\\)，\\(X,Y\\)本身都是一维随机变量，可以定义其均值、方差，我们记为\n\\[ E(X)=m_1,E(Y)=m_2,Var(X)=\\sigma_1^2,Var(Y)=\\sigma_2^2 \\]\n定义1\n称\\(E[(X-m_1)(Y-m_2)]\\)为\\(X,Y\\)的协方差，并记为\\(Cov(X,Y)\\)\n显然有\\(Cov(X,Y)=Cov(Y,X)\\)\n也有\n对常数\\(c_1,c_2,c_3,c_4\\)，有  \\[ Cov(c_1X+c_2,c_3Y+c_4)=c_1c_3Cov(X,Y) \\]\n\\(Cov(X,Y)=E(XY)-m_1m_2=E(XY)-E(X)E(Y)\\) \\(Cov(X,X)=Var(X)\\) \\(Cov(X_1+X_2,Y)=Cov(X_1,Y)+Cov(X_2,Y)\\) \\(Var(X\\pm Y)=Var(X)+Var(Y)\\pm 2Cov(X,Y)\\)  定理1\n若\\(X,Y\\)独立，则\\(Cov(X,Y)=0\\) \\([Cov(X,Y)]^2\\leq\\sigma_1^2\\sigma_2^2\\)，等号当且仅当\\(X,Y\\)之间有严格线性关系（即存在常数\\(a,b\\)使\\(Y=a+bX\\)）时成立。  定义2\n称\\(Cov(X,Y)/(\\sigma_1\\sigma_2)\\)为\\(X,Y\\)的相关系数，并记为\\(Corr(X,Y)\\)，有时也记为\\(\\rho_{XY}\\)\n可以将相关系数看做标准尺度下的协方差。\n定理2\n若\\(X,Y\\)独立，则\\(Corr(X,Y)=0\\)，当然也要求方差大于\\(0\\)才有定义。 \\(-1\\leq Corr(X,Y)\\leq 1\\)，等号当且仅当\\(X,Y\\)之间有严格线性关系时达到。  需要注意几点：\n当\\(Corr(X,Y)=0\\)（或\\(Cov(X,Y)=0\\)）时，称\\(X,Y\\)不相关，通常我们只能由“独立”推出“不相关”，而不能反过来。但是对于服从二维正态分布的\\(X,Y\\)，“独立”和“不相关”是一回事。 相关系数也常称为“线性相关系数”，相关系数并不是刻画\\(X,Y\\)之间一般关系的程度，而只刻画了“线性”关系的程度。上述定理的第二条提供了一个依据。 如果\\(0\u0026lt; |Corr(X,Y)|\u0026lt; 1\\)，则解释为\\(X,Y\\)之间有一定程度的线性关系。 线性相关的意义还可以从最小二乘法的角度去解释。  大数定理和中心极限定理 大数定理 定义1\n设\\(X_1,X_2,\\cdots\\)是随机变量序列，如果存在数列\\(a_1,a_2,\\cdots\\)使得对任意的\\(\\varepsilon\u0026gt;0\\)，有\n\\[ \\lim_{n\\to\\infty}P\\bigg(\\bigg|\\frac{1}{n}\\sum^n_{i=1}X_i-a_n\\bigg|\\geq\\varepsilon\\bigg)=0 \\]\n则称随机变量序列\\(\\{X_i\\}\\)服从大数定律。\n定义2\n设\\(X_1,X_2,\\cdots\\)是随机变量序列，\\(X\\)是随机变量，若对任意的\\(\\varepsilon\u0026gt;0\\)，有\n\\[ \\lim_{n\\to\\infty}P(|X_n-X|\\geq \\varepsilon)=0 \\]\n此时我们称\\(\\{X_i\\}\\)依概率收敛到\\(X\\)，记为\n\\[ X_n\\stackrel{P}\\rightarrow X,n\\to\\infty \\]\n马尔科夫不等式\n若\\(Y\\)为只取非负值的随机变量，则对任给常数\\(\\varepsilon\u0026gt;0\\)，有\n\\[ P(Y\\geq \\varepsilon)\\leq E(Y)/\\varepsilon \\]\n切比雪夫不等式\n若\\(Var(Y)\\)存在，则\n\\[ P(|Y-EY|\\geq\\varepsilon)\\leq Var(Y)/\\varepsilon^2 \\]\n可以推知\n\\[ P(|Y-EY|\u0026lt;\\varepsilon)\\leq 1-Var(Y)/\\varepsilon^2 \\]\n切比雪夫大数定理\n设\\(X_1,X_2,\\cdots,X_n,\\cdots\\)是相互独立独立的随机变量，具有相同的期望和方差，记它们的均值都为\\(a\\)。又设它们的方差存在并记为\\(\\sigma^2\\)。则对任意给定的\\(\\varepsilon\u0026gt;0\\)，有\n\\[ \\lim_{n\\to \\infty}P(|\\bar X_n-a|\\geq \\varepsilon) = 0 \\]\n更一般的形式\n设\\(X_1,X_2,\\cdots,X_n,\\cdots\\)是相互独立的随机变量序列，具有相同的期望\\(\\mu\\)，如果存在常数\\(C\u0026gt;0\\)，使得\\(D(X_k)\\leq C\\)，则对于任意\\(\\varepsilon\u0026gt;0\\)，有\n\\[ \\lim_{n\\to\\infty}P\\bigg(\\bigg|\\frac{1}{n}\\sum^n_{k=1}X_k-\\mu\\bigg|\\geq\\varepsilon\\bigg)=0 \\]\n马尔科夫大数定律\n设\\(X_1,X_2,\\cdots,X_n,\\cdots\\)是随机变量序列，且\n\\[ \\lim_{n\\to\\infty}\\frac{1}{n^2}D\\bigg[\\sum^n_{k=1}X_k\\bigg]=0 \\]\n则对于任意\\(\\varepsilon\u0026gt;0\\)，有\n\\[ \\lim_{n\\to\\infty}P\\bigg(\\bigg|\\frac{1}{n}\\sum^n_{k=1}X_k-\\frac{1}{n}\\sum^n_{k=1}E(X_k)\\bigg|\\geq\\varepsilon\\bigg)=0 \\]\n辛钦大数定律\n设\\(X_1,X_2,\\cdots,X_n,\\cdots\\)是相互独立且同分布的随机变量序列，具有有限的数学期望，记为\\(\\mu\\)。则对于任意\\(\\varepsilon\u0026gt;0\\)，有\n\\[ \\lim_{n\\to\\infty}P\\bigg(\\bigg|\\frac{1}{n}\\sum^n_{k=1}X_k-\\mu\\bigg|\\geq\\varepsilon\\bigg)=0 \\]\n伯努利大数定律\n设\\(n_A\\)是\\(n\\)次独立重复实验（\\(n\\)重伯努利实验）事件\\(A\\)发生的次数，\\(p\\)是事件\\(A\\)在每次试验中发生的概率，即\\(P(A)=p\\)，则对任意的\\(\\varepsilon\u0026gt;0\\)，有\n\\[ \\lim_{n\\to\\infty} P\\bigg(\\bigg|\\frac{n_A}{n}-p\\bigg|\\geq\\varepsilon\\bigg)=0 \\]\n中心极限定理 定理1\n设\\(X_1,X_2,\\cdots,X_n,\\cdots\\)为独立同分布的随机变量，\\(E(X_i)=\\mu,Var(X_i)=\\sigma^2(0\u0026lt;\\sigma^2\u0026lt;\\infty)\\)。则对任何实数\\(x\\)，有\n\\[ \\lim_{n\\to\\infty}P\\bigg(\\frac{1}{\\sqrt{n} \\sigma}(X_1+\\cdots+X_n-n\\mu)\\leq x\\bigg)=\\varPhi(x) \\]\n这里，\\(\\varPhi(x)\\)是标准正态分布\\(N(0,1)\\)的分布函数。\n也就是说，当\\(n\\)充分大时，有\n\\[ \\sum_{k=1}^n X_k\\sim N(n\\mu,n\\sigma^2),\\quad \\frac{\\sum_{k=1}^nX_k-n\\mu}{\\sqrt{n}\\sigma}\\sim N(0,1) \\]\n\\[ P\\bigg(\\sum^n_{k=1}X_k\\leq x\\bigg)\\approx\\Phi\\bigg(\\frac{x-n\\mu}{\\sqrt n\\sigma}\\bigg),\\quad P\\bigg(a\u0026lt;\\sum^n_{k=1}X_k\\leq b\\bigg)\\approx\\Phi\\bigg(\\frac{b-n\\mu}{\\sqrt n\\sigma}\\bigg)-\\bigg(\\frac{a-n\\mu}{\\sqrt n\\sigma}\\bigg) \\]\n\\[ \\bar X\\approx N(\\mu,\\sigma^2/n),\\quad \\frac{\\bar X-\\mu}{\\sigma/\\sqrt{n}}\\approx N(0,1) \\]\n李雅普诺夫中心极限定理\n设\\(X_1,X_2,\\cdots,X_n,\\cdots\\)相互独立，其具有如下数学期望和方差：\\(E(X_k)=\\mu_k,D(X_k)=\\sigma_k^2\u0026gt;0\\)，记\\(B_n^2=\\sum^n_{k=1}\\sigma^2_k\\)\n若存在正数\\(\\delta\\)使得当\\(n\\to\\infty\\)时\n\\[ \\frac{1}{B^{2+\\delta}}\\sum^n_{k=1}E\\bigg[|X_i-\\mu_i|^{2+\\delta}\\bigg]\\to 0 \\]\n则\n\\[ \\lim_{n\\to\\infty}P\\bigg(\\frac{\\sum^n_{k=1}X_k-\\sum^n_{k=1}\\mu_k}{B_n}\\leq x\\bigg)=\\Phi(x) \\]\n棣莫弗-拉普拉斯中心极限定理\n设\\(n_A\\)是\\(n\\)次独立重复实验（\\(n\\)重伯努利实验）事件\\(A\\)发生的次数，\\(p\\)是事件\\(A\\)在每次试验中发生的概率，即\\(P(A)=p\\)，\n\\[ \\lim_{n\\to\\infty}P\\bigg(\\frac{n_A-np}{\\sqrt{np(1-p)}}\\leq x\\bigg)=\\Phi(x) \\]\n即，若\\(X\\sim B(n,p)\\)，\\(n\\)充分大时\n\\[ X\\sim N(np,np(1-p)) \\]\n\\[ P(X\\leq x)\\approx\\Phi\\bigg(\\frac{x-np}{\\sqrt{np(1-p)}}\\bigg),\\quad P(a\u0026lt;X\\leq b)\\approx\\Phi\\bigg(\\frac{b-np}{\\sqrt{np(1-p)}}\\bigg)-\\Phi\\bigg(\\frac{a-np}{\\sqrt{np(1-p)}}\\bigg) \\]\n参数估计 数理统计学的基本概念 总体 总体是指与所研究的问题有关的对象（个体）的全体所构成的集合。\n赋有一定概率分布的总体就称为统计总体。\n在数理统计学中，“总体”这个基本概念的要旨——总体就是一个概率分布，当总体分布为指数分布时，称为指数分布总体；当总体分布为正态分布时，称为正态分布总体，或简称正态总体。\n总体分布是一个概率分布族。这个分布族包含一个参数时，称为单参数分布族，例如指数分布。包含两个参数时，称为两参数分布族，例如正态分布。如果总体分布不能通过若干个未知参数表达出来，这种情况称为非参数总体。\n样本 样本是按一定的规定从总体中抽出的一部分个体，所谓“按一定的规定”，就是指总体中的每一个个体有同等的被抽出的机会。\n样本表现为若干个数据\\(X_1,\\cdots,X_n,n\\)称为“样本大小”或“样本容量”、“样本量”，样本\\(X_1,\\cdots,X_n\\)中的每一个\\(X_i\\)也称为样本。有时\\(X_1,\\cdots,X_n\\)称为一组样本，而\\(X_i\\)称为其中的第\\(i\\)个样本。\n统计量 完全由样本所决定的量叫做统计量。统计量只以来于样本，而不能依赖于任何其他未知的量。\n简单随机样本 设\\(X\\)是具有分布函数\\(F\\)的随机变量，若\\(X_1,\\cdots,X_n\\)是相互独立，且与\\(X\\)具有相同分布函数\\(F\\)的随机变量，则称\\(X_1,\\cdots,X_n\\)是一个来自总体\\(X\\)的容量为\\(n\\)的简单随机样本，简称样本。\n一个样本\\(X_1,\\cdots,X_n\\)的观察值\\(x_1,\\cdots,x_n\\)，称为样本值。\n联合分布函数为\n\\[ F^*(x_1,x_2,\\cdots,x_n) = \\prod^n_{i=1}F(x_i) \\]\n如果是离散型，有\n\\[ p^*(X_1=x_1,X_2=x_2,\\dots,X_n=x_n)=\\prod^n_{i=1}p(x_i) \\]\n如果是连续型，有\n\\[ f^*(x_1,x_2,\\cdots,x_n) = \\prod^n_{i=1}f(x_i) \\]\n经验分布函数 设\\(X_1,\\cdots,X_n\\)是来自总体\\(X\\)的一个样本，\\(x_1,\\cdots,x_n\\)，是样本\\(X_1,\\cdots,X_n\\)的一组样本值，将其从小到大排列，并且重新编号为\\(x_1,\\cdots,x_n\\)，则称函数\n\\[ F_n(x)=\\frac{x_1,\\cdots,x_n中小于等于x的样本值的个数}{n} = \\left\\{\\begin{matrix} 0,\u0026amp;x\u0026lt;x_1 \\\\ k/n,\u0026amp;x_k\u0026lt;x_{k+1} \\\\ 1,\u0026amp;x\\geq x_n \\end{matrix}\\right. \\]\n为总体\\(X\\)的经验分布函数。\n常用统计量 样本均值\n\\[ \\overline{X} = \\frac{1}{n}\\sum^n_{i=1}X_i \\]\n其样本值为\n\\[ \\overline{x} = \\frac{1}{n}\\sum^n_{i=1}x_i \\]\n样本方差\n\\[ S^2 = \\frac{1}{n-1}\\sum^n_{i=1}(X_i-\\overline{X})^2 = \\frac{1}{n-1}\\bigg(\\sum^n_{i=1}X_i^2-n\\overline{X}^2\\bigg) \\]\n其样本值为\n\\[ s^2 = \\frac{1}{n-1}\\sum^n_{i=1}(x_i-\\overline{x})^2 = \\frac{1}{n-1}\\bigg(\\sum^n_{i=1}x_i^2-n\\overline{x}^2\\bigg) \\]\n样本标准差\n\\[ S = \\sqrt{\\frac{1}{n-1}\\sum^n_{i=1}(X_i-\\overline{X})^2} \\]\n其样本值为\n\\[ s = \\sqrt{\\frac{1}{n-1}\\sum^n_{i=1}(x_i-\\overline{x})^2} \\]\n样本\\(k\\)阶原点矩\n\\[ a_k = \\frac{1}{n}\\sum^n_{i=1}X_i^k \\]\n样本值略。\n样本\\(k\\)阶中心矩\n\\[ m_k = \\frac{1}{n}\\sum^n_{i=1}(X_i-\\overline{X})^k \\]\n样本值略\n定理1\n设总体\\(X\\)均值为\\(\\mu\\)，方差为\\(\\sigma^2\\)（无论何种分布），\\(X_1,X_2,\\cdots,X_n\\)是来自总体\\(X\\)的一个样本，\\(\\overline{X}\\)和\\(S^2\\)分别是样本均值和样本方差，则有\n\\[ E(\\overline{X})=\\mu,D(\\overline{X})=\\sigma^2/n,E(S^2) = \\sigma^2 \\]\n","date":"2022-08-30T10:41:24+08:00","image":"https://kegalas.top/p/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E6%95%B4%E7%90%86/cover_hu60f44b771e1522f4fa1d5246713b9a75_57927_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E6%95%B4%E7%90%86/","title":"概率论与数理统计整理"},{"content":"\r1.jpg\r\n情况如图所示，_ZSt28__throw_bad_array_new_lengthv无法被定位。\n经过检查，通过mingw64.exe运行的g++版本是12.1.0。这也是通过官网的教程安装的版本。并且我们通常会把msys2\\mingw64\\bin\\作为环境变量。\n而通过安装gcc（命令是pacman -S gcc，而不是官网的教程提供的命令），然后用msys2.exe运行的g++版本是11.3.0。将环境变量换为msys2\\usr\\bin\\，此时编译的程序可以正常运行不报错。\n推测原因是版本问题，或者是msys2和mingw64有什么差别。\n另外，通过mingw64打开的命令行来运行编译出来的exe文件不会报错。\n另外，如果遇到failed to synchronize all databases (unable to lock database)，而经过检查又没有发现/var/lib/pacman/db.lck这个文件的存在，可以考虑用管理员身份打开msys2.exe。如果能够打开就说明是权限问题，可以将整个msys2的权限进行修改，允许非管理员用户完全控制。\n","date":"2022-08-28T16:18:50+08:00","image":"https://kegalas.top/p/msys2%E4%B8%AD%E4%BD%BF%E7%94%A8mingw64%E7%9A%84g-%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%E5%85%A5%E5%8F%A3/1_hu8fe568a15a37a7bd8c510c832a970168_16486_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/msys2%E4%B8%AD%E4%BD%BF%E7%94%A8mingw64%E7%9A%84g-%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%E5%85%A5%E5%8F%A3/","title":"Msys2中使用mingw64的G++编译，运行报错无法找到入口"},{"content":" 动画原理 根据视觉暂留现象，只要离散的画面切换的足够快，在人眼看起来就是连续的。\n一般电影是24fps，一般视频是30fps以上，VR是90fps以上。\n关键帧动画 重要的动作节点，会作为关键帧。而中间的帧会作为动作间的过渡。\n关键帧一般是画出来的。过渡帧也可以画，现在也有不少的软件可以自动生成过渡帧。\n关键帧插值 自动生成过渡帧就用到了关键帧插值。\n有线性插值，也有更光滑的插值。\n物理模拟 将各种各样的物理公式用来计算物体的运动，称为物理模拟、物理仿真。\n质点弹簧系统 最简单的单位是：一个弹簧连接了两个质点。\n假设两个点为\\(a,b\\)\n则\n\\[ \\bm f_{a\\to b}=k_s(\\bm{b}-\\bm{a})\\\\ \\bm f_{b\\to a}=-\\bm f_{a\\to b} \\]\n上述情况的条件是弹簧长度为\\(0\\),若弹簧原始长度为\\(l\\)，则\n\\[ \\bm f_{a\\to b}=k_s\\frac{\\bm b-\\bm a}{||\\bm b-\\bm a||}(||\\bm b-\\bm a||-l) \\]\n上述情况假设没有能量损失，如果假设存在阻力，如\\(b\\)物体的阻力是\n\\[ \\bm f=-k_d\\dot{\\bm b} \\]\n其中\\(\\dot{\\bm b}\\)是\\(\\bm b\\)的一阶导数，即速度。\n考虑整个物体，此时要考虑两个物体的相对速度，则施加在\\(b\\)上面的阻力为\n\\[ \\bm f_b=-k_d\\frac{\\bm b-\\bm a}{||\\bm b-\\bm a||}\\cdot(\\dot{\\bm b}-\\dot{\\bm a})\\cdot\\frac{\\bm b-\\bm a}{||\\bm b-\\bm a||} \\]\n弹簧组成的结构 例如组成一个网状结构、立方体结构等等。\n结构的行为更多的取决于弹簧的连接方式。\n粒子系统 直接定义众多小粒子，来描述更宏观的运动现象。通常可能比物理意义上的粒子（如原子）要大得多。\n它便于理解和实现，并且有较好的扩展性。\n但是有时需要大量粒子，如模拟流体；还需要加速结构。\n对于每一帧动画：\n如果需要，创造新的粒子 计算每个粒子上收到的力 更新粒子的位置和速度 如果需要，移除一些粒子 渲染粒子  粒子系统中的力：引力、电磁力、摩擦力、空气阻力等等。粒子系统还有碰撞。\n单粒子模拟 速度场\n描述了在某个位置，某个时间上的粒子的速度。（这里的x我推测是向量）\n\\[ v(x,t) \\]\n然后有常微分方程(ODE)\n\\[ \\frac{dx}{dt}=\\dot{x}=v(x,t) \\]\n欧拉方法\n用前一帧的量去估计下一帧的量\n\\[ x_{t+\\Delta t}=x_t+\\Delta t\\dot{x}_t\\\\ \\dot{x}_{t+\\Delta t}=\\dot{x}_t+\\Delta t\\ddot{x}_t \\]\n问题：非常不准确，非常不稳定。主要是步长\\(\\Delta t\\)的存在导致的问题。这其实也是用数值方法来计算的共有问题。\n解决（降低）不稳定性的方法有：中点法、自适应步长法、隐式欧拉方法、基于位置的方法等等。\n中点法\n\\[ x_{mid}=x(t)+\\Delta t/2\\cdot v(x(t),t)\\\\ x(t+\\Delta t)=x(t)+\\Delta t\\cdot v(x_{mid},t) \\]\n自适应步长法\n定义一个threshold 计算以\\(T\\)为步长，计算一次欧拉方法，得到\\(x_T\\) 以\\(T/2\\)为步长，计算两次欧拉方法，得到\\(x_{T/2}\\) 计算error，即\\(x_T-x_{T/2}\\) 如果error\u0026gt;threshold，则减小步长\\(T\\)，重试。  隐式欧拉方法\n\\[ x_{t+\\Delta t}=x_t+\\Delta t\\dot{x}_{t+\\Delta t}\\\\ \\dot{x}_{t+\\Delta t}=\\dot{x}_t+\\Delta t\\ddot{x}_{t+\\Delta t} \\]\n解这个非线性方程，求出\\(x_{t+\\Delta t},\\dot{x}_{t+\\Delta t}\\)。用求根的算法，例如牛顿迭代法或者下述Runge-Kutta方法。隐式欧拉方法稳定性很好。\nRunge-Kutta 方法\n非常擅长解非线性方程。其中RK4最常被使用。\n首先，我们知道\n\\[ \\frac{dy}{dt}=f(t,y),\\quad y(t_0)=y_0 \\]\n则\n\\[ y_{n+1}=y_n+\\frac{1}{6}h(k_1+2k_2+2k_3+k_4)\\\\ t_{n+1}=t_n+h \\]\n其中\\(h\\)是步长\n\\[ k_1=f(t_n,y_n)\\\\ k_2=f(t_n+h/2,y_n+hk_1/2)\\\\ k_3=f(t_n+h/2,y_n+hk_2/2)\\\\ k_4=f(t_n+h,y_n+hk_3) \\]\n基于位置的方法\n 在修正欧拉方法的步长后，约束粒子的位置以防止其不稳定 使用约束位置计算速度  但是这会导致能量损失。\n刚体模拟 和粒子的模拟相似。\n需要考虑转角，角速度等。仍然可以使用欧拉方法。\n流体模拟 基于位置的方法 假设水都是由很多刚体小球组成的。\n假设水是不可压缩的。\n拉格朗日方法和欧拉方法 对于处理大量的物体\n拉格朗日方法是将每个物体看成质点去处理。\n欧拉法发是将空间切分为网格，对格子进行处理。\nMaterial Point Method 混合了欧拉方法和拉格朗日方法。\n正向运动学 关节骨骼模型\n拓扑的（什么连向了什么） 关节的几何关系 树状结构  关节的类型：\n类似于钉子的关节（只有一维旋转） 类似于球的关节（可以在两个维度内旋转） 平移关节  只要提供骨骼的长度和关节旋转的角度，就能知道尖端处于什么位置。\n逆向运动学 控制尖端的位置，然后自动计算合理的关节、骨骼位置。\n有时候解不唯一，并且解很难以求得。\nRigging 类似于提线木偶，也可以说是逆向运动学的一种应用。\n主要是给角色的一些部分以更高级的控件（控制点），可以进行鼠标拖动位置等修改。像是贝赛尔曲线。\n动作捕捉 把现实中的数据应用到Rigging上的操作。\n","date":"2022-08-10T12:54:34+08:00","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8A%A8%E7%94%BB%E4%B8%8E%E6%A8%A1%E6%8B%9F/","title":"计算机图形学基础学习笔记-动画与模拟"},{"content":" 全光函数 \\[ P(\\theta,\\phi,\\lambda,t,V_x,V_y,V_z) \\]\n记录了在某个位置，往某个方向看，在某个时间，某种颜色的的光的强度\n其中\\(\\theta,\\phi\\)决定了看的方向，\\(\\lambda\\)决定光的频率，也即颜色，\\(t\\)决定时间，\\(V_x,V_y,V_z\\)决定了相机位置。\n光线 \\[ P(\\theta,\\phi,V_x,V_y,V_z) \\]\n五个变量，了，两个描述了方向，三个描述了起点，这样就描述了一条射线。\n在非色散介质中，一个二维的点和一个二维的方向能定义光线。见光场。\n光场 一个物体发出的光可以映射到包围盒上。对于摄影机来说，看到的样子是不会改变的。（实际上应该是映射到和摄像机方向垂直的平面上）\n光场就是在任何一个位置，往任何一个方向去的光的强度。（实际上听上去和光线就是一个意思，只不过可能是将光线由物体表面发出换到了某个等效平面上发出）\n由于三维物体的表面是一个二维的。所以可以从物体表面发出一个二维方向来定义光线。\n好处在于，从任何位置看向这个物体，可以用四个变量得到光的信息。\n另外，可以把包围盒当成一个发光的盒子，看向这个物体直接查询盒子的光场，而不用考虑物体本身。\n如果只采用一个包围盒，则可以用平面上的一个点和其与法线的夹角定义光场。\n如果采用两个包围盒(一大一小，大的包含小的)，可以用两个点来描述光场。对于里面的平面上有一个点\\((u,v)\\)，外面的平面上有一个点\\((s,t)\\)，连接两点就是光场。\n光场相机 普通的透镜相机记录的是Irradiance，而光场相机通过将传感器上的像素替换为透镜，对不同颜色的光进行分光记录，就能够达到记录光场的效果。也就是记录Radiance。\n这样就可以先拍照，在后期处理的时候再聚焦。\n缺点：分辨率不足、成本高。\n可见光光谱 可见光光谱分布在400nm到700nm之间。\n谱功率密度（SPD） 可以通过SPD，描述某种东西发出的光在各个波长上的能量。\n其具有线性性质。可以直接相加。\n颜色的生物学基础 颜色是人的感知，而不是某一波长光的属性。\n视网膜上的感光细胞有两种，一种是棒状的视杆细胞，感觉光的强度。一种是锥形的视锥细胞，感觉光的颜色。视锥细胞要更少一点。\n视锥细胞分为三类：S、M、L；S感知较短波长的光，M感知中间波长的，L感知较长波长的。\n不同的人，三种细胞的分布会不一样，差异有时很大。\n实际上感知到的光，是每个细胞所能感知的波长范围内，每个波长乘以其强度再相加得到的结果（亦或者积分）。总共得到\\(S,M,L\\)三个数传输给大脑。\n同色异谱现象 不同的光谱，其进过积分后得到的三个数可能是相同的，也意味着在人看来是同一个颜色。\n颜色混合 通过将RGB三种颜色加起来来获得其他颜色。\n颜色空间 标准RGB  先让一个机器做好，其他机器以此为标准 广泛采用 色域有限  Gamut（色域） Gamut是一个原色集生成的所有色度。\n不同的颜色空间表示不同范围的颜色，同时也就具有不同的色域。\nHSV 由色调（各种颜色）、饱和度（决定接近白色还是接近某个特定颜色）和亮度组成\n","date":"2022-08-09T12:14:21+08:00","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%89%E5%9C%BA%E9%A2%9C%E8%89%B2%E5%92%8C%E6%84%9F%E7%9F%A5/","title":"计算机图形学基础学习笔记-光场、颜色和感知"},{"content":" 小孔成像 和初中介绍的一致。以此原理做成的相机叫做针孔相机。\n透镜成像 通过透镜进行成像，和初中介绍的一致。现在大多数相机都是透镜成像的。\n快门 控制曝光时间。\n运动模糊 在快门打开的时间内，物体已经发生了明显移动（或者相机动了），就会导致模糊。\n果冻效应 如果某个物体的运动速度非常快，在快门时间内曝光就会产生扭曲效果。仅存在于卷帘快门相机中。\n传感器 捕捉光，并记录的部件。记录的实际上是Irradiance。\n为什么不能用传感器直接收集光，而非要加一个透镜？\n因为传感器上的每一个点都会采集物体上每一个点发出的光，然后所有的像素就会因此变得相似。换言之因为传感器记录的是Irradiance\n针孔相机 没有深度可言，换言之，每个区域都是清晰地。而不像透镜相机，会出现景深效果等等。而光线追踪是以针孔相机的模型来做的，也不会得到景深效果。\n视场(FOV,Field of View) 设传感器的垂直长度为\\(h\\)，透镜到传感器的距离为\\(f\\)，则\n\\[ FOV=2arctan\\left(\\frac{h}{2f}\\right) \\]\n由此定义了垂直FOV。同理可以定义水平FOV。\n通常，以35mm格式的胶片为传感器标准大小，通过焦距的不同得到不同的FOV。\n例如17mm的胶片FOV是104°，50mm的是47°，200mm的是12°。\n但是对于手机摄像机，传感器并不是35mm格式的，要经过等效来换算焦距。\n当视场越窄，看到的东西越远。\n当然传感器尺寸也会影响FOV。想要保持FOV而减小传感器尺寸，则焦距也要变小。\n曝光 \\[ H=T\\times E\\\\ Exposure = time\\times irradiance \\]\n其中time由快门控制，irradiance由物体自己和光圈控制。\n总结，物体亮度，或者说曝光由以下东西控制：\n光圈大小 快门速度 ISO增益，这是后期的处理，而不是原始的数据。有软件和硬件的实现。  光圈 F-Number 描述光圈的大小。通常写作FN或F/N。\n一个不太正式的理解，N是直径的倒数。N越大，光圈越小。\n景深 成像最锐利的点在像距平面上，但是传感器的平面并不总会在像距上，因此会导致模糊。\n理论上，物距上一个点发出的光会在像距上形成一个点，但是如果传感器不在像距上，像就会在传感器上形成一个圈（CoC）。\n设光圈直径为\\(A\\)，CoC直径为\\(C\\)，像距为\\(z_i\\)，透镜到传感器的距离为\\(z_s\\)，则有\n\\[ \\frac{C}{A}=\\frac{|z_s-z_i|}{z_i} \\]\n而通常我们改变的是光圈大小，也即，大光圈导致模糊，小光圈成像清晰。\nF-Number的明确定义：焦距除以光圈直径。\n所以有\n\\[ C=A\\frac{|z_s-z_i|}{z_i}=\\frac{f}{N}\\frac{|z_s-z_i|}{z_i} \\]\n如果CoC足够小，从相机中还是不容易看得出模糊。也就是说在CoC的一小个范围内，成像都是清晰的。这也对应了一个距离，称为Depth of focus。也可以知道物体能够清晰成像的距离范围，称为Depth of field。\n高速摄影 非常快的快门时间。也会因此降低亮度。为了抵消这种影响，就需要用更大的光圈，或者用ISO。\n低速摄影 非常慢的快门时间。可以出现“拉丝效果”。\n透镜 理想薄凸透镜 物距\\(z_o\\)，像距\\(z_i\\)，焦距\\(f\\)有如下关系\n\\[ \\frac{1}{f}=\\frac{1}{z_i}+\\frac{1}{z_o} \\]\n模拟薄凸透镜的光线追踪 初始化：\n定义传感器大小，定义凸透镜的焦距、光圈大小。 设置物距，并计算像距。  渲染：\n对传感器上的每个像素x’ 随机在透镜上选择点x’’ 通过凸透镜定理得到物距平面上的点x’’’ 计算x’‘-\u0026gt;x’’’上的Radiance  ","date":"2022-08-08T12:12:03+08:00","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9B%B8%E6%9C%BA%E4%B8%8E%E9%80%8F%E9%95%9C/","title":"计算机图形学基础学习笔记-相机与透镜"},{"content":" 非表面模型 参与介质(Participating Media) 例如云、雾等。\n其中的小晶体、小分子等会吸收光、反射光等。\n使用相位函数(Phase Function)来描述如何反射等。\n渲染思路：\n随机选择一个方向来反射 随机选择一个距离来传播 在每个反射点来连接光源进行着色  头发材质 Kajiya-Kay 模型\n效果不是很好，只考虑了头发上的反射。\nMarschner 模型\n广泛应用，更进一步地考虑了光线透过头发。\n但是这个模型不能很好地表现动物毛发。\n这个模型将头发认为是有颜色的实心圆柱体。\n但实际上头发中不是均一的某种物质，其中还有一个更小的圆柱体含有髓质。头发的髓质较少，但是其他毛发的髓质较多。\n双圆柱模型\n同上文描述，即考虑了髓质的存在。\n颗粒(Granular)材质 例如盐、白砂糖、米、沙子等。\n表面模型 半透明(Translucent)材质 例如玉石、水母等。\n次表面反射\n也就是，在材质内部反射，然后从某个方向离开表面。\nBSSRDF：作为BRDF的延伸，决定了光从某个方向进来，某个点进来，某个方向出去，某个点出去时光照。也会改变渲染方程。\nDipole Approximation\n通过在物体内部加一个虚拟光源来达到次表面反射的效果\n布料 可以当做表面来渲染，用BRDF进行。\n也可以当做参与介质来渲染，效果比当做平面要好，但是慢。\n也可以直接暴力地将每一根纤维渲染出来，类似头发，效果好，速度慢。\n有细节的材质 例如遍布金属表面的小划痕。\n可以用法线贴图，以及微表面模型来渲染，虽然效果很好，但是十分的慢。\n解决办法：在像素意义上使用BRDF。\n有时候，物体表面反射出来的是各种颜色。例如照射一块铝片，反射出来的宏观上是银色，但是细细的观察会发现有很多不同的颜色。这需要波动光学的帮助。\n程序化生成表面 不用纹理而是用一个噪声函数定义表面。\n可以生成地形、木纹、铁锈等等。\n","date":"2022-08-07T15:46:35+08:00","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E5%A4%96%E8%A7%82%E6%A8%A1%E5%9E%8B/","title":"计算机图形学基础学习笔记-高级外观模型"},{"content":" 无偏差(Unbiased)光传播方法 无偏差的蒙特卡洛方法不会造成任何系统误差。其求出的期望值永远会是正确的值，无论有多少采样点。\n双向路径追踪(Bidirectional Path Tracing, BDPT) 即通过从相机和光同时发出光线，然后让其在某一表面相遇的办法。\n如果光源发出的光传播很复杂，比如一束光直接达到天花板来照亮整个环境。那么双向的效果会比单向的好。\n问题在于实现困难和速度较慢。\nMetropolis光传播(MLT) 在蒙特卡洛积分中使用马尔科夫链。从当前样本估计周围的样本。\n给一条路径可以生成很多相似的路径。以处理局部光路复杂的情况。例如镜面反射-漫反射-镜面反射的情况。\n问题在于：难以估计收敛速度；每个像素的收敛速度不同，导致图面比较脏；不适合用于动画渲染。\n有偏差(Biased)光传播方法 有偏差的蒙特卡洛方法，其期望值随着采样点的增加会趋向正确的值。\n光子映射 特别适合处理镜面反射-漫反射-镜面反射的情况，以及生成焦散线(Caustics)，或者说由于聚焦作用形成的各种图案。\n有众多实现办法，其中一种：\n从光源处射出光子，经过各种反射、折射，直到打到漫反射材料，并记录。 从摄像机射出路径，经过各种反射、折射，直到打到漫反射材料，并记录。 对第二次打到的点，取周围的最近的\\(n\\)个光子，算其密度，来计算亮度。  其有偏的原因是\n\\[ \\frac{dN}{dA}\\neq\\frac{\\Delta N}{\\Delta A} \\]\n当光子趋近于无限时，上式趋于相等。\n\\(N\\)比较小时，图片有很多噪声。\\(N\\)比较大时，图片比较模糊。如果足够多，就可以收敛到不模糊的结果。\nVertex Connection and Merging 其实就是双向路径追踪和光子映射的结合。\n实时辐射度 有时也叫做多光源方法。\n光源发出来的光线，打到某些地方，则把这些地方看做新的光源。\n渲染场景时将这些虚拟光源看作是光源。\n好处是：速度快，并且对于漫反射处理比较好。\n问题是：有些地方莫名的会发光；不 能做金属材质（Glossy）的渲染。\n","date":"2022-08-07T14:57:59+08:00","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E5%85%89%E7%BA%BF%E4%BC%A0%E6%92%AD/","title":"计算机图形学基础学习笔记-高级光线传播"},{"content":" 题意：有\\(N\\)个方块，初始时站在\\(1\\)方块上。每个方块上有一个数\\(a_i\\)，等概率地随机选一个\\(0\\sim a_i\\)的数，假设在\\(x\\)方块上选到了\\(y\\)，则跳到\\(x+y\\)方块。求跳到\\(N\\)上时，选取次数的期望值。\n设\\(dp[i]\\)是从\\(i\\)走到\\(N\\)的期望，那么\\(dp[N]=0\\)。\n记\n\\[ s = dp[i+1]+dp[i+2]+\\cdots+dp[i+a_i] \\]\n然后有\n\\[ dp[i] = \\frac{s+a_i}{a_i+1}+\\frac{1}{a_i+1}\\left(\\frac{s+2a_i}{a_i+1}\\right)+\\cdots \\]\n\\[ =\\sum_{n=1}^\\infty\\left(\\frac{1}{a_i+1}\\right)^{n-1}\\left(\\frac{s+na_i}{a_i+1}\\right) \\]\n\\[ =\\sum_{n=1}^\\infty\\frac{s}{(a_i+1)^n}+\\sum_{n=1}^\\infty\\frac{na_i}{(a_i+1)^{n}} \\]\n\\[ =\\frac{s}{1-\\frac{1}{a_i+1}}-s+1+\\frac{1}{a_i} \\]\n\\[ =\\frac{s+1}{a_i}+1 \\]\n最终\n\\[ dp[i]=\\frac{dp[i+1]+dp[i+2]+\\cdots+dp[i+a_i]+1+a_i}{a_i} \\]\n其中\\(s\\)可以用前缀和优化。\n\\[ \\frac{s+a_i}{a_i+1}=\\frac{dp[i+1]+1+dp[i+2]+1+\\cdots+dp[i+a_i]+1}{a_i+1} \\]\n其实就是非常朴素的选择次数除以概率再相加。然后如果某一次选中了0就再往下算。\n最终的代码如下\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdint\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;deque\u0026gt;  #define LL longlong #define ULL unsignedlonglong #define i128 __int128 #define debug(a)std::cout\u0026lt;\u0026lt;#a\u0026lt;\u0026lt;\u0026#34;=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;std::endl #define lth(i,x,y)for(inti=x;i\u0026lt;=y;i++) #define htl(i,x,y)for(inti=x;i\u0026gt;=y;i--) #define mms(x)memset(x,0,sizeof(x))  const int MAXN = 200005; const int INF = 0x7fffffff; const double EPS = 1e-8; const int MOD = 998244353; const double PI = acos(-1);  LL arr[MAXN]; LL inv[MAXN]; LL sum[MAXN]; LL dp[MAXN];  LL qPowMod(LL a, LL n, LL b){  LL ans = 1;  while(n){  if(n\u0026amp;1){  ans = ans%b*a%b;  }  a = a%b*a%b;  n\u0026gt;\u0026gt;=1;  }  return ans; }  LL fermat_inv(LL a, LL b){  return qPowMod(a,b-2,b); }  void init(int n){  for(int i=1;i\u0026lt;=n;i++){  inv[i] = fermat_inv(i,MOD);  } }  int main(){  std::ios::sync_with_stdio(false);  std::cin.tie(0);   int n;  std::cin\u0026gt;\u0026gt;n;   init(n);   for(int i=1;i\u0026lt;=n-1;i++){  std::cin\u0026gt;\u0026gt;arr[i];  }   dp[n] = 0;  sum[n] = 0;   for(int i=n-1;i\u0026gt;=1;i--){  dp[i] = (((sum[i+1]-sum[i+arr[i]+1]+arr[i]+1+MOD)%MOD)*(inv[arr[i]]%MOD))%MOD;  sum[i] = (sum[i+1]+dp[i])%MOD;  }   std::cout\u0026lt;\u0026lt;dp[1]\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;;   return 0; } 其中第74行的\ndp[i] = (((sum[i+1]-sum[i+arr[i]+1]+arr[i]+1+MOD)%MOD)*(inv[arr[i]]%MOD))%MOD; 不能写为\ndp[i] = (((sum[i+1]-sum[i+arr[i]+1]+arr[i]+1)%MOD)*(inv[arr[i]]%MOD))%MOD; 原因应当是，会出现负数。虽然按照原本的想法，sum[i+1]肯定是大于等于sum[i+arr[i]]。但是sum本身也在进行取余运算，可能会导致小于的情况，导致负数的出现。此时要加一个998244353。\n","date":"2022-08-07T12:57:17+08:00","permalink":"https://kegalas.top/p/atcoder-beginner-conteset-263-e%E6%A6%82%E7%8E%87dp/","title":"Atcoder Beginner Conteset 263 E（概率DP）"},{"content":"根据https://github.com/olOwOlo/hugo-theme-even/issues/139，hugo无法正确生成目录的原因是，没有加入\u0026ndash;toc参数。\n其中@jdhao所说的https://github.com/gohugoio/hugo/blob/master/helpers/content.go#L735这一部分代码现在（编辑日期时）已经转移到了https://github.com/gohugoio/hugo/blob/master/markup/pandoc/convert.go#L67。按他的办法来说应该改成\nargs := []string{\u0026#34;--mathjax\u0026#34;,\u0026#34;--toc\u0026#34;} 实际上并没有那么简单，即使是加入了\u0026ndash;toc参数也不能生成目录。笔者又找到一份他人修改的版本https://github.com/bigshans/hugo。这个版本的convert.go明显是修改过的，能够正确生成目录。\n将其克隆、编译，然后替换掉原来的hugo.exe。经测试可以正常使用。\n编译方法见hugo的github readme。\n如果因为网络问题无法编译，可以给powershell设置代理，见之前的文章。\n如果cgo exit status 2，那么可能是g++的问题，笔者的电脑上g++是msys2滚动更新的，更换为8.1.0版本成功编译了。\n","date":"2022-08-06T16:41:53+08:00","permalink":"https://kegalas.top/p/%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91hugo%E6%9D%A5%E4%BD%BF%E5%BE%97pandoc%E5%8F%AF%E4%BB%A5%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95/","title":"重新编译hugo来使得pandoc可以生成目录"},{"content":"通常，v2rayN设置中的ip是127.0.0.1，http协议的端口是10809，在PowerShell中临时使用代理，需要输入如下命令\n$env:HTTP_PROXY=\u0026#34;http://127.0.0.1:10809\u0026#34;\r$env:HTTPS_PROXY=\u0026#34;http://127.0.0.1:10809\u0026#34; 之后输入\ncurl www.google.com 来检验是否成功。如果v2rayN本身是能够连接到谷歌的，那么得到的结果应该类似于下方：\nStatusCode : 200\rStatusDescription : OK\rContent : \u0026lt;!doctype html\u0026gt;\u0026lt;html itemscope=\u0026#34;\u0026#34; itemtype=\u0026#34;http://schema.org/WebPage\u0026#34; lang=\u0026#34;en\u0026#34;\u0026gt;\u0026lt;head\u0026gt;\u0026lt;meta conten\rt=\u0026#34;Search the world\u0026#39;s information, including webpages, images, videos and more. Google has many spe\rci...\rRawContent : HTTP/1.1 200 OK\r...... 另外不要使用ping命令去测试，虽然不明原因但是确实无法ping到谷歌。\n","date":"2022-08-06T16:33:44+08:00","permalink":"https://kegalas.top/p/%E5%9C%A8powershell%E4%B8%AD%E4%BD%BF%E7%94%A8v2rayn%E4%BB%A3%E7%90%86/","title":"在PowerShell中使用v2rayN代理"},{"content":" 材质 某种意义上来说，材质就是决定双向反射分布函数(BRDF)的东西。\n漫反射材质 漫反射，代表着光均匀地反射到每一个方向。\n假设入射光也是均匀的。\n则\\(f_r,L_i(\\omega_i)\\)就是常数。那么渲染方程：\n\\[ L_o(\\omega_o)=\\int_{H^2}f_rL_i(\\omega_i)cos\\theta_i d\\omega_i \\]\n\\[ =f_rL_i\\int_{H^2}cos\\theta_i d\\omega_i \\]\n\\[ =\\pi f_rL_i \\]\n所以有\n\\[ f_r=\\frac{\\rho}{\\pi} \\]\n其中\\(\\rho\\)是反射率。\n有光泽的(Glossy)材质 金属材质是一类，金属材质的反射较为集中，但又不是镜子那样的镜面反射。\n折射材质 有时会有像玻璃这样的材质，既有反射又有折射。\n反射定律 反射角\\(\\theta_o\\)等于入射角\\(\\theta_i\\)。\\(\\theta=\\theta_o=\\theta_i\\)\n并且反射光线和入射光线在同一平面呢。\n或者入射光线的立体角\\(\\omega_i\\)与反射光线的立体角\\(\\omega_o\\)与反射面的法单位向量\\(\\bm n\\)之间的关系是\n\\[ \\omega_i+\\omega_o=2cos\\theta\\cdot\\bm n \\]\n折射定律 入射角\\(\\theta_i\\)、入射材质的折射率\\(\\eta_i\\)和折射角\\(\\theta_t\\)、折射材质的折射率\\(\\eta_t\\)有如下关系\n\\[ \\eta_i sin\\theta_i=\\eta_t sin\\theta_t \\]\n并且入射光线和折射光线在同一平面内。\n如果发生全反射，要从光密介质射到光疏介质里。并且因为：\n\\[ cos\\theta_t=\\sqrt{1-sin^2\\theta_t}=\\sqrt{1-\\left(\\frac{n_i}{n_t}\\right)^2sin^2\\theta_i} \\]\n所以全反射时满足\n\\[ 1-\\left(\\frac{n_i}{n_t}\\right)^2sin^2\\theta_i\u0026lt;0 \\]\n菲涅尔反射 经常观察到一些现象，比如木桌子上，低角度看过去有反射，高角度看过去没有反射。或者正对玻璃能看到外面，斜对着玻璃可能只能看到反射。\n这说明反射率和入射角有关。实际上这和光的偏振有关。\n一定功率的入射光被界面反射的比例称为反射比\\(R\\)；折射的比例称为透射比\\(T\\)。有\n\\[ R+T=1 \\]\n如果入射光的电矢量垂直于光平面（由入射、反射、折射光线构成的平面）（即\\(s\\)偏振），则反射比为：\n\\[ R_s=\\left[\\frac{sin(\\theta_t-\\theta_i)}{sin(\\theta_t+\\theta_i)}\\right]^2 \\]\n如果入射光的电矢量在光平面内（即\\(p\\)偏振），反射比为：\n\\[ R_p=\\left[\\frac{tan(\\theta_t-\\theta_i)}{tan(\\theta_t+\\theta_i)}\\right]^2 \\]\n这两个式子都可以用折射定律和三角恒等式展开。透射比无论如何都满足\\(T=1-R\\)\n如果入射光是无偏振的，即含有等量的\\(s,p\\)偏振，那么\n\\[ R=\\frac{R_s+R_p}{2} \\]\n显然近垂直入射时\n\\[ R=\\left(\\frac{n_i-n_t}{n_i+n_t}\\right)^2 \\]\n在图形学中，这个计算过于麻烦，通常会采用Schlick近似\n\\[ R(\\theta)=R_0+(1-R_0)(1-cos\\theta)^5 \\]\n\\[ R_0=\\left(\\frac{n_i-n_t}{n_i+n_t}\\right)^2 \\]\n微表面材质 假设物体表面是粗糙的。从远处看是平的、粗糙的；从近处看能看到凹凸不平，每一个小平面都是镜面反射。\n如果没有凹凸，则是镜面材质。\n如果凹凸变化不是很剧烈（法线分布比较均匀），那么会得到一个Glossy的材质。\n如果凹凸变化的比较剧烈（法线分布不均匀），那么会得到一个漫反射材质。\n微表面材质的BRDF可以如下写\n设\\(\\omega_i\\)是入射光线的立体角，\\(\\omega_o\\)是反射光线的立体角，\\(h\\)是它们的半程向量。\\(n\\)是宏观表面的法向量，则\n\\[ f_r(\\omega_i,\\omega_o)=\\frac{F(w_i,h)G(\\omega_i,\\omega_o,h)D(h)}{4(n\\cdot\\omega_i)(n\\cdot\\omega_o)} \\]\n其中\\(F\\)是菲涅尔项；\\(G\\)是几何项（阴影遮挡函数），光线可能会被微平面互相遮挡而影响，所以引入此函数；\\(D\\)是微表面分布函数，决定了有多少微表面的法线朝向\\(h\\)\n各向同性/异性材料 各向异性的材料，由于观察的方位角不同，BRDF不同（即使入射角和反射角相对不变）。\nBRDF的性质 非负\n\\[ f_r\\geq 0 \\]\n线性性质\n可以把各个方向的BRDF加起来，得到的结果和对这些方向和的BRDF一样。反之也可以拆分BRDF。\n可逆性\n\\[ f_r(\\omega_r\\to\\omega_i)=f_r(\\omega_i\\to\\omega_r) \\]\n能量守恒\n能量不会变多，如果物体没有吸收，那么入射多少就会反射多少。\n对于各向同性材质\nBRDF与方位角无关；方位角指的是光线投影到材质平面上，在材质平面上的角。\nBRDF的测量 由于图形学中的公式有估计的成分，BRDF可能与实际值相差很大，有时会用到测量的办法。\n","date":"2022-08-06T10:57:51+08:00","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%89%A9%E4%BD%93%E6%9D%90%E8%B4%A8/","title":"计算机图形学基础学习笔记-物体材质"},{"content":" 为什么需要光线追踪 光栅化不能很好地处理全局效果。例如软阴影，以及光照的多次反射。\n虽然光栅化很快，但是质量不非常好、不真实。\n相比之下光线追踪效果会好很多，但是也非常慢。在过去算力不发达的时候，光栅化是一个实时的算法，而光线追踪是一个离线的算法。\n基础的光线追踪算法 光线投射 对每一个像素投射一条光线来生成一张图 对光源发射一条光线来检查阴影  Pinhole Camera Model\n首先从眼睛，或者说相机发出一条光线，穿过图像平面上的一个像素。然后和空间中的一个物体边缘相交。当然可以和一个物体多次、或者和多个物体相交，我们需要的是最近的。\n然后对最近的这个交点进行着色计算。例如使用Blinn-Phong模型。\nRecursive(Whitted-Style) Ray Tracing\n仍然从相机发出一条光线，穿过图像平面上的一个像素。然后和空间中的一个物体边缘相交。当然，如果是较为镜面的物体，会继续反射光线的路径和下一个物体边缘相交。直到不出现镜面反射。如果是玻璃等透射物质，则要沿着折射光线继续，直到不透明物体。\n光线的数学表示 光线由光源点和方向向量表示。\n\\[ \\bm r(t) = \\bm o+t\\bm d\\quad 0\\leq t\u0026lt;\\infty \\]\n其中\\(t\\)是时间，\\(\\bm o\\)是光源向量，\\(\\bm d\\)是方向向量。\n光线相交 对于隐式表示的物体\n判断是否相交，例如一个球面：\n\\[ (\\bm{p}-\\bm{c})^2-R^2=0 \\]\n其中\\(\\bm p\\)是球面上的点，\\(\\bm c\\)是球心，和\n\\[ \\bm r(t) = \\bm o+t\\bm d\\quad 0\\leq t\u0026lt;\\infty \\]\n相交，则要满足\n\\[ (\\bm o+t\\bm d-\\bm c)^2-R^2=0 \\]\n只有\\(t\\)一个未知数，解即可。\n其他的隐式表示的，或者说用代数形式表示的物体都可以这么判断相交。\n对于三角形网格\n首先，三角形一定能够确定一个平面。所以先判断光线和平面的相交，以及计算交点。再计算交点是否在三角形内。\n一个平面可以表述为上面的一点和平面的法向量。\n所有在平面上的点满足如下等式\n\\[ (\\bm p-\\bm p\u0026#39;)\\cdot \\bm N = 0 \\]\n其中，\\(\\bm p\u0026#39;\\)是平面上已知一点，\\(\\bm N\\)是平面法向量。\n判断光线和平面的交点：\n和\n\\[ \\bm r(t) = \\bm o+t\\bm d\\quad 0\\leq t\u0026lt;\\infty \\]\n联立，得\n\\[ (\\bm o+t\\bm d-\\bm p\u0026#39;)\\cdot \\bm N = 0 \\]\n解得\n\\[ t = \\frac{(\\bm p\u0026#39;-\\bm o)\\cdot \\bm N}{\\bm d\\cdot\\bm N} \\]\n应确保\\(0\\leq t\u0026lt;\\infty\\)\n直接计算出交点重心坐标的方法\nMoller Trumbore Algorithm:\n\\[ \\bm O+t\\bm D = (1-b_1-b_2)\\bm P_0+b_1\\bm P_1+b_2\\bm P_2 \\]\n\\[ \\begin{bmatrix} t \\\\ b_1 \\\\ b_2 \\end{bmatrix}= \\frac{1}{\\bm S_1\\cdot\\bm E_1} \\begin{bmatrix} \\bm S_2\\cdot\\bm E_2 \\\\ \\bm S_1\\cdot\\bm S \\\\ \\bm S_2\\cdot\\bm D \\end{bmatrix} \\]\n其中：\n\\[ \\bm E_1=\\bm P_1 - \\bm P_0 \\]\n\\[ \\bm E_2=\\bm P_2 - \\bm P_0 \\]\n\\[ \\bm S=\\bm O - \\bm P_0 \\]\n\\[ \\bm S_1=\\bm D \\times \\bm E _2 \\]\n\\[ \\bm S_2=\\bm S \\times \\bm E _1 \\]\n光线追踪加速 包围盒 一个物体被完整地包含在一个长方体中，这个长方体称之为包围盒。有时有多个物体在内。\n显然如果光线没有击中包围盒，光线也就不会击中物体。\n由于长方体的六个面确定了六个平面，长方体又可以看作是三组平行平面的交叉。\n我们通常会使用轴对齐的包围盒。即三组平面都平行于坐标面。\n对每一组平面都求光线和其交点，都会求出一个近点和远点。将三组近点和远点比较，求出最远的近点和最近的远点，就是和包围盒的交点。当然同时注意\\(t\\geq 0\\)\n使用轴对齐的包围盒可以减少算法常数\n例如对齐x轴时\n\\[ t = \\frac{(\\bm p\u0026#39;-\\bm o)\\cdot \\bm N}{\\bm d\\cdot\\bm N}=\\frac{\\bm p\u0026#39;_x-\\bm o_x}{\\bm d_x} \\]\n空间均匀分割 找到一块区域，均匀地划分成正方形（三维情况为正方体）网格。在每个网格记录物体边缘的重叠情况。\n对于光线穿过的每个网格中，枚举和网格有交集的所有物体，检测是否和光线相交。\n网格划分太少，则很难于无划分区分开来。划分太多，则会有很多和网格的计算。\n一个启发式的算法是，网格数等于C乘以物体数。在三维中C为27.\n处理较好的情况是，有很多物体的情况。而处理不好的情况是，一个体育馆中心有一个茶壶等类似情况时。\n不均匀的分割 见数据结构笔记KD-Tree。\n下面讲解光线和KD-Tree中的小空间的相交处理。\n首先从根节点开始。光线首先会和根节点表述的空间有两个交点。\n然后判断和两个子节点是否有相交。如果没有则忽略。如果有，则持续往下分割。直到没有子节点，就判断小空间内的物体是否和光线相交。\n层次包围盒(BVH) 见数据结构笔记。\n辐射度量学 辐射能量 辐射能量是电磁辐射的能量。以焦耳（J）做单位，\\(Q\\)为符号。\n辐射通量(Radiant Flux) 辐射通量是每单位时间接收、发射、反射、传输的能量。\n\\[ \\Phi\\equiv\\frac{dQ}{dt} \\]\n单位是瓦特（W），或流明（lm）。\n但流明和瓦特略有不同，流明作为光通量的单位，只考虑了可见光的通量，而瓦特作为辐射通量考虑了电磁波的全部通量。\n辐射强度(Radiant Intensity) 辐射强度是每单位立体角所能从点光源接收到的辐射通量。\n\\[ I(\\omega)\\equiv\\frac{d\\Phi}{d\\omega} \\]\n对于可见光单位是坎德拉（cd），对于一般电磁波是\\(W/sr\\)。\n立体角 圆的角：\n\\[ \\theta = \\frac{l}{r} \\]\n其中\\(l\\)是弧长，以弧度制计算，总共有\\(2\\pi\\)\n对于球体的立体角\n\\[ \\Omega = \\frac{A}{r^2} \\]\n其中\\(A\\)是球面上的面积，以弧度制计算，总共有\\(4\\pi\\)\n其微分如下\n\\[ dA=(rd\\theta)(rsin\\theta d\\phi)=r^2sin\\theta d\\theta d\\phi \\]\n其中\\(\\theta\\)是与\\(z\\)轴的夹角，\\(\\theta\\)是与\\(x\\)轴的夹角。\n\\[ d\\omega=\\frac{dA}{r^2}=sin\\theta d\\theta d\\phi \\]\n所以有\n\\[ \\Phi = \\int_{S^2}Id\\omega=4\\pi I \\]\n\\[ I = \\frac{\\Phi}{4\\pi} \\]\n从实践上来看，立体角是一个单位向量\n辐射通量密度、辐照度(Irradiance) 指辐射通量对每单位面积的量，注意传播方向，或者分量传播方向与那个单位平面垂直。或者说每投影单位面积。\n\\[ E(x)\\equiv\\frac{d\\Phi(x)}{dA} \\]\n对于可见光，单位为\\(lm/m^2=lux\\)，对于一般电磁波，单位为\\(W/m^2\\)\n要求传播方向与平面垂直，和前面提到的Lambert’s Cosine Law是相应的。\n辐射率(Radiance) 是辐射强度对于每投影单位面积的量。\n\\[ L(p,\\omega) = \\frac{d^2\\Phi(p,\\omega)}{d\\omega dAcso\\theta} \\]\n其中\\(\\theta\\)是传播方向与平面法线的夹角。\n对于可见光，单位是\\(cd/m^2=lm/(sr\\cdot m^2)=nit\\)。对于一般电磁波，单位是\\(W/(sr\\cdot m^2)\\)\n显然可以推断出，辐射率是辐射通量在每立体角和每投影面积的量，也是辐照度每立体角的量。\n入射辐射率(Incident Radiance) 是辐射度对每单位立体角的量，其中辐射是到达平面。\n\\[ L(p,\\omega)=\\frac{dE(p)}{d\\omega cos\\theta} \\]\n出射辐射率(Exiting Radiance) 是辐射强度对每单位投影面积的量，其中辐射是从平面发出\n\\[ L(p,\\omega) = \\frac{dI(p,\\omega)}{dAcos\\theta} \\]\nRadiance和Irradiance \\[ dE(p,\\omega) = L_i(p,\\omega)cos\\theta d\\omega \\]\n\\(dE(p,\\omega)\\)，指的就是每个立体角的Irradiance，也即\\(dA\\)接收到\\(d\\omega\\)发来的能量。而计算各个方向上的\\(dE\\)之和，算出来的就是Radiance，也即\\(dA\\)从各个方向接收的能量。这个各个方向通常指的是单位半球的各个立体角。单位半球记作\\(H^2\\)。\n\\[ E(p)=\\int_{H^2}L_i(p,\\omega)cos\\theta d\\omega \\]\n双向反射分布函数(Bidirectional Reflectance Distribution Function) 在某一点的反射过程 首先，从某个立体角\\(\\omega_i\\)射过来的Radiance，变为了某个面积\\(dA\\)的能量。\n然后，这个能量从这个面积再辐射出Radiance到任意其他立体角\\(\\omega\\)\n入射的Radiance是\\(dE(\\omega_i)=L(\\omega_i)cos\\theta(i)d\\omega_i\\)\n出射的Radiance，对于某个立体角是\\(dL_r(\\omega_r)\\)\n而BRDF就是描述了，会有多少光从每个入射光线，反射到某个立体角\\(\\omega_r\\)。\n\\[ f_r(\\omega_i\\to\\omega_r)=\\frac{dL_r(\\omega_r)}{dE_i(\\omega_i)}=\\frac{dL_r(\\omega_r)}{L(\\omega_i)cos\\theta(i)d\\omega_i} \\]\n单位是\\(1/sr\\)\n反射方程 \\[ L_r(p,\\omega_r)=\\int_{H^2}f_r(p,\\omega_i\\to\\omega_r)L_i(p,\\omega_i)cos\\theta_i d\\omega_i \\]\n这个方程会遇到一些问题：如果入射光也有其他物体的反射光，会导致递归方程。\n渲染方程 如果一个物体自己会发光，反射方程需要添加一项。\n\\[ L_o(p,\\omega_o)=L_e(p,\\omega_o)\\\\ +\\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot w_i) d\\omega_i \\]\n简化的写法可以写作\n\\[ L(u)=e(u)+\\int L(v)K(u,v)dv \\]\n再进一步可以写作算子形式\nL = E+KL\n可以被离散化成一个简单的矩阵方程，\\(L,E\\)是向量，\\(K\\)是光传播矩阵。\n如果考虑物体的反射作为新的入射光线，就会导致递归方程。将算子做如下运算\n\\[ L=E+KL\\\\ (I-K)L=E\\\\ L=(I-K)^{-1}E \\]\n将中间的\\((I-K)^{-1}\\)展开成幂级数\n\\[ L=(I+K+K^2+K^3+\\cdots)E\\\\ L=E+KE+K^2E+K^3E+\\cdots \\]\n其中第一项代表光源直接射过来的光，第二项表示光源经过一次反射过来的光，第三项表示光源经过一次反射过来的光。以此类推。这也是全局光照的基础。\n路径追踪 Whitted-Style Ray Tracing的错误之处：无法正确处理略有磨砂感的金属表面，无法正确处理漫反射。\n但是渲染方程是正确的。但缺陷是，要在半球面上解定积分，以及有递归运算。\n一个简单情况下的蒙特卡罗积分 假设我们要渲染一个像素(点)，只考虑直接照射的光线。假设这个点不发光。渲染方程如下：\n\\[ L_o(p,\\omega_o)=\\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot \\omega_i) d\\omega_i \\]\n蒙特卡洛积分中的\\(f(x)\\)为：\n\\[ L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot \\omega_i) \\]\n蒙特卡洛积分中的pdf是（假设均匀采样）：\n\\[ p(\\omega_i)=\\frac{1}{2\\pi} \\]\n所以最终：\n\\[ L_o(p,\\omega_o)=\\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot \\omega_i) d\\omega_i \\]\n\\[ \\approx\\frac{1}{N}\\sum_{i=1}^N\\frac{L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot \\omega_i)}{p(\\omega_i)} \\]\n这对于直接光照来说是一个正确的光栅化算法。\n伪代码如下\nshade(p,wo) Randomly choose N directions wi~pdf Lo=0.0 For each wi Trace a ray r(p,wi) If ray r hit the light Lo+=(1/N)*L_i*f_r*cosine/pdf(wi) Return Lo 全局光照情况下 解决反射导致的光线数量爆炸 间接光照也要考虑的情况下，我们很容易得到一个伪代码：\nshade(p,wo) Randomly choose N directions wi~pdf Lo=0.0 For each wi Trace a ray r(p,wi) If ray r hit the light Lo+=(1/N)*L_i*f_r*cosine/pdf(wi) Else If ray r hit an object at q Lo+=(1/N)*shade(q,-wi)*f_r*cosine/pdf(wi) Return Lo 这会导致一个问题，如果是一个不太光滑的物体，第一次反射后有100个方向的漫反射，一直递归下去，就有\\(100^n\\)条光线，这是不能接受的。而且，显然只有在，反射后只有1个方向的光线时，才不会出现指数爆炸。此时叫做路径追踪。伪代码如下：\nshade(p,wo) Randomly choose ONE directions wi~pdf Trace a ray r(p,wi) If ray r hit the light Return L_i*f_r*cosine/pdf(wi) Else if ray r hit an object at q Return shade(q,-wi)*f_r*cosine*pdf(wi)  如果反射后的光线方向不止一个，那么称作分布式光线追踪，这已经是一个过时的想法了。\n虽然解决了指数爆炸问题，但是，这会导致很多的噪声。\n解决噪声的办法是，对于每一个像素，发出更多的光线，最后取Radiance的平均。伪代码如下\nray_generation(camPos, pixel) Uniformly choose N sample position within the pixel pixel_radiance = 0.0 For each sample in the pixel Shoot a ray r(camPos, cam_to_sample) If ray r hit the scene at p pixel_radiance+=1/N*shade(p,sample_to_cam) Return pixel_radiance 解决光线反射次数无限的问题 多次反射导致指数爆炸的问题解决了，还有一个问题是递归问题。\nshade函数并没有给出明确的函数停止的条件，这会导致无限递归。且粗暴的设定一个硬性条件则会导致能量的丢失。\n有一个俄罗斯转盘（RR）算法。\n之前，我们总是对一个像素射出光线来得到着色结果\\(Lo\\)。\n现在，假设我们手动设定了一个概率\\(P(0\u0026lt;P\u0026lt;1)\\)。\n当我们遇到概率为\\(P\\)的情况时，射出一个光线，并且返回着色结果，再讲这个结果除以\\(P\\)，得到\\(Lo/P\\)\n遇到概率为\\(1-P\\)的情况时，不射出光线，得到的结果为\\(0\\)。\n最后的能量为：\n\\[ E=P*(Lo/P)+(1-P)*0=Lo \\]\n伪代码如下\nshade(p,wo) Manually specify a probability P_RR Randomly select ksi in a uniform dist. in[0,1] If (ksi\u0026gt;P_RR) Return 0.0 Randomly choose ONE directions wi~pdf Trace a ray r(p,wi) If ray r hit the light Return L_i*f_r*cosine/pdf(wi)/P_RR Else if ray r hit an object at q Return shade(q,-wi)*f_r*cosine*pdf(wi)/P_RR  提升效率 在着色点上反射光线，如果光源面积很大，则几根光线就可以打到光源。如果光源很小、接近点光源，则要很多光线才能打到。因为我们是均匀地往四周反射光线，或者说，我们的pdf是一个常数。\n可以考虑将在半球上的积分转化为在光源上的积分。\n需要找到\\(d\\omega\\)（半球立体角）和\\(dA\\)（光源上的面积）的关系。\n显然，这是一个投影关系，又因为半球的半径是\\(1\\)，有如下关系\n\\[ d\\omega = \\frac{dAcos\\theta\u0026#39;}{||x\u0026#39;-x||^2} \\]\n其中\\(x\u0026#39;\\)是光源微平面的坐标，\\(x\\)是着色点的坐标，\\(\\theta\u0026#39;\\)是光源微平面法向量和\\(x-x\u0026#39;\\)向量的夹角。\n渲染方程重写为\n\\[ L_o(x,\\omega_o)= \\int_{\\Omega^+}L_i(x,\\omega_i)f_r(x,\\omega_i,\\omega_o)cos\\theta d\\omega_i\\\\ \\]\n\\[ =\\int_A L_i(x,\\omega_i)f_r(x,\\omega_i,\\omega_o)\\frac{cos\\theta cos\\theta\u0026#39;}{||x\u0026#39;-x||^2} dA \\]\n\\(\\theta\\)是着色点微平面的法向量和\\(x\u0026#39;-x\\)向量的夹角。\n蒙特卡洛积分的\\(f(x)\\)变为\n\\[ L_i(x,\\omega_i)f_r(x,\\omega_i,\\omega_o)\\frac{cos\\theta cos\\theta\u0026#39;}{||x\u0026#39;-x||^2} \\]\npdf变为\\(1/A\\)\n之后，我们对光源不使用RR，对其他反射使用RR。\n另外，转化为\\(dA\\)后，要考虑中间是否有物体挡住光源。\n最终伪代码如下\nshade(p,wo) # Contribution from the light source. L_dir = 0.0 Uniformly sample the light at x\u0026#39; (pdf_light = 1/A) Shoot a ray from p to x\u0026#39; If the ray is not blocked in the middle L_dir = L_i*f_r*cos1*cos2/|x\u0026#39;-p|^2/pdf_light # Contribution from other reflectors L_indir = 0.0 Test Russian Roulette with probability P_RR Uniformly samplethe hemisphere toward wi(pdf_hemi = 1/2pi) Trace a ray r(p,wi) If ray r hit a non-emitting object at q L_indir = shade(q,-wi)*f_r*cos1/pdf_hemi/P_RR Return L_dir+L_indir  ","date":"2022-07-28T17:36:32+08:00","image":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/cover_huee16c3054c7900bea9817aac8584ab5c_32954_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/","title":"计算机图形学基础学习笔记-光线追踪"},{"content":" 基础乐理部分 和声小调与旋律小调 为了制造导音，和声小调需要在自然小调的基础上升高\\(\\hat{7}\\)音。\n为了加强和声小调的旋律平滑性，旋律小调在上行时需要在和声小调的基础上升高\\(\\hat{6}\\)音，下行时则是在自然小调的基础上不做改动。\n关系大小调的推断 享有共同调号的两个调。\n一个小调的关系大调位于该小调主音上方三个-半音级。反之可以推大调的关系小调。\n平行大小调 享有共同的主音的大小调。\n近关系调 调号只相差一个升号或降号的两个调。也是五度循环圈中相邻的两个调。\n通过调号判断主音 大调意义上，调号中最后一个升号向上半级的音是主音。例如最后一个升号是#F，则主音是G。最后一个升号是#B，则主音是#C。（C大调没有升号，主音C）\n大调意义上，调号中倒数第二个降号是主音。例如调号中有♭B,♭E,♭A,♭D，主音就是♭A。（C大调没有降号，主音C，F大调有一个降号，♭B，主音是F）\n然后可以根据关系大小调推出相应的关系小调。\n音程的协和与不协和 完全协和音程：P1(纯一度),P5,P8\n不完全协和音程：M3（大三度）,m3（小三度）,M6,m6\n不协和音程：各种二度、七度、四度（有时四度是协和的），所有的增、减音程。\n旋律的写作 对于初学者给出了如下建议\n以主三和弦的成分开始（即\\(\\hat{1},\\hat{3},\\hat{5}\\)音），用\\(\\hat{2}-\\hat{1}\\)或\\(\\hat{7}-\\hat{1}\\)结束。这也成为旋律终止。 旋律的音区限制在10度以内，尽量保持基本音域在6度。 旋律进行主要是级进，有时可以小跳（三度）或大跳（四度及以上）。 不要含有太多跳进，最好跳进也不要超过小六度。以三度跳进为主。 不用不协和的跳进，如减四度。和声小调中的\\(\\hat{6}-\\hat{7}\\)是增二度，避免出现。 导音必须上行到主音，除非是\\(\\hat{1}-\\hat{7}-\\hat{6}-\\hat{5}\\)的一部分。 跳进后最好反向进行。 可以连用两个小跳，第二个小条后变向。  避免反复音与重复音型，或模进（如1-2-3,2-3-4,3-4-5），显得无趣。如果要用应控制次数，最多一次。 旋律应当有拱形，缓慢的抬升到高点，再折返到起点。  关于调性是否有色彩 这不在本书的讨论范围内，但是根据资料搜索，十二平均律使得大调之间以及小调之间的差异被抹除了。(大小调之间（和声小调）由于其和弦性质不同，存在色彩差异。)可以说各大调之间和各小调之间的色彩没有差异。但是乐器可能在各个频率发出的音色是不同的，这在某种情况下确实导致了听感的不同。另外作曲家选择调性时，通常也会考虑到乐器在某个调演奏是否方便，或者歌手的音域是否能够较为轻松的达到。\n音级的别名 \\(\\hat{1}\\)主音，\\(\\hat{2}\\)上主音，\\(\\hat{1}\\)中音，\\(\\hat{4}\\)下属音，\\(\\hat{5}\\)属音，\\(\\hat{6}\\)下中音，\\(\\hat{7}\\)导音，\n对位法部分 第一类对位法 规则：\n两声部间只允许P5、P8、M3、m3、M6、m6、P1。不允许P4。 反向进行最具有独立性。平行进行削弱独立性。同向进行能使对位更有效果。为了能在平行进行中尽量多地保持独立性和能动性，可以使用3、6度平行，但不能平行进行超过三次。 两个声部之间由纯音程进行到另一种纯音程是禁止的，例如纯五到纯八。也不能从一个完全协和音程平行进行到同一种完全协和音程。同样也不能用同向进行去处置完全协和音程。 不能同向进行到纯音程，进入到纯音程一般采取反向进行。有一种情况除外：上方声部级进时，可以同向进行到纯音程. 为了保持旋律平滑，避免两个声部同时进行跳进。 对位的开始与结束都是在\\(\\hat{1}\\)上。固定旋律是下方声部时，可以从\\(\\hat{5}\\)开始。 小调中，使用自然小调。只在最后升高\\(\\hat{7}\\)创建导音，如果前面有\\(\\hat{6}\\)也要升高。  指南\n对位声部尽可能级进，偶尔有跳进以增加趣味性。跳进后反向级进。 尽可能多用反向进行。  第二类对位法 规则\n强拍必须是协和音程。 避免下列情况的平行纯音程： 连续的两个强拍之间。 弱拍和强拍之间。  从弱拍到强拍的进行要避免同向进入到纯音程（定向性进行）。 唯一允许的不协和音是弱拍经过音（不协和音必须在两个强拍间通过级进的方式填补旋律三度的空间）。 对位声部在CF（固定旋律）下方时必须从\\(\\hat{1}\\)开始。在上方时可以从\\(\\hat{1},\\hat{3},\\hat{5}\\)开始。可以用二分休止符开始。倒数第二小节可以有一或两个音，最后一小节必须有一个全音。 同第一类对位法规则7。  指南\n尽可能多结合运用不协和经过音。 运用和弦跳进平衡不协和经过音。 大跳安排在小节内，不要出现在小节间。  弱拍上的协和音程\n只有一种方式构建协和的级进运动：\\(\\hat{5}-\\hat{6}\\)或\\(\\hat{6}-\\hat{5}\\)。称为5-6技术。\n和声学部分 三和弦概论 三和弦分为四种：\n大三和弦：大三度+小三度 小三和弦：小三度+大三度 减三和弦：小三度+小三度 增三和弦：大三度+大三度  大小三和弦都是协和的。增减三和弦都是不协和的。\n共性写作时期的音乐中，只有大三和弦、小三和弦与减三和弦用作和声的单元。增三和弦并不具有独立的音响性，但它是对位旋律线汇聚的结果。其功能可见增六和弦部分。\n三和弦的转位\n根音是最低音称为原位；三音是最低音称为第一转位，数字低音为\\({}_3^6\\)或\\({}^6\\)；五音是最低音称为第二转位，数字低音为\\({}_4^6\\)。其稳定性依次递减。\n数字低音中的符号\n首先是数字，数字几就代表在根音上方几度有音，这个几度并没有明显的区分出音程的性质，它指的是在调内的音程。\n其次是数字旁边的符号：\n♭ 代表该数字对应的音临时降低。其指的不是把某个音变成带♭号的音，而是指调内的这个音降低半音。 # 代表该数字对应的音临时升高。同上。 /、+ 代表升高一个半音。 ♮ 代表还原一个音。而且并不是还原成调内的音，而是还原成白键上的音。 - 代表某个音延长或者进行。  自然大调中的三和弦性质\n如下：I、ii、iii、IV、V、vi、vii°\n和声小调中三和弦的性质\n如下：i、ii°、III、iv、V、VI、vii°\n偶尔能见到IV,v,VII，不过并不是和声小调中的。\n三和弦的重复音\n四个声部显然要重复三和弦中的某个音，最常重复的是根音。其他规则见后。\n流行中的表示\n性质\nC大三和弦：C C小三和弦：c、C- C减三和弦：C° C增三和弦：C+  转位\n如C的第一转位C/E，C°的第一转位C°/♭E。前面写和弦性质，后面写低音。\n七和弦概论 七和弦都是不协和的。\n七和弦分类\n大七和弦：大三和弦+大七度 大-小七和弦：大+小 小七和弦：小+小 半-减七和弦：减+小 减七和弦：减+减  其中大-小七和弦通常称为属七和弦，因为它通常出现在属音上。\n七和弦转位\n根音为最低音，第一转位，\\({}^7\\);根音为三音，第二转位，\\({}_5^6\\);根音为五音，第二转位，\\({}_3^4\\);根音为七音，第三转位，\\({}_2^4\\)或\\({}^2\\);\n大调中的三和弦的性质\n如下：I\\({}^7\\)大七，ii\\({}^7\\)小七，iii\\({}^7\\)小七，IV\\({}^7\\)大七，V\\({}^7\\)属七，vi\\({}^7\\)小七，vii\\({}^{\\phi7}\\)半减七。\n和声小调中的三和弦的性质\n如下：i\\({}^7\\)小七，ii\\({}^{\\phi7}\\)半减七，III\\({}^7\\)大七，iv\\({}^7\\)小七，V\\({}^7\\)属七，VI\\({}^7\\)大七，vii°\\({}^7\\)减七。\n流行中的表示\n性质\nC大小七和弦：C7 C大七和弦：CM7、C\\(\\Delta\\) 7 C小七和弦：cm7、c7、c-7，Cm7 C半减七和弦：C7dim5,C\\(^{\\phi}\\) 7 C减七和弦：C°7  转位\n类似于三和弦。\nT-D-T进行 即I-V-I的和声进行，它是整个调性和声的基础。有时导和弦可以代替V。\nT-PD-D-T进行与乐句模式 主-预属-属-主。不可反向。这是二级分析意义上的。\n当预属和弦的低音是以级进接入属时，高音声部要反向进行。\n小调中，属功能中的导音要从上方级进。从下方会导致增二度。\n一个乐句中一般要包含T-PD-D-T或T-D-T以形成正格终止，T-PD-D或T-D形成半终止。其中主到预属的长度通常远远长于预属到属。而属持续的时间通常也要长于预属。有时可以用大量的和弦装饰扩展来延长主和属。\n有时会在主和弦中内嵌T-PD-D-T来扩展主和弦，这也称为嵌入乐句模式（EPMs）。为了防止听众误以为是结构上的、二级分析意义上的，需要弱化终止。例如将V7的七音放到根音位置，I使用第一转位。\nI-ii、IV-V、ii6-V中两个外声部反向进行。\n终止式 正格终止 原位的属和弦到原位的主和弦，叫正格终止，或叫完全终止，标注为AC。\n完全正格终止，PAC：高音声部是\\(\\hat{2}-\\hat{1}\\)或\\(\\hat{7}-\\hat{8}\\)，低音是\\(\\hat{5}-\\hat{1}\\)。\n不完全正格终止，IAC：如果高音声部结束在\\(\\hat{5},\\hat{3}\\)。\n对位终止，IAC的一种特定类型：低音不是\\(\\hat{5}-\\hat{1}\\)的IAC。\n皮卡迪三度：小调中结束全曲的主和弦不是小三和弦，而是使用升高三音的大三和弦。此风格被称作皮卡迪三度。\n半终止 结束在原位属和弦上的终止，标注为HC。\n弗里吉亚终止 这是一种特殊的半终止。由下属六和弦进行到原味属三和弦。通常小调更有效果。标注为PHRY。低音进行为\\(\\hat{6}-\\hat{5}\\)。\n巴洛克时期的作曲家都倾向于用其结束多乐章作品中的慢乐章，给听众留下一种强烈的预感，主和弦将在下一乐章的开始出现。\n规避终止 防止在主和弦的扩展中出现较强的终止，或者阻止听众对强烈终止的预期。常常将V-I的正格终止改为V2-I6等。\n变格终止 IV-I的终止。通常出现在教堂音乐中，又叫阿门终止。比正格终止弱得多，前面通常已经出现了一个正格终止。\n对位终止 使用V或I的转位或同时使用，所成的终止式叫对位终止。有时用到vii°6参与终止。一般会用在EPMs中。\n规避终止 V进行到vi。再之后回到预属或者主，再之后接正格终止。\n可以留下悬念以及对主和弦的期待。\n声部进行概论 合唱风格 女高音、女中音、男高音、男低音（SATB）\n使用四行五线谱（开放总谱）、或者使用两行五线谱（缩编谱）中，男低男高在低音谱表，女中女高在高音谱表的风格。\n注意缩编谱中，S、T符干始终向上，另外两个始终向下。\n键盘风格 SAT三声部在高音谱表，B在低音谱表。S符干向上，AT符干向下。\n声部进行规则 解决趋向音（如导音与和弦的不协和音）要用级进。导音在内声部中不一定要上行解决，可以下到\\(\\hat{5}\\)解决。和弦的七音在V\\({}^7\\)中总是下行解决。 不要有平行进行的同度、五度、八度。也不要在这三个音程中反向进行。 不要重复趋向音。如导音、不协和音、半音变音。 上方三声部，两个相邻的声部间不要超过八度。最下方两个声部可以超过八度。 不要四部同向。  声部进行的建议 一般可以保留两个和弦的共同音 上方三个声部的进行主要是二度、三度；大跳后要反向级进。 避免增音程跳进。可以跳进到减音程，随后要反向级进。 上方任意两个声部同时出现大于三度的跳进，有可能会出现问题。尽量使用转位音高。 避免出现声部交叉，如男高比女中高。避免出现声部重叠，如男高音走到了女中音前一个音的上方。 高音声部与低音声部间避免八度与五度的同向进行，除非高音声部是级进进行（称为定向八度与五度）。 总体上将，用完整的和弦。有时可以省略五音。 通常重复根音。为了声部进行正确也可以重复其他音。重复五音比三音好。但是绝对不能重复导音。 先写两个外声部。 上声部的运行与低音成反向。高音声部基本级进。  和声、节奏、旋律、节拍的互动 和声变换节奏 变换到一个新的和声上，会产生一个重音。最好在重拍上切换和弦。避免切分的和声节奏。\n但在四三拍上经常遇到在第3拍上切换和声，有助于强化三拍子。切分的和声节奏在四三拍的终止式中第2拍为属和弦并持续到第3拍时是允许的。\n装饰和弦与和声的二级分析 旋律中会有装饰音，为装饰音配和弦，这个和弦不具有功能，只是作为原和声的扩展。\n和声的一级分析就是将和弦标注出来。而二级分析就是区分重要的、功能性的和声和装饰的和声。\n结构性和声与从属性和声 结构性和声\n是进行性 具有和声功能（主、属、下属） 通常在强拍 通常是原位 是和声序进的组成成分 第二等级分析中保留罗马数字  从属性和声\n是延伸性 具有旋律功能 通常在弱拍 通常是转位 是对位进行的组成部分 第二等级分析中标注为装饰音  主和弦 主三和弦(I) 功能\n主功能，一般不用做装饰。\n主六和弦(I6) 功能\n主功能（较少） 作为低音的跳进和弦：I-I6-V，扩展I，低音由五度变成两个三度。 作为经过和弦：ii-I6-ii6，扩展ii。  主四六和弦(I46) 功能\n主功能（较少，不和谐），属功能（终止四六和弦时）。 作为弱位置上的持续四六和弦：V-I46-V，扩展V。其中属和弦的低音可以保持住，只改动三音五音。在一级分析中记为I\\({}_4^6\\)。二级分析中记为V-Ped\\({}^6_4\\)-V，或者V\\({}^{5-6-5}_{3-4-3}\\) 作为弱位置上的经过四六和弦：IV-i46-IV6，扩展IV。二级分析中记为P\\({}^6_4\\) 作为弱位置上的琶音四六和弦：I-I46-I6下行，扩展I。二级分析中记为Arp\\({}^6_4\\) 作为强位置上的终止四六和弦：I46-V-I，成为正格终止。也能I46-V成为半终止。二级分析记为V\\({}^{6-5}_{4-3}\\)  准备\n准备终止四六和弦的两种方式：\n用共同音做准备。I46前面是I(共同音为\\(\\hat{1}、\\hat{3}\\))或者IV（共同音是\\(\\hat{1}\\)）。 用级进准备。I46前面是预属和声。通常表现为ii6-I46-V-I。  解决\n终止四六和弦解决总是表现为级进下行到V。\n其他\n终止四六和弦在V7前，其进行为\\(\\hat{8}-\\hat{7},\\hat{6}-\\hat{5},\\hat{4}-\\hat{3}\\) 终止四六和弦可以参与到规避终止中，例如I46-V-V2-I6。 终止四六和弦绝对不会接在属功能之后。这会削弱其效果。 终止四六和弦出现在节奏强拍上。（部分书籍会要求不能比后面接的V弱，且不能比后面接的V时间短） 四六和弦重复低音。 四六和弦的进出都是共同音或者级进。  属和弦 属三和弦(V) 功能\n属功能，一般不用做装饰。\n解决\n解决到主三和弦。\n\\(\\hat{7}\\)到\\(\\hat{1}\\)，\\(\\hat{2}\\)到\\(\\hat{1}\\)或\\(\\hat{3}\\)，\\(\\hat{5}\\)到\\(\\hat{1}\\)\n属七和弦（V7） 功能\n属功能，一般不用做装饰。\n准备\n不协和音需要准备，有多种方式，级进的准备是首选的方式。\n解决\n不协和音只有一种解决的方式：三音出现在高音声部时上行，七音总是下行。\n由于三音和七音构成三全音，当为减五度时解决到三度，为增四度时解决到六度。除非选择不解决内部的导音。\n一般来说，完整的属七解决到不完整的主三和弦，不完整的属七解决到完整的主三和弦。也有完整到完整的情况，即内声部的导音进行到\\(\\hat{5}\\)。\n转位的解决类似。\n其他\nV可以进行到V7，但是不能反向。\n属六和弦(V6) 功能\n属功能（较少） 作为低音的跳进和弦：V-V6-I，扩展V，低音由四度变成三度与二度。 作为低音的邻音和弦：I-V6-I，扩展I，低音进行为\\(\\hat{1}-\\hat{7}-\\hat{1}\\)。通常\\(\\hat{5}\\)在高音声部。 作为不完整邻音和弦：I6-V6-I，扩展I，由下行三度变为下行四度再上行二度。  属四六和弦(V46) 功能\n属功能（较少） 作为弱位置上的经过和弦：I-V46-I6，扩展I。二级分析中可以标记为P\\({}^6_4\\) 作为弱位置上的琶音四六和弦：V-V46-V6下行，扩展V。二级分析中记为Arp\\({}^6_4\\)  其他\n四六和弦重复低音。 四六和弦的进出都是共同音或者级进。  属五六和弦(V56) 功能\n属功能（较少）。 作为邻音和弦：I-V56-I，扩展I。 跟随在V或者V6之后，扩展V，随后解决到I。  属三四和弦（V34） 功能\n属功能（较少）。 作为邻音和弦：I-V34-I，扩展I。 作为经过和弦：I-V34-I6，扩展I。  属二和弦（V2） 功能\n属功能（较少）。 作为不完整邻音和弦：I-V2-I6，扩展I，低音由上行3度变为上行4度再下行2度。 作为邻音和弦：I6-V2-I6，扩展I。  属七和弦转位的注意事项 解决与准备同原位和弦。 V7转位必须作为完整的形式出现。 V7转位往往在弱拍，通常连接到强拍上较稳定的主三和弦。 这些修饰和弦可以连用。  返回相关的属和弦 延伸了前面的主和弦却没有解决到主和弦。例如I-V-vi（不作为规避终止时），I-V-ii\n下属和弦 下属和弦经常被选作预属和弦，因为I-IV的进行是五度下行，是调性和声中最强劲的原位进行。\n下属三和弦（IV或iv） 功能\n预属功能。 作为邻音和弦：I6-IV-I6，扩展I。（较少）  其他\n进行到属和弦时注意低音和其他声部反向。 最好重复根音。  下属六和弦(IV6或iv6) 功能\n预属功能。（较少） 作为低音琶音和弦：I-IV6-I6，扩展I，由下行六度变为三度和四度。 作为经过音和弦：V-IV6-V6，扩展V，由三度变为两个二度。注意小调中要升高\\(\\hat{6}\\)以防止增二度。上方声部要与低音反向，防止平行五八。 进行到V形成弗里吉亚终止。  下属四六和弦(IV46或iv46) 功能\n预属功能。（较少） 作为弱位置上的持续四六和弦：I-IV46-I，扩展I。其中主和弦的低音可以保持住，只改动三音五音。在一级分析中记为IV\\({}_4^6\\)。二级分析中记为I-Ped\\({}^6_4\\)-I，或者I\\({}^{5-6-5}_{3-4-3}\\) 作为弱位置上的琶音四六和弦：IV-IV46-IV6下行，扩展IV。二级分析中记为Arp\\({}^6_4\\)  其他\n四六和弦重复低音。 四六和弦的进出都是共同音或者级进。  下属七和弦(IV7或iv7) 不如ii7常见，但也颇具色彩\n功能\n预属功能。  声部进行\n见后\n其他\n为了避免平行五度，通常不接V，而接V7，或者终止四六和弦。如果省略五音重复根音可以借V，既避免平行五度又准备了七音。\n下属五六和弦(IV56或iv56) 功能\n预属功能  声部进行\n见后\n其他\n通常后面接V56。\n导和弦 导减三和弦（vii°） 远不如第一转位常用，因为它有三全音，而第一转位会削弱三全音。\n导减六和弦（vii°6） 功能\n代替属和弦作为属功能（较少）。 作为低音中的经过音和弦：I-vii°6-I6，扩展I，由三度变为两个二度。ii不适合做这个经过和弦的原因是，ii是一个更强势的和声。 作为低音中的邻音和弦：I-vii°6-I，扩展I。  解决\n如果有可能，解决三全音。除非：\n走向完整的主和弦。 没有涉及低音。尤其是三全音表现为增四度。 低音与高音是平行十度。  其他\n不要重复导音。重叠三音(\\(\\hat{2}\\))时走向\\(\\hat{1}\\)或\\(\\hat{3}\\)，有时也可以重叠五音。  导减七和弦(vii°7) 功能\n代替属和弦作为属功能。（较少） 像V56，作为邻音和弦：I-vii°7-I，扩展I。  准备\n七音（\\(\\hat{6}\\)）用级进进入或共同音进入。  解决\n\\(\\hat{6}-\\hat{5}\\) \\(\\hat{4}-\\hat{3}\\) \\(\\hat{2}-\\hat{3}\\)（通常，尽管会重复主和弦的三音），有时也能\\(\\hat{2}-\\hat{1}\\) \\(\\hat{7}-\\hat{1}\\)  转位的准备与解决类似。\n导减五六和弦(vii°56) 功能\n属功能（较少）。 像V34，作为经过和弦：I-vii°56-I6，扩展I。  导减三四和弦(vii°34) 功能\n属功能（较少）。 像V2，作为经过和弦：V-vii°34-I6，扩展V。 像V2，作为邻音和弦：I6-vii°34-I6，扩展I。  导减二和弦(vii°2) 这个和弦比较罕见。\n功能\n属功能（较少）。 作为原位V的邻音和弦：V-vii°2-V，扩展V。  导半减七和弦(viiø7) 在大调中出现的概率要远低于在小调中出现导减七和弦的概率。并且大多以原位出现，很少有转位。\n功能\n作为邻音和弦：I-viiø7-I，扩展I。 作为和弦跳进：V-viiø7-V6，扩展V。  上主音和弦 上主音和弦是最常见的预属和弦。因为： 1. ii-V是五度下行，是调性和声中最强劲的原位进行。 2. 形成对比。大调中ii是小三和弦，I与V是大三和弦；小调中ii°是减三和弦，i是小三和弦，而V是大三和弦。 3. ii-V-I的序进中高音声部时常为\\(\\hat{2}-\\hat{7}-\\hat{1}\\)，力度比IV-V-I的\\(\\hat{1}-\\hat{7}-\\hat{1}\\)弱。也是围绕\\(\\hat{1}\\)的双重邻音的旋律性进行，使得终止尤为强烈。\n上主音小三和弦(ii) 即大调中的形式。\n功能\n预属功能。一般不用作装饰。\n其他\n最好重复根音。\n上主音减三和弦（ii°） 即小调中的形式。建议不用，因为存在三全音。更常用的是第一转位的形式，可以削弱三全音。\n上主音减六和弦(ii°6) 即小调中的形式。\n功能\n预属功能。一般不用作装饰。\n其他\n最好重复低音。\n上主音七和弦(ii°7或iiø7) 功能\n预属功能  声部进行\n见后\n上主音五六和弦(ii°56或iiø56) 比其他转位常见得多\n功能\n预属功能  声部进行\n见后\n下中音和弦 下中音三和弦（vi或VI） 功能\n作为琶音和弦：I-vi-IV，扩展I，或者是准备IV或ii。二级分析中视为从属于T。 作为五度圈下行中的和弦：VI-ii-V-I五度下行。 取代主和弦，作为规避终止：在V-I的终止中替代I，形成上行二度的V-vi，这是一种虚假运动。二级分析中写作“T”。其后跟着预属和弦或者主和弦，然后跟着正格终止。 预属功能。（较少） 属和弦修饰下中音和弦：I-V-vi的进行中，vi会使得V黯然失色，尤其是vi强拍而V弱拍时。 主和弦修饰下中音和弦：类似于上条，尤其是vi强拍而I弱拍。 貌似下中音和弦：不具有结构性意义而是声部进行的附属品。  声部进行\n按照之前的共同规则即可。\n规避终止中，高音宜采用\\(\\hat{2}-\\hat{1}\\)或\\(\\hat{7}-\\hat{1}\\)。注意小调中\\(\\hat{7}-\\hat{6}\\)会形成增二度，从而VI和弦必须重复三音。\n中音和弦 中音三和弦(iii或III) 功能\n作为琶音和弦：I-iii-V或I-iii-IV-V，扩展I。 五度下行中的中音和弦：iii-vi-ii-V-I。  声部进行\n进出iii时尽量将上访声部与低音反向。 iii用于支撑\\(\\hat{7}\\)时，高音采用\\(\\hat{1}-\\hat{7}-\\hat{6}\\)的旋律线条。 其他规则同一般规则。  其他\n小调中使用比大调多 中音和弦的准备：V/III-III，会在小调中出现VII和弦。并且更多时候用的是V6/III。  非属七和弦概论 有些七和弦不具备属音或导音七和弦的属功能性质，被归类到非属七和弦。它们用途宽广，富有色彩，易于实施。\n声部写作注意事项\n必须准备和弦的七音，同音（首选）或者高半音的方式接入 必须解决七音，级进下行到下一个和弦 转位和弦必须是完整的。原位和弦可以省略五音重复根音来避免平行五八。  装饰音 分为两类，弱拍装饰音和强拍装饰音。\n弱拍装饰音有：和弦大跳进、经过音、邻音、先现音等。还将进一步细化为协和的（和弦大跳进）与不协和的（大多数经过音与邻音）。协和的无须准备和解决。不协和的几乎总是出现在协和音之间并且是级进运动。\n强拍装饰音有：强经过音、强邻音、延留音、持续音和倚音等。他们是音乐中最富有情感的元素。\n琶音(ARP)\n如果连续出现了三个或以上以上的和弦音(CS)，那么可以称为琶音。\n经过音(P、PT)\n弥补和弦的音程。通常是三度。\n邻音(N)、上邻音(UN)、下邻音(LN)、不完整邻音(IN)、双重邻音(DN)\n邻音指从和弦音上行或下行二度后又回到原来的音。\n不完整邻音指跳进到与和弦音相邻的音，然后级进解决到和弦音。\n双重邻音指同时出现了上邻音和下邻音再解决到和弦音。\n和弦大跳(CL)\n从一个和弦音跳到另一个和弦音。允许不协和跳进，如三全音。\n强经过音(APT)\n弱拍强位上的经过音。通常发生在下行线条中。7-6、4-3最常用。\n半音经过音(CPT)\n用半音弥补两个自然音中的间隙。\n强邻音(AN)\n强拍上的邻音。\n半音邻音(CN)\n含一个或数个非自然音高。\n倚音(APP)、亦或不完整强邻音\n未准备的不协和音出现在强拍上，实质上是不完整的强邻音。由级进解决，通常与跳进方向相反。最常用的是4-3、9-8\n延留音(SUS)\n最重要的强拍装饰音，其中短暂地延缓了级进式的旋律下行，并在该线条继续之前构成一个不协和音 展开的三阶段 准备：弱拍和弦音 延留：延留准备音持续到强拍上的和弦变换。它此时变成了和弦外音 解决：延留音通过向下级进到弱拍上的和弦音  上声部的常见类型：9-8，7-6，4-3 低音的常见类型：2-3（9-10）  先现音(ANT)\n不协和音，即将出现的和弦的结构音提前进入。\n持续音(PED)\n大多数是在低音中，具有主功能或属功能；表面的和声序进往往是在其上方展开。\n调性音乐中的根音运动 五度下行(D5)。是调性音乐中最强劲的原位进行。如I-V 二度上行(A2)。如IV-V。 三度下行(D3)。如I-vi。  低音级进下行 例如低音为\\(\\hat{1}-\\hat{7}-\\hat{6}-\\hat{5}\\)，则可以配I-V6-IV6-V。小调（旋律小调）则是i-v6-iv6-V。\n级进下行低音经常有在作品中不断重复，形成一个坚实的和声基础。这样的重复叫做固定音型。以此为基础的作品叫固定低音或恰空。\n隐伏和声 通过复合旋律的分析可以分析出三和弦或者七和弦。但少部分情况仍然不完整，这就需要推断出确实的和弦音。\n和声模进 书上的定义不是很直白，简单说就是和弦级数（根音级数）按某一特定规律变化的进行。例如先下降五级在上升四级（也可以理解为连续下降五级），变成I-IV-vii°-III-vi-ii-V-I。\n分为两类，延伸模进（扩展一种功能，如T-T），离调模进（从一种功能到另一种功能，如T-PD）。总的来讲，模进是在主和弦扩展之后并在PD与D功能之前出现。\n下行二度(D2)模进 D2(-5/+4)模进，即先下行五度在上行四度，称为下行二度模进。毫无疑问也可以先上行四度再下行五度。\nI-IV-vii°-III-vi-ii-V-I中，间隔的两个和弦会有声部进行问题，而插入的那一个和弦正好解决了这个问题。称作声部进行和弦。另外IV-vii和vi-ii的进行中根音会出现三全音跳进，但在模进中是可以接受且必须的。\n在这个模进中，出现原位的减和弦是允许的。\n下行二度模进转位\n原位模进的低音有些跳进。通常会将模进中的每第二个和弦使用第一转位。\n下行三度(D3)模进 D3(-4/+2)模进与D2模进形成鲜明对比。\n同样有声部进行和弦避免平行问题。\n大调中I-V-vi-iii-IV-vii°-I。小调中i-v-VI-III-iv-V7-i。这是书中给出的例子，关于为什么会有倒数第二个属和弦，书中没给出解释，我认为是为了保持乐句模式。注意小调中第二个是小和弦，防止出现增二度。\n帕赫贝尔的卡农的形式是：I-V-vi-iii-IV-I-ii56-V-I。可以认为三度下行只有I-V-vi-iii-IV-I，后面接终止式以保持乐句模式。\n下行三度模进转位\n同样给每第二个和弦使用第一转位来平滑低音的运动。也称之为下行5-6模进，因为往往每第一个和弦每第二个和弦之间，有一个声部保持稳定，而低音下行二度，形成了5度-6度的关系。它的转位比原位更常用。\n上行二度(A2)模进 A2(+5/-4)比D2罕见，它几乎没有目标导向。常见的只发生在原位，I-V-ii-vi-iii-。然后通常接到预属。小调中为i-v-ii°-Vi-III-。注意小v。\n另一种A2(-3/+4)，同样也是引导向预属功能。通常每第二个和弦使用第一转为，也称作上行5-6模进。\n写和声模进的指南 确保前三个和弦的声部进行是正确的，后面的都是复制，不会导致新的问题。 是种都是用低音与高音声部开始；尽量使两个外声部之间成反向级进。 模句中的两个外声部之间至少要有一个不完全协和的音程。  在乐句模式中写作模进 比如要在四小节的乐句中确立主和弦，用D2模进，并且PAC结束。\n可以采用很快的节奏来处理模进和弦。 可以只采用模进的一部分。可以不用前几个，也可以提前结束模进。 加长乐句。  自然音七和弦的模进 可以将自然七音添加到每一个D2(-5/+4)模进中，也可以隔一个和弦添加一个七音。两个都可以使每个七音都有共同音准备并级进下行解决。前者叫带连锁七和弦的D2(-5/+4)\n写作指南\n设计好前三个和弦的链接。注意每个七音都要准备和解决。 交替出现的七和弦可以是完整的。 连锁七和弦中，相邻的两个七和弦一个是完整的一个是不完整的。  转位\n第一转位、第三转位较为常见。转位一定要是完整的和弦。\n平行第一转位三和弦 写作一连串平行运动的和弦，只有采用三和弦的第一转位一种方式。用于延长和声或者和声功能之间的离调。\n四声部写作时，三个声部平行运动，一个内声部重复高音、重复低音、重复高音、重复低音进行（也可以从低音开始）。\n副属和弦 概论 作为副属功能的和弦，必须表现得像个属和弦。也就是，必须是大三和弦或是属七和弦，并且通常要进行到其主和弦上。\n推断副属和弦，例如c小调中V的副属和弦。首先V是G大三和弦，就确定G大和弦（或者说G大调）的副属和弦，G大和弦的副属和弦是D大和弦。标注为V的V，即V/V。在预属和属前面增加其副属和弦是常见的。小调中在III前面加副属也常见。\n注意减和弦不能有副属和弦。副属和弦在二级分析中标注为其主和弦相同的功能。\n转位\n可以通过转位平滑低音线条。\n声部进行\n不能重复导音和七音。 导音在外声部要向上级进解决。 七音总是向下解决。  副导和弦 由vii°6和vii°7（以及少见的viiø7）是属和弦的替代品。他们也能参与到副属和弦中，作为副导和弦。比如说vii°6/ii。\n副属和弦运用在乐句中 没有新的规则。不过副属和弦布局在弱位置上是很常见的，因为含有导音，参与的运动是通往强位置的目标。\n带副属和弦的模进 D2(-5/+4)\n显然，这样有五度下行的结构，是可以运用副属和弦的。并且可以交替使用副属和弦，也可以连锁使用。\nD3(-4/+2)\n将每第二个和弦换为下一个和弦的副属和弦，从D3(-4/+2)变为D3(+3/-5)。可以用转位来平滑低音。也可以用副导七和弦变为D3(-4/+1)。\nA2(-3/+4)\n比A2(+5/-4)结合副属和弦常见。\n每第二个和弦采用第一转位时，只要低音升高半音就可以构建副属和弦。\n离调与转调 扩展离调 用副属和弦就是一种离调。副属和弦解决到其主和弦的过程是可以扩展的，使用那个调上的和弦进行扩展。在二级分析中这些都是该调主和弦的功能。罗马数字分析中，可以将离调的部分写作该调的和弦级数，再将离调的部分括号括起来标注临时主和弦。\n转调 长久的离调，其能占据作品的一整个段落，被称之为转调。虽然没有一条明确的分界线。但是：\n离调通常出现在乐句之中。 转调含有新调中强烈的终止式，并且新调在终止式之后还在延续。  近关系调 总体上讲，调性音乐中转调是从本调进行到任何其近关系调。\n有两种方式确定近关系调：\n本调上各音级上构筑自然音三和弦。所有的协和三和弦（大三和弦和小三和弦）都构成了主调的近关系调。 调号与原调号只差一个升降号的大调和小调。  虽然可以转到任何大小自然调，但是最常见的是（有先后）：\n大调转到V、vi和iii 小调转到III，v和VI  转调分析 有三种重要信息：\n新调在原调中的位置 新调在作品或作品段落中整体和声序进中的功能 新调与原调瞬间融合的点位  采用如下方式分析转调：\n在原调中开始处写罗马数字 一直分析和弦，直到罗马数字因调性变化而变得复杂或没有意义 为新调标出罗马数字，从终止式往回写，直到出现两个调中都用简单的罗马数字标记的第一个和弦。即中介和弦。  中介和弦转调 在理解中这和共同和弦转调是一个意思。\n中介和弦在两个调中都是自然音和弦。终止四六和弦不是优选，因为它们在新调中是强烈终止的一部分。中介和弦通常在新调中是PD功能的。\n写作指南\n新调和原调的两个调域的持续时间段是均衡的。中介和弦配置在转调乐句的中间位置，各调中都至少要用数个和弦。 找出两个调中的所有中介和弦。最佳的中介和弦应该能作为新调的PD和弦。为了避免刺耳音响，不能用新调的属和弦作为中介和弦。 中介和弦之后不要立刻冲进完全正格终止。插入一段对位终止或EPM。 在新调中采用级进式高音线条进行到最强的终止，即终止四六和弦的PAC。  较大音乐语境中的转调 几乎没有什么作品开始的与结束的调不同。考虑到作品的整体性，转调从未取代过主调。调性音乐中的转调只是参与到单一的整体和声运动中。\n例如，c小调的作品在引导向属和声并返回到c小调结束前可以转调到♭E大调与f小调。这构成了一个大型序进：i-III-iv-V-i。\n在模进中转调 在和声模进中，提早放弃模进并将其和弦之一重新解释成进行到属的预属，就可以有效地进入到一个新调。\n混合调式 18世纪晚期到19世纪初期的音乐，经常会有一种半音的类型，无法说成是附属功能以及离调所派生的。事实上只是非功能的出现，来为音乐的旋律与和声外表增添色彩。\n借用平行调式和声的技术称之为混合调式，简称混合。\n皮卡迪三度也是一种混合调式，大调中使用减七和弦也属于混合调式。\n虽然平行大小调之间可以借用和声，但是一般常见的是从小调中借用和弦给大调使用。因为小调中\\(\\hat{6},\\hat{7}\\)会根据情况有两种形式。在大调中引入这样的变化音非常特别。\n变音的预属和声 涉及ii°与iv\n涉及混合调式的最常见的音级是\\(\\hat{6}\\)，因为：\n\\(\\hat{6}\\)最不可能破坏本调与调式的完整性 降低\\(\\hat{6}\\)就能产生强力的半音级进运动到属和弦 混合调式援引\\(\\hat{6}\\)为所有的PD和声增添了色彩 主三和弦外唯一能用\\(\\hat{1}\\)级音位于低音的和声协和支撑的音级就是\\(\\hat{6}\\)。因此，是5-6运动的成分。  改变了和弦性质但没有改变根音的半音变化，称之为混合旋律。\n变音的下中音和声 涉及♭VI，和上一个一样变的是\\(\\hat{6}\\)，但这次是在根音情况。这种变化根音的情况叫做混合和声。\n只将\\(\\hat{6}\\)降低会形成增三和弦，通常也要同时降低\\(\\hat{3}\\)来形成大三和弦。\n它仍是作为下中音和弦的功能：\n参与到下行琶音 参与到下行五度运动 作为预属功能至于属和弦前 虚假运动中接到属和弦后代替主和弦 由于降低的\\(\\hat{6}\\)和属和弦仅相差半音，可以用作扩展V的上邻音。  变音的主音和声 涉及i，即降低\\(\\hat{3}\\)。将大调主和弦转换成小调主和弦，但是这种并置会引发整首作品的调式问题，所以i只能用于暗示而不能用作正式的陈述。\n十九世纪，有些作曲家，如舒伯特，大量使用小调元素，使得24个大小调融入到12个大-小调中。如果一首作品中D大调和d小调的音出现的数量差不多，就只能说成是D调作品。\n变音的中音和声 涉及♭III，降低了\\(\\hat{3}\\)和\\(\\hat{7}\\)构成大三和弦。功能仍然是中音和弦的功能：\nI和V之间的，将五度划分成两个三度的和弦。 T与PD之间的过渡。 参与到下行五度运动中，尽管比ii少见许多。 作为PD，引导向V34。 其之前添加副属和弦。 作为I6的替代品，不如iii常见。  混合和声的声部进行 避免重复变音，除非变音是根音 ♭\\(\\hat{6}\\)可以做邻音和下行经过音，要由级进运动做准备并解决。并且应该保持在同一声部中。 只要引入了混合调式，就必须一直持续到抵达属功能。  半音级进式低音下行 小调中\\(\\hat{6},\\hat{7}\\)有两种形式，所以半音级进式低音下行是可能的。\n有了混合调式，就能将其引入到大调中。\n变格运动 指下属和弦、上主音和弦与下中音和弦直接进行到主和弦。二级分析中缩写为PL功能。\n混合调式与副属和弦 离调与属功能密切相关 混合调式通常出现在预属功能中  半音转调 最常见的是转到♭VI和♭III，较少到VI和III。\n半音中介和弦转调 往往半音转调的时候，两个调没有共同和弦。但是本调的关系调和新调有中介和弦。也就是说，这个中介和弦必须是本调的混合和弦。\n写作指南\n在新调中添加必要的临时符号，或者调号。 中介和弦必须总是原子混合调式。通常由很好效果的是用i来作为新调的vi或iii。 尽量构建浑然一体的音乐进行，在新调中扩展PD，可通过转位或短暂的离调。  无准备的半音转调 即直接在某个停顿后突然进入到另一个调。\n半音共同音转调 例如D大调的\\(\\hat{1}\\)和♭B大调的\\(\\hat{3}\\)是同一个音，彼此间隔三度，进行转调。从书上给的例子看，舒伯特写了两小节长度的纯D音，不含别的成分，然后再进行到新调。\n那不勒斯和弦 概论 建立在♭\\(\\hat{2}\\)上的大三和弦称为那不勒斯和弦。\n通常以第一转位出现，为♭II6，重复低音，有时也可以重复\\(\\hat{6}\\)，不能重复♭\\(\\hat{2}\\)。\n作为预属功能强力推向V。出现在小调中比大调多，在大调中是混合调式的结果，大调中同时也要降低\\(\\hat{6}\\)，并且要避免增二度进行，\\(\\hat{1}\\)-♭\\(\\hat{2}\\)，而不是\\(\\hat{3}\\)-♭\\(\\hat{2}\\)。\n通常出现在终止式中，也能用于EPM。\n♭II6-V的序进是高音声部中有♭\\(\\hat{2}\\)-\\(\\hat{7}\\)的进行，这个减三度是可以接受的。也可以添加\\(\\hat{1}\\)作为经过音，此时配置终止四六和弦或者为V配置副减导七和弦。\n扩展 低音中的和弦跳进来延长，♭II-♭II6 作品的第一分句配置在主和声上，随后上移半音级进到♭II。 加入副属和弦，小调中的VI，大调中的♭VI。  无论怎么扩展，始终都是作为预属功能。\n模进 在模进中结合那不勒斯和弦，好处是，小调时二级和弦是减和弦，不能使用副属和弦。换成那不勒斯和弦后可以使用副属和弦。\n用作中介和弦的那不勒斯和弦 转调到自然音以及半音调时，那不勒斯和弦是一个有效的中结合线。如c小调转到♭A大调，则c小调中的♭II6和♭A大调中的IV6是共同和弦。\n增六和弦 概论 书上虽然没说，但是指的不是增三和弦的第一转位，而是含有增六度的和弦。\n通常是\\(\\hat{4}\\)上的和弦，升高\\(\\hat{4}\\)，然后第一转位。（小调上）\n同大多数半音和弦一样，作为预属功能。它更多地出现在小调中\n解决到属和弦，低音♭\\(\\hat{6}\\)级进下行到\\(\\hat{5}\\)，#\\(\\hat{4}\\)上行到\\(\\hat{5}\\)。内声部重复\\(\\hat{1}\\)，并且反向运动。（书上虽然说的是降六级，但是我怀疑打错了，小调中的五六级就是半音。大调中要降六级）\n如果直接解决到V7，会出现省略式解决。#\\(\\hat{4}\\)没有上行到\\(\\hat{5}\\)，而是到\\(\\hat{4}\\)并到\\(\\hat{3}\\).\n类型 基本成分是：\n\\(\\hat{6}\\)位于低音声部（书上没说，但是大调降六级） #\\(\\hat{4}\\)位于上声部（通常是高音声部） \\(\\hat{1}\\)是重复音  意大利增六和弦\n就是只含有基本成分的增六和弦，标注为It6\n德意志增六和弦\n意大利增六和弦是重复\\(\\hat{1}\\)。德国增六和弦不重复，而是增加了一个\\(\\hat{3}\\)音，大调♭\\(\\hat{3}\\)。标注为Ger56。\n法兰西增六和弦\n不重复，而是增加\\(\\hat{2}\\)音，形成增四度。大调也是增加\\(\\hat{2}\\)。标注为Fr34。\n瑞士增六和弦\n只存在于大调，就是法国增六和弦增加的是#\\(\\hat{2}\\)，构成倍增四度。也称为瑞士倍增六和弦。标注为Sw34。\nVI与增六和弦 通常(♭)VI是进行到预属。但有时也会直接作为预属，进行到V，来利用富有戏剧性的半音运动(♭)\\(\\hat{6}-\\hat{5}\\)。由于直接用(♭)VI-V有声部问题，所以经常会将(♭)VI转化为德国增六和弦。因为它们有三个共同音。\n作为预属扩展部分的增六和弦 鉴于两个声部都具有明确的到\\(\\hat{5}\\)的目标导向，增六和弦通常也就成为了到属和弦之前的最后一个环节，紧跟着前置的iv(6)或VI。\n在极为罕见的情况下，德国增六和弦会用到\\(\\hat{4}\\)低音位置，此时构成了德国减三和弦。记作Ger7。\n增六和弦与转调 由于有两个半音趋向于\\(\\hat{5}\\)，它比一般PD更富有同向属和弦的线性驱动力。因此，当其出现在中介和弦之后尤其有助于稳固新调。\n增六和弦作为转调的中介和弦 意大利增六和弦实际上和某个调的不完整V7（缺5音）是同音异名的关系。德意志增六和弦则和某个完整的V7是同音异名关系。一般是在降二级上的调。\n从而，有时会用这个和弦去进行中介和弦转调。\n曲式学部分 动机 最出名的动机之一就是命运交响曲的开头。\n动机类型 分为两种：独立的音型和主题的构件。具体如何区分书中并没有说得太清楚，疑似也不重要。\n动机的重复 严格重复 在动机的称述之间保持同样的音高-节奏结构。\n通常相对少见，但是在作品刚开始时进行严格重复是很适合的，可以帮助听众迅速掌握动机。\n为了避免枯燥，可以进行模仿，即在一个声部首先陈述动机，然后在另外的声部中重复（通常指八度模仿，不改变动机的音级）。也可以对动机进行重配和声。\n修饰重复 常见的修饰办法有：加入装饰音、将动机进行移位等。\n移位有很多种，可以把整个动机移位，也可以把动机中的几个音移位（比如把某个音提高八度，这很有效果）。\n移位分为两种，调内移位（这会改变音程性质）和完全移位（不改变音程性质的移位，会用到非自然音）。\n两次及以上的，同度的移位成为模进。\n修饰重复意义下，模仿不限于八度，可以在任意音程内，不过五度较为常见。\n如果动机的两次重复有时间上的重叠，则称为密接和应。\n镜像（或倒影）\n即将动机以某个音为水平面，将整个动机上下镜像翻转。节奏对于旋律来说可能比音高更为重要，即使翻转了，节奏不变还是能够有较强关联。\n逆行\n将动机左右翻转，第一个音变成最后一个音，依次进行。不如镜像常见，因为会改变节奏，难以辨认关系。\n逆行倒影\n即将倒影和逆行结合，更加难以辨认关系。\n节奏变形\n前文提到节奏比音高稍微重要，变化节奏容易导致动机难以辨认。更多情况下，会对整个动机扩增时值或者缩减时值。\n展开重复 这会导致动机的重大改变，虽然不容易听出来，但是某种意义上更为重要。\n插补\n可以说是加了很多音在动机之中，从而与添加装饰音的修饰重复区分开来。\n裂变\n将动机的一部分拿出来使用。通常会使用动机的头部。\n隐含重复\n十分重要。例如可以隐含在和声的轨迹中。能从一个乐章跨越到另一个乐章。\n单音程动机 只有一个音程的动机，具有高度的可塑性。\n乐句 通常是展示一小段完整的音乐的最短单位（不是书上的定义），通常具有四小节、六小节、八小节长度。每个乐句只有一个功能性的和声进行。可以理解为只有一个终止式。\n分乐句 一个完整的乐句是由两个或更多分乐句组成的，特点是具有断句（句读）。但是有句读不能保证有分乐句，有分乐句也可以没有句读。\n复合乐句 由三个分乐句组成的乐句成为复合乐句。和乐句一样，只有一个结构性的和声进行。\n有两种类型：各分句的和声功能不同；前几个分句都是主和声，最后一个分句是PD、D、T。\n乐段 当一个结论性不强的乐句搭配一个有很强结论意味的乐句时，我们将这种组配单位称之为乐段。通常起句是半终止，结句是正格终止。\n相似乐句、对比乐句\n乐段中的两个乐句彼此间有旋律的相似性，称之为相似乐句。而旋律不同的，称之为对比乐句。\n阻碍乐段\n如果第一乐句的半终止在第二乐句的开头解决到主和弦，则称为阻碍乐段。\n延续乐段\n如果第一乐句的半终止在第二乐句中没有解决，而是延续属功能直到正格终止，则称为延续乐段。\n当然有时也会在半终止后，第二乐句中接预属功能，形成返回相关的属和弦。\n有时也会让第一乐句结束在预属和弦的正格终止上，后接属功能在第二乐句。比如第一乐句结束在ii、IV、vi上（书上没有提到和声的正格终止是什么，估计是vi-ii的终止）。\n分段式乐段\n第一乐句结束在IAC上（亦即旋律未结束在\\(\\hat{1}\\)上），而第二乐句结束在PAC上（亦即旋律结束在\\(\\hat{1}\\)上）。\n进行式乐段\n第二乐句结束在另外一个调上，称为进行式乐段。第一乐句可以是HC或IAC。\n分类与使用频率\n相似阻碍乐段（PIP，常用），对比阻碍乐段（CIP，少用），相似分段乐段（PSP，有时用），对比分段乐段（CSP，有时用），相似延续乐段（PCP，少用），对比延续乐段（CCP，有时用），相似进行乐段（PPP，常用），对比进行乐段（CPP，常用）。\n句式结构 通常由三个更小的部分组成，形成短-短-长（通常比例为1：1：2）的结构，称为句式结构。比如2小节+2小节+4小节的结构。通常是a-a’-b的结构。\n如果b中嵌套了另一个句式，比如4小节的B中嵌套了另一套a-a’-b（1+1+2），那么称为嵌套句式。\n这种句式结构可以替换乐句在乐段中使用。\n复乐段 当一个乐段的起句和结句都能在更小的层面上划分起句与结句，那么称之为复乐段。\n例如一个乐段由4+4的两个乐句组成。而一个复乐段可能更长，由8+8的两个乐句组成，而这两个乐句又可以分为4+4的部分。这个更小的乐句的终止式有很多组合，常见的有HC-HC-HC-PAC、IAC-HC-IAC-PAC等。\n至于为什么不分成两个乐段处理，即是因为只有正格终止足以结束乐段，如果划分为两个乐段可能有一个无法真正的结束。\n非对称乐段 3乐句、5乐句等单数乐句的乐段，称为非对称乐段。\n非对称乐段的各乐句都要用终止式结束，但要弱于最后的终止式。如果最后的终止太弱，都不能称为乐段，只能称为乐句组。\n构建方式：\n立刻重复起句或结句，如aab和abb。 应用新的材料，如abc。 结合上述两种，如aabbc、aabcc。  二段曲式（二部曲式） 二段曲式，说的是一部完整的作品能够解析为两个段落。二段曲式中的两个段落几乎总是标写了重复标记，因此又叫二段-重复曲式。\n虽然书上没有明说，但是这个两个段落指的应该通常是乐段。\n简单式\n当两个段落并未共享旋律材料时，称为简单式。\n分段式\n当第一段结尾的终止式是结束在主和弦上，称为分段式。\n延续式\n第一段结束游离了主和弦，紧接着的段落又延续了这个和弦，称为延续式。\n回旋式\n第二段的旋律材料在开始时与第一段不同，或者称为游离。但在之后又全部或部分的重复第一段的材料，称之为再现。这种结构叫做回旋式。\n平衡式\n可以看作是简单式或者回旋式的修改，第二段的材料不同，但是在最后终止时，采用了第一段的结尾。这称作平衡式。\n变奏曲式 延续变奏 延续变奏组曲中，主题相对简短（通常为一个乐句），留下不完整的效果是为了让每段变奏能浑然一体地接入到下一段变奏。并且往往通过（在时间上）重叠变奏来实现，一段变奏结束的主和弦同时作为下一变奏的开始。或者固定低音趋向V，而下一段变奏解决。\n延续变奏大多是用重复的乐思，称为固定音型，而不是一段抒情的曲调。固定音型为变奏的骨架，在此基础上改变音区、织体以及动机设计。\n固定音型一半出现在下方声部，并能直接作为重复的低音音型，称之为固定低音；重复和声音型，称之为恰空；既重复低音同时又重复和声音型的称之为帕萨卡利亚。通常情况下这三个术语可以互换使用。\n分段变奏 在分段变奏组曲中，主题与各变奏常常是用二段曲式（往往是回旋延续式二段曲式。）结束在本调上，因此他们是彼此分离的。\n在分段变奏组曲中，变奏之间往往会有很大的改变。\n三部曲式 三部曲式具有三部分旋律的设计（ABA或ABA’）以及三部分的调性结构（本调-对比调-本调）。回旋二段曲式虽然也有三部分旋律设计，但是调性结构只有两个部分（实际上书中给的图例说只有一个调）。\n分类 收拢性三部曲式\n假设三部曲式的三个段落各自都结束在其主和弦上，则称为收拢性三部曲式。\n分段性三部曲式\n当A段（不常见）或B段（常见）未在其主和弦上结束且这种收拢性结尾为该段调性运动不可或缺的一部分时，称之为分段性三部曲式。\n延续性三部曲式\n当AB都未结束在主和弦上，称之为延续性三部曲式。\n有时很难区分它和回旋二段曲式。要考虑B部在多大程度上依附于A部。假设没多少关联，则是三部曲式。假如主题或动机有关联且调性很少变化或不变，则二段曲式更合适。\n连接部与回头过渡 为了形成连续感，会写作过门段落。主调与新调之间的过门材料（A到B）称之为连接部。从对比掉返回主调的过门材料称之为回头过渡。\n再现的曲式：复三部曲式 在复三部曲式中，每一段都可以被分为小的二段曲式。\n书上给出的两个例子，两者都是收拢性三部曲式，小的二段曲式都是回旋二段曲式。\n返始咏叹调 是巴洛克时期最重要的三部曲式结构。给出的例子是分段性三部曲式。\n小步舞曲-三声中部曲式 ABA，A是小步舞曲，B是三声中部。\n回旋曲式 概论 可以看做是扩展的三部曲式。\n五段回旋曲式的结构为A1-B-A2-C-A3\n七段的为A1-B1-A2-C-A3-B2-A4\n其中交替循环的A1、A2、A3称为叠部。对比性材料如B、C称为插部。\n通常插部的调和原调不一样。\n古典主义晚期的五段回旋曲式的调性结构为：i-III-i-v-i。书上还给出的结构有I-V-I-i-I。\n七段回旋曲式的典型调性布局：\n大调\nI-V、i或IV-I-i、IV或vi-I-I或i-I\n小调\ni-III或v-i-iv、IV、III、VI或I-i-I-i\n尾声、连接部与回头过渡 在最后可能会出现一个新的段落，并不像是叠部，而仅仅只是用于确认本调并提供一个完美的结束。这一段称之为尾声。\n连接部与回头过渡同三部曲式。\n复回旋曲式 同三部曲式，是在回旋曲式的每一段内部嵌入二段曲式。书上的例子同样嵌入了回旋二段曲式。\n奏鸣曲式 概论 奏鸣曲式不是一套刚性规则，它是一种基本的作曲方式：\n开始的材料在主调上陈述（呈示部） 在对比调上陈述附加材料（展开部） 在主调上重述所有的材料（再现部）  奏鸣曲式的二段模式 奏鸣曲式可以看作是平衡与回旋延续式二段曲式的结合。\n呈示部与再现部根据和声的定义划分成两个部分。\n在第一调域（FTA）中，材料在主调上呈示；在第二调域（STA）中，初始呈示的材料是在对比调中（通常为大调中的V和小调中的III）。\nFTA是基于回旋二段曲式的特性，原材料在游离（展开部）之后返回（再现部），并用半终止中断。\nSTA是基于平衡二段曲式的特点，第二段（STA，往往用新的主题）在第一段（呈示部）结尾处出现，在这首作品（再现部）的结尾处返回主调。\n这就是奏鸣曲原则。\n和声布局是I(FTA)-V(STA)-HC(半终止)-I(FTA)-I(STA)。\n其中呈示部主要成分是FTA，末尾会出现STA（不在本调）。然后进入展开部，继续发展STA，直到一个半终止。之后切换到FTA开始再现部，FTA完成后要在本调上写STA。\n连接部 FTA到STA中往往会有一小段，称之为连接部（Tr），有两种类型：\n非独立连接部（DTr），用重述FTA的初始主题开始。 独立连接部（ITr），用新的主题材料。  这两种类型都是转调到STA并结束在新的主调或新的属调上。\n在再现部中，FTA和STA都保持在主调中，但是连接部可以不用保持，但连接部往往会重现于再现部。\n结尾段 用于结束呈示部。STA后紧接着的终止段，称之为结尾段（Cl）。这个结尾段紧跟着出现了STA中对比性的主体材料，并且是那段和声材料的结论性终止。目的是为了加强新调。结尾段往往长于STA。\n展开部与回头过渡 展开部通常是奏鸣曲式中最自由的段落，类似于二段曲式中的游离。\n回头过渡（RTr）是展开部的最后一个部分，属调准备在再现部中折返到属调。\n再现部与尾声 通常，再现部都会重复许多呈示部的音乐，但它会有一些重要的变化，其中最重要的不仅仅只是FTA的材料，而且还有STA与结尾段的材料并返回到主调。\n尾声出现在再现部之后。它们也可出现在呈示部的结尾，它们在那里被称之为小尾声。\n奏鸣曲式的其他特点与要素 单主题奏鸣曲式\nFTA开始的主题又在STA中出现了。\n缓慢的引子\n有些用奏鸣曲式塑造的乐章带有缓慢的引子，它涉及外来的和声领域、半音调、并结合了混合调式。尤其常见于交响曲中。缓慢的引子通常是开始在主调上（尽管I不太好确立），并最终进行到半终止结束。这种引子听上去像一个巨大的弱拍，要解决到FTA的主调上。\n和声的变异\n假再现\nFTA的主题出现在错误的调中；而真正的再现部是用主调，通常紧随其后。假再现实际上还是发展部的一部分。\n下属返回\n再现部没有从I而是从IV上开始。\n其他各种调性策略 三调呈示部\n常见于大调作品。STA进行到自然三度音的关系调，将传统的I-V分为了两步走，传统意义的属调是在呈示部的结尾才被确立。\n不便于分类的部分 对位转位 从书上看起来和对位法没有关系，故放在这个部分。\n对位转位指的是，声部之间的旋律互相交换出现在后续部分。这能使得作曲家从单一乐思中得到双倍的音乐价值。并且能使音乐保持明晰的统一。\n主要有：八度转位（音程的协和性质不变，并且不协和音的处理在转位中也是正确的。除了五度会被转成四度。）、十二度等等。\n复合旋律 有时会遇到只有一个或两个声部的作品，没有明晰表现的三和弦与七和弦。比如巴赫的作品。\n而不采用完整的和弦也能隐含和声的功效的重要技术之一就是复合旋律。\n通过依靠旋律在音区中的跳进，就能使得一条单线的隐伏配置到有音域划分的多个声部中。比如阿尔贝替低音这样的分解和弦就是一种方法。\n","date":"2022-07-24T13:25:42+08:00","permalink":"https://kegalas.top/p/%E5%AE%8C%E5%85%A8%E9%9F%B3%E4%B9%90%E7%90%86%E8%AE%BA%E6%95%99%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"《完全音乐理论教程》读书笔记"},{"content":" 不均匀分割空间的数据结构 有Oct-Tree，KD-Tree，BSP-Tree。\nOct-Tree是均匀地将一个正方体分为八个小正方体的结构。可以根据物体在某一部分的密度来决定是否往下分。\nKD-Tree是将空间分为两部分，可以是不均匀的。但是分的时候是轴对齐的。\nBSP-Tree也是分为两部分，但分的时候可以不轴对称。\nKD-Tree KD-Tree的要求如下\n对于中间节点，存储：\n分割空间的平面垂直的坐标轴 分割空间的平面在坐标轴上的坐标 指向儿子节点的指针 不存储任何物体的信息  对于叶子节点，存储\n包含的物体列表  层次包围盒(BVH) 这也是一种树，根节点是所有物体的包围盒。\n然后对节点进行分割，使得该节点划分为两个部分，每个部分都是一个包围盒，一个物体仅在一个包围盒中。\n如果一个节点被分割了，它就不再作为含有物体的包围盒。只有叶子节点含有包围盒。\n其中有几个注意事项：\n选择节点中的最长轴，如果物体有沿\\(x\\)轴分布的形状，则在\\(x\\)轴上将物体分为两部分。 分割节点选择在中间的物体。 当一个节点只有很少物体时停止分割  ","date":"2022-07-20T15:09:04+08:00","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"计算机图形学基础学习笔记-数据结构"},{"content":" 三角形网格的细分 Loop细分 Loop Subdivision分为两步\n创建更多三角形（顶点） 改变三角形顶点的位置  创建更多的三角形非常简单，只用将三角形每条边的中点相连，我们就得到了四个三角形。\n对于顶点的位置，新的顶点和老的顶点都需要更改。\n对于新的顶点：\n 1.jpg  对于老的顶点\n 2.jpg  更一般的网格的细分 Catmull-Clark细分 对于不是方形的面和度数（所连边数）不等于4的点要进行细分\n步骤如下：\n在每个面的上添加顶点 在每条边的上添加顶点 连接新顶点  添加的规则如下\n 3.jpg  网格简化 二次误差度量  4.jpg  对于如上图的情况，不应该对顶点求平均值，而应该使得新的顶点到原来顶点的平方距离之和最小\n坍缩边的方法 通过坍缩某些边，然后使边的端点重合在一起，使得三角形减少。\n一个想法是将边的中点进行二次误差度量。\n 5.jpg  一个更好地想法是选择那些拥有最小二次误差的点。可以用优先队列来维护。\n","date":"2022-07-20T15:08:04+08:00","image":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86/cover_hu9da4564469e95373a7893edcdf989008_27817_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86/","title":"计算机图形学基础学习笔记-曲面细分"},{"content":" 有两种方法描述几何：隐式的、显式的。\n几何的隐式表示 取决于某些点是否符合表达式。\n例如描述一个球面\\(x^2+y^2+z^2=1\\)，所有符合这个表达式的点就是一个球面。\n更一般的情况：满足\\(f(x,y,z)=0\\)的所有点。\n它的特点是，采样比较困难，但判断一个点在集合体内外或者在几何体上非常方便。\n隐式表示包含：\n代数方程表示(Algebraic Surfaces) 通过布尔表达式对几何体进行运算(Constructive Solid Geometry) 距离函数(Distance Functions) Blending Distance Functions 水平集(Level Set) 分形(Fractals)  几何的显式表示 所有的点直接给出，或者通过参数映射地给出。\n比如从二维映射到三维\n\\[ f:\\mathbb{R^2\\to R^3};(u,v)\\to(x,y,z) \\]\n特点是，采样简单，但是判断关系较为困难。\n显式表示包含：\n点云(Point Cloud) 多边形网格(Polygon Mesh) 贝赛尔曲线(Bezier Curves)  贝塞尔曲线 Casteljau算法\n考虑平面上的三个点\\(b_0,b_1,b_2\\)，用线性差值的办法插入一个点到每一条边上。\n 1.jpg  将新增的两个点再利用相同的办法插入一个点。\n 2.jpg  然后对于插值的比例值\\([0,1]\\)上的所有点进行这个算法。\n 3.jpg  对于更多点，因为每次在边上进行插值后，新的点比原来的点少一个，反复进行这个算法直到只有一个点。\n 4.jpg  将这个过程公式化，对于三个点的情况，即为\n\\[ b_0^1(t)=(1-t)b_0+tb_1\\\\ b_1^1(t)=(1-t)b_1+tb_2\\\\ b_0^2(t)=(1-t)b_0^1+tb_1^1 \\]\n\\[ \\therefore b_0^2(t) = (1-t)^2b_0+2t(1-t)b_1+t^2b_2 \\]\n对于更多点的情况：\n\\[ b^n(t) = b^n_0(t)=\\sum^n_{j=0}b_jB^n_j(t) \\]\n其中\n\\[ B^n_i(t)=\\binom{n}{i}t^i(1-t)^{n-1} \\]\n也可以用递归的方法计算，比较简便。\n贝赛尔曲线的一些性质\n\\(t=0\\)是起点，\\(t=1\\)是终点。 曲线与端点段相切 仿射变换中，对控制点仿射变换再画曲线，和对已经画出来的曲线做仿射变换，得到的曲线是一样的。 曲线一定在控制点的凸包内  分段的贝赛尔曲线及其算法\n四个顶点构成的贝赛尔曲线为一段，再将许多贝赛尔曲线接到一起。\n这样的曲线一定是连续的，但光滑还有一个条件。即第一条曲线的第3、4个点的线段和第二条曲线的第1、2个点的线段长度、方向均相同。\n样条(Spline) TODO\n贝塞尔曲面 对于\\(4\\times 4\\)的控制点，首先在\\(u\\)方向上画出四条贝赛尔曲线，然后再在\\(v\\)方向上，根据四条贝塞尔曲线计算出四个控制点，再计算出曲面上的点。\n","date":"2022-07-20T13:47:39+08:00","image":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%A0%E4%BD%95%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/cover_hu6f2ff40bfc84c7f47df65f54ecbd43e8_39003_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%A0%E4%BD%95%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/","title":"计算机图形学基础学习笔记-几何的表示方法"},{"content":" 纹理映射 纹理映射流程如下\n对于每个光栅化的屏幕采样点\\((x,y)\\)（通常是像素的中心点）\n令\\((u,v)\\)为纹理上对应于\\((x,y)\\)的坐标 对纹理上\\((u,v)\\)进行采样 将采样得到的颜色作为光栅化需要使用的颜色  纹理映射函数 从世界坐标\\((x,y,z)\\)映射到纹理坐标\\((u,v)\\)的函数。\n平面投影\n直接忽略掉\\(z\\)坐标（或者根据理解，是忽略掉法向量那个方向的坐标）（世界空间是\\([-1,1]^3\\)）：\n\\[ \\phi(x,y,z)=(u,v)\\quad where\\quad \\begin{bmatrix} u \\\\ v \\\\ * \\\\ 1 \\end{bmatrix}=M_t \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix} \\]\n其中，\\(M_t\\)是一个仿射变换矩阵，而星号代表我们不在乎这个坐标。\n这个映射对于比较平的面的效果较好，但是对于一些闭合曲面（例如一个正方体）效果不佳。\n用透视投影替代正交投影，我们可以得到一个投影的纹理坐标\n\\[ \\phi(x,y,z)=(\\tilde{u}/\\omega,\\tilde{v}/\\omega)\\quad where\\quad \\begin{bmatrix} \\tilde{u} \\\\ \\tilde{v} \\\\ * \\\\ \\omega \\end{bmatrix}=P_t \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix} \\]\n其中矩阵\\(P_t\\)代表着一个投影变换。这个投影纹理坐标在阴影贴图中有重要的作用。\n球体坐标\n从球体上的点\\((x,y,z)\\)映射到纹理上\\((u,v)\\)，假设球心在原点，并且世界空间是\\([-1,1]^3\\)，则因为\n\\[ x = rcos\\phi sin\\theta\\\\ y = rsin\\phi sin\\theta\\\\ z = rcos\\theta \\]\n有\n\\[ \\theta = acos(z/\\sqrt{x^2+y^2+z^2})\\\\ \\phi = atan2(y,x) \\]\n再转化为\\((u,v)\\)的形式，有：\n\\[ \\phi(x,y,z) = ([\\pi+atan2(y,x)]/2\\pi,[\\pi-acos(z/||x||)]/\\pi) \\]\n圆柱体坐标\n世界空间是\\([-1,1]^3\\)，圆柱体中心在原点\n\\[ \\phi(x,y,z)=([\\pi+atan2(y,x)]/2\\pi,[1+z]/2) \\]\n注，Fundamentals Of Computer Graphics中写的是\\(\\phi(x,y,z)=(\\frac{1}{2\\pi}[\\pi+atan2(y,x)]/2\\pi,\\frac{1}{2}[1+z])\\)，怀疑有误。\n纹理放大 双线性插值 现在假设纹理上需要采样的点的坐标为(x,y)，显然这个点会落在某个\\(2\\times2\\)的像素矩形中。\n设左下角的像素为\\(u_{00}\\)，左上\\(u_{01}\\)，右下\\(u_{10}\\)，右上\\(u_{11}\\)\n设左下角像素中心点为原点建立坐标系。横轴记为s,纵轴记为t。则\\(u_{00}=(0,0)\\),\\(u_{10}=(1,0)\\),\\(u_{01}=(0,1)\\),\\(u_{11}=(1,1)\\)\n记采样点(x,y)在这个坐标系下的坐标为\\((s,t)\\)\n设函数\\(lerp(x,v_0,v_1)=v_0+x(v_1-v_0)\\)\n这个函数的意义是，假设直线上两个点的值为\\(v_0,v_1\\)，\\(x\\)为这两个点间的坐标，\\(x\\)在\\(x_0\\)处等于\\(0\\)，在\\(x_1\\)处等于\\(1\\)。此时所得的函数值为\\(x\\)处的插值。\n现在我们可以对\\((s,t)\\)这个点进行插值，首先定义\n\\[ u_0 = lerp(s,u_{00},u_{10}) u_1 = lerp(s,u_{01},u_{11}) \\]\n得到这两个点后再进行一次插值得\n\\[ f(x,y) = lerp(t,u_0,u_1) \\]\n当然也可以先进行垂直的插值，再水平插值。\n双立方插值 TODO\n纹理缩小 Mipmap 当一个像素代表了纹理中的一大块时，需要进行纹理缩小。\n之前介绍的超采样等是可以使用的，只不过这样会导致开销过大。\n我们需要找到一种办法直接对区间求平均值。\n引入Mipmap的概念。它允许快速的、近似的（而非准确的）、方形的范围均值查询。\n假设第0层是原纹理图像（方形）。\n则第1层是将长宽各缩小为一半，所所放出来的纹理。第2层则为第1层缩小一半，以此类推直到只有一个像素。\n额外占用的存储空间只有原纹理的\\(1/3\\)。\n我们要计算应该使用第几层，首先确定我们要光栅化的像素的坐标(x,y)，然后将其对应到纹理上的坐标记为\\((u,v)\\)。\n找到它的邻居像素，例如右边像素，然后如图进行计算。\n 1.jpg  存在的一个问题就是，层数是不连续的，但我们的空间是连续的。所以每一层mipmap在纹理映射时会出现块状的、不连续的现象。\n三线性插值 为了解决mipmap不连续的现象，引入三线性插值。\n在\\(D\\)层进行双线性插值 在\\(D+1\\)层进行双线性插值 对\\(D,D+1\\)层进行一次线性插值  Mipmap的缺陷 相较于超采样，在远处会出现模糊现象。原因在于，只能查询一个方形取余、近似的、以及是插值得到的。\n解决（部分的）办法：各向异性过滤。\n比各向异性过滤更好的：EWA过滤。\n纹理的应用 环境光贴图 将整个环境做成贴图，可以给比较镜面光滑的物体使用，使之反射出环境的样子。\n除了保存成方形的贴图，还可以保存在球面上。\n保存在球面上带来的问题是，越靠近上下的地方，越会出现变形。此时可以将球上的点映射到一个立方体上，来解决这种变形。\n 2.jpg  法线贴图 储存一个相对高度，从而改变某一点的法线，从而改变光照效果，从而实现凹凸不平的视觉效果。\n新的法向量的计算方法：\n二维情况：\n假设原来\\(p\\)点的法向量\\(n(p)=(0,1)\\)。\n将\\(p\\)点通过法线贴图的相对高度移到对应位置，则\\(p\\)点此时的导数为\\(dp=c[h(p+1)-h(p)]\\)，其中\\(c\\)是常数，\\(h(x)\\)是高度函数。\n则新的法向量为\\(n(p)=(-dp,1).normalized()\\)\n三维情况\n原始法向量为\\(n(p)=(0,0,1)\\)\n导数为\n\\[ \\frac{dp}{du} = c_1[h(u+1)-h(u)] \\]\n\\[ \\frac{dp}{dv} = c_2[h(v+1)-h(v)] \\]\n新的法向量为\\((-dp/du,-dp/dv,1)\\)\n法向量的一般情况\n对于原法向量为\\(\\bm n=(x,y,z)\\)的，首先令\n\\[ \\bm t = \\left(\\frac{xy}{\\sqrt{x^2+z^2}},\\sqrt{x^2+z^2},\\frac{zy}{\\sqrt{x^2+z^2}}\\right) \\]\n\\[ \\bm b = \\bm n\\times\\bm t \\]\n\\[ TBN = [\\bm{t,b,n}] \\]\n\\[ dU = kh\\cdot kn\\cdot(h(u+1/w,v)-h(u,v)) \\]\n\\[ dV = kh\\cdot kn\\cdot(h(u,v+1/h)-h(u,v)) \\]\n其中\\(kh,kn\\)是常数，\\(h(u,v)\\)是高度函数,\\(h,w\\)是纹理的高度和宽度。\n\\[ \\bm{ln} = (-dU,-dV,1) \\]\n那么最终得到的法向量为\n\\[ \\bm n = normalize(TBN\\cdot \\bm{ln}) \\]\n将法线的XYZ坐标以RGB的形式存储\n有些法线贴图会将法线的xyz坐标以RGB的形式存储。要得到\\([-1,1]\\)上的法线方向坐标，要经过两次转换。首先将\\(0\\sim 255\\)的\\(RGB\\)换到\\([0,1]\\)的形式，然后再转换到\\([0,1]*2-1=[-1,1]\\)。\n这在有些时候比从模型中顶点的法向量来插值计算内部点的法向量要更有细节。\n切线空间存储法向量\n在切线空间存储法向量时，会直接存储某个值的值作为颜色（当然也要转化到\\([-1,1]\\)），我们要做的就是计算出切线空间的基，然后将其转化为世界坐标中的法向量。\n对于一个三角形上的三个点\\(p_0,p_1,p_2\\)，以及这个三角形的法向量\\(\\bm n\\)。设\\(u_0,u_1,u_2\\)分别为三个点的纹理上的\\(u\\)坐标，\\(v_0,v_1,v_2\\)为\\(v\\)坐标。那么就有\n\\[ \\bm i = A^{-1}\\begin{pmatrix} u_1-u_0 \\\\ u_2-u_0 \\\\ 0 \\end{pmatrix} \\]\n\\[ \\bm j = A^{-1}\\begin{pmatrix} v_1-v_0 \\\\ v_2-v_0 \\\\ 0 \\end{pmatrix} \\]\n其中\n\\[ A = \\begin{pmatrix} \\overrightarrow{p0p1} \\\\ \\overrightarrow{p0p2} \\\\ \\bm n \\end{pmatrix} \\]\n之后切线空间的基就是\\((\\bm i,\\bm j,\\bm n)\\)，将其乘以纹理中提取到的值，就得到世界坐标中的法向量。\n位移贴图 与法线贴图类似，但是位移贴图真正地移动了顶点的位置，很多时候比法线贴图真实。\n噪声 TODO\n对纹理进行环境光预处理 TODO\n3D贴图和体积渲染 TODO\n阴影贴图 将光源也当作一个相机，进行光栅化，只计算zbuffer的信息。\n然后在相机光栅化时，判断两个zbuffer是否相等，相等才能被相机和光源看见。不相等的则在阴影中。\n","date":"2022-07-14T16:53:03+08:00","image":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%B4%E5%9B%BE/cover_hu19fc7c044e05b48ede368f76a4a534a3_160946_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%B4%E5%9B%BE/","title":"计算机图形学基础学习笔记-贴图"},{"content":" 点光源 假设点光源的光的强度（能流密度）是\\(E=I\\)，由于点光源向外发送能量是以球面波的形式发送。在距离光源\\(r\\)处的波面上，光的强度是\\(E=\\frac{I}{r^2}\\)。这一点与大学物理相同。\nBlinn-Phong反射模型 首先给出以下定义：\n对于某个物体上需要被着色的某一点。其单位法向量为\\(\\bm n\\)，这一点指向相机的单位向量为\\(\\bm v\\)，指向光源的向量为\\(\\bm l\\)。\n漫反射 漫反射意味着，从四面八方看过来，这个位置的颜色是一致的。\n我们主要关注，这个位置与光源的角度关系，从而得出这个点的颜色。\nLambert’s cosine law\n假设光源到达这个点的强度是\\(E=I\\)，那么经过漫反射后，其强度变为\\(E=Icos\\theta\\)，即\\(E=I\\cdot\\bm l\\cdot\\bm n\\)\n结合点光源，以及漫反射系数，可得\n\\[ L_d=k_d(\\frac{I}{r^2})max(0,\\bm n\\cdot\\bm l) \\]\n其中，\\(k_d\\)是漫反射系数，与材质有关。\\(I\\)是点光源的强度，\\(r\\)是点光源到需要着色的点的距离。后面max的作用是，防止从“内部”或者“下面”射来的光线影响了“表面”的颜色。\n通常，\\(k_d\\)是一个三维向量，如果将纹理颜色赋值给\\(k_d\\)，则会起到给模型贴纹理的效果。\n\\(L_d\\)和\\(I\\)也是三维向量，\\(I\\)不仅可以代表光的强度，也可以表示光的颜色。\\(k_d\\)与\\(I\\)的乘法是元素之间相乘。在Eigen中使用cwiseProduct函数。\n镜面反射 即，某些材质中，反射角等于入射角，或者反射角很接近入射角时，出现的光强明显大于其他角度的情况。\n此时\\(\\bm v\\)非常接近反射角，或者有，半程向量非常接近于法向量\\(\\bm n\\)。\n半程向量即是\\(\\bm l,\\bm n\\)的角平分线的单位向量。有\n\\[ \\bm h = \\frac{\\bm v+\\bm l}{||\\bm v+\\bm l||} \\]\n此时相机收到的光强为\n\\[ L_s = k_s(\\frac{I}{r^2})max(0,\\bm n\\cdot\\bm h)^p \\]\n其中\\(k_s\\)是镜面反射系数，\\(p\\)决定了\\(\\bm v\\)和反射角有多接近才算能触发镜面反射。\\(p\\)越大触发镜面反射的角度范围越小。通常会取到\\(100\\)以上。\n\\(k_s,L_s,I\\)仍然是三维向量，乘法规则同前，只不过这里的\\(k_s\\)通常会采用比较亮的白色，而不会采用其他颜色。\n环境光反射 即通过整个环境其他物体的反射，再次射入该物体，给该物体提供亮度。\n在Blinn-Phong模型中，我们选择添加常数的亮度。\n\\[ L_a = k_aI_a \\]\n\\(k_a\\)是环境光反射常数。\n\\(k_a,L_s,I\\)仍然是三维向量，乘法规则同前，只不过这里的\\(k_s\\)通常会采用比较暗的白色，而不会采用其他颜色。\n注意，有多个光源时，不要重复添加环境光反射。\n三个反射混合 \\[ L = L_a+L_d+L_s \\]\n","date":"2022-07-13T21:49:11+08:00","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/","title":"计算机图形学基础学习笔记-光照模型"},{"content":" 光栅化 线段绘制 对于一条给定线段\n\\[ f(x,y)\\equiv(y_0-y_1)x+(x_1-x_0)y+x_0y_1-x_1y_0=0 \\]\n假设\\(x_0\\leq x_1\\)，否则交换两个点。\n设\n\\[ m=\\frac{y_1-y_0}{x_1-x_0} \\]\n下面的讨论建立在\\(m\\in (0,1]\\)上，其他的取值情况类似。\n给出伪代码如下\ny=y0 for x=x0 to x1 do draw(x,y) if(some condition) then y = y+1  其中\\(x,y\\)都取整数。\n一种判断\\(y=y+1\\)的方法是，假设当前画出来的点的坐标（而不是序号下标）是\\((x,y)\\)（根据本书的规则，左下角的像素的中心点是原点），则下一个要画的点只有两种情况，要么是右边的点，要么是右上角的点。即\\((x+1,y),(x+1,y+1)\\)，我们取中点，即\\((x+1,y+0.5)\\)，如果直线在这个点的下方，则画右边的点；如果直线在这个点的上方，则画右上方的点。\n如果直线在上方（或者点在下方），那么\\(f(x+1,y+0.5)\u0026lt;0\\)，在下方则大于0.如果刚好等于零，可以任意画。\n所以可以写伪代码如下\nif f(x+1,y+0.5)\u0026lt;0 then y=y+1 对于这个算法有优化的办法。主要是针对每次都要调用\\(f\\)计算来进行的优化。\n注意到我们可能计算过\\(f(x-1,y+0.5),f(x-1,y-0.5)\\)，并且我们有\n\\[ f(x+1,y)=f(x,y)+(y_0-y_1) \\]\n\\[ f(x+1,y+1) = f(x,y)+(y_0-y_1)+(x_1-x_0) \\]\n有如下伪代码\ny = y0 d = f(x0+1,y0+0.5) for x = x0 to x1 do draw(x,y) if d\u0026lt;0 then y = y+1 d = d+(x1-x0)+(y0-y1) else d = d+(y0-y1) 三角形绘制 高洛德插值(Gouraud Interpolation)\n运用重心坐标系，我们可以对颜色进行插值。\n假设三个点的颜色值分别为\\(\\bm c_0,\\bm c_1,\\bm c_2\\)。假设我们要绘制的点的重心坐标为\\((\\alpha,\\beta,\\gamma)\\)，则其颜色为\n\\[ \\bm c = \\alpha\\bm c_0+\\beta\\bm c_1+\\gamma\\bm c_2 \\]\n暴力光栅化算法\n伪代码如下\nfor all x do for all y do compute(alpha,beta,gamma) for (x,y) if(alpha,beta,gamma in [0,1]) then c = alpha*c0+beta*c1+gamma*c2 drawpixel(x,y) with color c 优化后的算法\nxMin = floor(xi) xMax = ceiling(xi) yMin = floor(yi) yMax = ceiling(yi) for y = yMin to yMax do for x = xMin to xMax do alpha = f12(x,y)/f12(x0,y0) beta = f20(x,y)/f20(x1,y1) gamma = f01(x,y)/f01(x2,y2) if(alpha,beta,gamma\u0026gt;0) then c=alpha*c0+beta*c1+gamma*c2 drawpixel(x,y) with color c 其中的\\(f_{ij}\\)为\n\\[ f_{01}(x,y) = (y_0-y_1)x+(x_1-x_0)y+x_0y_1-x_1y_0\\\\ f_{12}(x,y) = (y_1-y_2)x+(x_2-x_1)y+x_1y_2-x_2y_1\\\\ f_{20}(x,y) = (y_2-y_0)x+(x_0-x_2)y+x_2y_0-x_0y_2 \\]\n对于公共边上的点的处理\nxMin = floor(xi) xMax = ceiling(xi) yMin = floor(yi) yMax = ceiling(yi) fAlpha = f12(x0,y0) fBeta = f20(x1,x1) fGamma = f01(x2,y2) for y = yMin to yMax do for x = xMin to xMax do alpha = f12(x,y)/fAlpha beta = f20(x,y)/fBeta gamma = f01(x,y)/fGamma if(alpha,beta,gamma\u0026gt;=0) then if(alpha\u0026gt;0 or fAlpha*f12(-1,-1)\u0026gt;0)and (beta\u0026gt;0 or fBeta*f20(-1,-1)\u0026gt;0)and (gamma\u0026gt;0 or fGamma*f01(-1,-1)\u0026gt;0) then c=alpha*c0+beta*c1+gamma*c2 drawpixel(x,y) with color c 用Z-Buffer处理覆盖问题 为了处理方便，假设\\(z\\)始终为正，且更小的\\(z\\)意味着更近，更大的\\(z\\)意味着更远。\n算法如下\n首先给\\(z-buffer\\)赋值无限大。\n在光栅化过程中，执行如下伪代码\nfor (each triangle T) for (each sample (x,y,z) in T) if(z\u0026lt;zbuffer[x,y]) framebuffer[x,y] = rgb; zbuffer[x,y] = z; else ; 即为，对每个三角形的采样像素，如果他的深度坐标，即\\(z\\)更小，那么在缓冲区更新这个像素的颜色，并且更新最小的\\(z\\)。\n该算法的复杂度是\\(O(n)\\)，对于\\(n\\)个三角形。\n着色频率的问题（Shading Frequencies） 对每个平面着色 又叫Flat着色。\n对每个顶点着色 又叫Gouraud着色。\n一个顶点的单位法向量，可以由以这个点为顶点的所有三角形的法向量求出。\n\\[ N_v=\\frac{\\sum_iN_i}{||\\sum_iN_i||} \\]\n然后这个单位法向量可以用于Blinn-Phong反射模型中。\n再之后，对于平面内的点的着色，需要使用插值算法。\n对每个片元（像素）着色 又称Phong着色。\n对于每个像素的单位法向量，假设我们已经知道顶点的法向量，我们可以采用重心坐标插值的算法来计算出每个像素的单位法向量。\n图形管线的工作流程 程序输入顶点 将顶点在屏幕中定位 根据顶点在屏幕中定位三角形 根据三角形进行光栅化 对于光栅化后的片元进行着色 输出到帧缓冲，最后输出到屏幕。  ","date":"2022-07-03T15:21:12+08:00","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%89%E6%A0%85%E5%8C%96%E4%B8%8E%E7%9D%80%E8%89%B2%E9%A2%91%E7%8E%87/","title":"计算机图形学基础学习笔记-光栅化与着色频率"},{"content":" 分辨率与坐标 假设屏幕分辨率是\\(n_x\\times n_y\\)，则，按照本书的规则，左下角的像素的中心点定为原点，那么有坐标范围为\\([-0.5,n_x-0.5]\\times [-0.5,n_y-0.5]\\)。若按照games101的规则，则坐标范围为\\([0,n_x]\\times[0,n_y]\\)。\nRGB格式 出于方便目的，RGB的三个分量的取值范围都是\\([0,1]\\)。在具体实现时，如8-bit图片，每个分量的所有可能的取值为\\(0,1/255,2/255,\\)\\(\\cdots,254/255,1\\)。\n","date":"2022-07-03T15:05:15+08:00","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%89%E6%A0%85%E5%8C%96%E5%9B%BE%E5%83%8F%E7%9A%84%E6%A0%87%E5%87%86/","title":"计算机图形学基础学习笔记-光栅化图像的标准"},{"content":"在MSYS2中安装程序时遇到如下问题：\nerror: mingw-w64-x86_64-mpc: signature from \u0026#34;David Macek \u0026lt;david.macek.0@gmail.com\u0026gt;\u0026#34; is unknown trust 尝试通过https://packages.msys2.org/中提供的方法，安装了key，解决问题。\n或者直接输入pacman -S msys2-keyring\n","date":"2022-07-01T12:05:59+08:00","permalink":"https://kegalas.top/p/msys2%E6%8A%A5%E9%94%99david-macek-is-unknown-trust/","title":"MSYS2报错David Macek is unknown trust"},{"content":" Viewing Transformations 视口变换（Viewport Transformation） 将\\([-1,1]^2\\)的正方形映射到屏幕上。这个屏幕宽\\(n_x\\)像素，高\\(n_y\\)像素。并且由于左下角像素中心点位置为原点，我们要有负0.5个像素，即映射到\\([-0.5,n_x-0.5]\\times[-0.5,n_y-0.5]\\)。（注，在games101中映射到的是\\([0,n_x]\\times[0,n_y]\\)）\n需要如下变换\n\\[ \\begin{bmatrix} x_{screen} \\\\ y_{screen} \\\\ 1 \\end{bmatrix}= \\begin{bmatrix} n_x/2 \u0026amp; 0 \u0026amp; (n_x-1)/2\\\\ 0 \u0026amp; n_y/2 \u0026amp; (n_y-1)/2\\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} x_{canonical}\\\\ y_{canonical}\\\\ 1 \\end{bmatrix} \\]\n三维形式有\n\\[ M_{vp}= \\begin{bmatrix} n_x/2 \u0026amp; 0 \u0026amp; 0 \u0026amp; (n_x-1)/2\\\\ 0 \u0026amp; n_y/2 \u0026amp; 0 \u0026amp; (n_y-1)/2\\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp;0\\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\]\n正交投影变换（Orthographic Projection Transformation） 将一个\\([l,r]\\times[b,t]\\times[f,n]\\)矩阵变换到\\([-1,1]^3\\)。\n其中\\(l\\)即left是\\(x\\)坐标小的平面，\\(r\\)即right是\\(x\\)坐标大的平面。\n其中\\(b\\)即bottom是\\(y\\)坐标小的平面，\\(t\\)即top是\\(y\\)坐标大的平面。\n其中\\(f\\)即far是\\(z\\)坐标小的平面，\\(n\\)即near是\\(z\\)坐标大的平面。\n注意\\(z\\)可能与常识不太相同，因为我们的相机所看的方向是\\(-z\\)方向。\n这也导致了OpenGL使用左手坐标系。\n完成这个变换的矩阵是\n\\[ \\begin{bmatrix} \\frac{2}{r-l} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; \\frac{2}{t-b} \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; \\frac{2}{n-f} \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; -\\frac{r+l}{2}\\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; -\\frac{t+b}{2}\\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; -\\frac{n+f}{2}\\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}= \\]\n\\[ \\begin{bmatrix} \\frac{2}{r-l} \u0026amp; 0 \u0026amp; 0 \u0026amp; -\\frac{r+l}{r-l}\\\\ 0 \u0026amp; \\frac{2}{t-b} \u0026amp; 0 \u0026amp; -\\frac{t+b}{t-b}\\\\ 0 \u0026amp; 0 \u0026amp; \\frac{2}{n-f} \u0026amp; -\\frac{n+f}{n-f}\\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\]\n相机变换（Camera Transformation） 首先知道三个向量：\n\\(\\bm e\\)，相机位置（eye position）向量 \\(\\hat{\\bm g}\\)，相机视线（gaze）方向。 \\(\\hat{\\bm t}\\)，相机头顶方向。（和视线方向正交）  我们要将相机位置变换到原点，将视线方向定为\\(-z\\)方向，头顶方向为\\(y\\)方向。同时所有物体都跟随相机变换，最终结果相机看到的画面不变。\n首先，显然的，将相机位置变换到原点的矩阵是\n\\[ T_{view} \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; -x_e\\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; -y_e\\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; -z_e\\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\]\n然后对两个另外两个向量进行旋转，直接想不太方便，可以反过来由\\(z\\)和\\(y\\)变换到\\(-\\hat g\\)和\\(\\hat t\\)，\\(x\\)变换到\\(\\hat g\\times \\hat t\\)\n\\[ R_{view}^{-1}= \\begin{bmatrix} x_{\\hat g\\times \\hat t} \u0026amp; x_{\\hat t} \u0026amp; x_{-\\hat{g}} \u0026amp; 0\\\\ y_{\\hat g\\times \\hat t} \u0026amp; y_{\\hat t} \u0026amp; y_{-\\hat{g}} \u0026amp; 0\\\\ z_{\\hat g\\times \\hat t} \u0026amp; z_{\\hat t} \u0026amp; z_{-\\hat{g}} \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\]\n然后再得到逆变换，由于这是个正交矩阵，逆矩阵就是转置矩阵\n\\[ R_{view}= \\begin{bmatrix} x_{\\hat g\\times \\hat t} \u0026amp; y_{\\hat g\\times \\hat t} \u0026amp; z_{\\hat g\\times \\hat t} \u0026amp; 0\\\\ x_{\\hat t} \u0026amp; y_{\\hat t} \u0026amp; z_{\\hat t} \u0026amp; 0\\\\ x_{-\\hat{g}} \u0026amp; y_{-\\hat{g}} \u0026amp; z_{-\\hat{g}} \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\]\n另一种算法\n假设我们初始时相机在\\((0,0,0)\\)，相机视线方向为\\((0,0,1)\\)，相机的上方向为\\((0,1,0)\\)。\n此时相机变换到\\(e\\)，我们保持相机上向量相对不变，而左向量\\(x\\)轴方向就为\\(\\hat r=((\\hat g-e)\\times (0,1,0)).normalized\\)，从而新的上方向则变为\\(\\hat t=(\\hat g-e)\\times\\hat r\\)。\n如果想改变上方向，则就把初始的上方向改变即可，整个变换矩阵同上。\n透视投影（Perspective Projection） 由正交投影变换到透视投影，矩阵如下\n\\[ P= \\begin{bmatrix} n \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; n \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; n+f \u0026amp; -fn\\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} \\]\n直观上的理解就是，将视锥中远平面压小到等于近平面。\n以上是games101的解释。\n在Real-Time Rendering的解释中，假设我们的相机在原点，我们想将任意一个点\\(p\\)，映射到平面\\(z=-d(d\u0026gt;0)\\)上，得到一个新点\\(q=(q_x,q_y,-d)\\)。显然根据相似三角形，我们有\n\\[ \\frac{q_x}{p_x}=\\frac{-d}{p_z}\\Rightarrow q_x = -d\\frac{p_x}{p_z} \\]\n对于\\(y\\)坐标也是同样的，所以能得到矩阵\n\\[ P_p = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; -1/d \u0026amp; 0 \\end{bmatrix} \\]\n因为\n\\[ q=P_pp= \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; -1/d \u0026amp; 0 \\end{bmatrix} \\begin{bmatrix} p_x \\\\ p_y \\\\ p_z \\\\ 1 \\end{bmatrix}= \\begin{bmatrix} p_x \\\\ p_y \\\\ p_z \\\\ -p_z/d \\end{bmatrix}\\Rightarrow \\begin{bmatrix} -dp_x/p_z \\\\ -dp_y/p_z \\\\ -d \\\\ 1 \\end{bmatrix} \\]\n但我们通常要做的不是把点都映射到一个平面上，而是要把视锥压缩到一个\\([-1,1]^3\\)的立方体上。\n这个视锥体是一个四棱椎，相机在椎顶，近平面\\(n\\)，远平面\\(f\\)，有\\(0\u0026gt;n\u0026gt;f\\)。因此四棱锥被截成了四棱台。以相机的角度，上下侧面分别为\\(t,b\\)，左右侧面分别为\\(l,r\\)。\n对于近平面，左下角是\\((l,b,n)\\)，右上角是\\((r,t,n)\\)，决定了我们能看到的画面的大小，或称作视野范围。\n将这样的视锥变为\\([-1,1]^3\\)的矩阵是\n\\[ P_p=\\begin{bmatrix} \\frac{2n}{r-l} \u0026amp; 0 \u0026amp; -\\frac{r+l}{r-l} \u0026amp; 0\\\\ 0 \u0026amp; \\frac{2n}{t-b} \u0026amp; -\\frac{t+b}{t-b} \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; \\frac{f+n}{f-n} \u0026amp; -\\frac{2fn}{f-n}\\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} \\]\n也正好和上方games101的正交投影矩阵*透视投影矩阵相同。\n然后，不在\\(n,f\\)平面之间的物体将会被剔除，不被渲染。\n如果远平面是无穷远，那么有\n\\[ P_p=\\begin{bmatrix} \\frac{2n}{r-l} \u0026amp; 0 \u0026amp; -\\frac{r+l}{r-l} \u0026amp; 0\\\\ 0 \u0026amp; \\frac{2n}{t-b} \u0026amp; -\\frac{t+b}{t-b} \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; -2n\\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} \\]\nOpenGL中的透视矩阵\n虽然都是右手系，但是OpenGL中zNear和zFar都是正数，透视矩阵就变为\n\\[ P_p=\\begin{bmatrix} \\frac{2n}{r-l} \u0026amp; 0 \u0026amp; \\frac{r+l}{r-l} \u0026amp; 0\\\\ 0 \u0026amp; \\frac{2n}{t-b} \u0026amp; \\frac{t+b}{t-b} \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; -\\frac{f+n}{f-n} \u0026amp; -\\frac{2fn}{f-n}\\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\]\n另外，OpenGL默认（指glm库）有\\(r=-l,t=-d\\)，就有\n\\[ P_p=\\begin{bmatrix} c/a \u0026amp; 0 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; c \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; -\\frac{f+n}{f-n} \u0026amp; -\\frac{2fn}{f-n}\\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\end{bmatrix} \\]\n其中\\(a\\)是显示分辨率的宽高比，\\(c\\)是\\(1/tan(fovY/2)\\)\n另外，将\\(z\\)轴上的\\([-0.1,-100]\\)映射到\\([-1,1]\\)上，不是均匀的，不精确的说，可能\\([-0.1+,1.0]\\)这一段映射到了\\([-1,0.5]\\)上，剩下的\\([1.0,100]\\)映射到了\\([0.5,1]\\)上，这在zbuffer、深度值中可能是需要注意的事。\n可以看https://learnopengl-cn.github.io/04 Advanced OpenGL/01 Depth testing/#_3了解具体的关系。\n视野（Field-of-View） 通常，对于近平面，我们可以用\\(l,r,b,t\\)描述（假设\\(l=-r,b=-t\\)，即平面中心位于\\(-z\\)轴上，且平面与\\(-z\\)垂直），也可以用垂直视野\\(fovY\\)和近平面的宽高比来表示。\n首先相机到近平面的距离为\\(|n|\\)，则有如下关系\n\\[ tan\\frac{fovY}{2} = \\frac{t}{|n|} \\]\n\\[ aspect = \\frac{r}{t} \\]\n","date":"2022-06-28T12:14:24+08:00","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%A7%86%E8%A7%92/","title":"计算机图形学基础学习笔记-视角"},{"content":" 放缩 \\[ scale(s_x,s_y)= \\begin{bmatrix} s_x \u0026amp; 0\\\\ 0 \u0026amp; s_y \\end{bmatrix} \\]\n\\[ \\begin{bmatrix} s_x \u0026amp; 0\\\\ 0 \u0026amp; s_y \\end{bmatrix} \\begin{bmatrix} x\\\\ y \\end{bmatrix}= \\begin{bmatrix} s_xx\\\\ s_yy \\end{bmatrix} \\]\n例如长宽各缩小为0.5倍，有\n\\[ scale(0.5,0.5)= \\begin{bmatrix} 0.5 \u0026amp; 0\\\\ 0 \u0026amp; 0.5 \\end{bmatrix} \\]\n切变 切变，想象一个由四根木条和四个钉子组装而成的正方形，我们可以将其“推”成一个平行四边形。但是在图形学中，长和高不变，意味着有两条边的长度会发生变化。\n\\[ shear-x(s)=\\begin{bmatrix} 1 \u0026amp; s\\\\ 0 \u0026amp; 1 \\end{bmatrix}, shear-y(s)=\\begin{bmatrix} 1 \u0026amp; 0\\\\ s \u0026amp; 1 \\end{bmatrix} \\]\n另外一种关于切变的理解是，仅仅对着x坐标或者y坐标进行了旋转操作，例如正向旋转（逆时针）\\(\\phi\\)，则有\n\\[ \\begin{bmatrix} 1 \u0026amp; tan\\phi\\\\ 0 \u0026amp; 1 \\end{bmatrix} or \\begin{bmatrix} 1 \u0026amp; 0\\\\ tan\\phi \u0026amp; 1 \\end{bmatrix} \\]\n旋转 顺时针转过\\(\\phi\\)，则\n\\[ rotate(\\phi) = \\begin{bmatrix} cos\\phi \u0026amp; -sin\\phi\\\\ sin\\phi \u0026amp; cos\\phi \\end{bmatrix} \\]\n镜像 即关于\\(x\\)轴或\\(y\\)轴将整个图像颠倒过来，有\n\\[ reflect-y = \\begin{bmatrix} -1 \u0026amp; 0\\\\ 0 \u0026amp; 1 \\end{bmatrix}, reflect-x = \\begin{bmatrix} 1 \u0026amp; 0\\\\ 0 \u0026amp; -1 \\end{bmatrix} \\]\n线性变换的复合 对于两个变换\\(\\bm S,R\\)\n\\[ first,\\bm v_2=\\bm{Sv}_1,then,\\bm v_3=\\bm{Sv}_2 \\]\n那么就可以写作\n\\[ \\bm v_3=\\bm R(\\bm{Sv}_1) \\]\n根据结合律，写作\n\\[ \\bm v_3=(\\bm{RS})\\bm{v}_1 \\]\n则\\(\\bm{M=RS}\\)就是复合变换，其中变换顺序是从右到左的。\n线性变换的拆分 例如，有一个\\(2\\times 2\\)正方形的左下角在点\\((1,1)\\)处，我们想要将它绕\\((1,1)\\)旋转\\(\\phi\\)度，我们就可以拆分成三个变换。首先，左下角平移到原点；然后，进行旋转；最后再平移回去。\n三维线性变换 总体来说，三维线性变换就是二维的扩展\n\\[ scale(s_x,s_y,s_z)= \\begin{bmatrix} s_x \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; s_y \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; s_z \\end{bmatrix} \\]\n\\[ rotate-z(\\phi)= \\begin{bmatrix} cos\\phi \u0026amp; -sin\\phi \u0026amp; 0\\\\ sin\\phi \u0026amp; cos\\phi \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\]\n\\[ rotate-x(\\phi)= \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0\\\\ 0 \u0026amp; cos\\phi \u0026amp; -sin\\phi\\\\ 0 \u0026amp; sin\\phi \u0026amp; cos\\phi \\end{bmatrix} \\]\n\\[ rotate-y(\\phi)= \\begin{bmatrix} cos\\phi \u0026amp; 0 \u0026amp; sin\\phi\\\\ 0 \u0026amp; 1 \u0026amp; 0\\\\ -sin\\phi \u0026amp; 0 \u0026amp; cos\\phi \\end{bmatrix} \\]\n\\[ shear-x(d_y,d_z)= \\begin{bmatrix} 1 \u0026amp; d_y \u0026amp; d_z\\\\ 0 \u0026amp; 1 \u0026amp; 0\\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\]\n如果要绕过原点的固定轴\\(\\bm n\\)旋转，可以有罗德里格斯公式如下\n\\[ \\bm R(\\bm n,\\alpha) = cos(\\alpha)\\bm I+(1-cos(\\alpha))\\bm{nn}^T+sin(\\alpha)\\bm N \\]\n其中\\(\\bm I\\)是单位矩阵，\n\\[ \\bm N= \\begin{bmatrix} 0 \u0026amp; -n_z \u0026amp; n_y\\\\ n_z \u0026amp; 0 \u0026amp; -n_x\\\\ -n_y \u0026amp; n_x \u0026amp; 0 \\end{bmatrix} \\]\n平移 平移不能被写作矩阵的形式，所以它不是线性变换。\n\\[ \\begin{bmatrix} x\u0026#39;\\\\ y\u0026#39; \\end{bmatrix}= \\begin{bmatrix} a \u0026amp; b\\\\ c \u0026amp; d \\end{bmatrix} \\begin{bmatrix} x\\\\ y \\end{bmatrix}+ \\begin{bmatrix} t_x\\\\ t_y \\end{bmatrix} \\]\n但是我们仍然有办法用矩阵来表示平移，这需要转化为齐次矩阵。\n为坐标（二维坐标）添加第三维，\n对于二维点，\\((x,y,1)^T\\) 对于二维向量，\\((x,y,0)^T\\)  于是我们有平移变换如下\n\\[ \\begin{bmatrix} x\u0026#39;\\\\ y\u0026#39;\\\\ w\u0026#39; \\end{bmatrix}= \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; t_x\\\\ 0 \u0026amp; 1 \u0026amp; t_y\\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}\\cdot \\begin{bmatrix} x\\\\ y\\\\ 1 \\end{bmatrix}= \\begin{bmatrix} x+t_x\\\\ y+t_y\\\\ 1 \\end{bmatrix} \\]\n并且这样定义点和向量有好处，向量加向量是向量，点减点是向量，点加向量是向量。\n平移一个向量，对于自由向量来说，起点都是远点，所以平移向量不会改变向量的坐标表示。为此设置第三维为0是合理的。\n同样地，在复合变换时，用矩阵乘法来复合。\n如果一个向量仅仅代表方向，例如法向量、平行光方向向量，不希望平移变换影响到这些向量，那么可以把第三维（对于三维向量是第四维）设置为零。此时除了平移，其他变换仍然能正常工作。\n三维平移 \\[ \\bm T(t_x,t_y,t_z)=\\ \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; t_x\\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; t_y\\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; t_z\\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\]\n仿射变换 即线性变换加上一个平移\n\\[ \\begin{bmatrix} x\u0026#39;\\\\ y\u0026#39; \\end{bmatrix}= \\begin{bmatrix} a \u0026amp; b\\\\ c \u0026amp; d \\end{bmatrix}\\cdot \\begin{bmatrix} x\\\\ y \\end{bmatrix}+ \\begin{bmatrix} t_x\\\\ t_y \\end{bmatrix} \\]\n\\[ \\begin{bmatrix} x\u0026#39;\\\\ y\u0026#39;\\\\ 1 \\end{bmatrix}= \\begin{bmatrix} a \u0026amp; b \u0026amp; t_x\\\\ c \u0026amp; d \u0026amp; t_y\\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}\\cdot \\begin{bmatrix} x\\\\ y\\\\ 1 \\end{bmatrix} \\]\n显然知道，这个矩阵先进行线性变换，再进行平移。\n逆变换 变换\\(\\bm M^{-1}\\)是变换\\(\\bm M\\)在矩阵和几何意义上的逆变换。\n显然，根据变换的复合，变换和其逆变换的复合相当于没变，两个变换矩阵的乘积是单位矩阵。故逆变换矩阵是变换矩阵的逆矩阵。\n坐标变换 TODO\n","date":"2022-06-27T16:25:19+08:00","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5/","title":"计算机图形学基础学习笔记-变换矩阵"},{"content":" 本章内容为线性代数，在线性代数整理中涵盖了大部分内容，不再重复，介绍一些那篇文章没有覆盖的内容。\nSVD（奇异值分解） 与对角化不同的是，计算SVD时，两边的正交矩阵不要求相同。例如：\n\\[ \\bm A=\\bm{USV}^T \\]\n其中\\(\\bm S\\)是一个对角阵，并且对角线上的元素就是奇异值。当\\(\\bm A\\)是对称的并且都是非负特征值，此时SVD和对角化相同。\n有一个特征值和奇异值之间的关系可以帮助我们计算奇异值\n\\[ M = \\bm{AA}^T=(\\bm{USV}^T)(\\bm{USV}^T)^T = \\bm{US}(\\bm V^T\\bm V)\\bm{SU}^T \\]\n\\[ =\\bm{US}^2\\bm U^T \\]\n","date":"2022-06-27T15:29:29+08:00","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","title":"计算机图形学基础学习笔记-线性代数"},{"content":" Cartesian Product（笛卡尔积） 内容同离散数学。\n几个特别的集合 \\(S^2\\)，在单位球面上的三维点的集合。\n映射、函数、反函数 内容同离散数学。\n三角学 书中提到的正弦余弦定理、半角公式、和差公式都已在高中学过，记录一些没学过的。\n正切定理\n\\[ \\frac{a+b}{a-b}=\\frac{tan\\left(\\frac{A+B}{2}\\right)}{tan\\left(\\frac{A-B}{2}\\right)} \\]\n海伦公式\n\\[ S = \\frac{1}{4}\\sqrt{(a+b+c)(-a+b+c)(a-b+c)(a+b-c)} \\]\n重心坐标系 可以用三个点\\(\\bm{a,b,c}\\)表示三角形。\n假设三点不共线，则\\(\\bm{c-a},\\bm{b-a}\\)线性无关，即可以作为二维坐标的一组基底。\n二维空间中任何一点都可以由\n\\[ \\bm{p}=\\bm a+\\beta(\\bm{b-a})+\\gamma(\\bm{c-a}) \\]\n表示\n整理得\n\\[ \\bm{p}=(1-\\beta-\\gamma)\\bm a+\\beta\\bm{b}+\\gamma\\bm{c} \\]\n令\n\\[ \\alpha\\equiv 1-\\beta-\\gamma \\]\n则有\n\\[ \\bm p(\\alpha,\\beta,\\gamma)=\\alpha\\bm a+\\beta\\bm{b}+\\gamma\\bm{c} \\]\n其中\n\\[ \\alpha+\\beta+\\gamma = 1 \\]\n一个点在三角形内部当且仅当\n\\[ 0\u0026lt;\\alpha\u0026lt;1,0\u0026lt;\\beta\u0026lt;1,0\u0026lt;\\gamma\u0026lt;1 \\]\n同时成立。也可以用向量叉乘的办法判断是否在内部。\n对于三角形三个点\\(A,B,C\\)，平面中一点\\((x,y)\\)可以表示为\n\\[ (x,y) = \\alpha A+\\beta B+\\gamma C \\]\n\\[ \\alpha+\\beta+\\gamma=1 \\]\n其中有\n\\[ \\alpha = \\frac{-(x-x_B)(y_C-y_B)+(y-y_B)(x_C-x_B)}{-(x_A-x_B)(y_C-y_B)+(y_A-y_B)(x_C-x_B)} \\]\n\\[ \\beta = \\frac{-(x-x_C)(y_A-y_C)+(y-y_C)(x_A-x_C)}{-(x_B-x_C)(y_A-y_C)+(y_B-y_C)(x_A-x_C)} \\]\n\\[ \\gamma = 1-\\alpha-\\beta \\]\n运用重心坐标系进行颜色插值见第九章笔记。\n另外，从另一个角度思考\n\\[ \\bm p = \\alpha\\bm a+\\beta\\bm b+\\gamma\\bm c\\\\ \\alpha+\\beta+\\gamma = 1 \\]\n有\n\\[ \\bm p = (1-\\beta-\\gamma)\\bm a+\\beta\\bm b+\\gamma\\bm c \\]\n\\[ \\bm p = \\bm a+\\beta\\overrightarrow{AB}+\\beta\\overrightarrow{AC} \\]\n\\[ 0 = \\overrightarrow{PA}+\\beta\\overrightarrow{AB}+\\gamma\\overrightarrow{AC} \\]\n也就是说，\n\\[ \\begin{bmatrix} 1 \u0026amp; \\beta \u0026amp; \\gamma \\end{bmatrix} \\begin{bmatrix} PA_x \\\\ AB_x \\\\ AC_x \\end{bmatrix}=0 \\]\n\\[ \\begin{bmatrix} 1 \u0026amp; \\beta \u0026amp; \\gamma \\end{bmatrix} \\begin{bmatrix} PA_y \\\\ AB_y \\\\ AC_y \\end{bmatrix}=0 \\]\n也就是说，向量\\((1,\\beta,\\gamma)\\)是向量\\((PA_x,AB_x,AC_x)\\)和\\((PA_y,AB_y,AC_y)\\)的叉积。根据向量第一位是1可以转变一下符号。\n这个方法代码相较于上一个方法比较简单。\n向量 同高中和线性代数\n积分 内容同高数。不过在计算机图形学里我们更注重数值而不是分析。\n曲线、曲面 内容同高数。\nLinear Interpolation（线性内插） \\[ f(x)=y_i+\\frac{x-x_i}{x_{i+1}-x_i}(y_{i+1}-y_i) \\]\n概率论 随机变量 \\(X\\)，表示任意一个可能取值。\n概率密度函数(PDF) \\(X\\sim p(x)\\)，表示随机过程取值为\\(x\\)的相对概率。\n概率的一些属性 \\(p_i\\geq 0\\) \\(\\sum_{i=1}^np_i=1\\)  期望 \\[ E[X] = \\sum_{i=1}^nx_ip_i \\]\n连续的情况 当随机变量\\(X\\)可以取一个连续的区间上的值。\n显然此时也会有连续的概率密度函数。\n并且\n\\[ p(x)\\geq 0,\\int p(x)dx=1 \\]\n\\[ E[x]=\\int xp(x)dx \\]\n随机变量的函数 随机变量的函数也是一个随机变量。\n\\[ X\\sim p(x)\\\\ Y=f(X) \\]\n\\[ E[Y]=E[f(X)]=\\int f(x)p(x)dx \\]\n蒙特卡罗积分 蒙特卡洛积分的目的：想计算一个定积分，但是难以从分析意义上解出，希望在数值上求解。\n方法：通过平均函数值的随机样本来估计函数的积分。\n定义定积分如下：\n\\[ \\int_a^b f(x)dx \\]\n随机变量如下\n\\[ X_i\\sim p(x) \\]\n则蒙特卡洛估计值是：\n\\[ F_N=\\frac{1}{N}\\sum_{i=1}^N\\frac{f(X_i)}{p(X_i)} \\]\n如果随机变量是均匀的，或者说\n\\[ X_i\\sim p(x)=C \\]\n\\(C\\)是一个常数\n那么，\n\\[ \\int_a^b p(x)dx=1 \\]\n\\[ \\int_a^b Cdx=1 \\]\n\\[ C=\\frac{1}{b-a} \\]\n此时基础蒙特卡洛估计值(Basic Monte Carlo Estimator)为\n\\[ F_N=\\frac{b-a}{N}\\sum_{i=1}^N f(X_i) \\]\n","date":"2022-06-27T15:17:29+08:00","permalink":"https://kegalas.top/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/","title":"计算机图形学基础学习笔记-数学基础"},{"content":"以Hugo站点为根目录，首先将\\themes\\hugo-theme-stack\\layouts\\partials\\sidebar\\中的left.html复制到\\layouts\\partials\\sidebar\\中。\n然后修改复制后的文件，如下图。\n\r1.jpg\r\n第41行中高亮的部分原来是relLangURL，改成absURL。\n不过这个方法是否会导致其他问题还有待观察。\n","date":"2022-06-25T23:46:57+08:00","image":"https://kegalas.top/p/hugo%E7%9A%84stack%E7%9A%AE%E8%82%A4%E4%B8%AD%E4%BD%BF%E5%BE%97mailto%E8%B6%85%E9%93%BE%E6%8E%A5%E8%83%BD%E5%A4%9F%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/cover_hu378ddc8c04e53c565ec514b2115f7fb1_40855_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/hugo%E7%9A%84stack%E7%9A%AE%E8%82%A4%E4%B8%AD%E4%BD%BF%E5%BE%97mailto%E8%B6%85%E9%93%BE%E6%8E%A5%E8%83%BD%E5%A4%9F%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF/","title":"Hugo的Stack皮肤中使得mailto超链接能够直接打开电子邮件客户端"},{"content":" 加减法 \\[ (a\\pm b)\\%p = [(a\\%p)\\pm (b\\%p)]\\%p \\]\n乘法 \\[ (a\\times b)\\%p = [(a\\%p)\\times (b\\%p)]\\%p \\]\n除法 \\[ (a/b)\\%p = (a\\times b^{-1})\\%p=[(a\\%p)\\times (b^{-1}\\%p)]\\%p \\]\n其中，\\(b^{-1}\\)是\\(b\\)在模\\(p\\)意义下的乘法逆元。\n","date":"2022-06-25T23:37:59+08:00","permalink":"https://kegalas.top/p/%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97%E7%9A%84%E5%88%86%E9%85%8D%E5%BE%8B/","title":"取余运算的分配律"},{"content":" [TOC]\n运动学 位移 位移：\\(\\Delta\\bm{r}\\)\n位移的大小：\\(|\\Delta\\bm{r}|\\)\n位矢大小的增量：\\(|\\Delta r|\\)\n其中后两者一般是不相等的，不能搞混。\n速度 平均速度  \\[ \\overline{\\bm{v}}=\\frac{\\bm{r}(t+\\Delta t)-\\bm{r}(t)}{\\Delta t}=\\frac{\\Delta\\bm{r}}{\\Delta t} \\]\n平均速度的大小  \\[ |\\overline{\\bm{v}}|=\\left|\\frac{\\Delta\\bm{r}}{\\Delta t}\\right| \\]\n同样的一般有\n\\[ |\\overline{\\bm{v}}|\\neq\\left|\\frac{\\Delta r}{\\Delta t}\\right| \\]\n瞬时速度  \\[ \\bm{v}=\\frac{d\\bm{r}}{dt} \\]\n速度的大小常称速率。\n\\[ |\\bm{v}|=\\left|\\frac{d\\bm{r}}{dt}\\right| \\]\n同样一般有\n\\[ |\\bm{v}|\\neq \\left|\\frac{dr}{dt}\\right| \\]\n加速度 平均加速度  \\[ \\overline{\\bm{a}}=\\frac{\\Delta\\bm{v}}{\\Delta t} \\]\n瞬时加速度  \\[ \\bm{a}=\\frac{d\\bm{v}}{dt} \\]\n关于加速度的大小和一般不相等与（）的性质类似于速度，不再介绍。\n直角坐标表示运动 其位移、速度、加速度都可以分成几个坐标分量来计算，总的位移、速度、加速度则是勾股定理的形式，不再介绍。\n自然坐标法表示运动 \\[ \\bm{v}=\\frac{ds}{dt}\\bm{\\tau} \\]\n其中\\(\\bm{\\tau}\\)是切向量。\n\\[ \\bm{a}_n=a_n\\bm{n}=\\frac{v^2}{r}\\bm{n} \\]\n其中\\(n\\)是法向量，\\(r\\)是曲率半径，曲率半径计算见高数上整理。\n\\[ \\bm{a}_\\tau=a_\\tau\\bm{\\tau}=\\frac{dv}{dt}\\bm{\\tau} \\]\n\\[ \\bm{a=a}_n+\\bm{a}_\\tau \\]\n圆周运动的角量表示 角坐标  \\[ \\theta=\\theta(t) \\]\n角速度和角平均速度  \\[ \\overline{\\omega}=\\frac{\\Delta\\theta}{\\Delta t} \\]\n\\[ \\omega=\\frac{d\\theta}{dt} \\]\n角加速度和角平均加速度  \\[ \\overline{\\beta}=\\frac{\\Delta\\omega}{\\Delta t} \\]\n\\[ \\beta=\\frac{d\\omega}{dt}=\\frac{d^2\\theta}{dt^2} \\]\n线速度、加速度与角速度的关系  \\[ v=r\\omega\\\\ a_\\tau=r\\beta\\\\ a_n=r\\omega^2 \\]\n坐标系变换 \\[ \\bm{v}_a=\\bm{v}_r+\\bm{u} \\]\n即绝对速度等于相对于坐标系的速度与坐标系的绝对速度的矢量和。\n\\[ \\bm{a}_a=\\bm{a}_r+\\bm{a}_e \\]\n类似。\n牛顿运动定律 第一定律  \\[ R=\\sum_i\\bm{F}_i=0 \\]\n也可以将\\(\\bm{F}\\)写成坐标分量的形式。\n第二定律  \\[ \\bm{R}=\\sum_i\\bm{F}_i=\\frac{d(m\\bm{v})}{dt} \\]\n质量为常量时\n\\[ \\bm{R}=m\\frac{d\\bm{v}}{dt}=m\\bm{a} \\]\n可以写作坐标分量和切向量、法向量分量的形式。\n第三定律  \\[ \\bm{F}_1=\\bm{F}_2 \\]\n刚体的平动 任意时刻，平动刚体上个点的速度、加速度都相同。\n力学 常见的几种力 万有引力  \\[ \\bm{F}_{21}=-G\\frac{m_1m_2}{r^2}\\bm{r}^0\\\\ G=6.67\\times10^{-11}\\quad m^2/(kg\\cdot s^2) \\]\n弹性力  \\[ F_x=-kx \\]\n摩擦力  静摩擦力\n\\[ f_{max}=\\mu_0N \\]\n前者为静摩擦系数，后者为支持力。\n滑动摩擦力\n\\[ f=\\mu N \\]\n前者为滑动摩擦系数。\n力矩 \\[ M_O=\\bm{r}\\times\\bm{F} \\]\n单位：\\(N\\cdot m\\)\n转动惯量 \\[ J_z=\\int_Vr^2dm \\]\n常见物体的转动惯量计算公式  5.2  平行轴定理  5.11  \\[ J_z\u0026#39;=J_z+Mh^2 \\]\n转动惯量和力矩的关系 \\[ M_z=J_z\\beta \\]\n功和能 功 恒力做功  \\[ A=\\bm{F}\\cdot\\bm{s}=Fscos\\theta \\]\n变力做功  \\[ A=\\int^b_{a(L)}\\bm{F}\\cdot d\\bm{r} \\]\n通常会拆分成对坐标系求曲线积分。\n平均功率  \\[ P=\\frac{\\Delta A}{\\Delta t} \\]\n瞬时功率  \\[ P=\\frac{dA}{dt} \\]\n\\[ P=\\frac{\\bm{F}\\cdot d\\bm{r}}{dt}=\\bm{F}\\cdot \\bm{v}=Fvcos\\theta \\]\n几种常见力的功 重力的功  \\[ A=mg(z_1-z_2) \\]\n万有引力的功  \\[ A=GmM(\\frac{1}{r_2}-\\frac{1}{r_1}) \\]\n弹性力的功  \\[ A=\\frac{1}{2}k\\lambda_1^2-\\frac{1}{2}k\\lambda_2^2 \\]\n动能定理 质点动能定理  \\[ dA=d(\\frac{1}{2}mv^2) \\]\n\\[ A=\\frac{1}{2}mv_1^2-\\frac{1}{2}mv_2^2 \\]\n质点系动能定理  \\[ \\sum_i A_i=E_{k2}-E_{k1} \\]\n势能、机械能守恒定律 保守力  做功只与始末位置有关而与路径无关的力。\n势能  零势能点\\(M_0\\)，空间中的某个点\\(M\\)\n\\[ E_p=\\int_M^{M_0}\\bm{F}\\cdot d\\bm{r} \\]\n重力势能  \\[ E_p=mgz \\]\n万有引力势能  \\[ E_p=-G\\frac{mM}{r} \\]\n弹性势能  \\[ A=\\frac{1}{2}kx_1^2-\\frac{1}{2}kx_2^2 \\]\n绕定轴转动刚体的动能、动能定理 动能  \\[ E=\\frac{1}{2}J_z\\omega^2 \\]\n力矩的功  \\[ A=\\int_{\\theta_1}^{\\theta_2}M_z(\\bm{F})d\\theta \\]\n动能定理  \\[ A=\\frac{1}{2}J_z\\omega_2^2-\\frac{1}{2}J_z\\omega_1^2 \\]\n冲量、动量、角动量 质点系动量定理 \\[ d(m\\bm{v})=\\bm{F}dt \\]\n\\[ \\bm{I}=m\\bm{v}_2-m\\bm{v}_1=\\int^{t_2}_{t_1}\\bm{F}dt \\]\n如果是恒力\n\\[ m\\bm{v}_2-m\\bm{v}_1=\\bm{F}(t_2-t_1) \\]\n质点系动量定理 \\[ \\sum_i m_i\\bm{v}_i-\\sum_i m\\bm{v}_{i0}=\\sum_i\\int^{t}_{t_0}\\bm{F}_i dt \\]\n质点系动量守恒定律 作用在质点系上的所有外力的矢量和为零，则该质点系的动量保持不变。\n如果某个方向的矢量和为零，则这个方向上的动量保持不变。\n\\[ \\sum_i m_i\\bm{v}_{ix}=C \\]\n\\(C\\)是常量\n质心、质心运动定理 质心位置  见高数下整理\n质心运动定理  质点系质心的运动，可以看成为一个质点的运动，这个质点集中了整个质点系的质量，也集中了质点系收到的所有外力。\n动量矩和动量矩守恒定律 动量矩  \\[ \\bm{L}_O=\\bm{r}\\times m\\bm{v} \\]\n\\[ L_z=J_z\\omega \\]\n动量矩定理  \\[ \\frac{d\\bm{L_O}}{dt}=\\bm{r}\\times\\bm{F}=\\bm{M}_O \\]\n动量矩守恒定律  当作用在质点上的合理对固定点之矩总是为零时，质点动量对该点的矩为常矢量。即\n\\[ \\bm{M}_O=0\\Rightarrow \\bm{L}_O=\\bm{C} \\]\n\\(\\bm{C}\\)是常矢量。\n刚体绕定轴转动的动量矩定理  \\[ (J_z\\omega)_t-(J_z\\omega)_{t_0}=\\int^t_{t_0}M_zdt \\]\n刚体绕定轴转动的动量矩守恒定律  \\[ M_z=0\\Rightarrow J_z\\omega=C \\]\n机械振动 简谐振动 \\[ x=Acos(\\omega t+\\varphi) \\]\n\\[ v=\\overset{\\cdot}{x}=-A\\omega sin(\\omega t+\\varphi) \\]\n\\[ a=\\overset{\\cdot\\cdot}{x}=-A\\omega^2 cos(\\omega t+\\varphi) \\]\n对于弹簧振子的周期：\n\\[ T=\\frac{2\\pi}{\\omega}=2\\pi\\sqrt{\\frac{m}{k}} \\]\n对于单摆的周期：\n\\[ T=2\\pi\\sqrt{\\frac{l}{g}} \\]\n弹簧串联并联和弹性系数 串联  \\[ k=\\frac{k_1k_2}{k_1+k_2} \\]\n并联  \\[ k=k_1+k_2 \\]\n注：有一种两根弹簧中间连了物体的，是一种并联。\n谐振动的能量 \\[ E=\\frac{1}{2}kA^2 \\]\n一个周期内，动能和势能的平均大小：\n\\[ \\overline{E_p}=\\frac{1}{4}kA^2 \\]\n\\[ \\overline{E_k}=\\frac{1}{4}kA^2 \\]\n谐振动的合成 同方向，同频率的合成  频率不变\n\\[ A=\\sqrt{A_1^2+A_2^2+2A_1A_2cos(\\varphi_2-\\varphi_1)} \\]\n\\[ \\varphi = arctan\\frac{A_1sin\\varphi_1+A_2sin\\varphi_2}{A_1cos\\varphi_1+A_2cos\\varphi_2} \\]\n同方向不同频率的合成  \\[ A=\\sqrt{A_1^2+A_2^2+2A_1A_2cos(\\omega_2-\\omega_1)t} \\]\n\\[ \\tau=\\frac{2\\pi}{|\\omega_2-\\omega_1|} \\]\n\\[ \\nu=\\frac{|\\omega_2-\\omega_1|}{2\\pi}=|\\nu_2-\\nu_1| \\]\n\\(\\nu\\)为拍频。\n两个相互垂直谐振动的合成  根据参数方程求出平面解析式。\n机械波 机械波的产生和传播 拉紧的绳子，横波的波速为\n\\[ u_t=\\sqrt{\\frac{T}{\\mu}} \\]\n其中\\(T\\)是绳子的张力，\\(\\mu\\)是线密度。\n平面简谐波 波函数  正向传播：\n\\[ y(x,t)=Acos\\left[\\omega\\left(t-\\frac{x}{u}\\right)+\\varphi_0\\right] \\]\n或者写成\n\\[ y(x,t)=Acos\\left[2\\pi\\left(\\frac{t}{T}-\\frac{x}{\\lambda}\\right)+\\varphi_0\\right] \\]\n负向传播：\n\\[ y(x,t)=Acos\\left[\\omega\\left(t+\\frac{x}{u}\\right)+\\varphi_0\\right] \\]\n波的能量 能量  设绳子每单位长度的质量为\\(\\mu\\)，线元总机械能：\n\\[ W=W_k+W_p=\\mu\\Delta xA^2\\omega^2sin^2\\left[\\omega\\left(t-\\frac{x}{u}\\right)+\\varphi_0\\right] \\]\n能量密度  把单位体积中波的能量称为波的能量密度：\n\\[ w=\\frac{W}{\\Delta V}=\\frac{W}{\\Delta x\\Delta S}=\\rho A^2\\omega^2sin^2\\left[\\omega\\left(t-\\frac{x}{u}\\right)+\\varphi_0\\right] \\]\n能流密度（波的强度）  \\[ I=\\overline{w}u \\]\n\\[ I=\\frac{1}{2}\\rho A^2\\omega^2u \\]\n\\[ \\bm{I}=\\overline{w}\\bm{u} \\]\n\\[ w_{max}=2\\overline{w} \\]\n\\[ I=\\frac{P}{S} \\]\n其中\\(P\\)是功率，\\(S\\)是波面面积。\n平面波和球面波的振幅  平面简谐波在理想无吸收的、均匀媒质中传播时振幅不变。\n球面波在均匀、无吸收媒质中传播，有\n\\[ \\frac{A_1}{A_2}=\\frac{r_2}{r_1} \\]\n即该点的振幅和到波源的距离成反比\n波的吸收  \\[ I=I_0e^{-ax} \\]\n波的干涉 干涉条件：频率相同、振动方向相同、相位差恒定。\n\\[ A^2=A_1^2+A_2^2+2A_1A_2cos\\Delta\\varphi \\]\n\\[ I=I_1+I_2+2\\sqrt{I_1I_2}cos\\Delta\\varphi \\]\n其中上面两式中\n\\[ \\Delta\\varphi=(\\varphi_2-\\varphi_1)-2\\pi\\frac{r_2-r_1}{\\lambda} \\]\n如果两个波源的初相位相同，则\\(\\Delta\\varphi\\)只取决于波程差\\(\\delta=r_1-r_2\\)，于是干涉相长的条件为：\n\\[ \\delta=r_1-r_2=\\pm k\\lambda,\\quad k=0,1,2,\\cdots \\]\n干涉相消的条件为：\n\\[ \\delta=r_1-r_2=\\pm (2k+1)\\frac{\\lambda}{2},\\quad k=0,1,2,\\cdots \\]\n驻波 形成驻波的条件：  \\[ L=n\\frac{\\lambda}{2},\\quad n=1,2,3,\\cdots \\]\n驻波波函数  \\[ y=2Acos2\\pi\\frac{x}{\\lambda}\\cdot cos2\\pi\\nu t \\]\n多普勒效应 波源\\(S\\)静止，观察者相对于波源的速度为\\(v_O\\)，靠近为正值，远离为负值。则观察者接收到的频率为：  \\[ \\nu=(1+\\frac{v_O}{u})\\nu_0 \\]\n观察者静止，波源相对于观察者的速度为\\(v_S\\)，靠近为正值，远离为负值。则观察者接收到的频率为：  \\[ \\nu=\\frac{u}{u-v_S}\\nu_0 \\]\n波动光学 光的干涉 相干叠加的条件：频率相同、光矢量振动方向平行、相位差恒定。\n杨氏双缝干涉  干涉加强的条件：\n\\[ \\delta=\\pm 2k\\frac{\\lambda}{2} \\]\n干涉相消的条件：\n\\[ \\delta=\\pm(2k+1)\\frac{\\lambda}{2} \\]\n屏上相邻明条纹或相邻暗条纹之间的间距为\n\\[ \\Delta x=\\frac{D\\lambda}{d} \\]\n\\(D\\)是双缝到屏的距离，\\(d\\)是双缝间距。\n洛埃镜  半波损失的条件：\n波从波疏介质射向波密介质时反射过程中，反射波会相对于入射波有相位突变\\(\\pi\\)\n光程与光程差 数值上，光程等于介质折射率乘以光在介质中传播的路程，经过多重介质时，光程\\(=\\sum_in_ir_i\\)\n光程差：\n\\[ \\delta=n_2r_2-n_1r_1 \\]\n薄膜干涉 等厚干涉 干涉图样中同一干涉条纹对应于薄膜上厚度相同点的连线，这种条纹称为等厚干涉条纹。\n劈尖干涉  显然要考虑半波损失，假设为垂直入射，则明条纹的条件为\n\\[ \\delta=2d+\\frac{\\lambda}{2}=2k\\frac{\\lambda}{2},\\quad k=1,2,3,\\cdots \\]\n暗条纹的条件是\n\\[ \\delta=2d+\\frac{\\lambda}{2}=(2k+1)\\frac{\\lambda}{2},\\quad k=0,1,2,\\cdots \\]\n牛顿环  \\(R\\)是平凸透镜的曲率半径，\\(r\\)是条纹半径。\n明条纹：\n\\[ r=\\sqrt{(2k-1)\\frac{R\\lambda}{2}},\\quad k=1,2,3,\\cdots \\]\n暗条纹：\n\\[ r=\\sqrt{k\\lambda R} \\]\n等倾干涉 因干涉图样中同一干涉条纹是来自薄膜表面的等倾角光纤经透镜聚焦后的轨迹，故称为等倾干涉条纹。\n迈克尔逊干涉仪 若视场从最亮到第\\(N\\)次最亮出现时，反光镜移动的距离为\n\\[ \\Delta d=N\\frac{\\lambda}{2} \\]\n相干长度  两个分光束产生干涉效应的最大光程差\\(\\delta_m\\)为波列长度\\(L\\)，称为相干长度\n相干时间  \\[ \\Delta t=\\frac{\\delta_m}{c} \\]\n惠更斯-菲涅尔原理 同一波前上各点发出的次波是相干波，经过传播在空间某点相遇时的叠加是相干叠加。\n单缝的夫琅禾费衍射 菲涅尔半波带法研究分布  \\(a\\)是夹缝宽度\n暗条纹：\n\\[ asin\\varphi = \\pm 2k\\frac{\\lambda}{2},\\quad k=1,2,3,\\cdots \\]\n明条纹：\n\\[ asin\\varphi=\\pm(2k+1)\\frac{\\lambda}{2},\\quad k=1,2,3,\\cdots \\]\n其中中央零级明条纹：\n\\[ asin\\varphi=0 \\]\n中央明纹的宽度是\n\\[ -\\lambda\u0026lt;asin\\varphi\u0026lt;\\lambda \\]\n当\\(\\varphi\\)很小时，有\\(sin\\varphi\\approx\\varphi\\approx\\frac{\\lambda}{a}\\)\n振幅矢量合成法研究强度  假设中央明纹的光强为\\(I_0\\)，则某一点\\(P\\)的光强为\n\\[ I=I_0\\left(\\frac{sinu}{u}\\right)^2 \\]\n艾里斑  \\[ \\theta_0\\approx sin\\theta_0=1.22\\frac{\\lambda}{D} \\]\n\\(D\\)是圆孔直径。\n衍射光栅及光栅光谱 刻痕间距为\\(a\\)，刻痕宽度为\\(b\\)，则\\(d=a+b\\)称为光栅常数。\\(N\\)是光栅的缝数，\\(n\\)是光栅一定长度内的缝数，单位通常为条/\\(mm\\)。并且有\\(d=1/n\\)\n光栅方程  光栅方程，或衍射明条纹的条件如下（只考虑干涉而不考虑各个缝的衍射的情况）\n\\[ (a+b)sin\\varphi=\\pm k\\lambda,\\quad k=0,1,2,\\cdots \\]\n主极大条纹  满足光栅方程的明条纹称为主极大条纹。\n缺级  现在来考虑各个缝的衍射。\n同时满足\n\\[ (a+b)sin\\varphi=\\pm k\\lambda \\]\n和\n\\[ asin\\varphi=\\pm k\u0026#39;\\lambda,\\quad k\u0026#39;=1,2,\\cdots \\]\n的为光谱线的缺级\n缺级的级数为\n\\[ k=k\u0026#39;\\frac{a+b}{a} \\]\n暗纹条件  \\[ N(a+b)sin\\varphi=\\pm m\\lambda \\]\n其中\\(m=1,2,\\cdots,(N-1),(N+1),\\cdots,(2N-1),(2N+1),\\cdots\\)，即除去\\(N\\)的整倍数。\n易知，两个主极大条纹间有\\((N-1)\\)条暗纹，以及\\((N-2)\\)条次级大。\n线偏振光、自然光 线偏振光  光矢量只限于单一方向振动的光。\n自然光  无论哪一个方向的振动都不比其他方向占优势。\n偏振片的起偏和检偏、马吕斯定律 起偏和检偏  自然光获得偏振光的过程叫起偏。\n对偏振光透过偏振片的角度的观察叫检偏。\n马吕斯定律  \\[ I=I_0cos^2\\alpha \\]\n对于自然光透过偏振片\n\\[ I=I_0/2 \\]\n反射和折射产生的偏振、布儒斯特定律 反射和折射产生的偏振  反射光为偏振方向垂直入射面成分较多的部分偏振光。\n布儒斯特定律  当入射角\\(i\\)与反射角\\(\\gamma\\)之和为\\(90\\degree\\)时，反射光称为光矢量与入射面垂直的完全偏振光。\n公式表示为\n\\[ tani=\\frac{n_2}{n_1} \\]\n双折射现象 晶体的双折射现象：\n其中一束折射光始终在入射面内，并遵守折射定律，称为寻常光，简称\\(o\\)光。另一束折射光一般不在入射面内，且不遵守折射定律，称为非常光，简称为\\(e\\)光。\n热力学 平衡态、理想气体状态方程 \\[ t=T-273.15 \\]\n理想气体状态方程（克拉伯龙方程）：\n\\[ pV=\\nu RT \\]\n注，大学物理一般用\\(n\\)表示分子数密度，而用\\(\\nu\\)表示物质的量\n功、热量、内能、热力学第一定律 绝热过程中外界对系统做功，则内能变化为\n\\[ E_2-E_1=A_Q \\]\n假设外界不对系统做功，系统内能变化和外界给系统的热量的关系：\n\\[ E_2-E_1=Q \\]\n热力学第一定律\n\\[ Q=(E_2-E_1)+A \\]\n即系统从外界吸收能力，一部分转化为内能，一部分则对外界做功\n对于无限小的变化过程\n\\[ dQ=dE+dA \\]\n准静态过程中功和热量的计算 功  在一个优先的准静态过程中，当气体的体积变化时，气体对外界所做的功为\n\\[ A=\\int_{V_1}^{V_2}pdV \\]\n应用上述结果，热力学第一定律可以表示为\n\\[ Q=(E_2-E_1)+\\int_{V_1}^{V_2}pdV \\]\n热量、热容  \\[ Q=mc(T_2-T_1) \\]\n\\(c\\)是物体的比热容。不同物质的比热容值不同，并且同一物质的比热容值一般随温度而变。但在温度变化不大时，可以看做常量。\n假定\\(1mol\\)气体在等体过程中温度升高\\(\\Delta T\\)时，吸收的热量为\\(Q_V\\)，则气体的摩尔定体热容定义为\n\\[ C_V=\\lim\\limits_{\\Delta T\\to 0}\\frac{Q_V}{\\Delta T}=\\left(\\frac{dE}{dT}\\right)_V \\]\n假定\\(1mol\\)气体在等压过程中温度升高\\(\\Delta T\\)时，吸收的热量为\\(Q_p\\)，则气体的摩尔定压热容定义为\n\\[ C_V=\\lim\\limits_{\\Delta T\\to 0}\\frac{Q_p}{\\Delta T}=\\left(\\frac{dE}{dT}\\right)_p+p\\left(\\frac{dV}{dT}\\right)_p \\]\n理想气体的内能和\\(C_V\\)、\\(C_p\\) 气体的内能仅仅是其温度的函数，与体积等无关\n\\[ E=E(T) \\]\n\\[ C_p=C_V+R \\]\n即迈耶公式，单位一般为\\(J/(mol\\cdot K)\\)，\\(R=8.31\\)\n比热容比：\n\\[ \\gamma=\\frac{C_p}{C_V} \\]\n对单原子分子\n\\[ C_V\\approx \\frac{3}{2}R \\]\n对双原子气体分子\n\\[ C_V\\approx \\frac{5}{2}R \\]\n热力学第一定律对理想气体在典型准静态过程中的应用 等体过程  \\[ Q_V=E_2-E_1=\\nu C_V(T_2-T_1) \\]\n由克拉伯龙公式\n\\[ Q_V=\\frac{V}{R}C_V(p_2-p_1) \\]\n等压过程  \\[ A=p(V_2-V_1)=\\nu R(T_2-T_1) \\]\n\\[ Q_p=vC_p(T_2-T_1) \\]\n\\[ E_2-E_1=Q_p-A=\\nu C_V(T_2-T_1) \\]\n等温过程  等温膨胀过程中，吸收的热量全部用来对外做功\n\\[ Q_T=A=\\nu RTln\\frac{p_1}{p_2} \\]\n绝热过程 绝热过程中\\(Q=0\\)，所以有\\(A=E_1-E_2=-vC_V(T_2-T_1)\\)\n\\[ A=\\frac{1}{\\gamma-1}(p_1V_1-p_2V_2)=-\\frac{\\nu R}{\\gamma-1}(T_2-T_1) \\]\n循环过程 循环过程  \\[ A=Q_1-Q_2 \\]\n循环效率  \\[ \\eta=\\frac{A}{Q_1}=1-\\frac{Q_2}{Q_1} \\]\n制冷系数  \\[ w=\\frac{Q_2}{A} \\]\n绝对零度不可达原理  不可能用有限的步骤使物体达到绝对零度。\n热力学第二定律 开尔文表述  不可能只从单一热源吸收热量，使之完全转化为功而不引起其他变化。\n克劳修斯表述  不可能使热量从低温物体传向高温物体而不引起其他变化。\n可逆与不可逆过程 如果过程的每一步都可沿相反的方向进行，同时不引起外界的任何变化，则称可逆过程。对于某一过程，用任何方法都不能使系统和外界恢复到原来状态，称为不可逆过程。\n热力学第二定律揭示了，自然界的一切自发过程都是单方向进行的不可逆过程。\n卡诺热机 卡诺循环  两个等温过程和两个绝热过程组成。\n\\[ \\eta = 1-\\frac{T_2}{T_1} \\]\n\\[ w=\\frac{T_2}{T_1-T_2} \\]\n卡诺定理  温度为\\(T_1,T_2\\)的两个给定热源之间工作的一切可逆热机，效率相同，都等于理想气体可逆卡诺热机的效率。这两个热源之间工作的一切不可逆热机，其效率都不可能大于卡诺热机。\n气体动理论 气体分子的热运动 平衡状态下，平均速度\n\\[ \\overline{v_x}=\\overline{v_y}=\\overline{v_z}=0 \\]\n统计平均值为\n\\[ \\overline{v^2_j}=\\frac{\\sum_i\\Delta N_iv^2_{ij}}{N},\\quad j=x,y,z \\]\n且有\n\\[ \\overline{v^2_x}=\\overline{v^2_y}=\\overline{v^2_z}=\\overline{v^2}/3 \\]\n大量分子平均平动动能的统计平均值为\n\\[ \\overline{\\varepsilon}=\\frac{1}{2}\\mu\\overline{v^2}=\\frac{\\mu\\sum_i\\Delta N_iv^2_{i}}{2N} \\]\n其中\\(\\mu\\)为一个分子的质量\n理想气体的压强公式 \\[ p=\\frac{2}{3}n(\\frac{1}{2}\\mu\\overline{v^2})=\\frac{2}{3}n\\overline{\\varepsilon} \\]\n麦克斯韦速度分布定律 麦克斯韦速度分布定律  \\[ f(v)=4\\pi\\left(\\frac{\\mu}{2\\pi kT}\\right)^{3/2}v^2e^{-\\frac{\\mu v^2}{2kT}} \\]\n其中\n\\[ k=\\frac{R}{N_A}=\\frac{8.31}{6.022\\times 10^{23}}=1.38\\times 10^{-23} J/K \\]\n称为玻尔兹曼常数。\n\\[ \\frac{dN}{N}=f(v)dv \\]\n\\[ \\int_0^\\infty f(v)dv=1 \\]\n分子速率的三种统计平均值  \\[ \\overline{v}=\\sqrt\\frac{8kT}{\\pi\\mu}=1.59\\sqrt{\\frac{RT}{M}} \\]\n\\[ \\sqrt{\\overline{v^2}}=\\sqrt\\frac{3kT}{\\mu}=1.73\\sqrt{\\frac{RT}{M}} \\]\n\\[ v_p=\\sqrt\\frac{2kT}{\\mu}=1.41\\sqrt{\\frac{RT}{M}} \\]\n温度的微观本质 \\[ \\overline{\\varepsilon}=\\frac{1}{2}\\mu\\overline{v^2}=\\frac{3}{2}kT \\]\n能量按自由度均分定理 能量按自由度均分定理  处于平衡态的理想气体分子，无论作何种运动，相应于分子每个自由度的平均动能都相等，并且都等于\\(kT/2\\)。\n如果气体分子有\\(i\\)个自由度，那么每个分子的平均总动能为\\(ikT/2\\)\n理想气体的内能  \\(1mol\\)气体中有\\(N_0\\)个分子，若不考虑振动能量，则\\(1mol\\)理想气体的内能为\n\\[ E=N_0\\frac{i}{2}kT=\\frac{i}{2}RT \\]\n气体的摩尔热容  \\[ C_V=\\frac{i}{2}R \\]\n\\[ C_p=\\frac{(i+2)}{2}R \\]\n\\[ \\gamma=\\frac{i+2}{i} \\]\n玻尔兹曼分布律 \\[ n=n_0e^{-\\frac{\\varepsilon_p}{kT}} \\]\n\\(n_0\\)是零势能面的分子数密度。\n可以推知\n\\[ p=nkT=p_0e^{-\\frac{\\varepsilon_p}{kT}} \\]\n分子的平均自由程 平均碰撞频率  \\[ \\overline{z}=\\sqrt{2}\\pi d^2\\overline{v}n \\]\n分子的平均自由程  \\[ \\overline{\\lambda}=\\frac{\\overline{v}}{\\overline{z}}=\\frac{1}{\\sqrt{2}\\pi d^2n}=\\frac{kT}{\\sqrt{2}\\pi d^2p} \\]\n静电场 电荷、库仑定律 电荷守恒定律\n在一个封闭系统内，不论进行怎样的变化过程，系统内正负电荷量的代数和保持不变。\n基尔霍夫第一定律\n根据电荷守恒定律，在稳恒电路中，节点处各支路电流的代数和应该为零。\n库伦定律\n在真空中两个静止点电荷之间的静电作用力为：\n\\[ F=\\frac{1}{4\\pi\\varepsilon_0}\\frac{q_1q_2}{r^2} \\]\n作用力的方向沿着两个点电荷的连线。\n其中\\(q_1,q_2\\)是两个点电荷的电量，\\(r\\)是它们之间的距离。\\(\\varepsilon_0\\)是真空电容率，或者叫真空介电常数。其值为\\(8.854187817\\times 10^{-12} F/m\\)\n用向量来表示，则有\n\\[ \\bm F = \\frac{1}{4\\pi\\varepsilon_0}\\frac{q_1q_2}{r^2} \\bm r^0 \\]\n电场 静电力是通过电场来传递的。电荷\\(q_1\\)对\\(q_2\\)施加的力是通过\\(q_1\\)产生的电场来传播的。并且这个电场不会对自身有作用力。\n电场的传播速度是光速。\n电场中某点的电场强度E的大小等于单位电荷在该点受力的大小，其方向为正电荷在该点受力的方向。\n\\[ \\bm E=\\frac{\\bm F}{q_0} \\]\n电场强度叠加原理\n点电荷系在某点\\(P\\)产生的电场的电场强度等于各点电荷单独在该点产生的电场强度的矢量和。\n电偶极矩\n两个大小相等的异号点电荷\\(+q\\)和\\(-q\\)，相距为\\(l\\)，如果要计算电场强度的各场点相对这一对电荷的距离\\(r\\)比\\(l\\)大很多（\\(r\u0026gt;\u0026gt;l\\)），这样一对点电荷称为电偶极子。定义\n\\[ \\bm p = q\\bm l \\]\n为电偶极子的电偶极矩，\\(\\bm l\\)的方向规定为由负电荷指向正电荷。\n一些常见带电体产生的电场强度 电通量、高斯定理 电场线 形象描述场强分布的空间曲线。\n曲线上每一点的切斜方向为电场方向\n通过垂直于电场方向单位面积电场线数为该点电场强度的大小。\n特点\n始于正电荷（或无穷远），终于负电荷（或无穷远），不会在没有电荷的地方中断 若体系正负电荷一样多，则正电荷发出的电场线全部终止与负电荷 电场线不是闭合曲线，电场线不会相交。  电通量 穿过某一有向曲面的电场线条数，称为通过该面的电通量，用\\(\\varPhi_e\\)表示。\n\\[ d\\varPhi_e=E_ndS=Ecos\\theta dS \\]\n直观上理解，就是将这个微小平面投影到垂直于电场线的平面上。用向量表示为\n\\[ d\\varPhi_e = \\bm E\\cdot d\\bm S \\]\n积分得\n\\[ \\varPhi_e=\\int d\\varPhi_e = \\int_S\\bm E\\cdot d\\bm S \\]\n高斯定理 真空中的任何静电场中，穿过任一闭合曲面的电通量，在数值上等于该闭合曲面内包围的电量的代数和乘以\\(1/\\varepsilon_0\\)。\n显然可以推知，如果高斯面内不包围电荷，电荷在它的外面，则电通量为0.\n对于不连续分布的源电荷\n\\[ \\varPhi_e=\\oint_S\\bm E\\cdot d\\bm S=\\frac{1}{\\varepsilon_0}\\sum_{(内)}q_i \\]\n对于连续分布的源电荷\n\\[ \\varPhi_e=\\oint_S\\bm E\\cdot d\\bm S=\\int_V\\frac{1}{\\varepsilon_0}\\rho dV \\]\n很容易联想到能否用这个公式反过来求电场强度。对于一般的电场很难来求，但是对于一些对称的电荷分布来说，是可以使用的。具体案例见教材。\n静电场的环路定理、电势能 静电力的功\n设一正的实验电荷\\(q_0\\)在静止的点电荷\\(q\\)产生的电场中，由\\(a\\)点经过某一路径\\(L\\)移动到\\(b\\)点，则静电力对\\(q_0\\)做功为\n\\[ A_{ab}=\\int^b_{a(L)}\\bm F\\cdot d\\bm l=\\int^b_{a(L)}q_0\\bm E\\cdot d\\bm l \\]\n\\[ =\\frac{qq_0}{4\\pi\\varepsilon_0}\\int^{r_b}_{r_a}\\frac{1}{r^2}dr=\\frac{qq_0}{4\\pi\\varepsilon_0}\\left(\\frac{1}{r_a}-\\frac{1}{r_b}\\right) \\]\n显然可知，这个功只取决于初末位置，而与路径无关。\n可以扩展到任何静电场。\n静电场的环路定理\n从上文可以得知，在静电场中，电场强度沿任一闭合路径的线积分（或称电场强度的环流）恒为零。静电场是无旋有源场，静电场的电场线不可能是闭合的。静电场是保守场。\n电势能\n电荷在电场中某点的电势能，在量值上等于把电荷从该点移动到电势能零参考点时，静电力所做的功\n\\[ W_a=A_{a\u0026#34;0\u0026#34;}=\\int^{\u0026#34;0\u0026#34;}_aq_0\\bm E\\cdot d\\bm l \\]\n电势、电势差 电场中某点的电势，其量值等于单位正电荷在该点所具有的电势能。\n\\[ u_a=\\frac{W_a}{q_0} \\]\n电场中某点的电势，其量值等于把单位正电荷从该点沿任意路径移动到电势能零参考点时，静电力所做的功。\n\\[ u_a = \\frac{A_{a\u0026#34;0\u0026#34;}}{q_0}=\\int^{\u0026#34;0\u0026#34;}_a\\bm E\\cdot d\\bm l \\]\n由电势的定义可知，电势差可以表示为\n\\[ U_{ab}=\\frac{W_a}{q_0}-\\frac{W_b}{q_0}=\\frac{A_{ab}}{q_0}=\\int^b_a\\bm E\\cdot d\\bm l \\]\n电场中\\(a,b\\)两点的电势差，在量值上等于把单位正电荷从\\(a\\)移动到\\(b\\)时，静电力所做的功。电势差与电势的零参考点的选择无关。\n可以计算电势能如下\n\\[ W_a=qu_a \\]\n可以计算电场做功如下\n\\[ A_{ab}=q(u_a-u_b) \\]\n电势叠加原理\n在点电荷系产生的电场中，某点的电势是各个点电荷单独存在时，在该点产生的电势的代数和。\n常见带电体产生的电势（以无穷远为电势零点）  10.2.jpg  等势面 类似于用电场线来描绘电场强度的空间分布，也可以用等势面来描绘电势的空间分布。\n电势值相等的点联成的面称为等势面。\n在静电场中，电场线与等势面处处正交。\n电势与电场强度的关系 \\[ E=-\\frac{du}{dn} \\]\n此式说明在任意一场点\\(P\\)处，电场强度的大小等于沿过该点等势面法线方向上电势的变化率。\n而\n\\[ E_l=-\\frac{du}{dl} \\]\n表明，电场强度在\\(d\\bm l\\)方向的投影等于电势沿该方向变化率的负值。\n而显然有\\(dl\\geq dn\\)，所以\n\\[ \\frac{du}{dl}\\leq\\frac{du}{dn} \\]\n即电势沿等势面法线方向的变化率最大。\n电场强度也可以表示为\n\\[ \\bm E = E_x+E_y+E_z = -\\left(\\frac{\\partial u}{\\partial x}\\bm i+\\frac{\\partial u}{\\partial y}\\bm j+\\frac{\\partial u}{\\partial z}\\bm k\\right) \\]\n导体的静电平衡 当导体内部的电场强度处处为零，导体上的电势处处相等时，导体达到静电平衡状态。\n静电平衡的导体有以下性质\n其表面上任意一点的电场强度方向与该点处导体表面垂直。并且设该处导体表面上电荷面密度为\\(\\sigma\\)，则  \\[ \\bm E = \\frac{\\sigma}{\\varepsilon_0}\\bm n \\]\n对于静电平衡状态的带电导体，未被抵消的净电荷只能分布在导体的表面上。 处于静电平衡状态的孤立导体，其表面上电荷密度的大小与表面的曲率有关。  电介质 电介质是指在通常条件下导电性能极差的物质，例如云母、变压器油等。电工中一般认为电阻率超过\\(10^8\\Omega\\cdot m\\)的物质为电介质。\n除了具有电气绝缘性能外，在电场作用下的电极化是它的一个重要特性。\n电容为\\(C_0\\)的平行板电容器（边缘效应不计），充电后两基板间电势差为\\(U_0\\)，这时极板上的电荷量为\\(Q_0=C_0U_0\\)。断开电源，并在两极板间注满各向同性的均匀电介质，再测量两极板间电势差，发现\n\\[ U = \\frac{U_0}{\\varepsilon_r} \\]\n并且同时有\n\\[ E = \\frac{E_0}{\\varepsilon_r} \\]\n由于电荷量\\(Q_0\\)不变。所以有\n\\[ C = \\frac{Q_0}{U} = \\frac{\\varepsilon_rQ_0}{U_0}=\\varepsilon_rC_0 \\]\n其中\\(\\varepsilon_r\\)对于各向同性的均匀电介质为一常数，称为该介质的相对介电常数，是无量纲量。\n电解质分子的电结构 根据分子电结构的不同，可把电介质分为两类：\n无极分子。指分子中负电荷对称地分布在正电荷周围，以致在无外电场作用时，分子的正负电荷中心重合，分子无电偶极矩。无外电场作用时，对外呈现电中性。 有极分子。在无外电场作用时，分子的正负电荷中心不重合。这时，等量的分子正负电荷形成电偶极子，具有电偶极矩\\(\\bm p\\)。在无外电场作用时，由于分子的不规则热运动，各分子电偶极矩取向杂乱无章，因此宏观上也呈现电中性。  电介质的极化、束缚电荷 将有极分子电介质放在均匀外电场中，各分子的电偶极子受到外电场力偶的作用，都要转向外电场方向，并有序地排列起来。\n由于分子的热运动，这种分子电偶极子的排列不可能是整齐的。然而，从总体来看，这种转向排列的结果，使电介质沿电场方向前后两个侧面分别出现正负电荷。\n这种不能在电介质内自由移动，也不能离开电介质表面的电荷，称为束缚电荷。\n在外电场作用下，电介质分子的电偶极矩趋于外电场方向排列，结果在电介质的侧面出现束缚电荷的现象称为电介质的极化现象。有极分子电介质的极化常称为取向极化。\n将无极分子电介质放在外电场中，由于分子中的正负电荷受到相反方向的电场力，因而正负电荷中心将发生微小的相对位移，从而形成电偶极子，其电偶极矩将沿外电场方向排列起来。\n这时，沿外电场方向电介质的前后两侧面也将分别出现正负束缚电荷，这也是一种电介质的极化现象。无极分子电介质的极化常称为位移极化。\n一般来说，外电场越强，极化现象越显著，电介质两侧面束缚电荷的面密度也就越大，电极化程度也就越高。\n另外，在各向同性均匀电介质内部的任何体积元内，都不会有净束缚电荷。\n电介质内的电场强度 在电介质内部，合电场强度\\(E\\)总是小于自由电荷产生的电场强度\\(E_0\\)\n电介质内任意一点的电场强度\\(\\bm E\\)，应等于极板上自由电荷在该点产生的电场强度\\(\\bm E_0\\)与分布在电介质两平行端面上的束缚电荷在该点产生的电场强度\\(\\bm E\u0026#39;\\)的矢量和，即\n\\[ \\bm E = \\bm E_0+\\bm E\u0026#39; \\]\n\\[ E = \\frac{\\sigma_0}{\\varepsilon_0}-\\frac{\\sigma \u0026#39;}{\\varepsilon_0} \\]\n如果电介质满足\n\\[ E=\\frac{E_0}{\\varepsilon_r} \\]\n则一定要有该各向同性的均匀电介质要充满电场所在空集。进一步研究表明，各向同性均匀电介质虽未充满电场所在空间，但只要电介质的表面是等势面，上式就成立。\n另外上式和上上式可以得出\n\\[ \\sigma\u0026#39;=(1-\\frac{1}{\\varepsilon_r})\\sigma_0 \\]\n电介质中的高斯定理、电位移矢量D 在平板电容器中，作一封闭圆柱形高斯面，使得面积为\\(S\\)的两个端面平行于电容器极板，且一个端面在导体极板内，另一个在电介质中。\n设自由电荷和束缚电荷面密度分别为\\(\\sigma_0,\\sigma\u0026#39;\\)，对所作高斯面应用高斯定理，有\n\\[ \\oiint_S \\bm E\\cdot d\\bm S = \\frac{1}{\\varepsilon_0}(\\sigma_0-\\sigma\u0026#39;)S \\]\n但是\\(\\sigma\u0026#39;\\)通常难以预先知道，所以上式不方便使用。\n而（电介质充满时）\n\\[ \\sigma\u0026#39;=(1-\\frac{1}{\\varepsilon_r})\\sigma_0 \\]\n所以有\n\\[ \\frac{1}{\\varepsilon_0}(\\sigma_0-\\sigma\u0026#39;)=\\frac{\\sigma_0}{\\varepsilon_0\\varepsilon_r} \\]\n代入得\n\\[ \\oiint_S \\bm E\\cdot d\\bm S = \\frac{\\sigma_0}{\\varepsilon_0\\varepsilon_r}S \\]\n或者写成\n\\[ \\oiint_S \\varepsilon_0\\varepsilon_r\\bm E\\cdot d\\bm S = \\sigma_0S = q_0 \\]\n令\n\\[ \\bm D = \\varepsilon_0\\varepsilon_r\\bm E \\]\n称为电位移矢量（又称电通密度）\n最后可以写成\n\\[ \\oiint_S\\bm D\\cdot d\\bm S = q_0 \\]\n通过任意闭合曲面\\(S\\)的总电位移通量，等于该比和曲面所包围的自由电荷量的代数和，与束缚电荷以及闭合曲面之外的自由电荷无关。\n孤立导体的电容 一个带电量为\\(q\\)的孤立导体，在静电平衡时，具有一定的电势\\(u\\)。当带电量增加时，电势也增加，且比值不变\n\\[ C=\\frac{q}{u} \\]\n其中\\(C\\)是和\\(u,q\\)无关的常量，值只取决于导体的大小形状等因素。\n电容器的电容 若电容器两极板上分别带电量为\\(+q,-q\\)，两极板间的电势差为\\(u_1-u_2\\)，则\n\\[ C=\\frac{q}{u_1-u_2} \\]\n并且可以推导出，若两极板相对面积为\\(S\\)，相距\\(d\\)，则有\n\\[ C=\\frac{\\varepsilon_0 S}{d} \\]\n如果充入电介质，其相对介电常数为\\(\\varepsilon_r\\)\n\\[ C=\\frac{\\varepsilon_0\\varepsilon_r S}{d} \\]\n电容器的串并联 串联\n\\[ \\frac{1}{C} = \\frac{1}{C_1}+\\frac{1}{C_2}+\\frac{1}{C_3}+\\cdots \\]\n电容越串越小，但是耐压值提高了\n并联\n\\[ C=C_1+C_2+C_3+\\cdots \\]\n电容越并越大，但是耐压值不会改变。\n静电能 电极板上迁移电荷，需要做功\n\\[ dA=U(t)dq=\\frac{q(t)}{C}dq \\]\n\\[ A = \\int dA = \\int^Q_0\\frac{q(t)}{C}dq=\\frac{Q^2}{2C} \\]\n另外因\\(Q=CU\\)，上式也可以写作\n\\[ A=\\frac{1}{2}CU^2=\\frac{1}{2}QU \\]\n也就是电容器中储存的能量\n\\[ W = \\frac{Q^2}{2C} = \\frac{1}{2}CU^2=\\frac{1}{2}QU \\]\n在平行板电容器中，如果忽略边缘效应，两极板间的电场是均匀的。因此，单位体积内储存的能量（能量密度）\\(\\omega\\)也应该是均匀的。因\\(U=Ed,C=\\varepsilon_0S/d\\)，有\n\\[ W = \\frac{1}{2}\\varepsilon_0E^2Sd=\\frac{1}{2}\\varepsilon_0E^2V \\]\n而\n\\[ \\omega=\\frac{W}{V}=\\frac{1}{2}\\varepsilon_0E^2 \\]\n只要空间任一处存在着电场，电场强度为\\(E\\)，该处单位体积中就储藏着\\(\\varepsilon_0E^2/2\\)的能量。\n恒定电流的磁场 磁感应强度 当\\(Id\\bm l\\)与磁感应强度方向垂直时，所受的磁场力最大，\n\\[ B = \\frac{dF_{max}}{Idl} \\]\n力的方向由右手定则确定。\n电流元\\(Id\\bm l\\)在磁场中受到的磁场力\\(d\\bm F\\)如下\n\\[ d\\bm F = Id\\bm l\\times \\bm B \\]\n毕奥-萨伐尔定律 电流元\\(Id\\bm l\\)在空间某点\\(P\\)出产生的磁感应强度为\n\\[ dB = \\frac{\\mu_0}{4\\pi}\\frac{Idl\\sin\\theta}{r^2} \\]\n其中\\(r\\)是距离，\\(\\theta\\)是矢量\\(\\bm r\\)和\\(d\\bm l\\)的夹角。\\(\\mu_0=4\\pi\\times 10^{-7}N/A^2\\)，称为真空磁导率。\n\\(d\\bm B\\)的方向由右手定则确定。写成矢量形式如下\n\\[ d\\bm B = \\frac{\\mu_0}{4\\pi}\\frac{Id\\bm l\\times \\bm r^0}{\\bm r^2} \\]\n运动电荷的磁场\n因为\\(I=nqvS\\)，代入有\n\\[ d\\bm B = \\frac{\\mu_0}{4\\pi}\\frac{nqvSd\\bm l\\times \\bm r^0}{\\bm r^2} \\]\n因为\\(\\bm v\\)和\\(d\\bm l\\)方向相同，又令\\(dN = nSdl\\)，故有\n\\[ d\\bm B = \\frac{\\mu_0}{4\\pi}\\frac{(dN)q\\bm v\\times \\bm r^0}{\\bm r^2} \\]\n此时，对于单个带电\\(q\\)的粒子，有\n\\[ \\bm B = \\frac{d\\bm B}{dN} = \\frac{\\mu_0}{4\\pi}\\frac{q\\bm v\\times \\bm r^0}{\\bm r^2} \\]\n常用的磁感应强度公式  11.2.jpg  磁通量 类似于电场线，可以用磁感应线描绘恒定磁场，规定\n磁力线上各点的切线方向与该点处的磁感应强度\\(\\bm B\\)的方向一致 在磁场中的某点处，垂直于该点\\(\\bm B\\)的单位面积上，穿过磁力线的数目等于该点处\\(\\bm B\\)的大小  磁场是无源场，磁力线既无起点又无终点。磁力线的环绕方向与电流的方向及环形电流绕行方向与磁力线方向都遵守右手螺旋法则。\n磁通量定义为\n\\[ d\\varPhi_m=\\bm B\\cdot d\\bm S=Bcos\\theta dS \\]\n也就有\n\\[ \\varPhi_m=\\int_S \\bm B\\cdot d\\bm S \\]\n磁场的高斯定理 穿过任一闭合曲面的总磁通量恒等于零，即\n\\[ \\oint_S\\bm B\\cdot d\\bm S = 0 \\]\n安培环路定理 磁场中\\(B\\)矢量沿闭合路径的线积分和闭合路径的形状大小无关，只与闭合路径包围的电流有关 当电流的方向与闭合路径绕行方向之间满足右螺旋法则时，I取正值；反之取负值  \\[ \\oint_L \\bm B\\cdot d\\bm l=\\mu_0\\sum_{内}I_i \\]\n磁场对电流的作用 磁场对载流导线的作用力\n\\[ \\bm F = \\int_L Id\\bm l\\times \\bm B \\]\n如果导线上各电流源的受力方向不一致，就要沿坐标轴分解力来计算。\n另外闭合载流线圈在匀强磁场中受到的安培力矢量和为零\n均匀磁场对载流线圈的作用\n磁力矩为\n\\[ \\bm M=\\bm p_m\\times B = IS\\bm n\\times B \\]\n其中\\(I\\)是线圈的电流，\\(S\\)是线圈面积，\\(\\bm n\\)是线圈法向量。\n磁力的功\n当回路中电流不变时，磁力所作的供等于电流乘以通过回路所包围面积内的磁通量的增量\n\\[ A=I\\Delta\\varPhi \\]\n带电粒子在电场和磁场中的运动 在电场中\n\\[ q\\bm E = m\\bm a=m\\frac{d\\bm v}{dt} \\]\n在磁场中\n\\[ \\bm F=q\\bm v\\times \\bm B \\]\n洛伦兹力\\(F\\)的一个重要特点是它始终垂直于速度\\(v\\)，因此洛伦兹力只改变带电运动粒子的运动方向，而不改变它的速度的大小。\n霍尔效应\n霍尔元件上下两面的电势差为\n\\[ U_{ab}=\\frac{IB}{nqd}=K\\frac{IB}{d} \\]\n其中\\(B\\)是与电流\\(I\\)垂直的，如果把电流方向记为霍尔元件的长度方向，那么宽度记为\\(d\\)（也就是\\(B\\)方向的长度），\\(n\\)为单位体积内载流子的数量，\\(q\\)为载流子的电荷量。\n如果载流子是电子，则称为\\(n\\)型半导体。如果是空穴，则为\\(p\\)型。\n磁介质 磁介质的分类\n磁介质是指放在磁场中经磁化后能反过来影响原来磁场的物质\n原来的磁场记作\\(\\bm B_0\\)，磁介质产生的记作\\(\\bm B\u0026#39;\\)，则磁介质中的磁感应强度是其矢量和\n\\[ \\bm B=\\bm B_0+\\bm B\u0026#39; \\]\n相对磁导率定义为\n\\[ \\mu_r=\\frac{B}{B_0} \\]\n顺磁质。顺磁质的\\(\\mu_r\u0026gt;1\\)。产生的磁场和原来的磁场同方向 抗磁质。抗磁质的\\(\\mu_r\u0026lt;1\\)。产生的磁场和原来的磁场反方向 铁磁质。铁磁质的\\(\\mu_r\u0026gt;\u0026gt;1\\)。产生的磁场和原来的磁场同方向  铁磁质是强磁性物质，其他称为弱磁性物质（非磁性）物质\n对于非磁性物质，其相对磁导率接近\\(1\\)，通常用磁化率来替代表示，即\n\\[ \\mathcal{X}_m=\\mu_r-1 \\]\n磁介质中的环路定理\n将安培环路定理应用到磁介质中，并取以\\(r\\)为半径的闭合同心圆周为积分路径，则有\n\\[ \\oint_L \\bm B\\cdot d\\bm l = \\mu_0(NI+I_s) \\]\n其中\\(I_s\\)是束缚电流，是线圈电流导致的在磁介质中产生的电流。顺磁质电流方向相同，抗磁质则相反。\n通常我们无法预先知道\\(I_s\\)，所以我们代换得\n\\[ \\oint_L \\bm B\\cdot d\\bm l = \\mu_0\\mu_rNI \\]\n令\\(\\mu=\\mu_0\\mu_r\\)称为磁导率,则\n\\[ \\oint_L \\frac{\\bm B}{\\mu}\\cdot d\\bm l = \\sum_{内}I \\]\n令\\(\\frac{\\bm B}{\\mu}=\\bm H\\)称为磁场强度，则\n\\[ \\oint_L \\bm H\\cdot d\\bm l = \\sum_{内}I \\]\n电磁感应与电磁场 电动势 法拉第通过研究发现，不论用什么办法，只要使穿过道题闭合回路的磁通量发生变化，此回路中就会产生电流。\n电动势的定义为：非静电力把单位正电荷从负极通过电荷内部搬移到正极所做的功，用\\(\\varepsilon\\)表示。如果用\\(A_k\\)表示在电源内非静电力把正电荷\\(q\\)从负极搬到正极所做的功，则\n\\[ \\varepsilon = \\frac{A_k}{q} \\]\n同样的，我们定义单位正电荷所受的非静电力定义为非静电性电场强度。若用\\(F_k\\)表示正电荷\\(q\\)所受的非静电力，用符号\\(E_k\\)表示非静电性电场强度，则\n\\[ \\bm E_k=\\frac{\\bm F_k}{q} \\]\n结合两式，有\n\\[ A_k = \\int^+_- \\bm F_k\\cdot d\\bm l = q\\int^+_- \\bm E_k\\cdot d\\bm l \\]\n\\[ \\varepsilon = \\int^+_- \\bm E_k\\cdot d\\bm l \\]\n如果一个闭合回路\\(L\\)上处处都有非静电力\\(F_k\\)存在，这时整个闭合回路内的总电动势是\n\\[ \\varepsilon = \\oint \\bm E_k\\cdot d\\bm l \\]\n对于有非静电力\\(F_k\\)存在的一段电路\\(ab\\)上的电动势为\n\\[ \\varepsilon = \\int^b_a \\bm E_k\\cdot d\\bm l \\]\n法拉第电磁感应定律 导体回路中产生的感应电动势\\(\\varepsilon_i\\)的大小与穿过回路的磁通量的变化率\\(d\\varPhi/dt\\)成正比\n\\[ \\varepsilon_i =-\\frac{d\\varPhi}{dt} \\]\n具体方向由右手螺旋定则确定。\n如果有多匝线圈，并且穿过各线圈的磁通量相同，则总磁通量\\(\\varPsi=N\\varPhi\\)\n楞次定律\n闭合回路中，感应电流的方向总是使得它自身所产生的磁通量反抗引起感应电流的磁通量的变化。\n动生电动势 由于导体或导体回路在恒定磁场中运动，导体或导体回路内产生的感应电动势。\n若长为\\(l\\)的导体棒\\(ab\\)，在恒定的均匀磁场中以匀速\\(\\bm v\\)沿垂直于磁场\\(\\bm B\\)的方向运动。\n导体棒\\(ab\\)上的动生电动势为\n\\[ \\varepsilon_i = \\int^b_a \\bm E_k\\cdot d\\bm l = \\int^b_a (\\bm v\\times \\bm B)\\cdot d\\bm l \\]\n可以根据左手定则判断电动势方向。\n感生电动势 导体或导体回路不动，由于磁场随时间变化，导体或导体回路中产生的感应电动势。\n变化的磁场在周围空间激发出电场线为闭合曲线的电场，称其为感生电场或有旋电场。有旋电场的出现与是否存在导体没有关系。\n当回路固定不动，磁通量\\(\\varPsi\\)的变化仅来自磁场的变化时，电动势为\n\\[ \\varepsilon_i = \\oint_L \\bm E_V\\cdot \\bm l=-\\iint_S\\frac{\\partial\\bm B}{\\partial t}\\cdot d\\bm S \\]\n自感现象 导体回路中由于自身电流的变化，而在自身回路中产生感应电动势的现象。产生的电动势称为自感电动势。\n设一回路通有电流\\(I\\)，根据毕奥-萨伐尔定律，总磁通\n\\[ \\varPsi = LI \\]\n式中比例系数\\(L\\)称为该回路的自感系数，简称自感。如果回路周围不存在铁磁质，自感\\(L\\)是衣蛾与电流\\(I\\)无关，仅由回路的匝数、几何形状、大小，以及周围介质的磁导率决定的物理量。\n若回路的自感\\(L\\)保持不变，则通过回路的总磁通\\(\\varPsi\\)仅随回路中电流的变化而变化，根据法拉第电磁感应定律，自感电动势为\n\\[ \\varepsilon_L = -\\frac{d\\varPsi}{dt} = -L\\frac{dI}{dt} \\]\n式中的负号表明自感电动势产生的感应电流的方向总是反抗回路中电流\\(I\\)的变化。\n互感现象 由于某一个导体回路中的电流发生变化，而在邻近导体回路内产生感应电动势的现象，称为互感现象。\n类似于自感系数。设\\(\\varPsi_{21}\\)表示回路\\(1\\)中通有电流\\(I_1\\)时，它激发的磁场在回路\\(2\\)中产生的总磁通。\n\\[ \\varPsi_{21} = M_{21}I_1 \\]\n同样也有\n\\[ \\varepsilon_M = -\\frac{d\\varPsi}{dt} = -M\\frac{dI}{dt} \\]\n磁能 一个自感为\\(L\\)通有电流\\(I\\)的线圈，其中所储存的磁能\n\\[ W_m=\\frac{1}{2}LI^2 \\]\n称为自感磁能。\n储存在线圈中的能量可以用描述磁场的物理量\\(B\\)或\\(H\\)来表示。长直螺线管的自感为\\(L=\\mu n^2 V\\)，其磁能为\n\\[ W_m = \\frac{1}{2}\\mu n^2 I^2V \\]\n对于长直螺线管，有\n\\[ H = nI;B=\\mu n I \\]\n有\n\\[ W_m = \\frac{1}{2}BHV=\\frac{1}{2}\\mu H^2V=\\frac{1}{2}\\frac{B^2}{\\mu} V \\]\n其中\\(\\mu\\)是其磁导率，\\(n\\)是每单位长度的匝数，\\(V\\)是螺线管的体积，所以能量密度为\n\\[ w_m = \\frac{1}{2}BH \\]\n进一步的研究表明，某点磁场的能量密度只与该点的磁感应强度\\(B\\)和介质的性质有关。\n\\[ dW_m = w_mdV = \\frac{1}{2}BHdV \\]\n\\[ W_m = \\int_V dW_m=\\frac{1}{2}\\int_V BHdV \\]\n位移电流 对于非恒定电流，例如电路中加一个电容器，那么原始的安培环路定理则不再适用，因为将曲面穿过两极板之间得到的结果是0. 不符合事实。\n于是麦克斯韦提出了位移电流的概念，即在电容器的两个极板中也有电流。定义为\n\\[ I_D=\\frac{d\\varPhi_D}{dt} \\]\n设极板的面积为\\(S\\)，某时刻极板上自由电荷面密度为\\(\\sigma\\)，则电位移为\\(D=\\sigma\\)，于是极板间的电位移通量\\(\\varPhi_D=DS=\\sigma S\\)。电位移通量的时间变化率为\n\\[ \\frac{d\\varPhi_D}{dt} = \\frac{d}{dt}\\sigma S=\\frac{dq}{dt} \\]\n其中\\(dq/dt\\)就是导线中的传到电流。\n于是可以把安培环路定理推广为\n\\[ \\oint_L \\bm H\\cdot d\\bm l=I+I_D \\]\n麦克斯韦方程组的积分形式，电磁场 \\[ \\oint_S \\bm D\\cdot d\\bm S = \\sum_i q_i \\]\n\\[ \\oint_L \\bm E\\cdot d\\bm l = -\\iint_S\\frac{\\partial \\bm B}{\\partial t}\\cdot d\\bm S \\]\n\\[ \\oint_S \\bm B\\cdot d\\bm S = 0 \\]\n\\[ \\oint_L \\bm H\\cdot d\\bm l = \\sum(I_D+I) \\]\n狭义相对论基础 力学相对性原理 在彼此作匀速直线运动的所有惯性系中，物体运动所遵循的力学规律是完全相同的，应具有完全相同的数学表达形式。也就是说，对于描述力学现象的规律而言，所有惯性系都是等价的。这称为力学相对性原理\n绝对时空观 狭义相对论之前，科学家们普遍认为时间和空间都是绝对的，可以脱离物质运动而存在，并且时间和空间也没有任何联系。\n这就是经典力学的时空观，也称为绝对时空观。\n伽利略坐标变换式 设有两个惯性参考系\\(S,S\u0026#39;\\)，取坐标系\\(Oxyz,O\u0026#39;x\u0026#39;y\u0026#39;z\u0026#39;\\)，简单起见他们的坐标轴相互平行且\\(x,x\u0026#39;\\)相互重合，设\\(S\u0026#39;\\)沿\\(x\\)轴方向以恒定速度\\(\\bm u\\)相对\\(S\\)运动，并且\\(O,O\u0026#39;\\)重合时\\(t=t\u0026#39;=0\\)\n则在\\(S\\)中一点\\((x,y,z)\\)在\\(S\u0026#39;\\)中的坐标为\n\\[ \\left.\\begin{matrix} x\u0026#39;=\u0026amp;x-ut \\\\ y\u0026#39;=\u0026amp;y \\\\ z\u0026#39;=\u0026amp;z \\end{matrix}\\right\\} \\]\n根据绝对时间概念，有\n\\[ t\u0026#39; = t \\]\n这就是这两个坐标系间的伽利略坐标变换式。\n牛顿运动定律具有伽利略变换的不变性 经典力学所有的基本定律都满足经典力学相对性原理，但是之后发现麦克斯韦方程组并不满足。\n狭义相对论的两个基本假设 光速的伽利略变换未能被实验证实\n光是电磁波，由麦克斯韦方程组可知\n\\[ c=\\frac{1}{\\sqrt{\\varepsilon_0\\mu_0}}=2.998\\times 10^8 m/s \\]\n也就是说光速是恒定的，与传播方向和参考系的选择无关。\n如果伽利略变换是正确的，则在\\(S\u0026#39;\\)中光速应该是\\(c-u\\)，但迈克耳孙-莫雷实验证实了光速都是\\(c\\)，发现了经典力学和光速的不相容性。\n假设1\n在所有惯性系中，一切物理学定律都相同，即具有相同的数学表达形式。或者说，对于描述一切物理现象的规律来说，所有惯性系都是等价的。这也称为狭义相对论的相对性原理。\n假设2\n在所有惯性系中，真空中光沿各个方向传播的速率都等于同一个恒量\\(c\\)，与光源和观察者的运动状态无关。这也称为光速不变原理。\n“同时性”的相对性 在\\(S\u0026#39;\\)系中异地同时发生的两个事件，在\\(S\\)系看来并不同时。反过来也是这样。\n需要说明的是，在一个惯性系同一地点发生的两个同时事件，对于其他惯性系也是同时的。\n产生“同时性”的相对性的原因是，光在不同惯性系中具有相同的速率和光的速率是有限的。\n时间延缓 将在一个惯性系中测得的、发生在该惯性系中同一地点的两个事件之间的时间间隔称为原时。\n时间的测量具有相对性，在不同惯性系中测量给定的两个事件之间的时间间隔，测得的结果以原时最短，这一现象称为时间延缓效应。\n时间延缓效应还可陈述为，运动时钟走的速率比静止时钟走的速率要慢。\n时间延缓效应也是相对的，运动的\\(S\u0026#39;\\)的时钟相对于静止的\\(S\\)的时钟要慢。反过来也是这样。\n以公式来说，设两件事发生的间隔在静止的\\(S\\)看来是\\(\\tau\\)，而在运动的\\(S\u0026#39;\\)看来是\\(\\tau_0\\)（即原时，事件是在\\(S\u0026#39;\\)中同一地点发生的），\\(S\u0026#39;\\)相对于\\(S\\)以\\(\\bm u\\)的速率运动则\n\\[ \\tau = \\frac{\\tau_0}{\\sqrt{1-\\beta^2}}=\\gamma\\tau_0 \\]\n其中\\(\\beta=u/c,\\gamma = 1/\\sqrt{1-\\beta^2}\\)\n长度收缩 设地面上有一静止的尺子，车（\\(S\u0026#39;\\)系）以速度\\(\\bm u\\)相对地面（\\(S\\)系）沿尺子长度方向运动。\n若地面上的人观察到尺子长为\\(L\\)，也称为原长，则车上的人观察到\n\\[ L\u0026#39;=L\\sqrt{1-\\bigg(\\frac{u}{c}\\bigg)^2} \\]\n其表明，沿尺长度方向运动的观测者测得的尺长，较相对尺静止观测者测得的同一尺的原长\\(L\\)要短，或者说，各惯性系中测量同一尺长，以原长为最长。\n洛伦兹坐标和时间变换式 条件设置和伽利略坐标变换式一致，只是增加了第四维时间，即\\(S\\)系中坐标为\\((x,y,z,t)\\)，\\(S\u0026#39;\\)系中为\\((x\u0026#39;,y\u0026#39;,z\u0026#39;,t\u0026#39;)\\)，洛伦兹坐标和事件变换式为\n\\[ x\u0026#39;=\\frac{x-ut}{\\sqrt{1-\\beta^2}},\\quad t\u0026#39;=\\frac{t-\\frac{u}{c^2}x}{\\sqrt{1-\\beta^2}} \\]\n\\[ y\u0026#39;=y,\\quad z\u0026#39;=z \\]\n逆变换为\n\\[ x=\\frac{x\u0026#39;+ut\u0026#39;}{\\sqrt{1-\\beta^2}},\\quad t=\\frac{t\u0026#39;+\\frac{u}{c^2}x\u0026#39;}{\\sqrt{1-\\beta^2}} \\]\n\\[ y=y\u0026#39;,\\quad z=z\u0026#39; \\]\n在低速时，即\\(u\u0026lt;\u0026lt;c\\)时，\\(\\beta\\approx0\\)，此时洛伦兹变换与伽利略变换几乎一致，也就是说低速情况我们可以使用伽利略变换。\n真空中的光速\\(c\\)是一切物体运动速率的极限。\n空间间隔和时间间隔是紧密联系着的，即\n\\[ \\Delta x\u0026#39;=\\frac{\\Delta x-u\\Delta t}{\\sqrt{1-\\beta^2}},\\quad \\Delta t\u0026#39;=\\frac{\\Delta t-\\frac{u}{c^2}\\Delta x}{\\sqrt{1-\\beta^2}} \\]\n逆变换\n\\[ \\Delta x=\\frac{\\Delta x\u0026#39;+u\\Delta t\u0026#39;}{\\sqrt{1-\\beta^2}},\\quad \\Delta t=\\frac{\\Delta t\u0026#39;+\\frac{u}{c^2}\\Delta x\u0026#39;}{\\sqrt{1-\\beta^2}} \\]\n洛伦兹变换与狭义相对论时空观 “同时性”的相对性\n设在\\(S\u0026#39;\\)系中不同地点、同时发生了两个事件，则在\\(S\\)看来发生的时间间隔为\n\\[ \\Delta t= \\bigg(\\frac{u}{c^2}\\Delta x\u0026#39;\\bigg)\\bigg/\\sqrt{1-\\beta^2} \\]\n时间延缓\n\\(S\u0026#39;\\)中在同一地点、不同时间发生的两个事件，对于\\(S\\)来说事件间隔为\n\\[ \\Delta t = \\frac{\\Delta t\u0026#39;}{\\sqrt{1-\\beta^2}}=\\frac{\\tau_0}{\\sqrt{1-\\beta^2}} \\]\n长度收缩\n设尺沿\\(x\u0026#39;\\)方向静止在\\(S\u0026#39;\\)系中，\\(S\u0026#39;\\)系中观测者测得尺长\\(L_0=\\Delta x\u0026#39;\\)为尺的原长，\\(S\\)系中观测者要测量运动尺的长度\\(L\\)，必须要在\\(S\\)系中同时确定尺两端的坐标\\(x_1,x_2\\)，这样\\(L=x_2-x_1\\)\n\\[ L=\\Delta x=L_0\\sqrt{1-\\beta^2} \\]\n爱因斯坦速度相加定律 \\[ v_x\u0026#39; = \\frac{v_x-u}{1-\\frac{u}{c^2}v_x} \\]\n\\[ v_y\u0026#39; = \\frac{v_y\\sqrt{1-\\beta^2}}{1-\\frac{u}{c^2}v_x} \\]\n\\[ v_z\u0026#39; = \\frac{v_z\\sqrt{1-\\beta^2}}{1-\\frac{u}{c^2}v_x} \\]\n相对论动量和质量 质量是一个和速率有关的量\n\\[ m(v) = \\frac{m_0}{\\sqrt{1-(\\frac{v}{c})^2}} \\]\n式中\\(m_0\\)是质点静止时的质量，即由相对该质点静止的观察者测得的质量，称为静止质量。\n于是动量为\n\\[ \\bm p = m\\bm v = \\frac{m_0}{\\sqrt{1-(\\frac{v}{c})^2}}\\bm v \\]\n同时，力为\n\\[ \\bm F = \\frac{d\\bm p}{dt} = \\frac{d}{dt}\\bigg(\\frac{m_0}{\\sqrt{1-(\\frac{v}{c})^2}}\\bm v\\bigg) \\]\n相对论动能 \\[ E_k = \\int\\bm F\\cdot d\\bm r = \\int_0^v d(mv)\\cdot \\bm v \\]\n\\[ E_k = \\int^m_{m_0}c^2dm = mc^2-m_0c^2 \\]\n质能关系式 \\[ E=mc^2\\\\ E_0=m_0c^2 \\]\n光子的静质量为零，而频率为\\(\\nu\\)的光子所对应的能量为\\(E=h\\nu\\)，所以光子的动质量为\n\\[ m_\\varphi = \\frac{E}{c^2} = \\frac{h\\nu}{c^2} \\]\n相对论能量和动量的关系 \\[ E^2 = p^2c^2 + E_0^2 \\]\n对于光子\n\\[ p = \\frac{h\\nu}{c} = \\frac{h}{\\lambda} \\]\n量子物理基础 ","date":"2022-06-13T19:13:12+08:00","image":"https://kegalas.top/p/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E5%85%AC%E5%BC%8F%E6%95%B4%E7%90%86/cover_huc6be90ba175cec12cafc892e1709e648_57796_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86%E5%85%AC%E5%BC%8F%E6%95%B4%E7%90%86/","title":"大学物理公式整理"},{"content":" 命题逻辑 联结词 否定联结词    \\(P\\) \\(\\neg P\\)    0 1  1 0    合取联结词    \\(P\\) \\(Q\\) \\(P\\wedge V\\)    0 0 0  0 1 0  1 0 0  1 1 1    析取联结词    \\(P\\) \\(Q\\) \\(P\\vee V\\)    0 0 0  0 1 1  1 0 1  1 1 1    条件联结词    \\(P\\) \\(Q\\) \\(P\\to V\\)    0 0 1  0 1 1  1 0 0  1 1 1    双条件联结词    \\(P\\) \\(Q\\) \\(P\\leftrightarrow V\\)    0 0 1  0 1 0  1 0 0  1 1 1    联结词的运算优先级 从高到低依次为，否定、合取、析取、条件、双条件\n命题公式 一些定义 定义1，命题变元与常元\n用于代表取值为真\\((T、1)\\)或假\\((F、0)\\)之一的变量，称为命题变元，通常用大写字母或带下标或上标的大写字母表示，如\\(P、Q、R、P_1、P_2\\)等。将\\(T\\)和\\(F\\)称为命题常元。\n通常把由命题常元、命题变元、联结词以及括弧组成的式子称为表达式,但是只有按照特定组合规则所形成的表达式才有实际意义。\n定义2，命题公式\n命题合式公式(简称命题公式):\n(1)(基础)单个命题常元或命题变元是命题合式公式\n(2)(归纳)如果A和B是命题公式,则\\(\\neg A\\)、\\((A\\wedge B)\\)、\\((A\\vee B)\\)、\\((A\\to B)\\)、\\((A\\leftrightarrow B)\\)是命题合式公式。\n(3)(极小性)只有有限次地应用条款(1)和(2)生成的表达式オ是命题合式公式\n定义3，子公式\n若\\(B\\)是命题公式\\(A\\)的一个连续段且\\(B\\)也是命题公式,则称\\(B\\)是\\(A\\)的个子公式。\n命题公式的赋值 对于有\\(n\\)个变元的公式，有\\(2^n\\)种不同赋值。\n永真式（重言式）\n一个命题公式在任何赋值下，其真值都为\\(T\\)，则称这个公式为永真式（重言式）\n永假式（矛盾式）\n一个命题公式在任何赋值下，其真值都为\\(F\\)，则称这个公式为永假式（矛盾式）\n偶然式\n既不是永真式也不是永假式，则为偶然式\n可满足式\n一个命题公式至少有一个赋值，使其真值为\\(T\\)，则称这个公式为可满足式。也即永真式和偶然式都是可满足式。不是可满足式的称为矛盾式。\n逻辑等价与蕴含 等价 定义\n给定两个命题公式\\(A\\)和\\(B4\\),设\\(P_1,P_2,\\cdots,P_n\\)为所有出现在A和B中的命题变元，但\\(P_i\\)不一定在\\(A\\)和\\(B\\)中同时出现，若对于\\(P_1,P_2,\\cdots,P_n\\)的任一赋值,\\(A\\)和\\(B\\)的真值都相同，则称\\(A\\)和\\(B\\)逻辑等价，记做\\(A\\Leftrightarrow B\\),读做“\\(A\\)等价于\\(B\\)”。\n下面列出常见的命题等价公式\n几个定理\n定理1（代入规则）\n设\\(A\\)、\\(B\\)是命题公式，其中\\(A\\)是重言式，\\(P\\)是\\(A\\)中的命题变元，如果将\\(A\\)中每一处出现的P均用B代入，则所得命题公式\\(A\\)仍然是一个重言式\n定理2\n设\\(A\\)、\\(B\\)是命题公式，则\\(A\\)和\\(B\\)逻辑等价,当且仅当\\(A\\leftrightarrow B\\)是一个重言式。\n定理3（替换规则）\n设\\(A\\)、\\(X\\)、\\(Y\\)是命题公式，\\(X\\)是\\(A\\)的子公式,且有\\(X\\Leftrightarrow Y\\)。如果将\\(A\\)中的\\(X\\)用\\(Y\\)来替换(不必每一处都替换)，则所得到的公式\\(B\\)与\\(A\\)等价,即\\(B\\Leftrightarrow A\\)。\n定理4（传递规则）\n设\\(A\\)、\\(B\\)、\\(C\\)是命题公式，若\\(A\\Leftrightarrow B\\)且\\(B\\Leftrightarrow C\\),则有\\(A\\Leftrightarrow C\\)。\n蕴含 设\\(A\\)、\\(B\\)是命题公式，如果\\(A\\to B\\)是一个重言式,则称\\(A\\)蕴含\\(B\\),记做\\(A\\Rightarrow B\\)。\n一些常见的蕴含公式\n 1.3.7-1   1.3.7-2  证明蕴含式\\(A\\Rightarrow B\\)的一些方法：\n肯定前件法。假设\\(A\\)为\\(T\\)，如果能够推出\\(B\\)为\\(T\\)，则有\\(A\\Rightarrow B\\) 否定后件法。假设\\(B\\)为\\(F\\)，如果能够推出\\(A\\)为\\(F\\)，则有\\(A\\Rightarrow B\\)  几个定理\n定理1\n设\\(A\\)和\\(B\\)是任意两个命题公式，\\(A\\Leftrightarrow B\\)当且仅当\\(A\\Rightarrow B\\)且\\(B\\Rightarrow A\\).\n几个性质\n性质1\n设\\(A\\)、\\(B\\)是命题公式，如果\\(A\\Rightarrow B\\)且\\(A\\)是重言式，则\\(B\\)也是重言式\n性质2\n蕴含关系是传递的，即\\(A\\Rightarrow B\\)且\\(B\\Rightarrow C\\)，则\\(A\\Rightarrow C\\).\n性质3\n如果\\(A\\Rightarrow B\\)且\\(A\\Rightarrow C\\)，则\\(A\\Rightarrow B\\wedge C\\)\n性质4\n如果\\(A\\Rightarrow C\\)且\\(B\\Rightarrow C\\)，则\\(A\\vee B\\Rightarrow C\\)\n对偶式 定义\n设有命题公式\\(A\\)，其中仅含有联结词\\(\\neg,\\vee,\\wedge\\)，如果将\\(A\\)中的\\(\\vee\\)替换为\\(\\wedge\\)，\\(\\wedge\\)替换为\\(\\vee\\)，常元\\(T,F\\)也互相替换，所得到的公式记为\\(A^*\\)，则称\\(A^*\\)为\\(A\\)的对偶式。\n显然有，\\(A\\)也是\\(A^*\\)的对偶式，并且\\((A^*)^*=A\\)\n几个定理\n定理1\n设\\(A\\)和\\(A^*\\)是对偶公式，其中仅含有联结词\\(\\neg,\\vee,\\wedge\\)；\\(P_1,P_2,\\cdots,P_n\\)是出现在\\(A\\)和\\(A^*\\)中的所有命题变元，于是有\n\\[ \\neg A(P_1,P_2,\\cdots,P_n)\\Leftrightarrow A^*(\\neg P_1,\\neg P_2,\\cdots,\\neg P_n) \\]\n\\[ A(\\neg P_1,\\neg P_2,\\cdots,\\neg P_n)\\Leftrightarrow\\neg A^*(P_1,P_2,\\cdots,P_n) \\]\n定理2\n设\\(A,B\\)是命题公式，则有\n如果\\(A\\Leftrightarrow B\\)，则\\(A^*\\Leftrightarrow B^*\\) 如果\\(A\\Rightarrow B\\)，则\\(B^*\\Rightarrow A^*\\)  范式 析取范式和合取范式 析取式\n仅由若干命题变元和若干命题变元之否定通过联结词\\(\\vee\\)构成的命题公式。\n合取式\n仅由若干命题变元和若干命题变元之否定通过联结词\\(\\wedge\\)构成的命题公式。\n析取范式\n一个命题公式被称为析取范式，当且仅当它具有如下形式\n\\[ A_1\\vee A_2\\vee\\cdots\\vee A_n \\]\n其中\\(A_1,A_2,\\cdots,A_n\\)是合取式。\n合取范式\n一个命题公式被称为合取范式，当且仅当它具有如下形式\n\\[ A_1\\wedge A_2\\wedge\\cdots\\wedge A_n \\]\n其中\\(A_1,A_2,\\cdots,A_n\\)是析取式。\n主析取范式 极小项\n一个含\\(n\\)个命题变元的合取式，如果其中每个变元和其否定不同时存在，但两者之一必须出现且仅出现一次，则称该合取式为极小项。\n\\(n\\)个命题变元\\(P_1,P_2,\\cdots,P_n\\)可构成\\(2^n\\)个不同的极小项，其形式为：\n\\[ \\tilde{P_1}\\wedge \\tilde{P_2}\\wedge\\cdots\\wedge \\tilde{P_n} \\]\n其中\\(\\tilde{P_i}\\)或者是\\(P_i\\)，或者是\\(\\neg P_i\\)\n可以用\\(n\\)位二进制编码表示极小项，例如\n\\[ m_{010}=\\neg P_1\\wedge P_2\\wedge\\neg P_3 \\]\n有如下三个性质：\n每一个极小项当其编码与赋值相同时，其真值为\\(T\\)，在其余\\(2^n-1\\)种赋值下其真值均为\\(F\\). 任意两个不同的极小项的合取式永假。 所有极小项的析取式永真。  主析取范式\n设\\(P_1,P_2,\\cdots,P_n\\)是命题公式\\(A\\)中包含的所有命题变元，若由\\(P_1,P_2,\\cdots,P_n\\)的若干极小项析取所构成的析取范式与\\(A\\)等价，则称该析取范式是\\(A\\)的主析取范式。\n有如下定理\n定理1\n在一个命题公式\\(A\\)的真值表中，使\\(A\\)的真值为\\(T\\)的所有赋值所对应的极小项构成的析取范式即为\\(A\\)的主析取范式。\n主合取范式 极大项\n一个含\\(n\\)个命题变元的析取式，如果其中每个变元和其否定不同时存在，但两者之一必须出现且仅出现一次，则称改合取式为极大项。\n\\(n\\)个命题变元\\(P_1,P_2,\\cdots,P_n\\)可构成\\(2^n\\)个不同的极小项，其形式为：\n\\[ \\tilde{P_1}\\vee \\tilde{P_2}\\vee\\cdots\\vee \\tilde{P_n} \\]\n其中\\(\\tilde{P_i}\\)或者是\\(P_i\\)，或者是\\(\\neg P_i\\)\n可以用\\(n\\)位二进制编码表示极大项，例如\n\\[ M_{101}=\\neg P_1\\vee P_2\\vee\\neg P_3 \\]\n（编码注意与极小项意义相反）\n有如下三个性质：\n每一个极大项当其真值赋值与编码相同时，其真值为\\(F\\)，在其余\\(2^n-1\\)种赋值下其真值均为\\(T\\). 任意两个不同的极大项的析取式永真。 所有极大项的合取式永假。  主合取范式\n设\\(P_1,P_2,\\cdots,P_n\\)是命题公式\\(A\\)中包含的所有命题变元，若由\\(P_1,P_2,\\cdots,P_n\\)的若干极大项合取所构成的合取范式与\\(A\\)等价，则称该合取范式是\\(A\\)的主合取范式。\n有如下定理\n定理1\n在一个命题公式\\(A\\)的真值表中，使\\(A\\)的真值为\\(F\\)的所有赋值所对应的极大项构成的合取范式即为\\(A\\)的主合取范式。\n定理\n设\\(A\\)的主析取范式的各个极小项的下标转为十进制，组成的集合为\\(S_1\\{i_1,i_2,\\cdots,i_k\\}\\)；主合取范式的各个极大项的下标转为十进制，组成的集合为\\(S_2=\\{j_1,j_2,\\cdots,j_t\\}\\)，则有\n\\[ S_1\\cap S_2=\\phi \\]\n\\[ S_1\\cup S_2=\\{0,1,2,\\cdots,2^n-1\\} \\]\n范式的计算 除了可以用真值表来算，还可以通过德摩根定律等将“\\(\\to\\)”等不是析取、合取、否定的联结词转化，直到只剩析取、合取、否定。再通过添加、删除括号转化为主合取范式或主析取范式。\n命题逻辑的推理理论 推理规则 P规则：在推导过程中，前提可以在任何步骤引入。 T规则：在推导过程中，如果由已经推出的一个或多个公式蕴含\\(S\\)，则公式\\(S\\)可以引入到推导过程中。  证明方法 无义证明法。如果能证明\\(P\\)恒为假，则有\\(P\\to Q\\)恒为真，即\\(P\\Rightarrow Q\\) 平凡证明法。如果能证明\\(Q\\)恒为真，则有\\(P\\to Q\\)恒为真，即\\(P\\Rightarrow Q\\) 直接证明法。从一组前提出发，利用公认的推理规则，逻辑演绎得到有效结论。 归谬法（即反证法）。  定理\n\\(H_1,H_2,\\cdots,H_m,C\\)是公式，如果存在公式\\(R\\)，使得\\(H_1,H_2,\\cdots,H_m,\\neg C\\Rightarrow R\\wedge\\neg R\\)，则有\\(H_1,H_2,\\cdots,H_m\\Rightarrow C\\)\nCP规则法。  \\(H_1,H_2,\\cdots,H_n,R,C\\)是命题公式，根据输出律\\(E_{22}\\)推知\n\\[ (H_1\\wedge H_2\\wedge\\cdots\\wedge H_n)\\to(R\\to C)\\Leftrightarrow(H_1\\wedge H_2\\wedge\\cdots\\wedge H_n\\wedge R)\\to C \\]\n因此，如果能够证明\\(H_1,H_2,\\cdots,H_n,R\\Rightarrow C\\)，则有\\(H_1,H_2,\\cdots,H_n\\Rightarrow R\\to C\\)\n谓词逻辑 谓词和量词 谓词 刻画单个个体的特性或者多个个体间关系的模式称为谓词。\n量词 全称量词\\(\\forall\\) 存在量词\\(\\exist\\)  几个规则\n应当使用\\(\\forall x(H(x)\\to D(x))\\)，而不能表示为\\(\\forall x(H(x)\\wedge D(x))\\)。\n应当使用\\(\\exist x(H(x)\\wedge D(x))\\)，而不能表示为\\(\\exist x(H(x)\\to D(x))\\)。\n谓词公式 定义\n谓词逻辑的合式公式（简称谓词公式）可由以下步骤生成 1. 原子公式（不出现联结词和量词的单个谓词）是谓词公式。 2. 如果\\(A\\)和\\(B\\)是谓词公式，则\\(\\neg A,(A\\wedge B),(A\\vee B),(A\\to B),(A\\leftrightarrow B)\\)是谓词公式 3. 如果\\(A\\)是谓词公式，并且\\(A\\)中有未被量化的个体变元\\(x\\)，则\\(\\forall xA(x)\\)和\\(\\exist xA(x)\\)是谓词公式。 4. 只有有限次应用步骤1、2、3所得到的的公式才是谓词公式。\n子公式\n若\\(B\\)是谓词公式\\(A\\)的一个连续段且\\(B\\)也是谓词公式，则称\\(B\\)是\\(A\\)的一个子公式。\n辖域\n紧跟\\(\\forall x\\)和\\(\\exist x\\)之后的最小的子公式称为该量词的辖域。\n约束变元\n在\\(\\forall x\\)和\\(\\exist x\\)辖域内\\(x\\)的一切出现称之为约束出现，这个\\(x\\)叫做约束变元。\n自由变元\n个体变元的非约束出现称为自由出现，自由出现的个体变元称为自由变元。\n约束变元的换名规则\n对某个约束变元换名时，需对量词的作用变元以及该量词辖域内所有受该量词约束的约束变元一起换名。 换名后的变元符号应是量词辖域内未出现的符号，最好是整个公式中未出现的符号。  谓词验算的永真公式 谓词公式的赋值 定义1\n对于一个谓词公式，若给它指定一个个体域\\(E\\)，再给所有谓词符均指派出确定的关系(具体的特性或关系)，给所有命题变元指派出确定命题(或者指定\\(T\\)或\\(F\\))，并为所有自由变元（注意不包含约束变元）分别指派\\(E\\)上确定的个体，则称为对谓词公式的一个赋值(指派或结识)。谓词公式经过赋值之后就变成了具有确定真值的命题。\n定义2\n设\\(A\\)是谓词公式，如果对于特定论域\\(E\\)上的任何赋值，\\(A\\)的真值都为真，则称谓词公式\\(A\\)在\\(E\\)上永真;如果对于特定论域\\(E\\)上的任何赋值，\\(A\\)的真值都为假，则称谓词公式\\(A\\)在\\(E\\)上永假;若特定论域\\(E\\)上存在一种赋值，使得\\(A\\)的真值都为真，则称谓词公式\\(A\\)在\\(E\\)上可满足。\n定义3\n设\\(A\\)是谓词公式，如果对于任何赋值，\\(A\\)的真值都为真，则称谓词公式\\(A\\)是永真式;如果对于任何赋值，\\(A\\)的真值都为假，则称谓词公式\\(A\\)是永假式;若存在一种赋值，使得\\(A\\)的真值为真，则称谓词公式\\(A\\)是可满足式。\n谓词演算的基本永真式 命题逻辑的等价式和蕴含式可在谓词逻辑中推广使用 量词的否定律  \\[ \\neg\\forall xP(x)\\Leftrightarrow \\exist x\\neg P(x) \\]\n\\[ \\neg\\exist xP(x)\\Leftrightarrow \\forall x\\neg P(x) \\]\n量词辖域的扩张与收缩律   2.3.2.3  量词的分配律  多重量词律  其他  \\(\\forall xP(x)\\Rightarrow P(y)\\)，\\(y\\)是论域中的任一确定个体。\n\\(P(y)\\Rightarrow\\exist xP(x)\\)，\\(y\\)是论域中的某个确定个体。\n\\(\\forall xP(x)\\Rightarrow\\exist xP(x)\\)\n谓词逻辑的推理理论 存在指定原则（ES）  \\[ \\frac{\\exist xP(x)}{\\therefore P(a)} \\]\n\\(a\\)是个体常元，注意所指定的个体常元要使得谓词为真。\n全称指定原则（US）  \\[ \\frac{\\forall xP(x)}{\\therefore P(y)} \\]\n\\(y\\)是自由变元，也可以指定到个体常元\\(a\\)\n\\[ \\frac{\\forall xP(x)}{\\therefore P(a)} \\]\n注意如果同时指定\\(\\exist xP(x)\\)和\\(\\forall xQ(x)\\)，应当先指定\\(P(a)\\)，再指定\\(Q(a)\\)，才能保证两者都为真。\n存在推广原则（EG）  \\[ \\frac{P(a)}{\\therefore\\exist xP(x) } \\]\n全称推广原则（UG）  \\[ \\frac{\\Gamma\\Rightarrow P(x)}{\\therefore\\Gamma\\Rightarrow\\forall xP(x)} \\]\n\\(\\Gamma\\)是已知公理和前提的合取，\\(\\Gamma\\)中没有自由变元\\(x\\)的出现。\n集合 集合的表示方法 列举法 描述法：用自然语言或谓词描述集合中元素的共同特征。 归纳定义法（见后）  集合间的关系 外延性公理\n两个集合\\(A,B\\)相等，记为\\(A=B\\)，当且仅当它们有相同的元素，即\n\\[ A=B\\Leftrightarrow \\forall x(x\\in A\\leftrightarrow x\\in B) \\]\n两个集合不相等，通常记为\\(A\\neq B\\)\n子集\n设\\(A、B\\)是任意的两个集合，若集合\\(A\\)的每个元素都是集合\\(B\\)的元素，则称\\(A\\)为\\(B\\)的子集或称\\(B\\)包含\\(A\\),记为\\(A\\subseteq B\\)或\\(B\\supseteq A\\)，用逻辑公式表示为\n\\[ A\\subseteq B\\Leftrightarrow\\forall x(x\\in A\\to x\\in B) \\]\n如果\\(A\\)不是\\(B\\)的子集，通常记为\\(A\\nsubseteq B\\)\n真子集\n如果集合\\(A\\)的每一个元素都属于\\(B\\)，但集合\\(B\\)中至少有一个元素不属于\\(A\\)，则称\\(A\\)为\\(B\\)的真子集，记为\\(A\\subset B\\)，用逻辑公式表示为\n\\[ A\\subset B\\Leftrightarrow\\forall x(x\\in A\\to x\\in B)\\wedge \\exist y(y\\in B\\wedge y\\notin A)\\Leftrightarrow(A\\subseteq B)\\wedge(A\\neq B) \\]\n全集\n在一定范围内所有事物组成的集合称为该范围内的全集记为\\(U\\)，用逻辑公式表示为\n\\[ U = \\{x|P(x)\\vee\\neg P(x)\\} \\]\n其中，\\(P(x)\\)是任意的谓词\n空集\n不含任何元素的集合称为空集，记为\\(\\phi\\)，用逻辑公式表示为\n\\[ \\phi = \\{x|P(x)\\wedge\\neg P(x)\\} \\]\n其中，\\(P(x)\\)是任意的谓词，并且显然有\\(|\\phi|=0\\)\n几个定理\n定理1\n空集是任一集合的子集，并且是任何非空集合的真子集。\n定理2\n设\\(A,B,C\\)是集合，若\\(A\\subseteq B\\)且\\(B\\subseteq C\\)，则\\(A\\subseteq C\\)。\n定理3\n集合\\(A,B\\)相等的充要条件是\\(A,B\\)互为子集。\n定理3.1\n对于任何集合\\(A\\)，有\\(A\\subseteq A\\)\n定理4\n空集是唯一的。\n集合的运算 集合的交，交集\n\\[ A\\cap B = \\{x|x\\in A\\wedge x\\in B\\} \\]\n集合的并，并集\n\\[ A\\cup B = \\{x|x\\in A\\vee x\\in B\\} \\]\n集合的差，相对补集\n\\[ A-B=\\{x|x\\in A\\wedge x\\notin B\\} \\]\n集合的补，绝对补集\n\\[ \\bar{A}=U-A=\\{x|x\\in U\\wedge x\\notin A\\} \\]\n集合的对称差\n\\[ A\\oplus B=(A-B)\\cup(B-A)=\\{x|(x\\in A\\wedge x\\notin B)\\vee(x\\in B\\wedge x\\notin A)\\} \\]\n集合的环积\n\\[ A\\otimes B=\\overline{A\\oplus B}=(A\\cap B)\\cup(\\bar{A}\\cap\\bar{B})=\\{x|(x\\in A\\wedge x\\in B)\\vee(x\\notin A\\wedge x\\notin B)\\} \\]\n满足如下运算律\n 3.2.1  幂集\n给定集合\\(A\\)，由\\(A\\)所有子集为元素构成的集合，称为\\(A\\)的幂集，记作\\(\\rho(A)\\)。若\\(|A|=n\\)，则有\\(|\\rho(A)=2^n|\\)\n容斥原理 定理1\n设\\(A_1,A_2\\)是有限集合，其元素个数分别为\\(|A_1|,|A_2|\\)，则\\(|A_1\\cup A_2|=|A_1|+|A_2|-|A_1\\cap A_2|\\)\n容斥原理\n将上式推广，得\n\\[ |A_1\\cup A_2\\cup\\cdots\\cup A_n|=\\sum_{i=1}^n|A_i|-\\sum_{1\\leq i\u0026lt;j\\leq n}|A_i\\cap A_j|+\\\\ \\sum_{1\\leq i\u0026lt;j\u0026lt;k\\leq n}|A_i\\cap A_j\\cap A_k|-\\cdots+(-1)^{n+1}|A_1\\cap A_2\\cap\\cdots\\cap A_n| \\]\n归纳证明 集合的归纳定义 基础条款：指出某些事物属于\\(S\\)，其功能是给集合\\(S\\)指定初始元素使其不为空。 归纳条款：指出由集合\\(S\\)中的已有元素构造新元素的办法。 极小性条款：断言一个事物除非能有限次应用基础条款和归纳条款构成，否则它不在集合\\(S\\)中。  归纳法证明 基础步骤。对于基础条款中的指定的每个初始元素\\(t\\)，证明命题\\(P(t)\\)为真。 归纳步骤。证明如果事物\\(x,y,\\cdots\\)有\\(P\\)性质，那么用归纳条款指定的方法组合它们所得的新元素也具有性质\\(P\\)  数学归纳法 第一原理\n（归纳基础）证明\\(P(0)\\)为真（可以用任何办法） （归纳假设）任取\\(n(n\\ge0)\\)，假设\\(P(n)\\)为真。 （归纳推理）由\\(P(n)\\)为真，推出\\(P(n+1)\\)也为真。  第二原理\n（归纳基础）证明\\(P(0)\\)为真（可以用任何办法） （归纳假设）假设对任意的\\(n\u0026lt;k\\)，均有\\(P(k)\\)为真。 （归纳推理）证明\\(P(n)\\)也为真。  集合的笛卡尔积 序偶\n两个元素\\(a\\)和\\(b\\)组成的具有固定次序的序列称为序偶或二元组，记为\\(\u0026lt;a,b\u0026gt;\\)。对于序偶\\(\u0026lt;a,b\u0026gt;\\)，\\(a\\)称为第\\(1\\)元素，\\(b\\)称为第\\(2\\)元素。\n序偶的相等\n两个序偶\\(\u0026lt;a,b\u0026gt;\\)和\\(\u0026lt;c,d\u0026gt;\\)相等，记为\\(\u0026lt;a,b\u0026gt;=\u0026lt;c,d\u0026gt;\\)，当且仅当\\(a=c\\)且\\(b=d\\)。\n笛卡尔积（叉积）\n\\[ A\\times B=\\{\u0026lt;a,b\u0026gt;|a\\in A,b\\in B\\} \\]\n对于多个集合，有\n\\[ A_1\\times A_2\\times\\cdots\\times A_n=\\{\u0026lt;a_1,a_2, \\cdots,a_n\u0026gt;|a_i\\in A_i,1\\leq i\\leq n\\} \\]\n其中\\(A\\times A\\times\\cdots\\times A\\)（\\(n\\)个）可以记作\\(A^n\\)\n规定\\(\u0026lt;a_1,a_2, \\cdots,a_n\u0026gt;=\u0026lt;\u0026lt;a_1,a_2, \\cdots,a_{n-1}\u0026gt;,a_n\u0026gt;\\)，而不等于\\(\u0026lt;a_1,\u0026lt;a_2, \\cdots,a_n\u0026gt;\u0026gt;\\)等等其他序偶。\n关于笛卡尔积有如下定理\n定理1\n\\(A\\times(B\\cup C)=(A\\times B)\\cup(A\\times C)\\) \\(A\\times(B\\cap C)=(A\\times B)\\cap(A\\times C)\\) \\((A\\cup B)\\times C=(A\\times C)\\cup(B\\times C)\\) \\((A\\cap B)\\times C=(A\\times C)\\cap(B\\times C)\\)  定理2\n如果\\(A_i(i=1,2,\\cdots,n)\\)都是有限集合，那么\n\\[ |A_1\\times A_2\\times\\cdots\\times A_n|=|A_1|\\cdot|A_2|\\cdot\\cdots\\cdot|A_n| \\]\n二元关系 关系的定义 两个集合\\(A\\)和\\(B\\)的笛卡儿积\\(A\\times B\\)的任一子集\\(R\\),称为集合\\(A\\)到\\(B\\)上的二元关系。二元关系\\(R\\)是由序偶构成的集合，若\\(\u0026lt;x,y\u0026gt;\\in R\\)，则称\\(x\\)与\\(y\\)有\\(R\\)关系，也记为\\(xRy\\);否则,\\(\u0026lt;x,y\u0026gt;\\notin R\\)，称\\(x\\)与\\(y\\)没有\\(R\\)关系，也记为\\(x\\cancel{R}y\\)。\n设\\(R\\)是集合\\(A\\)到\\(B\\)的二元关系。集合\\(A\\)称为\\(R\\)的前域，集合\\(B\\)称为\\(R\\)的陪域。集合\\(\\{x|(\\exist y)(\u0026lt;x,y\u0026gt;\\in R)\\}\\)称为\\(R\\)的定义域，记为\\(domR\\)。集合\\(\\{y|(\\exist x)(\u0026lt;x,y\u0026gt;)\\in R)\\}\\)称为\\(R\\)的值域，记为\\(ranR\\)。显然, \\(domR\\subseteq A\\)和\\(ranR\\subseteq B\\)。\n关系的表示 关系矩阵  \\[ r_{ij}= \\left\\{\\begin{matrix} 1, if\u0026lt;a_i,b_j\u0026gt;\\in R\\\\ 0, if\u0026lt;a_i,b_j\u0026gt;\\notin R \\end{matrix}\\right. \\]\n关系图   3.6.2  关系的运算 所有集合的运算对于二元关系同样适用。\n复合运算\n设\\(R\\)为集合\\(A\\)到\\(B\\)的二元关系，\\(S\\)为\\(B\\)到\\(C\\)的二元关系，令\n\\[ R\\circ S=\\{\u0026lt;a,c\u0026gt;|a\\in A\\wedge c\\in C\\wedge(\\exist b)(b\\in B\\wedge\u0026lt;a,b\u0026gt;\\in R\\wedge \u0026lt;b,c\u0026gt;\\in S)\\} \\]\n称\\(R\\circ S\\)为\\(R\\)与\\(S\\)的复合关系。\n复合运算可以通过关系的矩阵的运算来实现\n\\[ \\bm{M}_{R\\circ S}=\\bm{M}_R\\odot\\bm{M}_S \\]\n其中\\(\\odot\\)是布尔乘法运算，\\(c_{ij}=\\bigvee_{k=1}^{n}(a_{ik}\\wedge b_{kj})\\)\n复合运算有如下定理\n定理1\n\\((R\\circ S)\\circ T=R\\circ(S\\circ T)\\)\n关系的逆，逆关系\n\\[ R^{-1}=\\{\u0026lt;b,a\u0026gt;|\u0026lt;a,b\u0026gt;\\in R\\} \\]\n关系矩阵即为原矩阵的转置\n关系图即将箭头反向\n有如下定理\n定理1\n\\((R^{-1})^{-1}=R\\) \\((R_1\\cup R_2)^{-1}=R_1^{-1}\\cup R_2^{-1}\\) \\((R_1\\cap R_2)^{-1}=R_1^{-1}\\cap R_2^{-1}\\) \\((\\overline{R})^{-1}=\\overline{R^{-1}}\\)，其中\\(\\overline{R}=(A\\times B)-R\\)，\\(\\overline{R^{-1}}=(B\\times A)-R^{-1}\\)。 \\((R_1-R_2)^{-1}=R_1^{-1}-R_2^{-1}\\)  定理2\n\\[ (R\\circ S)^{-1}=S^{-1}\\circ R^{-1} \\]\n集合上的二元关系及其特性 集合上的二元关系 集合\\(A\\)与\\(A\\)的笛卡尔积\\(A\\times A\\)的子集称为\\(A\\)上的二元关系。\n相等关系\n\\[ I_A=\\{\u0026lt;a,a\u0026gt;|a\\in A\\} \\]\n\\(R\\)的幂次\n设\\(R\\)是\\(A\\)上的二元关系，\\(n\\in Z^+\\)，称\\(R\\circ R\\circ\\cdots\\circ R\\)(n个)为\\(R\\)的\\(n\\)次幂。记为\\(R^n\\)\n约定\\(R^0=I_A\\)\n有如下定理\n定理1\n\\(R^m\\circ R^n=R^{m+n}\\) \\((R^m)^n=R^{mn}\\)  定理2\n设存在\\(i,j\\in R\\)，使得\\(R^i=R^j\\)，则有\n对任意\\(k\\ge 0, R^{i+k}=R^{j+k}\\) 对任意\\(k,m\\ge 0, R^{i+md+k}=R^{i+k}\\)，其中\\(d=j-i\\) 记\\(S=\\{R_0,R^1,\\cdots,R^{j-1}\\}\\)，对于任意\\(n\\in N\\)，均有\\(R^n\\in S\\)  二元关系的特性 自反性。对于\\(A\\)中的每个元素\\(a\\)，都有\\(aRa\\)，则称\\(R\\)在\\(A\\)上是自反的。 反自反性。对于\\(A\\)中的每个元素\\(a\\)，都有\\(a\\cancel{R}a\\)。空集上的空关系即是自反的也是反自反的。 对称性。对于任意\\(a,b\\in A\\)，若有\\(aRb\\)，则必有\\(bRa\\)。 反对称性。对于任意\\(a,b\\in A\\)，若有\\(aRb\\)且\\(bRa\\)，则必有\\(a=b\\)。若关系图上只有零个或多个自回路，则既是对称的，又是反对称的。 传递性。对于任意\\(a,b,c\\in A\\)，若\\(aRb,bRc\\)则必有\\(aRc\\)。  关系的闭包运算 设\\(R\\)是集合\\(A\\)上的二元关系，如果\\(A\\)上另外一个二元关系\\(R\u0026#39;\\)满足： 1. \\(R\u0026#39;\\)是自反的（对称的，传递的） 2. \\(R\u0026#39;\\subseteq R\\) 3. 对于\\(A\\)上任何自反的（对称的，传递的）关系\\(R\u0026#39;\u0026#39;\\)，若\\(R\u0026#39;\u0026#39;\\subseteq R\\)，有\\(R\u0026#39;\u0026#39;\\subseteq R\u0026#39;\\)，则称\\(R\u0026#39;\\)是\\(R\\)的自反（对称，传递）闭包，记为\\(r(R)(s(R),t(R))\\)。\n有如下定理\n定理1\n\\(R\\)是自反的当且仅当\\(r(R)=R\\) \\(R\\)是对称的当且仅当\\(s(R)=R\\) \\(R\\)是传递的当且仅当\\(t(R)=R\\)  定理2\n\\(r(R)=R\\cup I_A\\) \\(s(R)=R\\cup R^{-1}\\) \\(t(R)=\\bigcup_{i=1}^{\\infty}R^i\\)  定理3\n假设\\(|A|=n\\)，那么\\(t(R)=\\bigcup_{i=1}^{n}R^i\\)\n定理4\n如果\\(R\\)是自反的，那么\\(s(R),t(R)\\)也是自反的。 如果\\(R\\)是对称的，那么\\(r(R),t(R)\\)也是对称的。 如果\\(R\\)是传递的，那么\\(r(R)\\)也是传递的。  定理5\n\\(sr(R)=rs(R)\\)，（\\(sr(R)=s(r(R))\\)以下运算顺序相同）。 \\(tr(R)=rt(R)\\) \\(ts(R)\\subseteq st(R)\\)  等价关系 集合的划分 给定非空集合\\(A\\)和集合簇\\(\\pi=\\{A_1,A_2,\\cdots,A_m\\}\\)，如果\n\\(A_i\\subseteq A\\)且\\(A_i\\neq\\phi\\) \\(A=\\bigcup_{i=1}^{m}A_i\\) \\(A_i\\cap A_j=\\phi, i\\neq j\\)  那么称\\(\\pi\\)是\\(A\\)的一个划分，若\\(\\pi\\)满足1.2.则称\\(\\pi\\)是\\(A\\)的一个覆盖。\n等价关系和等价类 等价关系\n\\(R\\)是\\(A\\)上的二元关系，若\\(R\\)是自反的、对称的、传递的，则称\\(R\\)是等价关系。\n等价类\n设\\(R\\)是非空集合\\(A\\)上的等价关系，对于任意\\(a\\in A\\)，称集合\\([a]_R=\\{x|x\\in A,xRa\\}\\)为\\(a\\)关于\\(R\\)的等价类，\\(a\\)称为等价类\\([a]_R\\)的代表元素。如果等价类个数有限，则\\(R\\)的不同等价类的个数叫做\\(R\\)的秩，否则秩是无限的。\n有如下定理\n定理1\n设\\(R\\)是非空集合\\(A\\)上的等价关系，对于\\(a,b\\in A\\)有\\(aRb\\)，当且仅当\\([a]_R=[b]_R\\)\n商集\n设\\(R\\)是集合\\(A\\)上的等价关系，由\\(R\\)确定的所有等价类组成的集合，称为集合\\(A\\)上关于\\(R\\)的商集，记为\\(A/R\\)\n\\[ A/R = \\{[x]_R|x\\in A\\} \\]\n有如下定理\n定理1\n任取\\(x\\in A\\)，\\([x]_R\\neq\\phi\\) 任取\\(x,y\\in A\\)，要么\\([x]_R=[y]_R\\)，要么\\([x]_R\\cap[y]_R=\\phi\\) \\(\\bigcup_{x\\in A}[x]_R=A\\)  定理2\n设\\(\\pi\\)是非空集合\\(A\\)的一个划分，则\\(A\\)上的二元关系\\(R=\\bigcup_{B\\in\\pi} B\\times B\\)是\\(A\\)上的等价关系（称为由划分\\(\\pi\\)诱导的\\(A\\)上的等价关系）。\n定理3\n设\\(R_1\\)和\\(R_2\\)是非空集合\\(A\\)上的等价关系，则\\(R_1=R_2\\Leftrightarrow A/R_1=A/R_2\\)\n定理4\n设\\(R\\)是非空集合\\(A\\)上的任意一个等价关系,\\(\\pi\\)是\\(A\\)的任意一个划分，那么\\(R\\)诱导出\\(\\pi\\)当且仅当\\(\\pi\\)诱导出\\(R\\)。即说明等价关系和集合的划分是一一对应的。\n序关系 偏序集合的概念与表示 偏序\n如果\\(A\\)上的关系\\(R\\)是自反的，反对称的和传递的，那么\\(R\\)是\\(A\\)上的偏序，通常用符号\\(\\preceq\\)表示，称序偶\\(\u0026lt;A,\\preceq\u0026gt;\\)为偏序集合。通常用\\(x\\prec y\\)表示\\(x\\preceq y\\)且\\(x\\neq y\\)\n可比与不可比\n在偏序集合\\(\u0026lt;A,\\preceq\u0026gt;\\)中，对于元素\\(a,b\\in A\\)，如果\\(a\\preceq b\\)或者\\(b\\preceq a\\)，那么称\\(a\\)或\\(b\\)是可比的，否则不可比的。\n盖住\n在偏序集合\\(\u0026lt;A,\\preceq\u0026gt;\\)中，对于\\(x,y\\in A\\)，如果\\(x\\prec y\\)且没有其他元素\\(z\\in A\\)满足\\(x\\prec z\\prec y\\)，则称\\(y\\)盖住\\(x\\)\n哈斯图\n 3.10.1  链\n设\\(\u0026lt;A,\\preceq\u0026gt;\\)是一个偏序集合，\\(B\\subseteq A\\)。如果\\(B\\)中的任意两个元素都是可比的，那么称\\(B\\)为\\(\u0026lt;A，\\preceq\u0026gt;\\)中的链，\\(B\\)中元素的个数称为该链的长度。如果\\(B\\)中的任意两个不同的元素都是不可比的，那么称\\(B\\)为\\(\u0026lt;A，\\preceq\u0026gt;\\)中的反链。\n偏序集合中的特殊元素 极大元\n设\\(\u0026lt;A，\\preceq\u0026gt;\\)是偏序集合，且\\(B\\subseteq A\\)。如果\\(b\\in B\\)，且\\(B\\)中不存在元素\\(x\\)，使得\\(x\\neq b\\)且\\(b\\preceq x\\)，那么\\(b\\)称为\\(B\\)的极大元。\n极小元\n设\\(\u0026lt;A，\\preceq\u0026gt;\\)是偏序集合，且\\(B\\subseteq A\\)。如果\\(b\\in B\\)，且\\(B\\)中不存在元素\\(x\\)，使得\\(x\\neq b\\)且\\(x\\preceq b\\)，那么\\(b\\)称为\\(B\\)的极小元。\n最大元\n设\\(\u0026lt;A，\\preceq\u0026gt;\\)是偏序集合，且\\(B\\subseteq A\\)。如果\\(b\\in B\\)，对于任意元素\\(x\\in B\\)，均有\\(x\\preceq b\\)，那么\\(b\\)称为\\(B\\)的最大元。\n最小元\n设\\(\u0026lt;A，\\preceq\u0026gt;\\)是偏序集合，且\\(B\\subseteq A\\)。如果\\(b\\in B\\)，对于任意元素\\(x\\in B\\)，均有\\(b\\preceq x\\)，那么\\(b\\)称为\\(B\\)的最小元。\n有如下定理\n定理1\n设\\(\u0026lt;A，\\preceq\u0026gt;\\)是偏序集合，且\\(B\\subseteq A\\)。如果\\(B\\)有最大（最小元），那么它是唯一的。\n上界\n设\\(\u0026lt;A，\\preceq\u0026gt;\\)是偏序集合，且\\(B\\subseteq A\\)。如果\\(a\\in A\\)，对于任意元素\\(b\\in B\\)，均有\\(b\\preceq a\\)，那么\\(a\\)称为\\(B\\)的上界。\n下界\n设\\(\u0026lt;A，\\preceq\u0026gt;\\)是偏序集合，且\\(B\\subseteq A\\)。如果\\(a\\in A\\)，对于任意元素\\(b\\in B\\)，均有\\(a\\preceq b\\)，那么\\(a\\)称为\\(B\\)的下界。\n最小上界（上确界）\n设\\(\u0026lt;A，\\preceq\u0026gt;\\)是偏序集合，且\\(B\\subseteq A\\)。\\(a\\)为\\(B\\)的上界，若对\\(B\\)的任意上界\\(a\u0026#39;\\)均有\\(a\\preceq a\u0026#39;\\)，则称\\(a\\)为\\(B\\)的最小上界或上确界。\n最大下界（下确界）\n设\\(\u0026lt;A，\\preceq\u0026gt;\\)是偏序集合，且\\(B\\subseteq A\\)。\\(a\\)为\\(B\\)的下界，若对\\(B\\)的任意下界\\(a\u0026#39;\\)均有\\(a\u0026#39;\\preceq a\\)，则称\\(a\\)为\\(B\\)的最大下界或下确界。\n有如下定理\n定理1\n若\\(B\\)有最小上界（最大下界），那么它是唯一的。\n定理2\n设\\(\u0026lt;A，\\preceq\u0026gt;\\)是偏序集合，且\\(B\\subseteq A\\)。\n若\\(b\\)是\\(B\\)的最大元，则\\(b\\)是\\(B\\)的极大元。 若\\(b\\)是\\(B\\)的最大元，则\\(b\\)是\\(B\\)的最小上界。 \\(b\\in B\\)，若\\(b\\)是\\(B\\)的上界，当且仅当\\(b\\)是\\(B\\)的最小上界。 若\\(b\\)是\\(B\\)的最小元，则\\(b\\)是\\(B\\)的极小元。 若\\(b\\)是\\(B\\)的最小元，则\\(b\\)是\\(B\\)的最大下界。 \\(b\\in B\\)，若\\(b\\)是\\(B\\)的下界，当且仅当\\(b\\)是\\(B\\)的最大下界。  定理3\n设\\(\u0026lt;A，\\preceq\u0026gt;\\)是非空有限偏序集，则\\(A\\)中必存在极大元和极小元。\n定理4\n设\\(\u0026lt;A，\\preceq\u0026gt;\\)是偏序集合，如果\\(A\\)中最长链的长度为\\(n\\)，则\\(A\\)中元素能划分为\\(n\\)个互不相交的反链。\n线序和良序 设\\(\u0026lt;A，\\preceq\u0026gt;\\)是偏序集合，如果任取\\(a,b\\in A\\)，都有\\(a\\preceq b\\)或者\\(b\\preceq a\\)，那么称\\(\\preceq\\)为\\(A\\)上的线序或全序。称\\(\u0026lt;A，\\preceq\u0026gt;\\)为线序集合，称\\(A\\)为链。\n如果\\(A\\)上的一个二元关系\\(R\\)是一个线序，且\\(A\\)的每一非空子集都有最小元，那么称\\(R\\)为\\(A\\)上的良序，称\\(\u0026lt;A,R\u0026gt;\\)为良序集合。\n有如下定理\n定理\n每一有限线序集合都是良序集合。\n函数与无限集合 函数的定义 注意对于每个\\(x\\in A\\)，都只和唯一一个\\(y\\in Y\\)有\\(f\\)关系。\\(y\\)是\\(x\\)的函数值或像，\\(x\\)是\\(y\\)的原像。\n定义域必须是整个前域，值域可以不是整个陪域。一般\\(X,Y\\)指的是前域和陪域。\n函数相等\n\\(f:A\\to B\\), \\(g:C\\to D\\)，如果\\(A=C,B=D\\)，且对于所有的\\(x\\in A\\)有\\(f(x)=g(x)\\)，则称\\(f,g\\)相等，记作\\(f=g\\)\n多元函数\n前域是\\(n\\)个集合的笛卡尔积，称为\\(n\\)元函数，像记作\\(f(x_1,x_2,\\cdots,x_n)\\)\n递归定义的函数 前域是归纳定义的集合时，可以采用递归定义方法来定义函数。规则是：用已经得到的元素函数值和给定的函数来计算新元素的函数值。\n特殊函数 单射\n任取\\(x_1,x_2\\in X\\)，如果\\(x_1\\neq x_2\\)，那么\\(f(x_1)\\neq f(x_2)\\)，则称\\(f\\)为单射函数，也称一对一函数。\n满射\n若任取\\(y\\in Y\\)，存在\\(x\\in X\\)，使得\\(f(x)=y\\)，则称为满射函数。\n双射\n既是单射又是满射，称为双射函数。也称一一对应函数。\n有如下定理\n定理1\n设\\(X,Y\\)是有限集合，\\(f:X\\to Y\\)\n若\\(f\\)是单射，则必有\\(|X|\\leq|Y|\\) 若\\(f\\)是满射，则必有\\(|X|\\ge|Y|\\) 若\\(f\\)是双射，则必有\\(|X|=|Y|\\)  定理2\n设\\(X\\)和\\(Y\\)是有限集合，\\(f\\)是从集合\\(X\\)到\\(Y\\)的函数。若\\(|X|=|Y|\\)，则\\(f\\)是单射，当且仅当\\(f\\)是满射。\n常数函数\n存在\\(c\\in Y\\)，对任意\\(x\\in X\\),\\(f(x)=c\\)\n恒等函数\n\\(f(x)=x\\)\n置换（排列）\n对于函数\\(f:X\\to X\\)，若\\(f\\)是双射的，则称\\(f\\)为\\(X\\)上的置换或排列。\\(X\\)上的恒等函数称为恒等置换或者幺置换。\\(|X|=n\\)时称为\\(n\\)次置换，\\(|X|\\)无限时称为无限次置换。\n通常写成\n\\[ P= \\begin{pmatrix} x_1 \u0026amp; x_2 \u0026amp; \\cdots \u0026amp; x_n\\\\ f(x_1) \u0026amp; f(x_2) \u0026amp; \\cdots \u0026amp; f(x_n) \\end{pmatrix} \\]\n复合函数和逆函数 类似于关系的复合运算\n但是注意书写顺序。\\(g\\diamond f\\)和\\(f\\circ g\\)的顺序正好相反\n定理1\n\\(f:X\\to Y,g:Y\\to Z\\)，那么\\(g\\diamond f\\)是\\(X\\)到\\(Z\\)的函数。\n定理2\n\\(h\\diamond(g\\diamond f)=(h\\diamond g)\\diamond f\\)\n\\(f^0=I_x\\) \\(f^{n+1}=f\\diamond f^n\\)  定理3\n\\(f:X\\to Y,g:Y\\to Z\\)\n若\\(f,g\\)满射，则\\(g\\diamond f\\)满射。 若\\(f,g\\)单射，则\\(g\\diamond f\\)单射。 若\\(f,g\\)双射，则\\(g\\diamond f\\)双射。 若\\(g\\diamond f\\)满射，则\\(g\\)满射 若\\(g\\diamond f\\)单射，则\\(f\\)单射 若\\(g\\diamond f\\)双射，则\\(g\\)满射，\\(f\\)单射。  逆函数 设\\(f\\)是双射函数，则\\(f^{-1}=\\{\u0026lt;y,x\u0026gt;|\u0026lt;x,y\u0026gt;\\in f\\}\\)。显然逆函数也是双射函数。\n定理1\n\\((f^{-1})^{-1}=f\\) \\(f^{-1}\\diamond f=I_X\\) \\(f\\diamond f^{-1}=I_X\\)  定理2\n\\((g\\diamond f)^{-1}=f^{-1}\\diamond g^{-1}\\)\n可数与不可数集合 集合的基数 基数\n度量\\(A\\)大小的数称为基数或势，记为\\(|A|\\)。\n等势\n若\\(A\\)到\\(B\\)能建立起双射函数，则称\\(A,B\\)等势，记为\\(A\\sim B\\)，或\\(|A|=|B|\\)\n定理1\n等势是任何集合簇上的等价关系。即是自反的、对称的、传递的。\n有限集合、无限集合\n含有有限个（包含0）元素的集合称为有限集合，不是有限集合的称为无限集合。\n定理1\n有限集合的任意子集是有限集合。无限集合的超集是无限集合。\n定理2\n无限集合存在与其等势的真子集。\n可数集 与自然数集\\(N\\)等势的集合称为可数无限集合，简称可数集。可数集的基数用\\(\\alef_0\\)表示。\n有限集和可数集通称为至多可数集。\n枚举\n设\\(A\\)是一个集合，如果\\(f\\)是从\\(N\\)或从\\(N_k=\\{0,1,2,\\cdots,k-1\\}\\)到\\(A\\)的一个满射函数，则称\\(f\\)为\\(A\\)的一个枚举。如果\\(f\\)是双射的，则称为无重复枚举，否则称为重复枚举。\n定理1\n一个无限集合\\(A\\)是可数集，当且仅当存在\\(A\\)的枚举。\n定理2\n可数无限集的任一无限子集是可数集。\n定理3\n任意两个可数集的并是可数集。\n定理4\n\\(N\\times N\\)是可数集。\n定理5\n可数个可数集的并是可数集。\n不可数集 与自然数集不等势的无限集称为不可数集\n定理1\n实数集的子集\\((0,1)\\)是不可数集\n基数的比较 Zemelo三歧性定理\n以下三条恰有一条成立\n|A|\u0026lt;|B| |A|\u0026gt;|B| |A|=|B|  Cantor-Schroder-Bernstein定理\n\\(|A|\\leq|B|\\)且\\(|A|\\ge|B|\\)，则\\(|A|=|B|\\)\n定理3\n设\\(A\\)是任意有限集合，则\\(|A|\u0026lt;\\alef_0\u0026lt;\\alef\\)\n定理4\n任意无限集合必定存在可数无限子集\n定理5\n\\(\\alef_0\\)是最小的无限集基数\nCantor定理\n\\(|M|\u0026lt;|\\rho (M)|\\)\n图论 图的基本概念 按边是否有方向，图可以分为有向图、无向图和混合图。\n设\\(G\\)是一个有向图，如果将\\(G\\)中的每条边的方向去掉就能得到一个无向图\\(G\u0026#39;\\)，则称\\(G\u0026#39;\\)为\\(G\\)的底图。\n邻接点\n关联于同一条边的两个结点被称为邻接点。\n邻接边\n关联于一个结点的两条边被称为邻接边。\n孤立结点\n不与任何结点邻接的结点称之为孤立节点\n零图\n仅由若干个孤立节点构成的图称为零图。\n平凡图\n仅由单个孤立节点组成的图称为平凡图。\n平行边\n\\(e_1=e_2=\\{u,v\\}\\)，若\\(e_1,e_2\\)是两条不同的边，则称\\(e_1,e_2\\)为平行边。\n自回路（环）\n\\(e=\\{u,u\\}\\)\n多重图\n有平行边的图。\n线图\n不含平行边的图。\n简单图\n不含自回路的图。\n结点的度数 与结点\\(v\\)关联的边数称为结点\\(v\\)的度数（无向图），记为\\(deg(v)\\)。\n如果是有向图，则以结点\\(v\\)为终点的边数称为入度\\(deg^-(v)\\)，为始点的边数称为出度\\(deg^+(v)\\)。显然有\\(deg(v)=deg^-(v)+deg^+(v)\\)\n有如下定理\n握手定理\n任何图中，所有节点的度数之和等于边数的两倍。\n定理2\n任何图中，奇数度的节点必有偶数个。\n定理3\n任何有向图中，所有节点的入度等于所有节点的出度。\n特殊图 无向完全图\n无向简单图中，任何两个不同结点间都恰有一条边相连。\\(n\\)个结点的无向完全图记为\\(K^n\\)。\n有向完全图\n有向图\\(G=\u0026lt;V,E\u0026gt;\\)满足\\(E=V\\times V\\)。记为\\(D_n\\)。\n二部图\n非零图，节点集合\\(V\\)可以划分成两个不相交的子集\\(X\\)和\\(Y\\)，使\\(G\\)中的每一条边的一个端点在\\(X\\)中而另一个端点在\\(Y\\)中，则称\\(G\\)为二部图，记为\\(G=\u0026lt;X,E,Y\u0026gt;\\)\n可以通过标号法确定一个图是不是二部图。\n二部图必无自回路，但可以有平行边。\n子图与补图 子图\n设\\(G=\u0026lt;V,E\u0026gt;\\)，\\(G\u0026#39;=\u0026lt;V\u0026#39;,E\u0026#39;\u0026gt;\\)，若有\\(E\u0026#39;\\subseteq E\\)且\\(V\u0026#39;\\subseteq V\\)，则称\\(G\u0026#39;\\)是\\(G\\)的子图。\n生成子图\n\\(V\u0026#39;=V\\)时，\\(G\u0026#39;\\)是\\(G\\)的生成子图。\n导出子图\n设\\(G\u0026#39;\\)是\\(G\\)的子图，\\(V\u0026#39;\\)仅由\\(E\u0026#39;\\)中边相关联的结点组成，则称\\(G\u0026#39;\\)为由边集\\(E\u0026#39;\\)导出的子图。\n补图\n给定一个图\\(G\\)，由\\(G\\)中所有的结点及所有能使\\(G\\)成为完全图的添加边组成的图，称为\\(G\\)相对于完全图的补图，简称为\\(G\\)的补图，记为\\(\\bar{G}\\)。\n图的同构 设\\(G=\u0026lt;V,E\u0026gt;,G\u0026#39;=\u0026lt;V\u0026#39;,E\u0026#39;\u0026gt;\\)，如果存在双射函数\\(f:V\\to V\u0026#39;,g:E\\to E\u0026#39;\\)，对于任何\\(e\\in E,e=[v_i, v_j]\\)当且仅当\\(g(e)=[f(v_i),f(v_j)]\\)。则称\\(G,G\u0026#39;\\)同构，记作\\(G\\cong G\u0026#39;\\)。\n相互同构的图只是画法不同或者结点与边的命名不同而已。\n两幅图同构的必要条件\n结点数相同 边数相同 度数相同的结点数目相同  图的连通性 路和回路 通路\n经过的结点不重复的路。\n迹\n经过的边不重复的路。回路为闭迹，非回路为开迹。\n圈\n除始点和终点外没有相同结点的闭迹称为圈。长度为\\(k\\)的圈称为\\(k\\)圈，又可根据\\(k\\)分为奇圈和偶圈。\n定理1\n在一个具有\\(n\\)个节点的图中，如果两个结点连通，则两个结点间必有一条长度小于\\(n\\)的路（也存在小于\\(n\\)的通路）。\n定理2\n在一个具有\\(n\\)个节点的图中，如果存在闭迹，则必存在一条长度小于等于\\(n\\)的圈。\n定理3\n设\\(G\\)是一个无向图，若\\(G\\)中每个结点的度数大于等于\\(2\\)，\\(G\\)中必含有圈。\n定理4\n\\(G=\u0026lt;V,E\u0026gt;\\)是无向图，\\(|E|\u0026gt;0\\)，\\(G\\)是二部图当且仅当\\(G\\)中不含有奇圈。\n无向图的连通性 割点与割点集\n删除某个结点和其相连边后，图变成不连通的，则称为割点。删除某个点集中的所有点和所连接边，图变成不连通的，并且删除该点集的任意真子集图仍然连通，则称这个点集为割点集。\nk连通\n由\\(G\\)产生一个不连通子图最少需要删去\\(k\\)个结点。则称\\(G\\)为\\(k\\)连通图。\n定理1\n无向图中，一个结点是割点，当且仅当存在两个结点间的每条路都要通过该节点。\n割边与割边集\n与割点相似。\nk边连通\n与\\(k\\)连通相似。\n定理1\n无向图中，一条边是割边，当且仅当它不包含在任一圈中。\n有向图的连通性 强连通，单侧连通，弱连通\n强连通则是两个结点双向可达。单侧连通则是单向可达。若联通则是看成无向图。\n定理1\n有向图是强连通的，当且仅当它存在一条回路，至少包含每个结点一次。\n最短路 见算法竞赛模板。\n图的矩阵表示 邻接矩阵 \\(AA^T\\)\n\\(G\\)中刚好有\\(b_{ij}\\)个结点，从\\(v_i\\)和\\(v_j\\)均有边引出到这些节点。\n\\(A^TA\\)\n\\(G\\)中刚好有\\(b_{ij}\\)个结点，以这些节点为始边，既有边到\\(v_i\\)又有边到\\(v_j\\)。\n\\(A\\times A\\)\n从\\(v_i\\)到\\(v_j\\)的路，长度为2的有\\(b_{ij}\\)条。\n同理可知\\(A^{(m)}\\)的含义。\n可达矩阵 \\(P(G)=A^{(0)}\\vee A^{(1)}\\vee\\cdots\\vee A^{(n-1)}\\)\n定理\n无向图是连通图，当且仅当可达矩阵所有元素都为1. 有向图是强连通图，当且仅当可达矩阵所有元素都为1. 有向图是单侧连通图，当且仅当\\(P\\vee P^T\\)所有元素都为1. 有向图是弱连通图，当且仅当以\\(A\\vee A^T\\)作为邻接矩阵求出来的可达矩阵\\(P\u0026#39;\\)所有元素都为1.  求传递闭包的快速算法 设\\(R\\)是集合\\(V\\)上的二元关系，\\(n\\in \\bm{Z}^+\\)，对于任意\\(a,b\\in V,\u0026lt;a,b\u0026gt;\\in R^n\\)，当且仅当\\(R\\)的关系图\\(G=\u0026lt;V,E\u0026gt;\\)中存在从\\(a\\)到\\(b\\)有长度为\\(n\\)的有向路。\n设\\(\\bm{M}_R\\)是\\(V\\)上二元关系\\(R\\)的关系矩阵，则\n\\[ \\bm{M}_{t(R)}=\\bm{M}_R\\vee\\bm{M}_R^{(2)}\\vee\\cdots\\vee\\bm{M}_R^{(n)} \\]\n欧拉图与汉密尔顿图 欧拉图 欧拉路（欧拉迹）\n包含图中所有边的开迹。\n欧拉回路\n包含图中所有边的闭迹。\n欧拉图\n包含欧拉回路的图称为欧拉图。\n定理1\n无向图是欧拉图当且仅当图是连通的并且每个结点的度均为偶数。\n无向图中存在一条欧拉路，当且仅当图是联通的，并且图中恰有两个奇数度的点。并且这两个点是起点和终点。\n定理2\n有向图是欧拉图，当且仅当它是联通的，并且每个结点的出度等于入度。\n有向图有欧拉路，当且仅当它是联通的，并且除了两个结点以外都出度等于入度，这两个结点必须一个出度比入度大一，另一个入度比出度大一。\n汉密尔顿图 包含图中每个结点一次且仅一次的通路称为汉密尔顿路。包含图中每个结点一次且仅一次的圈叫汉密尔顿回路。含汉密尔顿回路的图叫做汉密尔顿图。\n定理1（必要条件）\n若\\(G\\)是汉密尔顿图，则对于结点集\\(V\\)的每一个非空子集\\(S\\)都有\n\\[ \\omega(G-S)\\leq|S| \\]\n其中\\(\\omega(G-S)\\)表示\\(G\\)删除\\(S\\)中所有结点后得到的连通分支的个数。\n定理2（必要条件）\n设\\(G=\u0026lt;X,E,Y\u0026gt;\\)是无向连通二部图，其中\\(|X|=m,|Y|=n\\)，若\\(m\\neq n\\)，则必不是汉密尔顿图。\n若\\(|m-n|\u0026gt;1\\)，则必不存在汉密尔顿路。\n定理3（充分条件）\n设\\(G=\u0026lt;V,E\u0026gt;\\)是含有\\(n(n\\ge3)\\)个节点的简单无向图，如果\\(G\\)中的任何两个不同结点的度数之和都大于等于\\(n-1\\)，则\\(G\\)中存在汉密尔顿路。\n如果都大于等于\\(n\\)，则存在汉密尔顿回路。\n平面图 平面嵌入\n将一个平面图\\(G\\)重新排列得到边不相交的图\\(G\u0026#39;\\)，\\(G\u0026#39;\\)称为一个平面嵌入。\n面的次数\n面\\(r\\)的边界回路长度称为面的次数，记作\\(deg(r)\\)\n定理1\n连通平面图，所有面的次数之和等于边数的两倍\n定理2\n连通平面图，有\\(n\\)个节点，\\(m\\)条边，\\(r\\)个面，则有\\(n-m+r=2\\)成立。\n若\\(n\\ge3\\)，则\\(m\\leq3n-6\\)\n若每个面至少由\\(k\\)边围成，则有\\(m\\leq\\frac{k(n-2)}{k-2}\\)\n同胚\n给定两个图\\(G_1\\)和\\(G_2\\)，如果它们本身是同构的，或者通过反复插入度为2的结点(在某边上嵌入结点)或反复删除度为2的结点(仅去除结点,其关联边拼接)后，能够使\\(G_1\\)和\\(G_2\\)同构，则称\\(G_1\\)和\\(G_2\\)在\\(2\\)度结点内同构，亦称同胚。\n库拉托夫斯基定理\n一个图是平面图，当且仅当它不包含与\\(K_{3,3}\\)和\\(K_5\\)同胚的子图。\n图的着色 图的结点着色 正常着色\n无向图，给每个结点指定一种颜色，若满足邻接的两个结点颜色不同，则称为正常着色。\n可k-着色\n可以用\\(k\\)种不同的颜色给无向图正常着色。\nk色图\n对无向图正常着色所需要的最少的颜色数，称为顶着色数，简称色数，记为\\(\\mathcal{X}(G)\\)。色数为\\(k\\)的图称为\\(k\\)色图\nWelch Powell着色法\n将图\\(G\\)中的结点按度数递减的次序进行排列。 用一种与已着色结点所着颜色不同的新的颜色\\(C\\)对排列最前的尚未着色的节点着色，并按排列次序对与前面已着上颜色\\(C\\)的结点均不相邻的每一结点着同样的颜色\\(C\\)。 重复2知道着色结束。  定理1\n任何图均满足\\(\\mathcal{X}(G)\\leq \\Delta(G)+1\\)。\\(\\Delta(G)=max\\{d(u)|u\\in V\\}\\)\n定理2\n\\(\\mathcal{X}(G)=2\\)，当且仅当\\(G\\)是二部图。\n平面图的着色 对偶图\n设\\(G=\u0026lt;V,E\u0026gt;\\)是平面图，\\(G\u0026#39;\\)是\\(G\\)的一个平面嵌入，\\(F(G\u0026#39;)\\)是\\(G\u0026#39;\\)的面集合。构造图\\(G^*\\)，若\\(G^*\\)的结点集合\\(V(G^*)=F(G\u0026#39;)\\)，且任取两个结点\\(f_1,f_2\\in V(G^*)\\)，\\(f_1\\)和\\(f_2\\)之间存在边\\(e\\)当且仅当\\(f_1\\)和\\(f_2\\)在\\(G\u0026#39;\\)中有一条公共边，则称\\(G^*\\)是\\(G\\)的对偶图。\n定理\n设\\(G=\u0026lt;V,E\u0026gt;\\)是一个连通简单平面图，且\\(|V|\\ge 3,|E|=m\\)，则\\(G\\)中必存在结点\\(u\\in V\\)，满足\\(deg(u)\\leq 5\\)。\n希伍德五色定理\n任何一个连通简单平面图都是5可着色的。\n四色定理\n平面图的色数不超过4。\n树 无向树的定义 平凡树\n只有一个孤立节点的树。\n定理1\n对于一个含有\\(n\\)个结点\\(m\\)条边的无向树，以下定义等价\n无圈且连通 无圈且\\(m=n-1\\) 连通且\\(m=n-1\\) 无圈，但任意新增一条边，恰得到一个圈 连通，且每条边都是割边 每一对结点有且只有一条通路  定理2\n任何一颗非平凡树中至少有两片树叶\n生成树 定理1\n任何一个无向连通图至少有一颗生成树\n定理2\n连通图中的一个圈与其任何一棵生成树的补至少有一条公共边。\n定理3\n一个边割集和任何一棵生成树至少有一条公共边。\n最小生成树及其算法\n见竞赛模板。\n根树及其应用 根树\n一棵有向树，恰有一个节点入度为0，其余节点入度都为1。\nm元树\n每个结点的出度均小于等于\\(m\\)的根树。\n每个节点的出度均等于\\(0\\)或\\(m\\)的根树称为正则\\(m\\)元树。\n定理1\n正则\\(m\\)元树\\(T\\)，其树叶数为\\(t\\)，分支结点数为\\(i\\)，则有\\((m-1)i=t-1\\)\n带权树\n如果一颗二元树\\(T\\)共有\\(n\\)片树叶，分别带权\\(\\omega_1,\\omega_2,\\cdots,\\omega_n\\)。定义这棵二元树\\(T\\)的权值为，\n\\[ W(T)=\\sum_{i=1}^{n}\\omega_iL(\\omega_i) \\]\n其中\\(L(\\omega_i)\\)为带权\\(\\omega_i\\)的树叶的深度（根深度为0）。在所有带这些权的二元树中，具有最小权的二元树称为最优二元树。\n定理1\n最优二元树是一颗正则二元树。\n定理2\n最优二元树中，层数最大的分支节点的两个儿子所带权分别为最小的两个权。\n最优二元树的构造方法\n 7.7.12  前缀码\n给定一个以\\(0,1\\)组成序列为元素的集合，若没有一个序列是另一个序列的前缀，则该集合称为前缀码。\n利用有序正则二元树解决前缀码问题\n 7.7.13  ","date":"2022-06-06T08:44:57+08:00","image":"https://kegalas.top/p/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86/cover_huf80a3777f066c3f01437aeed10211fe1_29240_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86/","title":"离散数学整理"},{"content":" [TOC]\n矩阵 几个特殊矩阵 方阵 行数与列数相同的矩阵\\(\\bold{A}_{n\\times n}\\)称为\\(n\\)阶矩阵或\\(n\\)阶方阵\n零矩阵 元素都是零的矩阵称为零矩阵，记作\\(\\bold O\\)\n三角矩阵 上三角矩阵\n主对角线以下的元素全为零的方阵，即\n\\[ \\bold{A}_n=\\begin{bmatrix} a_{11} \u0026amp; a_{12} \u0026amp; \\cdots \u0026amp; a_{1n}\\\\ 0 \u0026amp; a_{22} \u0026amp; \\cdots \u0026amp; a_{2n}\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; a_{nn} \\end{bmatrix} \\]\n下三角矩阵\n主对角线以上的元素全为零的方阵，即\n\\[ \\bold{A}_n=\\begin{bmatrix} a_{11} \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0\\\\ a_{21} \u0026amp; a_{22} \u0026amp; \\cdots \u0026amp; 0\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ a_{n1} \u0026amp; a_{n2} \u0026amp; \\cdots \u0026amp; a_{nn} \\end{bmatrix} \\]\n对角阵 主对角线（左上到右下的对角线；右上到左下的是副对角线）以外的元素全为零的方阵，即\n\\[ \\bold{A}_n=\\begin{bmatrix} a_{11} \u0026amp; \u0026amp; \u0026amp; \\\\ \u0026amp; a_{22} \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026amp; \\ddots \u0026amp; \\\\ \u0026amp; \u0026amp; \u0026amp; a_{nn} \\end{bmatrix} \\]\n对角矩阵常记为\\(\\Lambda\\)或\\(diag(a_{11},a_{22},\\cdots,a_{nn})\\)\n单位矩阵 主对角线上全为1的对角矩阵称为单位矩阵，记作\\(\\bold{E}_n\\)，即\n\\[ \\bold{E}_n=\\begin{bmatrix} 1 \u0026amp; \u0026amp; \u0026amp; \\\\ \u0026amp; 1 \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026amp; \\ddots \u0026amp; \\\\ \u0026amp; \u0026amp; \u0026amp; 1 \\end{bmatrix} \\]\n系数矩阵 对于线性方程组\n\\[ \\left\\{\\begin{matrix} 2x_1-2x_2+6x_4=-2 \\\\ 2x_1-x_2+2x_3+4x_4=-2 \\\\ 3x_1-x_2+4x_3+4x_4=-3 \\\\ x_1+x_2+x_3+8x_4=2 \\end{matrix}\\right. \\]\n其系数矩阵为\n\\[ \\bold{A}=\\begin{bmatrix} 2 \u0026amp; -2 \u0026amp; 0 \u0026amp; 6\\\\ 2 \u0026amp; -1 \u0026amp; 2 \u0026amp; 4\\\\ 3 \u0026amp; -1 \u0026amp; 4 \u0026amp; 4\\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 8 \\end{bmatrix} \\]\n增广矩阵 由线性方程组所有系数和常数项所构成的矩阵称为线性方程组的增广矩阵，并记为\\(\\tilde{\\bold{A}}=(\\bold{A,b})\\)或\\(\\tilde{\\bold{A}}=[\\bold{A,b}]\\)\n\\[ \\tilde{\\bold{A}}=[\\bold{A,b}]=\\begin{bmatrix} 2 \u0026amp; -2 \u0026amp; 0 \u0026amp; 6 \u0026amp; -2\\\\ 2 \u0026amp; -1 \u0026amp; 2 \u0026amp; 4 \u0026amp; -2\\\\ 3 \u0026amp; -1 \u0026amp; 4 \u0026amp; 4 \u0026amp; -3\\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 8 \u0026amp; 2 \\end{bmatrix} \\]\n对称矩阵 满足\\(\\bold{A}^T=\\bold{A}\\)的矩阵称为对称矩阵，满足\\(\\bold{A}^T=-\\bold{A}\\)的矩阵称为反对称矩阵。\n行阶梯型矩阵 满足以下两个条件\n如果有零行（元素全为0的行），则零行位于非零行的下方 非零行（元素不全为0的行）的首个非零元素，其前面零元素的个数逐行增加。  最简行阶梯型矩阵：进一步满足非零行的首非零元均为1，且所在列的其余元素为0.\n初等矩阵 由\\(n\\)阶单位矩阵\\(\\bold{E}\\)经过一次初等变换所得到的矩阵称为初等矩阵或初等方阵。\n奇异矩阵 行列式为0的矩阵称为奇异矩阵。不为0的称为非奇异矩阵。\n可逆矩阵 见后\n伴随矩阵 矩阵\\(\\bold{A}\\)的各个元素的代数余子式\\(A_{ij}\\)所构成的如下矩阵\n\\[ \\bold{A}^*= \\begin{bmatrix} A_{11} \u0026amp; A_{21} \u0026amp; \\cdots \u0026amp; A_{n1}\\\\ A_{12} \u0026amp; A_{22} \u0026amp; \\cdots \u0026amp; A_{n2}\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ A_{1n} \u0026amp; A_{2n} \u0026amp; \\cdots \u0026amp; A_{nn} \\end{bmatrix} \\]\n即\\(\\bold{A}^*=(A_{ij})^T_{n\\times n}\\)，称为\\(A\\)的伴随矩阵。\n并且伴随矩阵满足\\(\\bold{AA^*}=\\bold{A^*A}=\\bold{|A|E}\\)\n并且可推知，当\\(\\bold{|A|}\\ne 0\\)时，有\\(\\bold{|A^*|}=\\bold{|A|}^{n-1}\\)\n另外注意，伴随矩阵的序号和原矩阵的序号相当于进行了转置。\n正交矩阵 见后\n矩阵的运算 加减法 对于矩阵\\(\\bold{A}=(a_{ij})_{m\\times n},\\bold{B}=(b_{ij})_{m\\times n}\\)，定义\n\\[ \\bold{A\\pm B}=\\begin{bmatrix} a_{11}\\pm b_{11} \u0026amp; a_{12}\\pm b_{12} \u0026amp; \\cdots \u0026amp; a_{1n}\\pm b_{1n}\\\\ a_{21}\\pm b_{21} \u0026amp; a_{22}\\pm b_{22} \u0026amp; \\cdots \u0026amp; a_{2n}\\pm b_{2n}\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ a_{m1}\\pm b_{m1} \u0026amp; a_{m2}\\pm b_{m2} \u0026amp; \\cdots \u0026amp; a_{mn}\\pm b_{mn} \\end{bmatrix} \\]\n数乘 \\[ \\lambda\\bold{A}=\\begin{bmatrix} \\lambda a_{11} \u0026amp; \\lambda a_{12} \u0026amp; \\cdots \u0026amp; \\lambda a_{1n}\\\\ \\lambda a_{21} \u0026amp; \\lambda a_{22} \u0026amp; \\cdots \u0026amp; \\lambda a_{2n}\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ \\lambda a_{m1} \u0026amp; \\lambda a_{m2} \u0026amp; \\cdots \u0026amp; \\lambda a_{mn} \\end{bmatrix} \\]\n线性运算的运算规律 矩阵的加减法和数乘统称为矩阵的线性运算，满足以下运算律\n\\(\\bold{A+B=B+A}\\) \\(\\bold{(A+B)+C=A+(B+C)}\\) \\(\\bold{A+O=A}\\) \\(\\bold{A+(-A)=O}\\) \\(1\\bold{A=A}\\) \\((\\lambda\\mu)\\bold{A}=\\lambda(\\mu\\bold{A})=\\mu(\\lambda\\bold{A})\\) \\((\\lambda+\\mu)\\bold{A}=\\lambda\\bold{A}+\\mu\\bold{A}\\) \\(\\lambda(\\bold{A+B})=\\lambda \\bold{A}+\\lambda \\bold{B}\\)  乘积 设矩阵\\(\\bold{A}=(a_{ij})_{m\\times s},\\bold{B}=(b_{ij})_{s\\times n}\\)，其乘积是一个\\(m\\times n\\)矩阵，记为\\(\\bold{C}=(c_{ij})_{m\\times n}\\)\n\\[ c_{ij}=\\sum^{s}_{k=1}a_{ik}b_{kj}=a_{i1}b_{1j}+a_{i2}b_{2j}+\\cdots+a_{is}b_{sj} \\]\n\\[ (i=1,2,\\cdots,m;j=1,2,\\cdots,n) \\]\n由定义知，只有左边矩阵的列数等于右边矩阵的行数时，两个矩阵才能相乘。\n矩阵乘法满足如下运算规律\n\\(\\bold{(AB)C=A(BC)}\\) \\(\\bold{A(B+C)=AB+AC,(A+B)C=AC+BC}\\) \\(\\lambda(\\bold{AB})=(\\lambda\\bold{A)B}=\\bold{A}(\\lambda\\bold{B})\\) \\(\\bold{A}_{m\\times n}\\bold{E}_n=\\bold{E}_m\\bold{A}_{m\\times n}=\\bold{A}_{m\\times n}\\) \\(\\bold{A}^k\\bold{A}^l=\\bold{A}^{k+l},(\\bold{A}^k)^l=\\bold{A}^{kl}\\)  注意，由于矩阵乘法不满足交换律，故一般情况下，\\((\\bold{AB}^k)\\ne\\bold{A}^k\\bold{B}^k\\)\n转置 将矩阵\\(\\bold{A}\\)中的行换成同序数的列而得到的矩阵，称之为\\(\\bold{A}\\)的转置矩阵，记作\\(\\bold{A}^T\\)或\\(\\bold{A}\u0026#39;\\)，即若\n\\[ \\bold{A}=\\begin{bmatrix} a_{11} \u0026amp; a_{12} \u0026amp; \\cdots \u0026amp; a_{1n}\\\\ a_{21} \u0026amp; a_{22} \u0026amp; \\cdots \u0026amp; a_{2n}\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ a_{m1} \u0026amp; a_{m2} \u0026amp; \u0026amp; a_{mn} \\end{bmatrix} \\]\n\\[ \\bold{A}^T=\\begin{bmatrix} a_{11} \u0026amp; a_{21} \u0026amp; \\cdots \u0026amp; a_{m1}\\\\ a_{12} \u0026amp; a_{22} \u0026amp; \\cdots \u0026amp; a_{m2}\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ a_{1n} \u0026amp; a_{2n} \u0026amp; \u0026amp; a_{mn} \\end{bmatrix} \\]\n转置满足以下运算律\n\\((\\bold{A}^T)^T=\\bold{A}\\) \\((\\bold{A+B})^T=\\bold{A}^T+\\bold{B}^T\\) \\((\\lambda\\bold{A})^T=\\lambda\\bold{A}^T\\) \\((\\bold{AB})^T=\\bold{B}^T\\bold{A}^T\\)  可逆矩阵 设\\(\\bold{A}\\)为\\(n\\)阶方阵，若存在\\(n\\)阶方阵\\(\\bold{B}\\)，使得\\(\\bold{AB=BA=E}_n\\)，则称\\(\\bold{A}\\)为可逆矩阵，或称其为可逆的。称\\(\\bold{B}\\)为\\(\\bold{A}\\)的逆矩阵。\\(\\bold{B}=\\bold{A}^{-1}\\).\n设\\(\\bold{A},\\bold{B}\\)都为\\(n\\)阶方阵，若\\(\\bold{AB=E}_n\\)，则\\(\\bold{A},\\bold{B}\\)都可逆，并且\n\\[ \\bold{A}^{-1}=\\bold{B},\\bold{B}^{-1}=\\bold{A} \\]\n可逆矩阵的性质 若\\(\\bold{A}\\)可逆，则\\(\\bold{A}\\)的逆矩阵唯一. 若\\(\\bold{A}\\)可逆，则\\(\\bold{A}^{-1}\\)也可逆，并且\\(\\bold{A}=(\\bold{A}^{-1})^{-1}\\) 若\\(\\bold{A}\\)可逆，数\\(\\lambda\\ne0\\)，则\\(\\lambda\\bold{A}\\)可逆，并且\\((\\lambda\\bold{A})^{-1}=\\frac{1}{\\lambda}\\bold{A}^{-1}\\) 若\\(\\bold{A}\\)、\\(\\bold{B}\\)均为\\(n\\)阶可逆方阵，则\\(\\bold{A}\\bold{B}\\)也可逆，且\\((\\bold{A}\\bold{B})^{-1}=\\bold{B}^{-1}\\bold{A}^{-1}\\) 若\\(\\bold{A}\\)可逆，则\\(\\bold{A}^{T}\\)也可逆，并且\\((\\bold{A}^T)^{-1}=(\\bold{A}^{-1})^{T}\\)  逆矩阵的求法 借用伴随矩阵和行列式，见行列式一章 初等变换法  设有方阵\\(\\bm A\\)，将其和同阶单位阵写在一起\\((A,E)\\)，然后通过初等行变换（只能是行变换），化成\\((E,A\u0026#39;)\\)的形式，然后\\(A\u0026#39;\\)就是逆矩阵。\n分块矩阵 加减法、数乘、乘法与普通矩阵相似。转置时除了将整个矩阵，还要将每个元素本身转置。\n初等变换 下面三种变换称之为初等行变换\n交换两行的位置 以非零数\\(k\\)乘某行 把某一行的\\(k\\)倍加到另一行上  初等列变换只用把上述的行换成列即可。两种变换通称初等变换。显然初等变换是可逆的。\n矩阵等价 如果矩阵\\(\\bold{A}\\)经有限次初等变换成矩阵\\(\\bold{B}\\)，那么称这两个矩阵等价，记作\\(\\bold{A} \\sim \\bold{B}\\)\n等价关系具有：自反性、对称性、传递性。\n相似一定等价，等价不一定相似。 合同一定等价，等价不一定合同。 合同不一定相似，相似不一定合同。\n矩阵的秩 设\\(\\bold{A}\\)为\\(m\\times n\\)矩阵，\\(\\bold{B}\\)是与\\(\\bold{A}\\)等价的行阶梯型矩阵，若矩阵\\(\\bold{B}\\)的非零行数为\\(r\\)，则称矩阵\\(\\bold{B}\\)的秩为\\(r\\)，矩阵\\(\\bold{A}\\)的秩也为\\(r\\)，记作\\(R(\\bold{A})=R(\\bold{B})=r\\)\n矩阵的秩的性质 \\(0\\leq R(\\bold{A}_{m\\times n})\\leq min\\{m,n\\}\\) \\(R(\\bold{A})=0\\Leftrightarrow \\bold{A=O}\\) \\(R(\\bold{A}^T)=R(\\bold{A})\\) 若\\(\\bold{A}\\sim\\bold{B}\\)，则\\(R(\\bold{A})=R(\\bold{B})\\) 若\\(\\bold{P},\\bold{Q}\\)可逆，则\\(R(\\bold{A})=R(\\bold{PA})=R(\\bold{AQ})=R(\\bold{PAQ})\\)（可逆矩阵不影响矩阵的秩）（初等变换不影响矩阵的秩） \\(max\\{R(\\bold{A}),R(\\bold{B})\\}\\leq R(\\bold{A,B})\\leq R(\\bold{A})+R(\\bold{B})\\) \\(R(\\bold{A\\pm B})\\leq R(\\bold{A})+R(\\bold{B});R(\\bold{AB})\\leq min\\{R(\\bold{A}),R(\\bold{B})\\}\\) 若\\(\\bold{A}_{m\\times n}\\bold{B}_{n\\times l}=\\bold{O}\\)，则\\(R(\\bold{A})+R(\\bold{B})\\leq n\\) \\(\\bold{A}_{m\\times n}\\)行满秩\\(\\Leftrightarrow R(\\bold{A})=m\\Leftrightarrow\\bold{A}\\)的等价标准型为\\((\\bold{I}_m,\\bold{O})\\)（\\(\\bold{I}\\)是单位矩阵）。\\(\\bold{A}_{m\\times n}\\)列满秩\\(\\Leftrightarrow R(\\bold{A})=n\\Leftrightarrow\\bold{A}\\)的等价标准型为\\((\\bold{I}_n,\\bold{O})^T\\)。 若\\(\\bold{A}\\)为\\(n\\)阶方阵，则\\(R(\\bold{A})=n\\Leftrightarrow \\bold{A}\\)是可逆矩阵 若\\(\\bold{A},\\bold{B}\\)均为\\(n\\)阶方阵，则\\(R(\\bold{AB})\\ge R(\\bold{A})+R(\\bold{B})-n\\) \\(R(\\bold{ABC})\\ge R(\\bold{AB})+R(\\bold{BC})-R(\\bold{B})\\) \\(R(\\bold{A}_{m\\times n})=n\\Leftrightarrow\\)齐次线性方程组\\(\\bold{Ax=0}\\)只有零解。 \\[ R\\begin{pmatrix} \\bold{A} \u0026amp; 0\\\\ 0 \u0026amp; \\bold{B} \\end{pmatrix}=R(\\bold{A})+R(\\bold{B}) \\] 矩阵的秩等于矩阵的行秩也等于矩阵的列秩  对于一个矩阵一些相互等价的命题 第一组 设\\(\\bold{A}\\)为\\(n\\)阶方阵，那么下列命题等价\n满秩 非奇异 可逆 \\(\\bold{Ax=0}\\)只有零解 \\(|\\bold{A}|\\ne0\\) \\(\\bold{A}\\)可以经过有限次初等行变换华为单位矩阵\\(\\bold{E}_n\\) \\(\\bold{A}\\)可以表示为有限个初等矩阵的乘积。 特征值均非零  第二组 设\\(\\bold{A}\\)为\\(n\\)阶方阵，那么下列命题等价\n降秩 奇异 不可逆 \\(\\bold{Ax=0}\\)不只有零解 \\(|\\bold{A}|=0\\) \\(\\bold{A}\\)不可以经过有限次初等行变换华为单位矩阵\\(\\bold{E}_n\\) \\(\\bold{A}\\)不可以表示为有限个初等矩阵的乘积。 特征值至少有一个为零  第三组 设\\(f(x_1,\\cdots,x_n)=\\bm{x}^T\\bm{Ax}\\)是\\(n\\)元实二次型，则下列命题等价\n\\(f=\\bm{x}^T\\bm{Ax}\\)是正定二次型，即\\(\\bm{A}\\)是正定矩阵 \\(\\bm{A}\\)的特征值均为正数 \\(f=\\bm{x}^T\\bm{Ax}\\)的正惯性指数为\\(n\\) \\(\\bm{A}\\)与单位矩阵\\(\\bm{E}\\)合同 存在可逆矩阵\\(\\bm B\\)，使得\\(\\bm{A=B}^T\\bm B\\) 顺序主子式均大于零  第四组 设\\(f(x_1,\\cdots,x_n)=\\bm{x}^T\\bm{Ax}\\)是\\(n\\)元实二次型，则下列命题等价\n\\(f\\)是负定二次型 \\(f\\)的负惯性指数为\\(n\\) \\(\\bm A\\)的特征值全为负数 \\(\\bm A\\)合同于\\(-\\bm E\\) \\(\\bm A\\)的奇数阶顺序主子式均为负数，偶数阶顺序主子式均为负数  行列式 二阶行列式 \\[ D=\\begin{vmatrix} a_{11} \u0026amp; a_{12} \\\\ a_{21} \u0026amp; a_{22} \\end{vmatrix}=a_{11}a_{22}-a_{12}a_{21} \\]\nn阶行列式 余子式与代数余子式 在\\(n\\)阶行列式\n\\[ D=\\begin{vmatrix} a_{11} \u0026amp; a_{12} \u0026amp; \\cdots \u0026amp; a_{1n}\\\\ a_{21} \u0026amp; a_{22} \u0026amp; \\cdots \u0026amp; a_{2n}\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ a_{n1} \u0026amp; a_{n2} \u0026amp; \\cdots \u0026amp; a_{nn} \\end{vmatrix} \\]\n中划掉元素所在的第\\(i\\)行与第\\(j\\)列后，剩下的\\((n-1)^2\\)个元素按原来的次序构成的\\(n-1\\)阶行列式称为元素\\(a_{ij}\\)的余子式，记为\\(M_{ij}\\)，并称\\((-1)^{i+j}M_{ij}\\)为元素\\(a_{ij}\\)的代数余子式，记为\\(A_{ij}\\)。\n计算 \\[ D=\\begin{vmatrix} a_{11} \u0026amp; a_{12} \u0026amp; \\cdots \u0026amp; a_{1n}\\\\ a_{21} \u0026amp; a_{22} \u0026amp; \\cdots \u0026amp; a_{2n}\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ a_{n1} \u0026amp; a_{n2} \u0026amp; \\cdots \u0026amp; a_{nn} \\end{vmatrix} \\]\n\\[ =a_{11}A_{11}+a_{12}A_{12}+\\cdots+a_{1n}A_{1n}=\\sum_{k=1}^{n}a_{k1}A_{k1} \\]\n上式为该行列式按第一行的展开定义。也可以按其他行（或者列）展开。\n易知对于对角矩阵和上下三角矩阵，其行列式为对角线上元素的乘积。对次三角矩阵则不等于副对角线上元素的乘积。单位矩阵的行列式等于\\(1\\).\n行列式的性质 行列式与其转置行列式相等，\\(|\\bold{A}|=|\\bold{A}^T|\\)\n 行列式中某行（或列）元素的公因子可以提到行列式之外\n某行（或列）元素全为零的行列式等于0 对于\\(n\\)阶矩阵\\(\\bold{A}\\)，有\\(|k\\bold{A}|=k^n|\\bold{A}|\\)  交换某两行（或列）的位置，行列式的值变号.\n如果行列式中有两行（或两列）元素相同，则行列式为0. 行列式中若有两行（或两列）对应元素成比例，则行列式为0  若行列式某一行（或列）的元素是两项之和，则该行列式可以写成两个行列式之和，即\n  \\[ \\begin{vmatrix} a_{11} \u0026amp; \\cdots \u0026amp; a_{1j} \u0026amp; \\cdots \u0026amp; a_{1n}\\\\ \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ a_{i1}+b_{i1} \u0026amp; \\cdots \u0026amp; a_{ij}+b_{ij} \u0026amp; \\cdots \u0026amp; a_{in}+b_{in}\\\\ \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ a_{n1} \u0026amp; \\cdots \u0026amp; a_{nj} \u0026amp; \\cdots \u0026amp; a_{nn} \\end{vmatrix} \\]\n\\[ =\\begin{vmatrix} a_{11} \u0026amp; \\cdots \u0026amp; a_{1j} \u0026amp; \\cdots \u0026amp; a_{1n}\\\\ \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ a_{i1} \u0026amp; \\cdots \u0026amp; a_{ij} \u0026amp; \\cdots \u0026amp; a_{in}\\\\ \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ a_{n1} \u0026amp; \\cdots \u0026amp; a_{nj} \u0026amp; \\cdots \u0026amp; a_{nn} \\end{vmatrix}+ \\begin{vmatrix} a_{11} \u0026amp; \\cdots \u0026amp; a_{1j} \u0026amp; \\cdots \u0026amp; a_{1n}\\\\ \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ b_{i1} \u0026amp; \\cdots \u0026amp; b_{ij} \u0026amp; \\cdots \u0026amp; b_{in}\\\\ \\vdots \u0026amp; \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ a_{n1} \u0026amp; \\cdots \u0026amp; a_{nj} \u0026amp; \\cdots \u0026amp; a_{nn} \\end{vmatrix} \\]\n将某一行（或列）的任意\\(k\\)倍加到另一行（或列）上去，行列式的值不变 对于\\(n\\)阶行列式D，有  \\[ \\sum_{j=1}^na_{ij}A_{kj}= \\left\\{\\begin{matrix} D,i=k\\\\ 0,i\\ne k \\end{matrix}\\right. \\]\n\\[ \\sum_{i=1}^na_{ij}A_{ik}= \\left\\{\\begin{matrix} D,j=k\\\\ 0,j\\ne k \\end{matrix}\\right. \\]\n设\\(\\bold{A,B}\\)均为\\(n\\)阶方阵，则\\(|\\bold{AB}|=\\bold{|A||B|}\\)  范德蒙行列式 \\[ V_n=\\begin{vmatrix} 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1\\\\ x_1 \u0026amp; x_2 \u0026amp; x_3 \u0026amp; \\cdots \u0026amp; x_n\\\\ x_1^2 \u0026amp; x_2^2 \u0026amp; x_3^2 \u0026amp; \\cdots \u0026amp; x_n^2\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ x_1^{n-1} \u0026amp; x_2^{n-1} \u0026amp; x_3^{n-1} \u0026amp; \\cdots \u0026amp; x_n^{n-1} \\end{vmatrix} \\]\n有\n\\[ V_n=\\prod_{1\\leq j\u0026lt;i\\leq n}(x_i-x_j) \\]\n行列式求逆矩阵 \\(\\bold{A}\\)为可逆矩阵的充分必要条件是\\(|\\bold{A}|\\ne 0\\)，且有\n\\[ \\bold{A}^{-1}=\\frac{1}{|\\bold{A}|}\\bold{A}^* \\]\n行列式求解非齐次线性方程组（克莱默法则） 对于线性方程组\\(\\bold{Ax=b}\\)，定义\n\\[ D=|\\bold{A}|\\\\ D_1=|[\\bold{b},\\bold{a}_2,\\bold{a}_3,\\cdots,\\bold{a}_n]|\\\\ D_2=|[\\bold{a}_1,\\bold{b},\\bold{a}_3,\\cdots,\\bold{a}_n]|\\\\ \\cdots\\\\ D_n=|[\\bold{a}_1,\\bold{a}_2,\\bold{a}_3,\\cdots,\\bold{b}]|\\\\ \\]\n当\\(D\\ne0\\)时，该方程组有唯一解，其解为\n\\[ x_1=\\frac{D_1}{D},x_2=\\frac{D_2}{D},\\cdots,x_n=\\frac{D_n}{D} \\]\nn维向量与向量空间 前提：本章默认为列向量。\n向量的运算 线性运算 加减法和数乘和矩阵一样，不再介绍。\n向量乘法 也和矩阵一样，但只有两种情况\n\\[ \\bm{\\alpha}^T\\bm{\\beta}= \\begin{bmatrix} a_1\u0026amp;a_2\u0026amp;\\cdots\u0026amp;a_n \\end{bmatrix}\\begin{bmatrix} b1\\\\b2\\\\\\vdots\\\\b3 \\end{bmatrix}= a_1b_1+a_2b_2+\\cdots+a_nb_n \\]\n\\[ \\bm{\\alpha}\\bm{\\beta}^T= \\begin{bmatrix} a_1\\\\a_2\\\\\\vdots\\\\a_n \\end{bmatrix}\\begin{bmatrix} b1\u0026amp;b2\u0026amp;\\cdots\u0026amp;b3 \\end{bmatrix}= \\begin{bmatrix} a_1b_1 \u0026amp; a_1b_2 \u0026amp; \\cdots \u0026amp; a_1b_n\\\\ a_2b_1 \u0026amp; a_2b_2 \u0026amp; \\cdots \u0026amp; a_2b_n\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ a_nb_1 \u0026amp; a_nb_2 \u0026amp; \\cdots \u0026amp; a_nb_n \\end{bmatrix} \\]\n向量运算的性质 和矩阵相同，看成行或列为1的矩阵即可。\n向量组的线性相关性 向量组的线性表示 设\\(n\\)维向量组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_s\\)，对于任何一组实数\\(k_1,k_2,\\cdots,k_s\\)，称\\(k_1\\bm{\\alpha}_1,k_2\\bm{\\alpha}_2,\\cdots,k_s\\bm{\\alpha}_s\\)为向量组的一个线性组合。\n设\\(\\bm{b}\\)为\\(n\\)维向量，若存在一组数\\(\\lambda_1,\\lambda_2,\\cdots,\\lambda_s\\)使得\\(\\bm{b}=\\lambda_1\\bm{\\alpha}_1,\\lambda_2\\bm{\\alpha}_2,\\cdots,\\lambda_s\\bm{\\alpha}_s\\)，则称\\(\\bm{b}\\)可由\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_s\\)线性表示。\n线性方程组\\(\\bm{Ax=b}\\)有解的充分必要条件是\\(\\bm{b}\\)可由\\(\\bm{A}\\)的列向量组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_n\\)线性表示.\n向量组的线性相关性定义及性质 设有\\(n\\)维向量组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m\\)，如果存在不全为零的数\\(k_1,k_2,\\cdots,k_m\\)，使得\n\\[ k_1\\bm{\\alpha}_1+k_2\\bm{\\alpha}_2+\\cdots+k_m\\bm{\\alpha}_m=0 \\]\n则称向量组线性相关，否则称线性无关。\n可以得到如下结论：\n包含零向量的向量组必线性相关 当向量组只包含一个向量时，若为零向量，则线性相关；否则线性无关。 非零向量组若只有两个向量，则线性相关的充要条件是两个向量的对应分量成比例。 向量组线性相关的充要条件是至少存在其中的一个向量可由其余向量线性表示 当\\(t\u0026gt;n\\)，含有\\(t\\)个\\(n\\)维向量的向量组必线性相关。 向量组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m\\)线性无关，而向量组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m,\\bm{b}\\)线性相关，则\\(\\bm{b}\\)可由\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m\\)唯一线性表示 \\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m\\)线性无关，则任一部分组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_r(r\u0026lt;m)\\)必线性无关 \\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m\\)线性相关，则增加向量后的向量组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_s(s\u0026gt;m)\\)必线性相关。 设\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m\\)为\\(m\\)个\\(m\\)维列向量。则\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m\\)线性无关\\(\\Leftrightarrow\\)行列式\\(|[\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m]|\\ne0\\);\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m\\)线性相关\\(\\Leftrightarrow\\)行列式\\(|[\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m]|=0\\) 从几何角度理解：设\\(\\bm{\\alpha,\\beta,\\gamma}\\)为三维向量，向量组\\(\\bm{\\alpha,\\beta}\\)线性相关\\(\\Leftrightarrow\\bm{\\alpha,\\beta}\\)共线;向量组\\(\\bm{\\alpha,\\beta,\\gamma}\\)线性相关\\(\\Leftrightarrow\\bm{\\alpha,\\beta,\\gamma}\\)共面  向量组的秩和极大无关组 设有两个向量组，每个向量组中的每一个向量都可以由另一个向量组线性表示，则称两个向量组等价。\n设有向量组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_s\\)，而\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_r\\)是向量组中的\\(r\\)个向量\\((r\\leq s)\\)，若满足\n向量组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_r\\)线性无关; 向量组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_s\\)中的任\\(r+1\\)个向量（如果有）线性相关  则称向量组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_r\\)是向量组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_s\\)的一个极大无关组，极大无关组所含向量个数\\(r\\)称为向量组的秩，记作\\(R(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_s)=r\\).\n只含零向量的向量组，规定秩为0；向量组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_s\\)线性无关时，其秩为\\(s\\).\n有如下定理\n阶梯型矩阵\\(J\\)的行秩和列秩相等，恰等于\\(J\\)的非零行数，并且\\(J\\)的主元（非零行的首个元素）所在的列构成列向量组的一个极大无关组。 矩阵的初等行（列）变换不改变矩阵的列（行）（注意与前一句相反）向量组的线性相关性，从而不改变矩阵的列（行）秩。 矩阵的秩等于矩阵的行秩等于矩阵的列秩。 设\\(\\bm{A}\\)是\\(m\\times n\\)矩阵，则  矩阵\\(A\\)的列向量组线性相关（无关）的充要条件为\\(R(\\bm{A})\u0026lt;n(R(\\bm{A})=n)\\)\n矩阵\\(A\\)的行向量组线性相关（无关）的充要条件为\\(R(\\bm{A})\u0026lt;m(R(\\bm{A})=m)\\)\n若向量组\\(I\\)可由向量组\\(II\\)线性表示，则\\(I\\)的秩不超过\\(II\\)的秩； 等价向量组的秩相等。  极大无关组表示其他向量  1.jpg  转化为行最简形为\n 2.jpg  显然极大无关组是\\(\\alpha_1,\\alpha_3,\\alpha_5\\)。\n并且有\\(\\alpha_2=3\\alpha_1,\\alpha_4=-2\\alpha_1+\\alpha_3,\\alpha_6=\\alpha_1+2\\alpha_3-\\alpha_5\\)\n向量空间 向量空间的定义 设\\(\\bm{V}\\)是非空\\(n\\)维向量的集合，如果\\(\\bm{V}\\)对向量的加法和数乘封闭，即\n若\\(\\bm{a,b\\in V}\\)，有\\(\\bm{a+b}\\in V\\); 若\\(\\bm{a\\in B},\\lambda\\in R\\)，有\\(\\lambda\\bm{a\\in V}\\)（特别注意\\(\\lambda=0\\)的情况）  则称\\(\\bm{V}\\)为一个向量空间\n向量空间必须含有零向量。\n子空间的定义\n设\\(\\bm{V}\\)和\\(\\bm{H}\\)都是向量空间，若\\(\\bm{H}\\subset V\\)，则称\\(\\bm{H}\\)是\\(\\bm{V}\\)的子空间。\n线性变换的定义\n已知\\(\\bm{A}\\)为\\(n\\)阶方阵，则称映射\\(f:\\bm{R}^n\\to \\bm{R}^n,\\bm{x}\\to \\bm{y},\\bm{y}=\\bm{Ax}\\)为\\(\\bm{R}^n\\)上的线性变换，\\(\\bm{A}\\)称为线性变换矩阵.\n向量的内积与正交矩阵 向量的内积\n设\\(n\\)维向量\\(\\bm{x}=[x_1,x_2,\\cdots,x_n]^T\\)，\\(\\bm{y}=[y_1,y_2,\\cdots,y_n]^T\\)，称\n\\[ \u0026lt;\\bm{x},\\bm{y}\u0026gt;=x_1y_1+x_2y_2+\\cdots+x_ny_n \\]\n为向量\\(\\bm{x,y}\\)的内积。\n内积具有以下性质\n\\(\u0026lt;\\bm{x},\\bm{y}\u0026gt;=\u0026lt;\\bm{y},\\bm{x}\u0026gt;\\) \\(\u0026lt;k\\bm{x},\\bm{y}\u0026gt;=\u0026lt;\\bm{x},k\\bm{y}\u0026gt;=k\u0026lt;\\bm{x},\\bm{y}\u0026gt;\\)，\\(k\\)是实数 \\(\u0026lt;\\bm{x+y},\\bm{z}\u0026gt;=\u0026lt;\\bm{x},\\bm{z}\u0026gt;+\u0026lt;\\bm{y},\\bm{z}\u0026gt;\\) \\(\u0026lt;\\bm{x},\\bm{x}\u0026gt;\\ge0,\u0026lt;\\bm{x},\\bm{x}\u0026gt;=0\\)当且仅当\\(\\bm{x}=\\bm{0}\\) 柯西-施瓦茨不等式：\\(\u0026lt;\\bm{x},\\bm{y}\u0026gt;^2\\leq\u0026lt;\\bm{x},\\bm{x}\u0026gt;\u0026lt;\\bm{y},\\bm{y}\u0026gt;\\)  向量的范数\n设\\(n\\)维向量\\(\\bm{x}=[x_1,x_2,\\cdots,x_n]^T\\)，称\n\\[ ||\\bm{x}||=\\sqrt{\\bm{x}^T\\bm{x}}=\\sqrt{\u0026lt;\\bm{x},\\bm{x}\u0026gt;}=\\sqrt{x_1^2+x_2^2+\\cdots+x_n^2} \\]\n为向量\\(\\bm{x}\\)的范数。\n范数具有以下性质\n\\(||\\bm{x}||\\ge0,||\\bm{x}||=0\\)当且仅当\\(\\bm{x}=\\bm{0}\\) \\(||k\\bm{x}||=|k|||\\bm{x}||\\)，k为实数 \\(||\\bm{x}+\\bm{y}||\\leq||\\bm{x}||+||\\bm{y}||\\)  向量的夹角与正交\n设\\(\\bm{x,y}\\)是\\(n\\)维非零向量，称\n\\[ \\theta=\\arccos\\frac{\\bm{x}^T\\bm{y}}{||\\bm{x}||||\\bm{y}||}=\\arccos\\frac{\u0026lt;\\bm{x},\\bm{y}\u0026gt;}{||\\bm{x}||||\\bm{y}||} \\]\n为向量\\(\\bm{x,y}\\)的夹角。特别的，当\\(\u0026lt;\\bm{x},\\bm{y}\u0026gt;=0时\\)，\\(\\theta=\\pm\\frac{\\pi}{2}\\)，称两向量正交（或垂直）。\n两两正交的向量组称为正交向量组。由单位向量构成的正交向量组称为标准（规范）标准正交组\n有如下定理：\n不含零向量的正交向量组必线性无关。  施密特正交化方法\n设向量组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m\\)线性无关，令\n\\[ \\bm{\\beta}_1=\\bm{\\alpha}_1\\\\ \\bm{\\beta}_2=\\bm{\\alpha}_2-\\frac{\u0026lt;\\bm{\\alpha}_2,\\bm{\\beta}_1\u0026gt;}{\u0026lt;\\bm{\\beta}_1,\\bm{\\beta}_1\u0026gt;}\\bm{\\beta}_1\\\\ \\bm{\\beta}_3=\\bm{\\alpha}_3-\\frac{\u0026lt;\\bm{\\alpha}_3,\\bm{\\beta}_1\u0026gt;}{\u0026lt;\\bm{\\beta}_1,\\bm{\\beta}_1\u0026gt;}\\bm{\\beta}_1-\\frac{\u0026lt;\\bm{\\alpha}_3,\\bm{\\beta}_2\u0026gt;}{\u0026lt;\\bm{\\beta}_2,\\bm{\\beta}_2\u0026gt;}\\bm{\\beta}_2\\\\ \\cdots\\\\ \\bm{\\beta}_m=\\bm{\\alpha}_m-\\sum_{j=1}^{m-1}\\frac{\u0026lt;\\bm{\\alpha}_m,\\bm{\\beta}_j\u0026gt;}{\u0026lt;\\bm{\\beta}_j,\\bm{\\beta}_j\u0026gt;}\\bm{\\beta}_j \\]\n则\\(\\bm{\\beta}_1,\\bm{\\beta}_2,\\cdots,\\bm{\\beta}_m\\)是与\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m\\)等价的正交向量组\n若进一步单位化，即令\\(\\bm{\\eta}_j=\\frac{\\bm{\\beta}j}{||\\bm{\\beta}_j||}\\)，则\\(\\bm{\\eta}_1,\\bm{\\eta}_2,\\cdots,\\bm{\\eta}_m\\)是一个与\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m\\)等价的标准正交向量组.\n正交矩阵\n设\\(\\bm{A}\\)为\\(n\\)阶方阵，若满足\\(\\bm{A}^T\\bm{A}=\\bm{E}\\)，则称\\(\\bm{A}\\)为正交矩阵。\n有如下性质：\n若\\(\\bm{A}\\)为正交矩阵，则\\(\\bm{A}^T=\\bm{A}^{-1}\\) 若\\(\\bm{A}\\)为正交矩阵，则\\(\\bm{A}^T\\)和\\(\\bm{A}^{-1}\\)和\\(\\bm{A}^{*}\\)也为正交矩阵 若\\(\\bm{A},\\bm{B}\\)为\\(n\\)阶正交矩阵，则\\(\\bm{AB}\\)也为正交矩阵 若\\(\\bm{A}\\)为正交矩阵，则\\(|\\bm{A}|=\\pm1\\)  有如下定理：\n\\(n\\)阶方阵\\(\\bm{A}\\)为正交矩阵的充要条件是\\(\\bm{A}\\)的列（行）向量组是标准向量组。\n基、维数与坐标 向量空间的基与维数 设\\(\\bm{V}\\)是向量空间，如果向量\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_r\\in\\bm{V}\\)，满足\n\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_r\\)线性无关 \\(\\bm{V}\\)中任一向量都可以由\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_r\\)线性表示  则称向量组\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_r\\)是向量空间\\(\\bm{V}\\)的一组基，\\(r\\)称为向量空间的维数，记为\\(dim\\bm{V}=r\\)，规定零向量构成的向量空间的维数为0.\n类似的还有正交基和标准（规范）正交基的概念。\n向量的坐标 设\\(\\bm{V}\\)是\\(r\\)维向量空间，\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_r\\)是\\(\\bm{V}\\)的一组基，则\\(\\bm{V}\\)中的任一向量\\(\\bm{x}\\)可由\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_r\\)唯一线性表示为\\(\\bm{x}=x_1\\bm{\\alpha}_1+\\cdots+x_r\\bm{\\alpha}_r\\)，数组\\(x_1,x_2,\\cdots,x_r\\)称为向量\\(\\bm{x}\\)在基\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_r\\)下的坐标。\n过渡矩阵与基变换公式\n设\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_r\\)和\\(\\bm{\\beta}_1,\\bm{\\beta}_2,\\cdots,\\bm{\\beta}_r\\)是\\(r\\)维向量空间\\(\\bm{V}\\)的两组基，则两个向量组等价，从而有\\(\\bm{\\beta}_j=k_{1j}\\bm{\\alpha}_1+\\cdots+k_{rj}\\bm{\\alpha}_r\\)，即\n\\[ [\\bm{\\beta}_1,\\cdots,\\bm{\\beta}_r]=[\\bm{\\alpha}_1,\\cdots,\\bm{\\alpha}_r] \\begin{bmatrix} k_{11} \u0026amp; \\cdots \u0026amp; k_{1r}\\\\ \\vdots \u0026amp; \u0026amp; \\vdots\\\\ k_{r1} \u0026amp; \\cdots \u0026amp; k_{rr} \\end{bmatrix} =[\\bm{\\alpha}_1,\\cdots,\\bm{\\alpha}_r]\\bm{K} \\]\n称\\(\\bm{K}\\)是由\\(\\bm{A}\\)到\\(\\bm{B}\\)的过度矩阵，上式为基变换公式。另外\\(\\bm{K}\\)一定是可逆矩阵。\n坐标变换公式\n设\\(\\bm{\\alpha}\\)在两组基\\(\\bm{A,B}\\)下的坐标分别为\\([x_1,\\cdots,x_r]^T\\)和\\([y_1,\\cdots,y_r]^T\\)，则有\n\\[ \\begin{bmatrix} x_1 \\\\ \\vdots \\\\ x_r \\end{bmatrix} =\\bm{K} \\begin{bmatrix} y_1 \\\\ \\vdots \\\\ y_r \\end{bmatrix} or \\begin{bmatrix} y_1 \\\\ \\vdots \\\\ y_r \\end{bmatrix} =\\bm{K}^{-1} \\begin{bmatrix} x_1 \\\\ \\vdots \\\\ x_r \\end{bmatrix} \\]\n一般有\\(\\bm{K}=\\bm{A}^{-1}\\bm{B}\\)\n线性方程组 解法 高斯消元法 即通过对增广矩阵进行初等行变换（只能是行变换），化为简单的形式进行求解。\n克莱默法则 见前\n性质定理 齐次线性方程组\\(\\bold{A}_{m\\times n}\\bold{x=0}\\)有非零解的充要条件是\\(R(\\bold{A})=r\u0026lt;n\\)，且有无穷多解，自由量为\\(n-r\\)个（解空间的维数为\\(n-r\\)）。这个充要条件可以替换为\\(|\\bm A|=0\\)及其他等价命题。\n 非齐次线性方程组\\(\\bold{A}_{m\\times n}\\bold{x=b}\\)有解的充要条件是\\(R(\\bold{A})=R(\\~\\bold{A})=r\\)，且当\n\\(r=n\\)时有唯一解，称为适定线性方程组 \\(r\u0026lt;n\\)时有无穷多解，自由量是\\(n-r\\)个，称为欠定线性方程组   线性方程组解的结构 齐次情况 设\\(\\bm{\\xi}_1,\\bm{\\xi}_2,\\cdots,\\bm{\\xi}_t\\)是\\(\\bm{Ax=0}\\)的解，则\\(c_1\\bm{\\xi}_1+c_2\\bm{\\xi}_2+\\cdots+c_t\\bm{\\xi}_t\\)也是解，\\(c_i\\)为任意常数。\n齐次线性方程组\\(\\bm{Ax=0}\\)的解空间的一组基\\(\\bm{\\xi}_1,\\bm{\\xi}_2,\\cdots,\\bm{\\xi}_{n-r}\\)也称为方程组的一个基础解系。\n换言之，基础解系\\(\\bm{\\xi}_1,\\bm{\\xi}_2,\\cdots,\\bm{\\xi}_{n-r}\\)是\\(\\bm{Ax=0}\\)的解向量，且满足\n\\(\\bm{\\xi}_1,\\bm{\\xi}_2,\\cdots,\\bm{\\xi}_{n-r}\\)线性无关 \\(\\bm{Ax=0}\\)的任一解都可由\\(\\bm{\\xi}_1,\\bm{\\xi}_2,\\cdots,\\bm{\\xi}_{n-r}\\)线性表示  通过基础解系可以写出通解为\\(\\bm{x}=c_1\\bm{\\xi}_1+c_2\\bm{\\xi}_2+\\cdots+c_{n-r}\\bm{\\xi}_{n-r}\\)，\\(c_i\\)为任意常数。\n非齐次情况 有如下性质：\n设\\(\\bm{x}=\\bm{\\eta}_1+\\bm{\\eta}_2+\\cdots+\\bm{\\eta}_{t}\\)为\\(\\bm{Ax=b}\\)的解，令\\(\\bm{\\eta}=c_1\\bm{\\eta}_1+c_2\\bm{\\eta}_2+\\cdots+c_{t}\\bm{\\eta}_{t}\\)，当\\(c_1+\\cdots+c_t=0\\)时，\\(\\bm{\\eta}\\)为\\(\\bm{Ax=0}\\)的解，当\\(c_1+\\cdots+c_t=1\\)时\\(\\bm{\\eta}\\)为\\(\\bm{Ax=b}\\)的解 设\\(\\bm\\xi\\)为\\(\\bm{Ax=0}\\)的解，\\(\\bm\\eta\\)为\\(\\bm{Ax=b}\\)的解，则\\(\\bm{x=\\xi+\\eta}\\)仍为\\(\\bm{Ax=b}\\)的解。 非齐次线性方程组的解集关于加法和数乘不封闭，因此不构成向量空间  由此可知，\\(\\bm{Ax=b}(R(\\bm{A})=R(\\~{\\bm{A}})=r\\)的通解为\n\\[ \\bm x=k_1\\bm{\\xi}_1+\\cdots+k_{n-r}\\bm{\\xi}_{n-r}+\\bm\\eta^* \\]\n其中\\(\\bm{x}=\\bm{\\xi}_1+\\bm{\\xi}_2+\\cdots+\\bm{\\xi}_{n-r}\\)为导出组\\(\\bm{Ax=0}\\)的一个基础解系，\\(\\bm\\eta^*\\)为\\(\\bm{Ax=b}\\)的任意一个解，称为特解。\n相似矩阵与二次型 特征值和特征向量 设\\(\\bm{A}\\)为\\(n\\)阶矩阵，如果存在数\\(\\lambda\\)和\\(n\\)维非零（注意非零）列向量\\(\\bm\\alpha\\)使得\n\\[ \\bm A\\bm\\alpha=\\lambda\\bm\\alpha \\]\n则称\\(\\lambda\\)为\\(\\bm A\\)的特征值，\\(\\bm\\alpha\\)为\\(\\bm A\\)对于这个\\(\\lambda\\)的特征向量。\n由上式可知，\\(\\bm\\alpha\\)必是如下方程的非零解\n\\[ (\\lambda\\bm E-\\bm A)\\bm x=\\bm 0 \\]\n显然有非零解当且仅当\\(|\\lambda\\bm E-\\bm A|=0\\)，\\(\\lambda\\bm E-\\bm A\\)称为特征矩阵，\\(|\\lambda\\bm E-\\bm A|\\)称为特征多项式，\\(|\\lambda\\bm E-\\bm A|=0\\)称为特征方程。\n特征值和特征向量的求解步骤\n求\\(|\\lambda\\bm E-\\bm A|=0\\)的全体根，记为\\(\\lambda_1,\\lambda_2,\\cdots,\\lambda_n\\) 对于每个特征值\\(\\lambda_i\\)，求出对应其次线性方程组\\((\\lambda_i\\bm E-\\bm A)\\bm x=\\bm0\\)的一个基础解系\\(\\bm{\\alpha}_1,\\cdots,\\bm{\\alpha}_s\\)，并以此求出\\(\\lambda_i\\)对应的全部特征向量\\(k_1\\bm{\\alpha}_1,\\cdots,k_s\\bm{\\alpha}_s\\)。其中\\(k_1,\\cdots,k_s\\)是任意不全为零的常数。  特征值和特征向量的性质 设\\(\\lambda\\)为\\(\\bm A\\)的任一特征值，\\(\\bm\\alpha\\)为其对应的特征向量，则\\(f(\\lambda)\\)是\\(f(\\bm A)\\)的特征值，其对应的特征向量还是\\(\\bm\\alpha\\)，其中\\(f(x)\\)是\\(x\\)的\\(m\\)次多项式。\n 设\\(\\lambda\\)为\\(\\bm A\\)的任一非零特征值，\\(\\bm\\alpha\\)为其对应的特征向量，则\\(\\bm A^*\\)的特征值为\\(|\\bm A|/\\lambda\\)。特征向量仍为\\(\\bm\\alpha\\)\n 若矩阵\\(\\bm A\\)可逆，则\\(1/\\lambda\\)是\\(A^{-1}\\)的特征值。特征向量仍为\\(\\bm\\alpha\\)\n 转置矩阵由于行列式不变，所以特征值不变。但是特征向量并不一定一样。\n 设\\(n\\)阶矩阵\\(\\bm A\\)的\\(n\\)个特征值为\\(\\lambda_1,\\lambda_2,\\cdots,\\lambda_n\\)（重根按重数计算），则\n\\(\\lambda_1+\\lambda_2+\\cdots+\\lambda_n=a_{11}+a_{22}+\\cdots+a_{nn}=tr(\\bm A)\\),\\(tr(\\bm A)\\)称之为矩阵的迹 \\(\\lambda_1\\lambda_2\\cdots\\lambda_n=|\\bm A|\\)  矩阵可逆\\(\\Leftrightarrow\\)所有特征值均非0\n 若\\(\\lambda_1,\\lambda_2,\\cdots,\\lambda_m\\)是\\(\\bm A\\)的互不相同的特征值，\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m\\)是对应的特征向量，则\\(\\bm{\\alpha}_1,\\bm{\\alpha}_2,\\cdots,\\bm{\\alpha}_m\\)线性无关\n 设\\(\\lambda\\)是\\(k\\)重特征值，对于\\(\\lambda\\)的线性无关的特征向量的最大个数为\\(l\\)，则\\(k\\ge l\\)\n  相似矩阵 相似矩阵的定义和性质 设\\(\\bm{A,B}\\)为\\(n\\)阶矩阵，若存在\\(n\\)阶可逆矩阵\\(\\bm P\\)，使得\n\\[ \\bm P^{-1}\\bm A\\bm P=\\bm B \\]\n则称\\(\\bm A\\)与\\(\\bm B\\)相似，记作\\(\\bm A\\sim \\bm B\\)\n具有以下性质：自反性、传递性、对称性。\n以及\n如果两矩阵相似，则具有相同的特征多项式，从而有相同的特征值。但特征向量不一定相同。并且特征多项式相同并不能推出两矩阵相似。 两矩阵相似，则具有相同的秩。 两矩阵相似，则具有相同的迹。 两矩阵相似，则具有相同的行列式。 若\\(\\bm A\\sim \\bm B\\)，且\\(\\bm A\\)可逆，则\\(\\bm B\\)可逆，并且有\\(\\bm A^{-1}\\sim \\bm B^{-1}\\) 若\\(\\bm A\\sim \\bm B\\)，则对任一多项式\\(g(x)\\)，有\\(g(\\bm A)\\sim g(\\bm B)\\)  矩阵可对角化的条件 设\\(\\bm A\\)为\\(n\\)阶矩阵，如果存在一个\\(n\\)阶可逆矩阵\\(\\bm P\\)，使得\\(\\bm P^{-1}\\bm A\\bm P\\)为对角矩阵，则称\\(\\bm A\\)可对角化。\n有如下定理：\n\\(\\bm A\\)可对角化的充要条件是\\(\\bm A\\)有\\(n\\)个线性无关的特征向量。 \\(n\\)阶矩阵\\(\\bm A\\)的\\(n\\)个特征值互不相同\\(\\Rightarrow\\)\\(\\bm A\\)可对角化 \\(\\bm A\\)可对角化的充要条件是对于\\(\\bm A\\)的每个\\(k\\)重特征值\\(\\lambda\\)，都有\\(R(\\lambda\\bm E-\\bm A)=n-k\\)  实对称矩阵的对角化 实对称矩阵一定能对角化\n并且有如下定理：\n实对称矩阵的特征值都为实数 实对称矩阵的不同特征值所对应的特征向量必正交 设\\(\\bm A\\)为\\(n\\)阶实对称矩阵，则存在正交矩阵\\(\\bm Q\\)使得  \\[ \\bm Q^T\\bm{AQ}=\\bm Q^{-1}\\bm{AQ}= \\begin{bmatrix} \\lambda_1 \u0026amp; \u0026amp; \u0026amp; \\\\ \u0026amp; \\lambda_2 \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026amp; \\ddots \u0026amp; \\\\ \u0026amp; \u0026amp; \u0026amp; \\lambda_n \\end{bmatrix} \\]\n其中\\(\\lambda_i\\)为\\(\\bm A\\)的特征值。\n设\\(\\bm A\\)为\\(n\\)阶实对称矩阵，\\(\\lambda\\)为\\(\\bm A\\)的\\(k\\)重特征值，则\\(\\bm A\\)必有\\(k\\)个对于特征值\\(\\lambda\\)的线性无关的特征向量  求解对角阵的方法\n求\\(\\bm A\\)的全部不同特征值\\(\\lambda_1,\\lambda_2,\\cdots,\\lambda_s\\) 对于每个不同的特征值，求出齐次线性方程组\\((\\lambda_i\\bm E-\\bm A)\\bm x=\\bm 0\\)的基础解系，将其正交化、单位化 将所得的正交单位特征向量作为列向量组构成正交矩阵（注意特征向量和特征值的顺序）\\(\\bm Q\\)，则\\(\\bm Q^T\\bm{AQ}=\\bm Q^{-1}\\bm{AQ}=diag(\\lambda_1,\\lambda_2,\\cdots,\\lambda_n)\\)  二次型及其标准型 n元二次型的定义如下 \\[ f(x_1,\\cdots,x_n)=a_{11}x_1^2+2a_{12}x_1x_2+\\cdots+2a_{1n}x_1x_n+a_{22}x_2^2+2a_{2n}x_2x_n+\\cdots+a_{nn}x_{n}^2\\\\= (x_1,\\cdots,x_n) \\begin{bmatrix} a_{11}x_1+a_{12}x_2+\\cdots+a_{1n}x_n\\\\ a_{21}x_1+a_{22}x_2+\\cdots+a_{2n}x_n\\\\ \\vdots\\\\ a_{n1}x_1+a_{n2}x_2+\\cdots+a_{nn}x_n \\end{bmatrix}\\\\= (x_1,\\cdots,x_n) \\begin{bmatrix} a_{11} \u0026amp; a_{12} \u0026amp; \\cdots \u0026amp; a_{1n}\\\\ a_{21} \u0026amp; a_{22} \u0026amp; \\cdots \u0026amp; a_{2n}\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \u0026amp; \\vdots\\\\ a_{n1} \u0026amp; a_{n2} \u0026amp; \\cdots \u0026amp; a_{nn} \\end{bmatrix} \\begin{bmatrix} x_1\\\\ x_2\\\\ \\vdots\\\\ x_n \\end{bmatrix} \\]\n亦可表示为\\(f(\\bm x)=\\bm x^T\\bm {Ax}\\)。其中\\(\\bm A^T=\\bm A\\)为实对称矩阵。\\(\\bm A\\)称为二次型式的矩阵，其秩称为二次型式的秩。\n仅含平方项的二次型称之为标准型。\n显然\\(\\bm x^T\\bm {Ax}\\)为标准型的充要条件是\\(\\bm A\\)为对角矩阵。\n\\(\\bm A\\)可以直接读出，先写一个对角矩阵，对角线的元素值即为平方项的系数，对角线以上的元素找对应项的系数除以2，之后再将对角线以上的元素“对称地”写到对角线以下的元素\n矩阵的合同 设\\(\\bm{A,B}\\)为\\(n\\)阶矩阵，若存在\\(n\\)阶可逆矩阵\\(\\bm C\\)，使得\\(\\bm C^{T}\\bm A\\bm C=\\bm B\\)则称\\(\\bm A\\)与\\(\\bm B\\)合同，记作\\(\\bm A\\simeq \\bm B\\)\n具有以下性质：自反性、传递性、对称性。\n以及若\\(\\bm{A,B}\\)合同，且\\(\\bm A\\)为对称矩阵，则\\(\\bm B\\)也为对称矩阵，且\\(R(\\bm A)=R(\\bm B)\\)\n化二次型为标准型 有三种方法\n1.正交变换法\n若\\(\\bm Q\\)为正交矩阵，则称线性变换\\(\\bm{x=Qy}\\)为正交变换。\n对于任意\\(n\\)元二次型\n\\[ f(x_1,x_2,\\cdots,x_n)=\\bm{x}^T\\bm{Ax} \\]\n总存在正交变换\\(\\bm{x=Qy}\\)，使得\n\\[ f(x_1,x_2,\\cdots,x_n)\\xlongequal{\\bm{x=Qy}}\\lambda_1y_1^2+\\lambda_2y_2^2+\\cdots+\\lambda_ny_n^2 \\]\n其中\\(\\lambda_1,\\lambda_2,\\cdots,\\lambda_n\\)为\\(\\bm A\\)的全部特征值。\n\\(\\bm Q\\)的计算方法：\n求\\(\\bm A\\)的特征向量 将所有特征向量正交化、单位化 再将得到的向量组成列向量组，即为\\(\\bm Q\\)。注意组合的顺序  2.配方法\n例如：\n\\[ f(x_1,x_2.x_3)=2(x_1^2+2x_1x_2+4x_1x_3)+x_2^2+14x_2x_3-x_3^2\\\\ =2(x_1+x_2+2x_3)^2-(x_2-3x_3)^2 \\]\n令\n\\[ \\left\\{\\begin{matrix} y_1=x_1+x_2+2x_3 \\\\ y_2=x_2-3x_3 \\\\ y_3=x_3 \\end{matrix}\\right. \\]\n则有\n\\[ \\left\\{\\begin{matrix} x_1=y_1-y_2-5y_3 \\\\ x_2=y_2+3y_3 \\\\ x_3=y_3 \\end{matrix}\\right. \\]\n即\n\\[ \\bm x= \\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; -1 \u0026amp; -5 \\\\ 0 \u0026amp; 1 \u0026amp; 3 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} =\\bm{Qy} \\]\n3.初等变换法\n对\\(2n\\times n\\)矩阵实施一次初等列变换及相应的初等行变换，直至把\\(\\bm A\\)化为对角矩阵\\(\\bm \\Lambda\\)，即\n\\[ \\begin{bmatrix} \\bm A \\\\ \\bm E \\end{bmatrix} \\sim \\begin{bmatrix} \\bm \\Lambda \\\\ \\bm Q \\end{bmatrix} \\]\n且有\\(\\bm{Q}^T\\bm{AQ}=\\bm\\Lambda\\)\n二次型的规范型 设实二次型\\(f(x_1,x_2,\\cdots,x_n)\\)经过可逆线性变换转化为标准型\n\\[ f(x_1,x_2,\\cdots,x_n)=d_1y_1^2+\\cdots+d_py_p^2-d_{p+1}y_{p+1}^2-\\cdots-d_ry_r^2 \\]\n其中\\(r\\)是二次型的秩，\\(d_i\u0026gt;0\\)，则可以再做一次线性变换\n\\[ \\left\\{\\begin{matrix} y_1=\\frac{1}{\\sqrt{d_1}}z_1 \\\\ \\vdots \\\\ y_r = \\frac{1}{\\sqrt{d_r}}z_r \\\\ y_{r+1}=z_{r+1} \\\\ \\vdots\\\\ y_n=z_n \\end{matrix}\\right. \\]\n则得到\n\\[ f(x_1,x_2,\\cdots,x_n)=z_1^2+\\cdots+z_p^2-z_{p+1}^2-\\cdots-z_r^2 \\]\n称为规范标准型，简称规范型。\n二次型的标准型是不唯一的，但规范标准型是唯一的（并且对于实二次型来说一定存在规范型）。这也被称作惯性定律。\n标准型中正平方项的个数\\(p\\)称为正惯性指数，负平方项的个数\\(q\\)称为负惯性指数。\\(p-q\\)称为二次型的符号差。\n并且有如下定理\n定理\n任何实对称矩阵必合同于如下形式的对角矩阵\n\\[ \\begin{bmatrix} \\bm{E}_p \u0026amp; \u0026amp; \\\\ \u0026amp; -\\bm{E}_q \u0026amp; \\\\ \u0026amp; \u0026amp; \\bm{0} \\end{bmatrix} \\]\n正定二次型 对于任何非零（强调非零）向量\\(\\bm{x}=(x_1,\\cdots,x_n)\\)都有\n\\[ f(x_1,\\cdots,x_n)=\\bm{x}^T\\bm{Ax}\u0026gt;0(\u0026lt;0) \\]\n则称\\(f\\)是正定（负定）二次型，\\(\\bm{A}\\)称为正定（负定）矩阵。\n如果上式取\\(\\ge(\\leq)\\)，则为半正定（半负定）二次型。\n如果\\(f\\)既不是半正定的，也不是半负定的，则称为不定的。\n有如下定理\n定理1\n可逆的线性变换不改变二次型的正定性\n定理2\n\\(\\bm{A,B}\\)合同，则\\(\\bm{A}\\)正定的充要条件是\\(\\bm{B}\\)正定。\n定理3\n若\\(\\bm A\\)是\\(n\\)阶正定矩阵，则\n\\(\\bm A\\)的主对角线元\\(a_{ii}\u0026gt;0\\) \\(|\\bm A|\u0026gt;0\\)  \\(k\\)阶顺序主子式\n设\\(\\bm A\\)为\\(n\\)阶方阵，依次取\\(\\bm A\\)的前\\(k\\)行与前\\(k\\)列所构成的子式的行列式称为矩阵\\(\\bm A\\)的\\(k\\)阶顺序主子式。\n显然\\(n\\)阶方阵\\(\\bm A\\)的顺序主子式有且只有\\(n\\)个。\n有如下定理\n霍尔维茨定理\n\\(n\\)元实二次型\\(f=\\bm{x}^T\\bm{Ax}\\)正定的充要条件是\\(\\bm A\\)的\\(n\\)个顺序主子式均大于零。\n","date":"2022-06-04T12:11:53+08:00","image":"https://kegalas.top/p/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%95%B4%E7%90%86/cover_hu670730d9bdf70a44294ca8d2a00a2ced_185066_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%95%B4%E7%90%86/","title":"线性代数整理"},{"content":" [TOC]\n向量代数与空间解析几何 方向角与方向余弦 非零向量\\(\\bold{r}\\)与三条坐标轴的夹角\\(\\alpha\\)、\\(\\beta\\)、\\(\\gamma\\)称为向量\\(\\bold{r}\\)的方向角。设\\(\\overrightarrow{OM}=\\bold{r}=(x,y,z)\\)，则有\n\\[ (cos\\alpha,cos\\beta,cos\\gamma)=\\left(\\frac{x}{|\\bold{r}|},\\frac{y}{|\\bold{r}|},\\frac{z}{|\\bold{r}|}\\right)=\\frac{1}{|\\bold{r}|}(x,y,z)=\\frac{\\bold{r}}{|\\bold{r}|}=\\bold{e} \\]\n\\(cos\\alpha,cos\\beta,cos\\gamma\\)称为向量\\(\\bold{r}\\)的方向余弦。并且有\n\\[ cos^2\\alpha+cos^2\\beta+cos^2\\gamma = 1 \\]\n数量积的运算规律 交换律 \\(\\bold{a}\\cdot\\bold{b}=\\bold{b}\\cdot\\bold{a}\\)\n 分配律 \\((\\bold{a+b})\\cdot \\bold{c}=\\bold{a\\cdot c+b\\cdot c}\\)\n 如下的结合律 \\((\\lambda \\bold{a})\\cdot\\bold{b}=\\lambda(\\bold{a\\cdot b})\\),\\(\\lambda\\)为数\n  向量积的运算规律 \\(\\bold{b\\times a=-a\\times b}\\)\n 分配律 \\(\\bold{(a+b)\\times c=a\\times c+b\\times c}\\)\n 如下的结合律 \\((\\lambda \\bold{a})\\times \\bold{b}=\\lambda(\\bold{a\\times b})\\),\\(\\lambda\\)为数\n  平面的点法式方程 当平面\\(\\Pi\\)上一点\\(M_0(x_0,y_0,z_0)\\)和它的一个法线向量\\(\\bold{n}=(A,B,C)\\)已知时，有平面的点法式方程：\n\\[ A(x-x_0)+B(y-y_0)+C(z-z_0)=0 \\]\n平面的一般方程 \\[ Ax+By+Cz+D=0 \\]\n其中这个平面的法向量为\\(\\bold{n}=(A,B,C)\\)\n平面的截距式方程 \\[ \\frac{x}{a}+\\frac{y}{b}+\\frac{z}{c}=1 \\]\n其中\\(a,b,c\\)分别为\\(x,y,z\\)轴上的截距\n两平面夹角 \\[ cos\\theta=\\frac{|A_1A_2+B_1B_2+C_1C_2|}{\\sqrt{A_1^2+B_1^2+C_1^2}\\sqrt{A_2^2+B_2^2+C_2^2}} \\]\n点到平面距离公式 点\\(P_0(x_0,y_0,z_0)\\)到平面\\(Ax+By+Cz+D=0\\)的距离公式\n\\[ d=\\frac{|Ax_0+By_0+Cz_0+D|}{\\sqrt{A^2+B^2+C^2}} \\]\n空间直线的一般方程 \\[ \\left\\{\\begin{matrix} A_1x+B_1y+C_1z+D_1=0\\\\ A_2x+B_2y+C_2z+D_2=0 \\end{matrix}\\right. \\]\n即两个平面的交线\n另外两个平面的法向量的向量积可以算出直线的切向量\n平面束方程 由上述空间直线方程可知，通过这一直线的平面还有\n\\[ \\lambda(A_1x+B_1y+C_1z+D_1)+\\mu(A_2x+B_2y+C_2z+D_2)=0 \\]\n其中\\(\\lambda=1\\)时\n\\[ (A_1x+B_1y+C_1z+D_1)+\\mu(A_2x+B_2y+C_2z+D_2)=0 \\]\n表示除了\\(A_2x+B_2y+C_2z+D_2=0\\)，之外的过直线的平面束。\n空间直线的对称式方程(点向式方程) 若已知直线过一点\\(M_0(x_0, y_0, z_0)\\)和它的一个方向向量\\(\\bold{s}=(m,n,p)\\)。则有方程\n\\[ \\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p} \\]\n空间直线的参数方程 若设\n\\[ \\frac{x-x_0}{m}=\\frac{y-y_0}{n}=\\frac{z-z_0}{p}=t \\]\n则有\n\\[ \\left\\{\\begin{matrix} x=x_0+mt \\\\ y=y_0+nt \\\\ z=z_0+pt \\end{matrix}\\right. \\]\n两直线的夹角 设两直线方向向量分别为\\(\\bold{s_1}=(m_1,n_1,p_1)\\)和\\(\\bold{s_2}=(m_2,n_2,p_2)\\)\n\\[ cos\\varphi = \\frac{|m_1m_2+n_1n_2+p_1p_2|}{\\sqrt{m_1^2+n_1^2+p_1^2}\\sqrt{m_2^2+n_2^2+p_2^2}} \\]\n直线与平面的夹角 设直线方向向量和平面法向量分别为\\(\\bold{s}=(m,n,p)\\)和\\(\\bold{n}=(A,B,C)\\)\n\\[ sin\\varphi = \\frac{|Am+Bn+Cp|}{\\sqrt{A^2+B^2+C^2}\\sqrt{m^2+n^2+p^2}} \\]\n旋转曲面 设在\\(yOz\\)坐标面上有一已知曲线\\(f(y,z)=0\\)\n则把这个曲线绕z轴旋转一周，得到的曲面为\\(f(\\pm\\sqrt{x^2+y^2},z)=0\\)\n绕y轴旋转则为\\(f(y,\\pm\\sqrt{x^2+z^2})=0\\)\n在其他坐标面上的曲线类似。\n二次曲面举例 椭圆锥面 \\[ \\frac{x^2}{a^2}+\\frac{y^2}{b^2}=z^2 \\]\n 8-47.jpg  椭球面 \\[ \\frac{x^2}{a^2}+\\frac{y^2}{b^2}+\\frac{z^2}{c^2}=1 \\]\n 8-49.jpg  单叶双曲面 \\[ \\frac{x^2}{a^2}+\\frac{y^2}{b^2}-\\frac{z^2}{c^2}=1 \\]\n 8-40.jpg  双叶双曲面 \\[ \\frac{x^2}{a^2}-\\frac{y^2}{b^2}-\\frac{z^2}{c^2}=1 \\]\n 8-41.jpg  椭圆抛物面 \\[ \\frac{x^2}{a^2}+\\frac{y^2}{b^2}=z \\]\n 8-50  双曲抛物面 \\[ \\frac{x^2}{a^2}-\\frac{y^2}{b^2}=z \\]\n 8-51  空间曲线及其方程 一般方程 即两个曲面的交线\n\\[ \\left\\{\\begin{matrix} F(x,y,z) = 0 \\\\ G(x,y,z) = 0 \\end{matrix}\\right. \\]\n参数方程 \\[ \\left\\{\\begin{matrix} x=x(t) \\\\ y=y(t) \\\\ z=z(t) \\end{matrix}\\right. \\]\n多元函数微分法及其应用 多元函数的极限 注意极限存在，当且仅当从各个方向趋近那个点时得到的值存在并相等。\n例如\\(f(x,y)=\\frac{xy}{x^2+y^2},x^2+y^2\\neq 0;f(x,y)=0,x^2+y^2=0\\)，有沿x轴y轴趋近\\((0,0)\\)极限都为0，但沿直线\\(y=kx\\)趋近时极限随\\(k\\)变化。故极限不存在。\n偏导数 注意有时利用定义求解偏导数会更优\n例如关于\\(x\\)的偏导数\n\\[ \\lim_{\\Delta x \\to 0}\\frac{f(x_0+\\Delta x,y_0)-f(x_0,y_0)}{\\Delta x} \\]\n在如\\(x_0=0,y_0=0\\)或者其他性质比较好的点，会更容易求。\n高阶偏导数 注意分母上，求导顺序为从左到右。\n 如果函数\\(z=f(x,y)\\)的两个二阶混合偏导数\\(\\frac{\\partial^2z}{\\partial y\\partial x}\\)及\\(\\frac{\\partial^2z}{\\partial x\\partial y}\\)在区域\\(D\\)内连续，那么在该区域内这两个二阶混合偏导数必相等。\n  全微分 必要条件 如果函数\\(z=f(x,y)\\)在点\\((x,y)\\)可微分（蕴含着函数在该点上连续），那么该函数在点\\((x,y)\\)的偏导数\\(\\frac{\\partial z}{\\partial x}\\)与\\(\\frac{\\partial z}{\\partial y}\\)必定存在，且该函数在该点的全微分为\n\\[ dz=\\frac{\\partial z}{\\partial x}\\Delta x+\\frac{\\partial z}{\\partial y}\\Delta y \\]\n但这只是必要条件。\n形式上的全微分\\(\\Delta z\\)(和上文的\\(dz\\)一个意思)应该满足\n\\[ \\frac{\\Delta z-[f_x(x_0,y_0)\\cdot\\Delta x+f_y(x_0,y_0)\\cdot\\Delta y]}{\\rho} \\]\n随着\\(\\rho\\to0\\)而趋于\\(0\\)。\n其中\n\\[ \\rho=\\sqrt{(\\Delta x)^2+(\\Delta y)^2} \\]\n才能可微。\n充分条件 如果函数\\(z=f(x,y)\\)的偏导数\\(\\frac{\\partial z}{\\partial x}\\)、\\(\\frac{\\partial z}{\\partial y}\\)在\\((x,y)\\)连续，那么该函数在该点可微分。\n多元复合函数的求导法则 一元函数与多元函数复合的情形 如果函数\\(u=\\varphi(t)\\)及\\(v=\\psi(t)\\)都在点\\(t\\)可导，函数\\(z=f(u,v)\\)在对应点\\((u,v)\\)具有连续偏导数，那么复合函数\\(z=f[\\varphi(t),\\psi(t)]\\)在t可导，且有\n\\[ \\frac{dz}{dt}=\\frac{\\partial z}{\\partial u}\\frac{du}{dt}+\\frac{\\partial z}{\\partial v}\\frac{dv}{dt} \\]\n多元函数与多元函数复合的情形 \\[ u=\\varphi(x,y),v=\\psi(x,y),z=f(u,v) \\]\n若都在对应点\\((x,y)\\)具有连续偏导数，则\n\\[ \\frac{\\partial z}{\\partial x}=\\frac{\\partial z}{\\partial u}\\frac{\\partial u}{\\partial x}+\\frac{\\partial z}{\\partial v}\\frac{\\partial v}{\\partial x} \\]\n\\[ \\frac{\\partial z}{\\partial y}=\\frac{\\partial z}{\\partial u}\\frac{\\partial u}{\\partial y}+\\frac{\\partial z}{\\partial v}\\frac{\\partial v}{\\partial y} \\]\n混合复合 根据每个复合函数是否含有自变量\\(x,y\\)进行偏导，例如\n\\[ u=\\varphi(x,y),v=\\psi(y),z=f(u,v) \\]\n则\n\\[ \\frac{\\partial z}{\\partial x}=\\frac{\\partial z}{\\partial u}\\frac{\\partial u}{\\partial x} \\]\n\\[ \\frac{\\partial z}{\\partial y}=\\frac{\\partial z}{\\partial u}\\frac{\\partial u}{\\partial y}+\\frac{\\partial z}{\\partial v}\\frac{d v}{d y} \\]\n如果有两层复合函数，则要求导至将\\(x,y\\)这样的自变量暴露出来。\n全微分形式的不变性 设函数\\(z=f(u,v)\\)具有连续偏导数，则有全微分\n\\[ dz=\\frac{\\partial z}{\\partial u}du+\\frac{\\partial z}{\\partial v}dv \\]\n若有\\(u=\\varphi(x,y),v=\\psi(x,y)\\)，有\n\\[ dz=\\frac{\\partial z}{\\partial x}dx+\\frac{\\partial z}{\\partial y}dy \\]\n显然可以算出\\(\\frac{\\partial z}{\\partial x},\\frac{\\partial z}{\\partial y}\\)，代入有\n\\[ dz=\\frac{\\partial z}{\\partial u}du+\\frac{\\partial z}{\\partial v}dv \\]\n此为全微分形式的不变性。\n隐函数的求导公式 一个方程的情形 \\[ F(x,y)=0 \\]\n\\[ \\frac{dy}{dx}=-\\frac{F_x}{F_y} \\]\n条件：F在某点的某一邻域内具有连续偏导数，\\(F_y\\)在该点不为0\n\\[ F(x,y,z)=0 \\]\n\\[ \\frac{\\partial z}{\\partial x}=-\\frac{F_x}{F_z},\\frac{\\partial z}{\\partial y}=-\\frac{F_y}{F_z} \\]\n条件类似于上条。\n方程组的情形 考虑如下方程组\n\\[ \\left\\{\\begin{matrix} F(x,y,u,v)=0\\\\ G(x,y,u,v)=0 \\end{matrix}\\right. \\]\n一般四个变量只能有两个变量独立变化\n即\n\\[ u(x,y),v(x,y) \\]\n两边应用求导法则得\n\\[ F_x+F_u\\frac{\\partial u}{\\partial x}+F_v\\frac{\\partial v}{\\partial x}=0 \\]\n\\[ G_x+G_u\\frac{\\partial u}{\\partial x}+G_v\\frac{\\partial v}{\\partial x}=0 \\]\n解方程求出偏导数，求关于\\(y\\)的偏导数同理。\n多元函数积分学的几何应用 一元向量值函数及其导数 空间曲线\\(\\Gamma\\)的参数方程为\n\\[ \\left\\{\\begin{matrix} x=\\varphi(t), \\\\ y=\\psi(t), \\\\ z=\\omega(t) \\end{matrix}\\right. t\\in[\\alpha,\\beta] \\]\n写成向量形式，则为\n\\[ \\bold{r}=x\\bold{i}+y\\bold{j}+z\\bold{k} \\]\n\\[ \\bold{f}(t)=\\varphi(t)\\bold{i}+\\psi(t)\\bold{j}+\\omega(t)\\bold{k} \\]\n所以有\\(\\bold{r=f}(t)\\),\\(\\bold{r}\\)称为向量函数\n向量值导数如下：\n\\[ \\bold{f}\u0026#39;(t_0)=\\lim_{\\Delta t\\to 0}\\frac{\\Delta \\bold{r}}{\\Delta t} =\\lim_{\\Delta t\\to 0}\\frac{\\bold{f}(t_0+\\Delta t)-\\bold{f}(t_0)}{\\Delta t} \\]\n或者如下计算：\n\\[ \\bold{f}\u0026#39;(t_0)=\\bold{f_1}\u0026#39;(t_0)\\bold{i}+\\bold{f_2}\u0026#39;(t_0)\\bold j+ \\bold{f_3}\u0026#39;(t_0)\\bold k \\]\n空间曲线的切线与法平面 还是上面那个曲线\\(\\Gamma\\)，则切线方程为\n\\[ \\frac{x-x_0}{\\varphi\u0026#39;(t_0)}= \\frac{y-y_0}{\\psi\u0026#39;(t_0)}= \\frac{z-z_0}{\\omega\u0026#39;(t_0)} \\]\n法平面方程为\n\\[ \\varphi\u0026#39;(t_0)(x-x_0)+ \\psi\u0026#39;(t_0)(y-y_0)+ \\omega\u0026#39;(t_0)(z-z_0)=0 \\]\n若\\(\\Gamma\\)变为\n\\[ \\left\\{\\begin{matrix} x=x \\\\ y=\\varphi(x) \\\\ z=\\psi(x) \\end{matrix}\\right. \\]\n则切线方程变为\n\\[ \\frac{x-x_0}{1}= \\frac{y-y_0}{\\varphi\u0026#39;(x_0)}= \\frac{z-z_0}{\\psi\u0026#39;(x_0)} \\]\n法平面方程变为\n\\[ (x-x_0)+ \\varphi\u0026#39;(x_0)(y-y_0)+ \\psi\u0026#39;(x_0)(z-z_0)=0 \\]\n曲线为方程组情形时（三个变量一般只有一个自由变量，所以直接将\\(y,z\\)替换为\\(\\varphi(x),\\psi(x)\\)）\n\\[ F[x,\\varphi(x),\\psi(x)]=0 \\]\n\\[ G[x,\\varphi(x),\\psi(x)]=0 \\]\n两边求对\\(x\\)的全导数\n\\[ \\frac{\\partial F}{\\partial x}+\\frac{\\partial F}{\\partial y} \\frac{dy}{dx}+\\frac{\\partial F}{\\partial z}\\frac{dz}{dx}=0 \\]\n\\[ \\frac{\\partial G}{\\partial x}+\\frac{\\partial G}{\\partial y} \\frac{dy}{dx}+\\frac{\\partial G}{\\partial z}\\frac{dz}{dx}=0 \\]\n解出\\(\\bold{T}=(1,\\frac{dy}{dx},\\frac{dz}{dx})\\)，即\\(\\bold{T}=(1,\\varphi\u0026#39;(x_0),\\psi\u0026#39;(x_0))\\)，就是在此点的切向量，代入可知切线与法平面方程\n曲面的切平面与法线 若曲面由\\(F(x,y,z)=0\\)隐性给出，则在点\\(M(x_0,y_0,z_0)\\)切平面方程为\n\\[ F_x(x-x_0)+F_y(y-y_0)+F_z(z-z_0)=0 \\]\n其中各个偏导数都是在M点的偏导数，法线方程如下\n\\[ \\frac{x-x_0}{F_x}=\\frac{y-y_0}{F_y}=\\frac{z-z_0}{F_z} \\]\n考虑曲面方程为\\(z=f(x,y)\\)，则可令\\(F(x,y,z)=f(x,y)-z\\)\n显然有\n\\[ F_x(x,y,z)=f_x(x,y),F_y(x,y,z)=f_y(x,y),F_z(x,y,z)=-1 \\]\n切平面、法线方程类似于上。\n方向导数与梯度 方向导数：\n\\[ \\frac{\\partial f}{\\partial l}\\bigg|_{(x_0,y_0)}= \\lim _{t\\to 0^+}\\frac{f(x_0+tcos\\alpha,y_0+tcos\\beta)-f(x_0,y_0)}{t} \\]\n如果函数\\(f(x,y)\\)在点\\(P_0(x_0,y_0)\\)可微分，那么函数在该点沿任一方向\\(l\\)的方向导数存在，且有\n\\[ \\frac{\\partial f}{\\partial l}\\bigg|_{(x_0,y_0)}= f_x(x_0,y_0)cos\\alpha+f_y(x_0,y_0)cos\\beta \\]\n其中\\(cos\\alpha,cos\\beta\\)是方向\\(l\\)的方向余弦。\n梯度：\n\\[ \\bold{grad}f(x_0,y_0)=\\nabla f(x_0,y_0)=f_x(x_0,y_0)\\bold{i}+ f_y(x_0,y_0)\\bold{j} \\]\n如果方向导数存在，则\n\\[ \\frac{\\partial f}{\\partial l}\\bigg|_{(x_0,y_0)}= f_x(x_0,y_0)cos\\alpha+f_y(x_0,y_0)cos\\beta =\\nabla f(x_0,y_0)\\cdot \\bold{e}_l=|\\nabla f|cos\\theta \\]\n其中\n\\[ \\theta=\u0026lt;\\nabla f,\\bold{e}_l\u0026gt; \\]\n多元函数的极值及其求法 必要条件 设函数\\(z=f(x,y)\\)在点\\((x_0,y_0)\\)具有偏导数，且在点\\((x_0,y_0)\\)处有极值，则有\n\\[ f_x(x_0,y_0)=0,f_y(x_0,y_0)=0 \\]\n充分条件 设函数\\(z=f(x,y)\\)在点\\((x_0,y_0)\\)的某领域内连续且有一阶和二阶连续偏导数，又\\(f_x(x_0,y_0)=0,f_y(x_0,y_0)=0\\)，令\n\\[ f_{xx}(x_0,y_0)=A,f_{xy}(x_0,y_0)=B,f_{yy}(x_0,y_0)=C \\]\n若\n\\(AC-B^2\u0026gt;0\\)时具有极值，\\(A\u0026lt;0\\)时有极大值，\\(A\u0026gt;0\\)时有极小值；\n \\(AC-B^2\u0026lt;0\\)时没有极值\n \\(AC-B^2=0\\)时可能有也可能没有，需要另作讨论。\n  拉格朗日乘数法 要找函数\\(z=f(x,y)\\)在附加条件\\(\\varphi(x,y)=0\\)下的可能极值点，先设\n\\[ L(x,y)=f(x,y)+\\lambda\\varphi(x,y) \\]\n令\n\\[ \\left\\{\\begin{matrix} L_x=f_x+\\lambda\\varphi_x=0 \\\\ L_y=f_y+\\lambda\\varphi_y=0 \\\\ L_{\\lambda}=\\varphi=0 \\end{matrix}\\right. \\]\n解出\\(x,y,\\lambda\\)，代入函数\\(f\\)中求得可能的极值点。\n多个条件时，如多加一个\\(\\psi(x,y)=0\\)，则设方程\n\\[ L(x,y)=f(x,y)+\\lambda\\varphi(x,y)+\\mu\\psi(x,y) \\]\n分别求\\(L_x=0,L_y=0,L_\\lambda=0,L\\mu=0\\)，代入原函数中求可能的极值点。\n重积分 二重积分的概念与性质 性质：\n设\\(\\alpha,\\beta\\)为常数，则  \\[ \\iint\\limits_{D}[\\alpha f(x,y)+\\beta g(x,y)]d\\sigma= \\alpha\\iint\\limits_{D}f(x,y)d\\sigma+\\beta\\iint\\limits_{D}g(x,y)d\\sigma \\]\n如果闭区域\\(D\\)被有限条曲线分为有限个部分闭区域，那么在\\(D\\)上的二重积分等于在各部分闭区域上的二重积分的和  \\[ \\iint\\limits_{D}f(x,y)d\\sigma= \\iint\\limits_{D_1}f(x,y)d\\sigma+\\iint\\limits_{D_2}f(x,y)d\\sigma \\]\n如果在\\(D\\)上，\\(f(x,y)=1\\),\\(\\sigma\\)为\\(D\\)的面积，那么  \\[ \\sigma=\\iint\\limits_{D}1\\cdot d\\sigma=\\iint\\limits_{D}d\\sigma \\]\n如果在\\(D\\)上，\\(f(x,y)\\leq g(x,y)\\)，那么有  \\[ \\iint\\limits_{D}f(x,y)d\\sigma\\leq\\iint\\limits_{D}g(x,y)d\\sigma \\]\n特别的，有\n\\[ \\left|\\iint\\limits_{D}f(x,y)d\\sigma\\right|\\leq \\iint\\limits_{D}|f(x,y)|d\\sigma \\]\n设\\(M\\)和\\(N\\)分别是\\(f(x,y)\\)在闭区域\\(D\\)上的最大值和最小值，\\(\\sigma\\)是\\(D\\)的面积，则有  \\[ m\\sigma\\leq\\iint\\limits_{D}f(x,y)d\\sigma\\leq M\\sigma \\]\n设函数\\(f(x,y)\\)在闭区域D上连续，\\(\\sigma\\)是\\(D\\)的面积，则在\\(D\\)上至少存在一点\\((\\xi,\\eta)\\)，使得  \\[ \\iint\\limits_{D}f(x,y)d\\sigma=f(\\xi,\\eta)\\sigma \\]\n二重积分的计算法 利用直角坐标计算二重积分  10-4  在如图的区域中，积分上限为上方曲线，积分下限为下方曲线。\n\\[ \\iint\\limits_{D}f(x,y)d\\sigma=\\int_a^bdx\\int_{\\varphi_1(x)} ^{\\varphi_2(x)}f(x,y)dy \\]\n 10-6  如图则，积分上限为右侧曲线，下限为左侧曲线。\n\\[ \\iint\\limits_{D}f(x,y)d\\sigma=\\int_c^ddy\\int_{\\psi_1(y)} ^{\\psi_2(y)}f(x,y)dx \\]\n利用极坐标计算二重积分 有\n\\[ x=\\rho cos\\theta \\]\n\\[ y=\\rho sin\\theta \\]\n且有对于下图\n 10-18  \\[ \\iint\\limits_{D}f(x,y)d\\sigma=\\iint\\limits_{D}f(\\rho cos\\theta, \\rho sin\\theta)\\rho d\\rho d\\theta \\]\n\\[ =\\int_\\alpha^\\beta d\\theta\\int_{\\varphi_1(\\theta)} ^{\\varphi_2(\\theta)}f(\\rho cos\\theta, \\rho sin\\theta)\\rho d\\rho \\]\n三重积分的计算 利用直角坐标计算三重积分 “先1后2法”，即先以\\(z\\)为积分变量计算  \\[ \\iiint\\limits_\\Omega f(x,y,z)dv=\\int_a^bdx\\int_{y_1(x)}^{y_2(x)} dy\\int_{z_1(x,y)}^{z_2(x,y)}f(x,y,z)dz \\]\n“先2后1法”，即先以\\(xy\\)为积分变量计算  \\[ \\iiint\\limits_\\Omega f(x,y,z)dv=\\int_{c_1}^{c_2}dz\\iint\\limits_{D_z} f(x,y,z)dxdy \\]\n利用柱面坐标计算 有\n\\[ \\left\\{\\begin{matrix} x=\\rho cos\\theta \\\\ y=\\rho sin\\theta \\\\ z=z \\end{matrix}\\right. \\]\n有\n\\[ \\iiint\\limits_{\\Omega}f(x,y,z)dxdydz= \\iiint\\limits_{\\Omega}F(\\rho,\\theta,z)\\rho d\\rho d\\theta dz \\]\n利用球面坐标计算 有\n\\[ \\left\\{\\begin{matrix} x=rsin\\varphi cos\\theta \\\\ y=rsin\\varphi sin\\theta \\\\ z=rcos\\varphi \\end{matrix}\\right. \\]\n有\n\\[ \\iiint\\limits_{\\Omega}f(x,y,z)dxdydz= \\iiint\\limits_{\\Omega}F(r,\\varphi,\\theta)r^2sin\\varphi drd\\varphi d\\theta \\]\n拆分被积函数 详细的证明没有在书中和老师的教学中找到，互联网搜索也较难\n书上有许多例子，如当\n\\[ \\rho ^2\\leq z\\leq4,0\\leq\\rho\\leq2,0\\leq\\theta\\leq2\\pi \\]\n有\n\\[ \\iiint\\limits_{\\Omega}zdxdydz=\\iiint\\limits_{\\Omega}z\\rho d\\rho d\\theta dz=\\int_0^{2\\pi}d\\theta\\int_0^2\\rho d\\rho\\int_{\\rho^2}^4zdz \\]\n推断为，首先被积函数要是\\(f(z)g(\\rho)\\)等用乘法连接的，如\\(z\\rho\\)，而不能是加法如\\(z+\\rho\\)，才能拆分。另外跟积分上下限的关系不明。\n如果是加法，如\\(x+y+z\\)可以从轮换对称性考虑（如果有）\n重积分的应用 曲面面积 设曲面为\\(z=f(x,y)\\)，则\n\\[ A=\\iint\\limits_D\\sqrt{1+f_x^2(x,y)+f_y^2(x,y)}dxdy \\]\n质心 设有一平面薄片，占据\\(xOy\\)面上的闭区域\\(D\\)，在点\\((x,y)\\)处的面密度为\\(\\mu(x,y)\\)\n则有\n\\[ M_y=\\iint\\limits_Dx\\mu(x,y)d\\sigma, M_x=\\iint\\limits_Dy\\mu(x,y)d\\sigma \\]\n\\[ M=\\iint\\limits_D\\mu(x,y)d\\sigma \\]\n质心坐标为\n\\[ \\bar{x}=\\frac{M_y}{M}= \\frac{\\iint\\limits_Dx\\mu(x,y)d\\sigma}{\\iint\\limits_D\\mu(x,y)d\\sigma} \\]\n\\[ \\bar{y}=\\frac{M_x}{M}=\\frac{\\iint\\limits_Dy\\mu(x,y)d\\sigma}{\\iint\\limits_D\\mu(x,y)d\\sigma} \\]\n转动惯量 \\[ I_x=\\iint\\limits_Dy^2\\mu(x,y)d\\sigma,I_y=\\iint\\limits_Dx^2\\mu(x,y)d\\sigma \\]\n引力 空间一物体对物体外一点\\(P_0(x_0,y_0,z_0)\\)的单位质量的质点的引力\n物体密度\\(\\rho(x,y,z)\\)，\n\\[ \\bold{F}=(F_x,F_y,F_z) \\]\n\\[ =\\left ( \\iiint\\limits_\\Omega\\frac{G\\rho(x,y,z)(x-x_0)}{r^3}dv, \\iiint\\limits_\\Omega\\frac{G\\rho(x,y,z)(y-y_0)}{r^3}dv, \\iiint\\limits_\\Omega\\frac{G\\rho(x,y,z)(z-z_0)}{r^3}dv \\right ) \\]\n曲线积分与曲面积分 对弧长的曲线积分 性质 设\\(\\alpha,\\beta\\)为常数，则  \\[ \\int_L[\\alpha f(x,y)+\\beta g(x,y)]ds=\\alpha\\int_L f(x,y)ds+\\beta \\int_Lg(x,y)ds \\]\n若积分弧段\\(L\\)课分成两段光滑曲线弧\\(L_1\\)和\\(L_2\\)，则  \\[ \\int_Lf(x,y)ds=\\int_{L_1}f(x,y)ds+\\int_{L_2}f(x,y)ds \\]\n设在\\(L\\)上\\(f(x,y)\\leq g(x,y)\\), 则  \\[ \\int_L f(x,y)ds\\leq\\int_L g(x,y)ds \\]\n特别地，有\n\\[ \\left|\\int_L f(x,y)ds\\right|\\leq\\int_L|f(x,y)|ds \\]\n对弧长的曲线积分的计算法 设\\(f(x,y)\\)在曲线弧\\(L\\)上有定义且连续，\\(L\\)的参数方程为\n\\[ \\left\\{\\begin{matrix} x=\\varphi(t) \\\\ y=\\psi(t) \\end{matrix}\\right. (\\alpha\\leq t\\leq\\beta) \\]\n若\\(\\varphi(t)\\)、\\(\\psi(t)\\)在\\([\\alpha,\\beta]\\)上具有一阶连续导数，且\\(\\varphi\u0026#39;^2(t)+\\psi\u0026#39;^2(t)\\neq0\\)，则曲线积分\\(\\int_Lf(x,y)ds\\)存在，且\n\\[ \\int_Lf(x,y)ds=\\int_\\alpha^\\beta f[\\varphi(t),\\psi(t)] \\sqrt{\\varphi\u0026#39;^2(t)+\\psi\u0026#39;^2(t)}dt (a\u0026lt;\\beta) \\]\n注意\\(\\alpha\u0026lt;\\beta\\)是一定要有的。\n对坐标的曲线积分 \\[ \\int_LP(x,y)dx+Q(x,y)dy \\]\n也可以写作向量形式\n\\[ \\int_L\\bold{F(x,y)}\\cdot d\\bold{r} \\]\n其中\\(\\bold{F}=P\\bold{i}+Q\\bold{j}\\),\\(d\\bold{r}=dx\\bold{i}+dy\\bold{j}\\).\n性质 与上节相同\n 与上节相同\n 设\\(L\\)是有向光滑曲线弧，\\(L^-\\)是\\(L\\)的反向曲线弧，则\n  \\[ \\int_{L^-}\\bold F(x,y)d\\bold r = -\\int_L\\bold F(x,y)d\\bold r \\]\n对坐标的曲线积分的计算方法 条件相似，不再重复，查阅书籍\n\\[ \\left\\{\\begin{matrix} x=\\varphi(t) \\\\ y=\\psi(t) \\end{matrix}\\right. \\]\n\\(t\\)单调地由\\(\\alpha\\)变到\\(\\beta\\)\n\\[ \\int_LP(x,y)dx+Q(x,y)dy \\]\n\\[ =\\int_\\alpha^\\beta\\{P[\\varphi(t),\\psi(t)]\\varphi\u0026#39;(t)+ Q[\\varphi(t),\\psi(t)]\\psi\u0026#39;(t)\\}dt \\]\n不需要\\(\\alpha\u0026lt;\\beta\\)，有时有\\(x=x,y=y(x)\\)，类似的替换公式即可。\n两类曲线积分之间的联系 \\[ \\int_LPdx+Qdy=\\int_L(Pcos\\alpha+Qcos\\beta)ds \\]\n易推广至三维\n也可以写成向量形式\n\\[ \\int_L\\bold A\\cdot d\\bold r = \\int_L\\bold A\\cdot\\bm{\\tau}ds= \\int_LA_{\\tau}ds \\]\n格林公式 定理1，设闭区域\\(D\\)由分段光滑的曲线\\(L\\)围成，若函数\\(P(x,y)\\)及\\(Q(x,y)\\)在\\(D\\)上具有一阶连续偏导数，则有\n\\[ \\iint\\limits_D(\\frac{\\partial Q}{\\partial x}-\\frac{\\partial P}{\\partial y}) dxdy=\\oint_LPdx+Qdy \\]\n其中\\(L\\)是\\(D\\)的取正向的边界曲线。\n对平面区域\\(D\\)的边界曲线\\(L\\)，规定正向如下：当观察者沿着\\(L\\)的这个方向行走时，\\(D\\)总在他的左边。\n定理2，设区域\\(G\\)是一个单连通域（复连通不是充要条件），若函数\\(P(x,y),Q(x,y)\\)在\\(G\\)内具有一阶连续偏导数，则曲线积分\\(\\int_LPdx+Qdy\\)在\\(G\\)内与路径无关（或沿着\\(G\\)内任意闭曲线的曲线积分为0）的充分必要条件是\n\\[ \\frac{\\partial P}{\\partial y}=\\frac{\\partial Q}{\\partial x} \\]\n在\\(G\\)内恒成立。\n定理3，设区域\\(G\\)是一个单连通域（复连通不是充要条件，若函数\\(P(x,y),Q(x,y)\\)在\\(G\\)内具有一阶连续偏导数，则\\(P(x,y)dx+Q(x,y)dy\\)在\\(G\\)内为某一函数\\(u(x,y)\\)的全微分的充分必要条件是\n\\[ \\frac{\\partial P}{\\partial y}=\\frac{\\partial Q}{\\partial x} \\]\n在\\(G\\)内恒成立。\n对面积的曲面积分 \\[ \\iint\\limits_{\\Sigma}f(x,y,z)dS \\]\n\\[ =\\iint\\limits_{D_{xy}}f[x,y,z(x,y)]\\sqrt{1+z_x^2(x,y)+z_y^2(x,y)}dxdy \\]\n对坐标的曲面积分 关于方向 假设某块小曲面\\(\\Delta S\\)与\\(z\\)轴的夹角为\\(\\gamma\\)角，在\\(xOy\\)面上的投影是\\((\\Delta\\sigma)_{xy}\\)，则规定\\(\\Delta S\\)在\\(xOy\\)面上的投影\\((\\Delta S)_{xy}\\)为\n\\[ (\\Delta S)_{xy}=\\left\\{\\begin{matrix} (\\Delta\\sigma)_{xy}, cos\\gamma\u0026gt;0 \\\\ -(\\Delta\\sigma)_{xy}, cos\\gamma\u0026lt;0 \\\\ 0, cos\\gamma\\equiv 0 \\end{matrix}\\right. \\]\n投影到其他坐标面类似，总而言之向上、向右、向前是正向曲面。\n对坐标的曲面积分的计算法 如果曲面积分是在曲面\\(\\Sigma\\)上侧的，那么\n\\[ \\iint\\limits_\\Sigma R(x,y,z)dxdy=\\iint\\limits_{D_{xy}}R[x,y,z(x,y)]dxdy \\]\n若在下侧，则\n\\[ \\iint\\limits_\\Sigma R(x,y,z)dxdy=-\\iint\\limits_{D_{xy}}R[x,y,z(x,y)]dxdy \\]\n同理有\n\\[ \\iint\\limits_\\Sigma P(x,y,z)dydz=\\pm\\iint\\limits_{D_{yz}}P[x(y,z),y,z]dydz \\]\n\\[ \\iint\\limits_\\Sigma Q(x,y,z)dzdx=\\pm\\iint\\limits_{D_{zx}}Q[x,y(z,x),z]dzdx \\]\n两类曲面积分之间的联系 \\[ \\iint\\limits_\\Sigma Pdydz+Qdzdx+Rdxdy=\\iint\\limits_\\Sigma(Pcos\\alpha+Qcos\\beta+Rcos\\gamma)dS \\]\n写成向量形式\n\\[ \\iint\\limits_\\Sigma \\bold{A}\\cdot d\\bold{S}=\\iint\\limits_\\Sigma \\bold{A}\\cdot\\bold{n}dS \\]\n高斯公式 通量与散度 高斯公式 设空间闭区域\\(\\Omega\\)是由分片光滑的闭曲面\\(\\Sigma\\)所围成，若函数\\(P(x,y,z),Q(x,y,z),R(x,y,z)\\)在\\(\\Omega\\)上具有一阶连续偏导数，则有 \\[ \\iiint\\limits_\\Omega(\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z})dv=\\oiint\\limits_\\Sigma Pdydz+Qdzdx+Rdxdy \\]\n或\n\\[ \\iiint\\limits_\\Omega(\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z})dv=\\oiint\\limits_\\Sigma(Pcos\\alpha+Qcos\\beta+Rcos\\gamma)dS \\]\n这里\\(\\Sigma\\)是\\(\\Omega\\)的整个边界曲面的外侧，\\(cos\\alpha、cos\\beta、cos\\gamma\\)是\\(\\Sigma\\)在点\\((x,y,z)\\)处的法向量的方向余弦。\n沿任意闭曲面的曲面积分为零的条件 设\\(G\\)是空间二维单连通区域，若\\(P(x,y,z),Q(x,y,z),R(x,y,z)\\)在\\(G\\)内具有一阶连续偏导数，则曲面积分\n\\[ \\iint\\limits_\\Sigma Pdydz+Qdzdx+Rdxdy \\]\n在\\(G\\)内所取曲面\\(\\Sigma\\)无关而只取决于\\(\\Sigma\\)的边界曲线(或沿\\(G\\)内任一闭曲面的曲面积分为零)的充分必要条件是\n\\[ \\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z}=0 \\]\n在\\(G\\)内恒成立。\n通量与散度 设有向量场\n\\[ \\bold{A}(x,y,z) = P(x,y,z)\\bold i+Q(x,y,z)\\bold j+R(x,y,z)\\bold k \\]\n其中函数\\(P,Q,R\\)均有一阶连续偏导数，\\(\\Sigma\\)是场内的一片有向曲面，\\(\\bold n\\)是\\(\\Sigma\\)在点\\((x,y,z)\\)处的单位法向量，则积分\n\\[ \\iint\\limits_\\Sigma \\bold A\\cdot \\bold ndS \\]\n称为向量场\\(\\bold A\\)通过曲面\\(\\Sigma\\)向着指定侧的通量（或流量）。 又可表达为\n\\[ \\iint\\limits_\\Sigma \\bold A\\cdot \\bold ndS=\\iint\\limits_\\Sigma \\bold Ad\\bold S=\\iint\\limits_\\Sigma Pdydz+Qdzdx+Rdxdy \\]\n对于这个向量场，其散度记作\\(div\\bold A\\)，即\n\\[ div\\bold A=\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z} \\]\n利用向量微分算子\\(\\nabla\\)，也可以表示为\n\\[ div\\bold A = \\nabla\\cdot\\bold A \\]\n利用向量场的通量和散度，高斯公式可以写成\n\\[ \\iiint\\limits_{\\Omega}div\\bold Adv=\\iint\\limits_\\Sigma A_ndS \\]\n斯托克斯公式 环流量与旋度 斯托克斯公式 设\\(\\Gamma\\)为分段光滑的空间有向闭曲线，\\(\\Sigma\\)是以\\(\\Gamma\\)为边界的分片光滑的有向曲面，\\(\\Gamma\\)的正向与\\(\\Sigma\\)的侧符合右手规则，若函数\\(P(x,y,z),Q(x,y,z),R(x,y,z)\\)在曲面\\(\\Sigma\\)(连同边界\\(\\Gamma\\))上具有一阶连续偏导数，则有\n\\[ \\iint\\limits_\\Sigma\\left(\\frac{\\partial R}{\\partial y}-\\frac{\\partial Q}{\\partial z}\\right)dydz+\\left(\\frac{\\partial P}{\\partial z}-\\frac{\\partial R}{\\partial x}\\right)dzdx+\\left(\\frac{\\partial Q}{\\partial x}-\\frac{\\partial P}{\\partial y}\\right)dxdy \\]\n\\[ =\\oint_\\Gamma Pdx+Qdy+Rdz \\]\n空间曲线积分与路径无关的条件 设空间区域\\(G\\)是一维单连通域，若函数\\(P(x,y,z),Q(x,y,z),R(x,y,z)\\)在\\(G\\)内具有一阶连续偏导数，则空间曲线积分\\(\\int_\\Gamma Pdx+Qdy+Rdz\\)在\\(G\\)内与路径无关（或沿\\(G\\)内任意闭合曲线的曲线积分为零）的充分必要条件是\n\\[ \\frac{\\partial P}{\\partial y}=\\frac{\\partial Q}{\\partial x},\\frac{\\partial Q}{\\partial z}=\\frac{\\partial R}{\\partial y},\\frac{\\partial R}{\\partial x}=\\frac{\\partial P}{\\partial z} \\]\n在\\(G\\)内恒成立\n环流量与旋度 设有向量场\n\\[ \\bold{A}(x,y,z) = P(x,y,z)\\bold i+Q(x,y,z)\\bold j+R(x,y,z)\\bold k \\]\n其中函数\\(P,Q,R\\)均连续，\\(\\Gamma\\)是\\(\\bold A\\)的定义域内的一条分段光滑的有向闭曲线，\\(\\bm\\tau\\)是\\(\\Gamma\\)在点\\((x,y,z)\\)处的单位切向量，则积分\n\\[ \\oint_L\\bold A\\cdot\\bm {\\tau}ds \\]\n称为向量场\\(\\bold A\\)沿有向闭曲线\\(\\Gamma\\)的环流量。\n又可表述为\n\\[ \\oint_L\\bold A\\cdot\\bm {\\tau}ds=\\oint_L\\bold Ad\\bold r = \\oint_\\Gamma Pdx+Qdy+Rdz \\]\n向量场\\(\\bold A\\)的旋度，记作\\(\\bold{rotA}\\)，即\n\\[ \\bold{rotA} = \\left(\\frac{\\partial R}{\\partial y}-\\frac{\\partial Q}{\\partial z}\\right)\\bold i+\\left(\\frac{\\partial P}{\\partial z}-\\frac{\\partial R}{\\partial x}\\right)\\bold j+\\left(\\frac{\\partial Q}{\\partial x}-\\frac{\\partial P}{\\partial y}\\right)\\bold k \\]\n\\[ \\bold{rotA}=\\nabla\\times\\bold A \\]\n同样的，斯托克斯公式可以写成\n\\[ \\iint\\limits_\\Sigma\\bold{rotA}\\cdot\\bold{n}dS=\\oint_\\Gamma\\bold{A}\\cdot\\bm{\\tau}ds \\]\n\\[ \\iint\\limits_\\Sigma(\\bold{rotA})_ndS=\\oint_{\\Gamma}\\bold{A}_{\\tau} ds \\]\n无穷级数 常数项级数的概念和性质 常数项级数的概念 如果级数\\(\\sum^{\\infty}_{i=1}u_i\\)的部分和数列\\(\\{s_n\\}\\)有极限s，即\n\\[ \\lim\\limits_{n\\to\\infty}s_n=s \\]\n那么称无穷级数\\(\\sum^{\\infty}_{i=1}u_i\\)收敛，这时极限\\(s\\)叫做这级数的和，并写成\n\\[ s=u_1+u_2+\\dots+u_n+\\cdots \\]\n如果\\(\\{s_n\\}\\)没有极限，那么称无穷级数\\(\\sum^{\\infty}_{i=1}u_i\\)发散\n收敛级数的基本性质 性质1 如果级数\\(\\sum^{\\infty}_{n=1}u_n\\)收敛于和\\(s\\)，那么级数\\(\\sum^{\\infty}_{i=1}ku_i\\)也收敛，且其和为\\(ks\\).\n性质2 如果级数\\(\\sum^{\\infty}_{n=1}u_n\\)与\\(\\sum^{\\infty}_{n=1}v_n\\)分别收敛于\\(s,\\sigma\\)，那么级数\\(\\sum^{\\infty}_{n=1}(u_n\\pm v_n)\\)也收敛，且其和为\\(s\\pm\\sigma\\)\n性质3 在级数中去掉、加上或改变有限项，不会改变级数的收敛性\n性质4 如果级数\\(\\sum^{\\infty}_{n=1}u_n\\)收敛，那么对于这级数的项任意加括号后所成的级数仍收敛，且其和不变\n性质5（级数收敛的必要条件） 如果级数\\(\\sum^{\\infty}_{n=1}u_n\\)收敛，那么它的一般项\\(u_n\\)趋于0，即\n\\[ \\lim\\limits_{n\\to\\infty}u_n=0 \\]\n常数项级数的审敛法 正项级数及其审敛法 定理1 正项级数\\(\\sum^{\\infty}_{n=1}u_n\\)收敛的充分必要条件是：它的部分和数列\\(\\{s_n\\}\\)有界\n定理2（比较审敛法） 设\\(\\sum^{\\infty}_{n=1}u_n\\)和\\(\\sum^{\\infty}_{n=1}v_n\\)都是正项级数，且\\(u_n\\leq v_n\\).若级数\\(\\sum^{\\infty}_{n=1}v_n\\)收敛，则级数\\(\\sum^{\\infty}_{n=1}u_n\\)收敛，若级数\\(\\sum^{\\infty}_{n=1}u_n\\)发散，则级数\\(\\sum^{\\infty}_{n=1}v_n\\)发散.\n推论 设\\(\\sum^{\\infty}_{n=1}u_n\\)和\\(\\sum^{\\infty}_{n=1}v_n\\)都是正项级数，如果级数\\(\\sum^{\\infty}_{n=1}v_n\\)收敛，且存在正整数\\(N\\)使当\\(n\\ge N\\)时有\\(u_n\\leq kv_n(k\u0026gt;0)\\)成立，那么级数\\(\\sum^{\\infty}_{n=1}u_n\\)收敛；如果级数\\(\\sum^{\\infty}_{n=1}v_n\\)发散，且存在正整数\\(N\\)使当\\(n\\ge N\\)时有\\(u_n\\ge kv_n(k\u0026gt;0)\\)成立，那么级数\\(\\sum^{\\infty}_{n=1}u_n\\)发散.\n定理3（比较审敛法的极限形式） 设\\(\\sum^{\\infty}_{n=1}u_n\\)和\\(\\sum^{\\infty}_{n=1}v_n\\)都是正项级数，\n如果\\(\\lim\\limits_{n\\to\\infty}\\frac{u_n}{v_n}=l(0\\leq l\u0026lt;+\\infty)\\)，且级数\\(\\sum^{\\infty}_{n=1}v_n\\)收敛，那么级数\\(\\sum^{\\infty}_{n=1}u_n\\)收敛； 如果\\(\\lim\\limits_{n\\to\\infty}\\frac{u_n}{v_n}=l\u0026gt;0\\)或\\(\\lim\\limits_{n\\to\\infty}\\frac{u_n}{v_n}=+\\infty\\)，且级数\\(\\sum^{\\infty}_{n=1}v_n\\)发散，那么级数\\(\\sum^{\\infty}_{n=1}u_n\\)发散；  定理4（比值审敛法，达朗贝尔判别法） 设\\(\\sum^{\\infty}_{n=1}u_n\\)是正项级数，如果\n\\[ \\lim\\limits_{n\\to\\infty}\\frac{u_{n+1}}{u_n}=\\rho \\]\n那么当\\(\\rho\u0026lt;1\\)时级数收敛，\\(\\rho\u0026gt;1\\)(或\\(\\lim\\limits_{n\\to\\infty}\\frac{u_{n+1}}{u_n}=\\infty\\))时级数发散，\\(\\rho=1\\)时级数可能收敛也可能发散。\n定理5（根值审敛法，柯西判别法） 设\\(\\sum^{\\infty}_{n=1}u_n\\)是正项级数，如果\n\\[ \\lim\\limits_{n\\to\\infty}\\sqrt[n]{u_n}=\\rho \\]\n那么当\\(\\rho\u0026lt;1\\)时级数收敛，\\(\\rho\u0026gt;1\\)(或\\(\\lim\\limits_{n\\to\\infty}\\sqrt[n]{u_n}=+\\infty\\))时级数发散，\\(\\rho=1\\)时级数可能收敛也可能发散。\n定理6（极限审敛法） \\(\\sum^{\\infty}_{n=1}u_n\\)是正项级数，\n如果\\(\\lim\\limits_{n\\to\\infty}nu_n=l\u0026gt;0\\)(或\\(\\lim\\limits_{n\\to\\infty}nu_n=+\\infty\\))，那么该级数发散； 如果\\(p\u0026gt;1\\)，而\\(\\lim\\limits_{n\\to\\infty}n^pu_n=l\u0026gt;0(0\\leq l\u0026lt;+\\infty)\\)，那么该级数收敛.  交错级数及其审敛法 定理7（莱布尼茨定理） 如果交错级数\\(\\sum^{\\infty}_{n=1}(-1)^{n-1}u_n\\)满足条件： 1. \\(u_n\\ge u_{n+1}\\) 2. \\(\\lim\\limits_{n\\to\\infty}u_n=0\\)\n那么级数收敛，且其和\\(s\\leq u_1\\)，其余项\\(r_n\\)的绝对值小于等于\\(u_{n+1}\\)\n绝对收敛与条件收敛 对于级数\\(\\sum^{\\infty}_{n=1}u_n\\)，若\\(\\sum^{\\infty}_{n=1}|u_n|\\)收敛，那么称\\(\\sum^{\\infty}_{n=1}u_n\\)绝对收敛；如果\\(\\sum^{\\infty}_{n=1}u_n\\)收敛，而\\(\\sum^{\\infty}_{n=1}|u_n|\\)发散，则成\\(\\sum^{\\infty}_{n=1}u_n\\)条件收敛。\n定理8 如果级数\\(\\sum^{\\infty}_{n=1}u_n\\)绝对收敛，那么\\(\\sum^{\\infty}_{n=1}u_n\\)必定收敛。\n绝对收敛级数的性质 定理9 绝对收敛级数经改变项的位置后构成的级数也收敛，且与原级数有相同的和.\n定理10 （绝对收敛级数的乘法） 设\\(\\sum^{\\infty}_{n=1}u_n\\)和\\(\\sum^{\\infty}_{n=1}v_n\\)都是绝对收敛，其和分别为\\(s,\\sigma\\)，则它们的柯西乘积\n\\[ u_1v_1+(u_1v_2+u_2v_1)+\\dots+(u_1v_n+u_2v_{n-1}+\\dots+u_nv_1)+\\cdots \\]\n也是绝对收敛的，且其和为\\(s\\sigma\\)\n幂级数 收敛域：开区间；收敛区间：要判断边界点\n定理1（阿贝尔定理) 如果级数\\(\\sum^{\\infty}_{n=0}a_nx^n\\)当\\(x=x_0\\neq0\\)时收敛，那么适合不等式\\(|x|\u0026lt;|x_0|\\)的一切\\(x\\)使这幂级数绝对收敛，反之，如果级数\\(\\sum^{\\infty}_{n=0}a_nx^n\\)当\\(x=x_0\\neq0\\)当\\(x=x_0\\)时发散，那么适合不等式\\(|x|\u0026gt;|x_0|\\)的一切\\(x\\)使这幂级数发散.\n推论 如果幂级数\\(\\sum^{\\infty}_{n=0}a_nx^n\\)不仅在\\(x=0\\)一点收敛，也不是在整个数轴上都收敛，那么必有一个确定的正数\\(R\\)存在，使得\n当\\(|x|\u0026lt;R\\)时，幂级数绝对收敛\n当\\(|x|\u0026gt;R\\)时，幂级数发散\n当\\(|x|=R\\)时，幂级数可能收敛也可能发散，如果收敛可能是绝对或条件收敛。\n正数\\(R\\)通常叫做收敛半径。\n定理2 如果 \\[ \\lim\\limits_{n\\to\\infty}\\left|\\frac{a_{n+1}}{a_n}\\right|=\\rho \\]\n其中\\(a_n,a_{n+1}\\)是幂级数\\(\\sum^{\\infty}_{n=0}a_nx^n\\)的相邻两项的系数，那么这幂级数的收敛半径\n\\[ R=\\left\\{\\begin{matrix} \\frac{1}{\\rho}, \\rho\\ne0\\\\ +\\infty, \\rho=0 \\\\ 0, \\rho=+\\infty \\end{matrix}\\right. \\]\n注意如果级数的项中为\\(x^{2n}\\)等不能化为\\(x^n\\)的，不能用这个定理，只能用比值审敛法等通用手段。\n幂级数的运算 设\\(\\sum^{\\infty}_{n=0}a_nx^n\\)和\\(\\sum^{\\infty}_{n=0}b_nx^n\\)分别在区间\\((-R,R),(-R\u0026#39;,R\u0026#39;)\\)内收敛，则对于这两个幂级数，\n\\(\\sum^{\\infty}_{n=0}a_nx^n\\pm\\sum^{\\infty}_{n=0}b_nx^n=\\sum^{\\infty}_{n=0}(a_n\\pm b_n)x^n\\)在\\((-R,R),(-R\u0026#39;,R\u0026#39;)\\)中较小的区间内成立. \\(\\sum^{\\infty}_{n=0}a_nx^n\\sum^{\\infty}_{n=0}b_nx^n=a_0b_0+(a_0b_1+a_1b_0)x+\\dots+(a_0b_n+a_1b_{n-1}+\\dots+a_nb_0)x^n+\\cdots\\)\\((-R,R),(-R\u0026#39;,R\u0026#39;)\\)中较小的区间内成立. \\(\\frac{\\sum^{\\infty}_{n=0}a_nx^n}{\\sum^{\\infty}_{n=0}b_nx^n}=\\sum^{\\infty}_{n=0}c_nx^n\\)，假设\\(b_0\\ne0\\)，\\(c\\)可以由下式求出 \\[ a_0=b_0c_0\\\\ a_1=b_1c_0+b_0c_1\\\\ a_2=b_2c_0+b_1c_1+b_0c_2\\\\ \\cdots \\] 幂级数\\(\\sum^{\\infty}_{n=0}c_nx^n\\)的收敛区间可能比原来两级数的收敛区间小得多。  幂级数的和函数的性质\n性质1 幂级数\\(\\sum^{\\infty}_{n=0}a_nx^n\\)的和函数\\(s(x)\\)在其收敛域\\(I\\)上连续\n性质2 幂级数\\(\\sum^{\\infty}_{n=0}a_nx^n\\)的和函数\\(s(x)\\)在其收敛域\\(I\\)上可积，并有逐项积分公式\n\\[ \\int_0^xs(x)dt=\\int_0^x[\\sum^{\\infty}_{n=0}a_nt^n]dt=\\sum^{\\infty}_{n=0}\\int_0^xa_nt^ndt=\\sum^{\\infty}_{n=0}\\frac{a_n}{n+1}x^{n+1}(x\\in I), \\]\n逐项积分后所得到的幂级数和原级数有相同的收敛半径。\n性质3 幂级数\\(\\sum^{\\infty}_{n=0}a_nx^n\\)的和函数\\(s(x)\\)在其收敛域\\(I\\)上可导，且有逐项求导公式\n\\[ s\u0026#39;(x)=(\\sum^{\\infty}_{n=0}a_nx^n)\u0026#39;=\\sum^{\\infty}_{n=0}(a_nx^n)\u0026#39;=\\sum^{\\infty}_{n=1}na_nx^{n-1} \\]\n逐项求导后所得到的幂级数和原级数有相同的收敛半径.\n反复应用上述结论可得：\\(s(x)\\)在其收敛区间\\((-R,R)\\)内具有任意阶导数。\n函数展开成幂级数 泰勒级数和麦克劳林级数不再重复，见上册整理。\n\\(f(x)\\)能在某个邻域展开成泰勒级数的充要条件是\n\\[ \\lim\\limits_{n\\to\\infty}R_n(x)=0, x\\in U(x_0) \\]\n除了直接展开外，通常也会有间接展开的办法。即通过四则运算、求导、积分、变量替换等等运算转化为一些常见的函数，再代入这些常见函数的展开式。\n下面给出一些常见函数的展开式\n\\[ \\frac{1}{1-x}=\\sum_{n=0}^{\\infty}x^n,x\\in(-1,1) \\]\n\\[ \\frac{1}{1+x}=\\sum_{n=0}^{\\infty}(-1)^nx^n,x\\in(-1,1) \\]\n\\[ e^x=\\sum_{n=0}^{\\infty}\\frac{x^n}{n!},x\\in(-\\infty,\\infty) \\]\n\\[ sinx=\\sum_{n=0}^{\\infty}\\frac{(-1)^n}{(2n+1)!}x^{2n+1},x\\in(-\\infty,\\infty) \\]\n\\[ cosx=\\sum_{n=0}^{\\infty}\\frac{(-1)^n}{(2n)!}x^{2n},x\\in(-\\infty,\\infty) \\]\n\\[ ln(1+x)=\\sum_{n=0}^{\\infty}\\frac{(-1)^n}{n+1}x^{n+1}= \\sum_{n=1}^{\\infty}\\frac{(-1)^{n-1}}{n}x^{n},x\\in(-1,1] \\]\n\\[ (1+x)^m=1+mx+\\frac{m(m-1)}{2!}x^2+\\cdots+\\frac{m(m-1)\\cdots(m-n+1)}{n!}x^n+\\cdots \\]\n傅里叶级数 一个定义在\\((-\\infty,\\infty)\\)上周期为\\(2\\pi\\)的函数\\(f(x)\\)，如果它在一个周期上可积，那么一定可以做出\\(f(x)\\)的傅里叶级数\n\\[ f(x) = \\frac{a_0}{2}+\\sum_{n=1}^{\\infty}(a_ncosnx+b_nsinnx) \\]\n其中\n\\[ a_n=\\frac{1}{\\pi}\\int^\\pi_{-\\pi}f(x)\\cos nxdx,(n=0,1,2,3,\\cdots) \\]\n\\[ b_n=\\frac{1}{\\pi}\\int^\\pi_{-\\pi}f(x)\\sin nxdx,(n=1,2,3,\\cdots) \\]\n定理 设\\(f(x)\\)是周期为\\(2\\pi\\)的周期函数，如果它满足：\n在一个周期内连续或只有有限个第一类间断点 在一个周期内至多只有有限个极值点  那么\\(f(x)\\)的傅立叶级数收敛，并且\n当\\(x\\)是\\(f(x)\\)的连续点时，级数收敛于\\(f(x)\\);\n当\\(x\\)是\\(f(x)\\)的间断点时，级数收敛于\\(\\frac{1}{2}[f(x^-)+f(x^+)]\\)\n如果函数只在\\([-\\pi,\\pi]\\)上有定义，可以使用周期延拓来展开成傅里叶级数。\n正弦级数和余弦级数 当\\(f(x)\\)为奇函数时，可以展开为正弦级数 \\[ \\sum_{n=1}^\\infty b_n\\sin nx \\]\n当\\(f(x)\\)为偶函数时，可以展开为余弦函数 \\[ \\frac{a_0}{2}+\\sum_{n=1}^\\infty a_n\\cos nx \\]\n一般周期的傅里叶级数 周期为\\(2l\\)\n\\[ f(x)=\\frac{a_0}{2}+\\sum^\\infty_{n=1}\\left(a_ncos\\frac{n\\pi x}{l}+b_nsin\\frac{n\\pi x}{l}\\right)(x\\in C) \\]\n其中\n\\[ a_n=\\frac{1}{l}\\int_{-l}^lf(x)cos\\frac{n\\pi x}{l}dx\\quad (n=0,1,2,\\cdots) \\]\n\\[ b_n=\\frac{1}{l}\\int_{-l}^lf(x)sin\\frac{n\\pi x}{l}dx\\quad (n=1,2,3,\\cdots) \\]\n\\[ C=\\left\\{x\\left|f(x)=\\frac{1}{2}[f(x^-) +f(x^+)]\\right. \\right\\} \\]\n","date":"2022-05-25T21:43:40+08:00","image":"https://kegalas.top/p/%E6%88%91%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E5%86%8C%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8-51_hu1c49316b400cd781c785bbdbc8d18c16_11689_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E6%88%91%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E5%86%8C%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/","title":"我的高等数学下册资料整理"},{"content":"第一部分 第一篇 协和和弦——三和弦 第一章 大调式三和弦 自然大调的七个三和弦中，I、IV、V是大三和弦，II、III、VI是小三和弦，VII是减三和弦。\nI级上的三和弦称之为主和弦，IV上的为下属和弦，V上的称为属和弦。\n按功能分，主和弦组：I、VI；属和弦组：V、III；下属和弦组：IV、II；\n第二章 大调式三和弦的连接 对于初学者来说，根据低音写出另外三个声部的音，应当重复根音。\n除相邻的音级上建立的三和弦，任意两个三和弦至少有一个共同音。\n对于初学者，链接两个三和弦应当将共同音保持，不是共同音的音按照最近的方式排列；\n显然旋律音的位置受到共同音的影响，但是根音可以较为自由的上行或下行，如果一定要在六度跳进或是三度进行中做出选择，那后者应该更好。\n第三章 无共同音的三和弦连接 不允许有两个声部间出现平行五度和平行八度。按照之前的共同音保持法链接，显然不会出现平行五八。但如果两个和弦间没有共同音，则上方声部的音应当和根音做反向进行。并且上方声部的两个和弦之间，音的排列顺序不能相同。\n第四章 打破三和弦连接规则 打破规则的原因：如果坚持规则可能会导致某一声部的音太高。\n要注意的有：\n  两个三和弦，上方声部连接时不能保持同样的音的排列顺序，否则必然出现平行五八。\n  最上方声部不能跳进超过四度。\n  低声部和高声部要反向进行，防止出现隐伏五八度。当两个声部通向进行到五度或八度，则会构成隐伏五八度。（注意高声部内部也不要出现隐伏五度）。\n  不允许违背规则的情况：\n  属和弦进行到主和弦时，如果属和弦的三音即导音位于最高声部，必须上行到主音。如果导音在内声部，可以下行三度进行。\n  主和弦到下属和弦时，主和弦的三音类似导音，处理方式同上。\n  第五章 和声模进 模进动机保持相同的声部排列位置。\nVII是减三和弦，使用的时候要特别谨慎，但在和弦模进中，它是允许的，因为可以作为动机重复和模进进行。\n当然减三和弦还可以作为两个和弦的经过和弦。这种连接必须同一声部保留共同音。\n第六章 小调式和声 小调式和声建立在和声小调之上。除七音升高半音外，其他与平行大调音阶上的音相同。\n和声小调上的三和弦：小三和弦：I、IV；大三和弦V、VI；减三和弦：II、VII；增三和弦：III。\n和声小调的和弦连接也应当遵从前面的规则。\n不协和和弦（除小三和大三）要有预备，可以与两个相邻的三和弦作正确连接，或是作为一个动机内的和弦。\n不协和和弦连接具体如下：\n  VII级通常连到V级，而不连到II和IV级，因为此时会出现增二度进行，及其不悦耳。\n  II级可以与IV、V、VI连接，但要避免隐伏五八、增二度进行；减三和弦与属三和弦连接时，上方三声部与低声部作反向进行就不会出现增二度。\n  III级与I、V、VI连接不会有问题。\n  任何时候都要避免使用增二度。因此，导音（属和弦三音）要上行解决到VI级三和弦时，VI级三和弦应当重复三音。当VI进行到V时（比较少见），也应当重复VI的三音。\n第七章 密集排列与开放排列 声部之间的音排列比较密集，成为密集排列。否则称为开放排列。\n将密集排列改写为开放排列时，注意要一个声部整体移动八度，不能出现声部更换，也不能出现声部超越。\n第八章 三和弦的转位 将根音转移到上方其他声部，低声部不是根音的三和弦，被称为和弦的转位。\n第一转位，即最低声部为三音，被称为三六和弦，简称六和弦。\n第二转位，即最低声部为五音，被称为四六和弦。\n原位和弦因为具有纯五度，音响协和程度要高于两个转位和弦。\n和弦通常重复根音或者五音，重复三音不够自然，仅用在一些特殊位置（如可以获得更好的声部进行）。\n我们常常会碰到连续的六和弦级进进行。这种情况最好让两个声部与低音作同向进行，另一声部作反向进行。如果低音上行，首先重复五音；如果低音下行，首先重复根音。\n如果是属六和弦进行到主和弦，那么属六和弦的三音不能重复，因为其是导音。\n第九章 减三和弦与增三和弦的转位 减三和弦的第一转为接近协和和弦，所以用的比原位多。\n减六和弦与其他和弦的连接分为两种情况\n  在主和弦之前。减三和弦的根音，即导音，必须上行解决，因为它不能重复。最好重复五音，偶尔可以重复三音。由于导音在任何时候都必须解决到主音，因此减三和弦中的五音位于根音上方时，不能上行，否则必定会出现禁止进行（平行五度）(所以必须让在根音上方的五音下行)。因此，我们必须避免减六和弦中的两个五音都位于根音上方(这样会导致两个五音之后一个上行一个下行)。\n  除主和弦外的其他和弦之前。大多数重复根音（就像其他六和弦一样），因为这里根音不作为导音。\n  小调中II级上的减六和弦也遵从这些规则。\n第二篇 不协和和弦——七和弦和九和弦 七和弦和九和弦都不是独立的和弦，都需要有准备，并要合理地进行到后面的和弦。不协和和弦进行到协和和弦，被称为“解决”。每一个七和弦都必须要解决到三和弦上。\n第十章 属七和弦 所有七和弦中，最重要，最常用的是V级上的七和弦，即属七和弦。属七和弦解决到主和弦。\n属七和弦的解决方式：七音级进下行解决到主和弦的三音。五音级进上行或下行解决到主和弦的三音或根音，更多解决到根音。三音（即导音）级进上行到主音，根音四度上行或五度下行到主和弦的根音。\n属七和弦的解决会产生缺五音的不完全主和弦。\n停更 ","date":"2021-12-31T22:44:43+08:00","permalink":"https://kegalas.top/p/%E5%AE%9E%E7%94%A8%E5%92%8C%E5%A3%B0%E5%AD%A6%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"《实用和声学指南》读书笔记"},{"content":"函数与极限 等价无穷小 当$x\\to 0$时，有\n$$ sinx\\sim x\\qquad tanx\\sim x\\qquad ln(1+x)\\sim x\\qquad e^x-1\\sim x $$\n$$ arcsinx\\sim x\\qquad arctanx\\sim x\\qquad log_a(1+x)\\sim \\frac{x}{lna} $$\n$$ x-ln(1+x)\\sim \\frac{1}{2}x^2\\qquad 1-cosx\\sim\\frac{1}{2}x^2\\qquad ln(x+\\sqrt{1+x^2})\\sim x $$\n$$ x-sinx\\sim \\frac{1}{6}x^3\\qquad tanx-x\\sim \\frac{1}{3}x^3\\qquad (1+x)^a-1\\sim ax $$\n$$ arcsinx-x\\sim \\frac{1}{6}x^3\\qquad x-arctanx\\sim\\frac{1}{3}x^3\\qquad tanx-sinx\\sim\\frac{1}{2}x^3 $$\n两个重要极限 $$ \\lim_{x\\to 0}\\frac{sinx}{x}=1 $$\n$$ \\lim_{x\\to \\infty}(1+\\frac1x)^x=e $$\n间断点的分类 第一类间断点 如果$x_0$是函数的间断点，且左极限$f(x_0^-)$及右极限$f(x_0^+)$都存在。\n  若左极限和右极限相等，但不等于该点函数值或函数在该点无定义，则称为可去间断点。\n  若左极限右极限不相等，则称为跳跃间断点。\n  第二类间断点 不是第一类间断点的任何间断点称之为第二类间断点，包含震荡间断点，无穷间断点等。\n部分函数及其图像 双曲函数 $$ sh\\ x=\\frac{e^x-e^{-x}}{2}\\qquad ch\\ x=\\frac{e^x+e^{-x}}{2}\\qquad th\\ x=\\frac{sh\\ x}{ch\\ x}=\\frac{e^x-e^{-x}}{e^x+e^{-x}} $$\n函数图像如下\n\r\n其常用公式如下：\n$$ sh(x+y)=sh\\ xch\\ x+ch\\ xsh\\ y $$\n$$ sh(x-y)=sh\\ xch\\ x-ch\\ xsh\\ y $$\n$$ ch(x+y)=ch\\ xch\\ x+sh\\ xsh\\ y $$\n$$ ch(x-y)=ch\\ xch\\ x-sh\\ xsh\\ y $$\n$$ ch^2x-sh^2x=1\\qquad sh\\ 2x=2sh\\ xch\\ x\\qquad ch\\ 2x=ch^2x+sh^2x $$\n反双曲函数如下\n$$ arsh\\ x=ln(x+\\sqrt{x^2+1}) $$\n$$ arch\\ x=ln(x+\\sqrt{x^2-1}) $$\n$$ arth\\ x=\\frac{1}{2}ln\\frac{1+x}{1-x} $$\n部分三角函数和反三角函数 $cot\\ x,sec\\ x,csc\\ x$的函数图像如下\n\r\n\r\n\r\n反三角函数图像如下\n\r\n三角函数公式 和差化积 ​ $$sin\\alpha+sin\\beta=2sin\\frac{\\alpha+\\beta}{2}\\cdot cos\\frac{\\alpha-\\beta}{2}$$ ​ $$sin\\alpha-sin\\beta=2cos\\frac{\\alpha+\\beta}{2}\\cdot sin\\frac{\\alpha-\\beta}{2}$$ ​ $$cos\\alpha+cos\\beta=2cos\\frac{\\alpha+\\beta}{2}\\cdot cos\\frac{\\alpha-\\beta}{2}$$ ​ $$cos\\alpha-cos\\beta=-2sin\\frac{\\alpha+\\beta}{2}\\cdot sin\\frac{\\alpha-\\beta}{2}$$\n积化和差 ​ $$sin\\alpha cos\\beta=\\frac{1}{2}\\left[sin(\\alpha+\\beta)+sin(\\alpha-\\beta)\\right]$$ ​ $$cos\\alpha sin\\beta=\\frac{1}{2}\\left[sin(\\alpha+\\beta)-sin(\\alpha-\\beta)\\right]$$ ​ $$cos\\alpha cos\\beta=\\frac{1}{2}\\left[cos(\\alpha+\\beta)+cos(\\alpha-\\beta)\\right]$$ ​ $$sin\\alpha sin\\beta=-\\frac{1}{2}\\left[cos(\\alpha+\\beta)-cos(\\alpha-\\beta)\\right]$$\n半角公式 ​ $$sin\\frac{\\theta}{2}=\\pm \\sqrt{\\frac{1-cos\\alpha}{2}}$$ ​ $$sin\\frac{\\theta}{2}=\\pm \\sqrt{\\frac{1+cos\\alpha}{2}}$$ ​ $$tan\\frac{\\theta}{2}=\\pm \\sqrt{\\frac{1-cos\\alpha}{1+cos\\alpha}}=\\frac{sin\\alpha}{1+cos\\alpha}=\\frac{1-cos\\alpha}{sin\\alpha}$$\n辅助角公式 ​ $$asin\\theta\\pm bcos\\theta=\\sqrt{a^2+b^2}sin(\\theta\\pm\\varphi),\\quad tan\\varphi=\\frac{b}{a}$$\n$sin\\ x$和$cos\\ x$的$tan\\ \\frac x2$有理式表示 $$ sin\\ x=\\frac{2tan\\frac x2}{1+tan^2\\frac x2} $$\n$$ cos\\ x=\\frac{1-tan^2\\frac x2}{1+tan^2\\frac x2} $$\n导数与微分 反函数求导 如果函数$x=f(y)$在区间$I_y$内单调、可导且$f\u0026rsquo;(y)\\ne 0$，那么它的反函数$y=f^{-1}(x)$在区间$ I_x = \\{ x | x = f(y) , y\\in I_y \\} $内也可导，且\n$$ [f^{-1}(x)]\u0026rsquo;=\\frac{1}{f\u0026rsquo;(y)}\\quad or \\quad \\frac{dy}{dx}=\\frac{1}{\\frac {dx}{dy}} $$\n部分常用导数 $$ (tan\\ x)\u0026rsquo;=sec^2x\\qquad (cot\\ x)\u0026rsquo;=-csc^2x $$\n$$ (sec\\ x)\u0026rsquo;=sec\\ xtan\\ x\\qquad (csc\\ x)\u0026rsquo;=-csc\\ xcot\\ x $$\n$$ (a^x)\u0026rsquo;=a^xlna(a\u0026gt;0,a\\ne 1)\\qquad (log_ax)\u0026rsquo;=\\frac{1}{xlna} $$\n$$ (arcsin\\ x)\u0026rsquo;=\\frac{1}{\\sqrt{1-x^2}}\\qquad (arccosx)\u0026rsquo;=-\\frac{1} {\\sqrt{1-x^2}} $$\n$$ (arctan\\ x)\u0026rsquo;=\\frac{1}{1+x^2}\\qquad (arccotx)\u0026rsquo;=-\\frac{1}{1+x^2} $$\n$$ (sh\\ x)\u0026rsquo;=ch\\ x,\\ (ch\\ x)\u0026rsquo;=sh\\ x,\\ (th\\ x)\u0026rsquo;=\\frac{1}{ch^2x} $$\n$$ (arsh\\ x)\u0026rsquo;=\\frac{1}{\\sqrt{x^2+1}},\\ (arch\\ x)\u0026rsquo;=\\frac{1}{\\sqrt{x^2-1}}, \\ (arth\\ x)\u0026rsquo;=\\frac{1}{1-x^2} $$\n参数方程求导 对如下参数方程\n$$ x = \\varphi (t),\\ y = \\psi (t) $$\n求导得\n$$ \\frac{dy}{dx}=\\frac{dy}{dt}\\cdot \\frac{1}{\\frac{dx}{dt}}= \\frac{\\psi\u0026rsquo;(t)}{\\varphi\u0026rsquo;(t)} $$\n中值定理 罗尔定理 如果函数$f(x)$满足\n（1）在闭区间$[a,b]$上连续\n（2）在开区间$(a,b)$内可导\n（3）在区间端点处的函数值相等，即$f(a)=f(b)$,\n那么在$(a,b)$内至少有一点$\\xi\\ (a\u0026lt;\\xi\u0026lt;b)$，使得$f\u0026rsquo;(\\xi)=0.$\n拉格朗日中值定理 如果函数$f(x)$满足\n（1）在闭区间$[a,b]$上连续；\n（2）在开区间$(a,b)$内可导，\n那么在$(a,b)$内至少有一点$\\xi (a\u0026lt;\\xi\u0026lt;b)$，使等式\n$$ f(b)-f(a)=f\u0026rsquo;(\\xi)(b-a) $$\n成立\n柯西中值定理 如果函数$f(x)$及$F(x)$满足\n（1）在闭区间$[a,b]$上连续\n（2）在开区间$(a,b)$内可导\n（3）对任一$x\\in(a,b),F\u0026rsquo;(x)\\ne0$\n那么在$(a,b)$内至少有一点$\\xi$，使等式\n$$ \\frac{f(b)-f(a)}{F(b)-F(a)}=\\frac{f\u0026rsquo;(x)}{F\u0026rsquo;(x)} $$\n成立\n泰勒公式 在$x_0$处展开如下\n$$ f(x)=f(x_0)+f\u0026rsquo;(x_0)(x-x_0)+\\frac{f\u0026rsquo;\u0026rsquo;(x_0)}{2!}(x-x_0)^2+\\dots+ \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x) $$\n皮亚诺余项 $$ R_n(x)=o((x-x_0)^n) $$\n拉格朗日余项 $$ R_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-x_0)^{(n+1)} $$\n这里$\\xi$是$x_0$与$x$之间的某个值\n曲率 弧微分公式 $$ ds=\\sqrt{1+y\u0026rsquo;^2}dx $$\n曲率表达式 对于$y=f(x)$，曲率$K$为\n$$ K=\\frac{|y\u0026rsquo;\u0026rsquo;|}{(1+y\u0026rsquo;^2)^{3/2}} $$\n对于$x = \\varphi (t),y = \\psi (t)$，有\n$$ K=\\frac{|\\varphi\u0026rsquo;(t)\\psi\u0026rsquo;\u0026rsquo;(t)-\\varphi\u0026rsquo;\u0026rsquo;(t)\\psi\u0026rsquo;(t)|}{[\\varphi\u0026rsquo;^2(t)+ \\psi\u0026rsquo;^2(t)]^{3/2}} $$\n曲率圆与曲率半径 曲率半径与曲率的关系\n$$ \\rho = \\frac{1}{K},\\ K=\\frac{1}{\\rho} $$\n曲率中心$D(\\alpha,\\beta)$\n$$ \\alpha = x-\\frac{y\u0026rsquo;(1+y\u0026rsquo;^2)}{y\u0026rsquo;\u0026rsquo;},\\quad \\beta = y+\\frac{1+y\u0026rsquo;^2}{y\u0026rsquo;\u0026rsquo;} $$\n不定积分 常用积分表 $$ \\int\\frac{dx}{1+x^2}=arctan\\ x+C,\\quad \\int\\frac{dx}{\\sqrt{1-x^2}} =arcsin\\ x+C $$\n$$ \\int\\frac{dx}{cos^2x}=\\int{sec^2x}dx=tan\\ x+C,\\quad\\int\\frac{dx}{sin^2x}= \\int csc^2xdx=-cot\\ x+C $$\n$$ \\int sec\\ xtan\\ xdx=sec\\ x+C,\\quad \\int csc\\ xcot\\ xdx=-csc\\ x+C $$\n$$ \\int sh\\ xdx=ch\\ x+C,\\quad \\int ch\\ xdx=sh\\ x+C $$\n$$ \\int tan\\ xdx=-ln|cos\\ x|+C,\\quad \\int cot\\ xdx=ln|sin\\ x|+C $$\n$$ \\int sec\\ xdx=ln|sec\\ x+tan\\ x|+C,\\quad \\int csc\\ xdx=ln|csc\\ x-cot\\ x|+C $$\n$$ \\int \\frac{dx}{a^2+x^2}=\\frac{1}{a}arctan\\frac{x}{a}+C,\\quad \\int \\frac{dx}{x^2-a^2}=\\frac{1}{2a}ln\\left |\\frac{x-a}{x+a}\\right |+C $$\n$$ \\int \\frac{dx}{\\sqrt{a^2-x^2}}=arcsin\\frac xa+C,\\quad \\int \\frac{dx}{\\sqrt{x^2+a^2}}=ln(x+\\sqrt{x^2+a^2})+C $$\n$$ \\int \\frac{dx}{\\sqrt{x^2-a^2}}=ln|x+\\sqrt{x^2-a^2}|+C $$\n换元积分法 第一类换元法 设$f(u)$具有原函数，$u=\\varphi(x)$可导，则有换元公式\n$$ \\int f[\\varphi(x)]\\varphi\u0026rsquo;(x)dx=\\left[\\int f(u)du \\right]_{u=\\varphi(x)} $$\n设要求$\\int g(x)dx$，如果$g(x)$可以化为$g(x)=f[\\varphi(x)]\\varphi\u0026rsquo;(x)$的形式，那么\n$$ \\int g(x)dx= \\int f[\\varphi(x)]\\varphi\u0026rsquo;(x)dx=\\left[\\int f(u)du \\right]_{u=\\varphi(x)} $$\n第二类换元法 设$x=\\psi(t)$是单调的可导函数，并且$\\psi\u0026rsquo;(t)\\ne 0$.又设$f[\\psi(x)]\\psi\u0026rsquo;(x)dx$具有原函数 ，则有换元公式\n$$ \\int f(x)dx= \\left[\\int f[\\psi(t)]\\psi\u0026rsquo;(t)dt\\right]_{t=\\psi^{-1}(x)} $$\n分部积分法 设函数$u=u(x)$及$v=v(x)$具有连续导数，则有\n$$ \\int uv\u0026rsquo;dx=uv-\\int u\u0026rsquo;vdx $$\n定积分 积分上限的函数的导数 若\n$$ \\Phi(x)=\\int_{a}^{x}f(t)dt $$\n则\n$$ \\Phi\u0026rsquo;(x)=f(x) $$\n若\n$$ \\Phi(x)=\\int_{a}^{g(x)}f(t)dt $$\n则\n$$ \\Phi\u0026rsquo;(x)=f(g(x))g\u0026rsquo;(x) $$\n定积分在几何学上的应用 平面图形的面积 直角坐标 例如，以$x$为积分变量，求$f(x)$及直线$x=a$, $x=b$与$x$轴围成的曲边梯形的面积\n$$ A=\\int_a^bf(x)dx $$\n以y为积分变量，则求的是两直线、函数、与$y$轴围成的曲边梯形的面积\n极坐标 $$ dA=\\frac12(\\rho(\\theta))^2d\\theta $$\n$$ A=\\int_\\alpha^\\beta\\frac12[\\rho(\\theta)]^2d\\theta $$\n体积 旋转体的体积 $$ V=\\int_a^b\\pi[f(x)]^2dx $$\n平行截面面积为已知的立体的体积 $$ V=\\int_a^bA(x)dx $$\n平面曲线的弧长 参数方程 $x=\\varphi(t),\\quad y=\\psi(t).\\quad(\\alpha\\leq t\\leq\\beta)$\n$$ s=\\int_\\alpha^\\beta\\sqrt{\\varphi\u0026rsquo;^2(t)+\\psi\u0026rsquo;^2(t)}dt $$\n直角坐标 $$ s=\\int_a^b\\sqrt{1+y\u0026rsquo;^2}dx $$\n极坐标 $$ s=\\int_\\alpha^\\beta\\sqrt{\\rho^2(\\theta)+\\rho\u0026rsquo;^2(\\theta)}d\\theta $$\n微分方程 齐次方程 如果一阶微分方程可化成\n$$ \\frac{dy}{dx}=\\varphi\\left(\\frac yx\\right) $$\n的形式，那么就称这方程为齐次方程。在齐次方程中，引入新的未知函数$u=\\frac{y}{x}$，有\n$$ y=ux,\\ \\frac{dy}{dx}=u+x\\frac{du}{dx} $$\n$$ u+x\\frac{du}{dx}=\\varphi(u) $$\n用分离变量的办法求出关于$u$的积分，最后再以$\\frac yx$代替$u$.\n一阶线性微分方程  方法一  方程\n$$ \\frac{dy}{dx}+P(x)y=Q(x) $$\n的通解为\n$$ y=Ce^{-\\int P(x)dx}+e^{-\\int P(x)dx}\\int Q(x)e^{\\int P(x)dx}dx $$\n方法二  先求对应齐次方程\n$$ \\frac{dy}{dx}+P(x)y=0 $$\n的解，得到\n$$ y=Ce^{-\\int P(x)dx} $$\n将$C$替换为$u$，再对上解求导得$\\frac{dy}{dx}$，将其代入原非齐次方程，解出$u$，则\n$$ y=ue^{-\\int P(x)dx} $$\n可降阶的高阶微分方程   $y\u0026rsquo;\u0026rsquo;=f(x,y\u0026rsquo;)$型的微分方程\n设$y\u0026rsquo;=p$则$y\u0026rsquo;\u0026rsquo;=\\frac{dp}{dx}=p\u0026rsquo;$，代入原方程中求解$p$，再求解$y$\n  $y\u0026rsquo;\u0026rsquo;=f(y,y\u0026rsquo;)$型的微分方程\n设$y\u0026rsquo;=p$\n$$ y\u0026rsquo;\u0026rsquo;=\\frac{dp}{dx}=\\frac{dp}{dy}\\cdot\\frac{dy}{dx}=p\\frac{dp}{dy} $$\n代入原方程中求解$p$，再求解$y$\n  高阶线性微分方程 定理1 如果函数$y_1(x)$与$y_2(x)$是方程\n$$ y\u0026rsquo;\u0026rsquo;+P(x)y\u0026rsquo;+Q(x)y=0 $$\n的两个特解，那么\n$$ y=C_1y_1(x)+C_2y_2(x) $$\n也是方程的解\n定理2 如果函数$y_1(x)$与$y_2(x)$是方程的两个线性无关的特解，那么\n$$ y=C_1y_1(x)+C_2y_2(x) $$\n就是 方程的通解\n定理3 设$y^*(x)$是方程\n$$ y\u0026rsquo;\u0026rsquo;+P(x)y\u0026rsquo;+Q(x)y=f(x) $$\n的一个特解，$Y(x)$是该方程对应的齐次方程的通解，则\n$$ y=Y(x)+y^*(x) $$\n是该非齐次方程的通解\n定理4 设定理三种的非齐次线性方程的右端$f(x)$是两个函数之和，即\n$$ y\u0026rsquo;\u0026rsquo;+P(x)y\u0026rsquo;+Q(x)y=f_1(x)+f_2(x) $$\n而$y_1^* (x)$与$y_2^*(x)$分别是方程\n$$ y\u0026rsquo;\u0026rsquo;+P(x)y\u0026rsquo;+Q(x)y=f_1(x) $$\n与\n$$ y\u0026rsquo;\u0026rsquo;+P(x)y\u0026rsquo;+Q(x)y=f_2(x) $$\n的特解，则$y_1^*(x)+y_2^ *(x)$就是原方程的特解\n常系数齐次线性微分方程 二阶形式如下 $$ y\u0026rsquo;\u0026rsquo;+py\u0026rsquo;+qy=0 $$\n先求解如下方程\n$$ r^2+pr+q=0 $$\n分为三种情况\n  有两个不等实根$r_1,r_2$\n则通解为\n$$ y=C_1e^{r_1x}+C_2e^{r_2x} $$\n  有两个相等实根$r_{1,2}$\n则通解为\n$$ y=(C_1+C_2x)e^{r_1x} $$\n  有一对共轭复根\n$$ r_1=\\alpha+\\beta i,\\quad r_2=\\alpha-\\beta i $$\n$$ \\alpha=-\\frac{p}{2},\\quad \\beta=\\frac{\\sqrt{4q-p^2}}{2} $$\n则通解为\n$$ y=e^{\\alpha x}(C_1cos\\ \\beta x+C_2sin\\ \\beta x) $$\n  n阶形式如下 $$ y^{(n)}+p_1y^{(n-1)}+p_2y^{(n-2)}+\\dots+p_{n-1}y\u0026rsquo;+p_ny=0 $$\n其中$p_1\\dots p_n$都是常数。\n其特征方程如下\n$$ r^n+p_1r^{n-1}+\\dots+p_{n-1}r+p_n=0 $$\n分四种情况\n  单实根$r$，给出一项：$Ce^{rx}$\n  一对单负根$r_{1,2}=\\alpha\\pm\\beta i$，给出两项：$e^{\\alpha x}(C_1cos\\beta x+C_2sin\\beta x)$\n  k重实根r，给出$k$项：$e^{rx}(C_1+C_2x+\\dots+C_kx^{k-1})$\n  一对k重复根$r_{1,2}=\\alpha\\pm\\beta i$，给出$2k$项：$e^{\\alpha x}[(C_1+C_2x+\\dots+C_kx^{k-1})cos\\beta x+(D_1+D_2x+\\dots+D_kx^{k-1})sin\\beta x]$\n  常系数非齐次线性微分方程 二阶常系数非齐次线性微分方程的一般形式是\n$$ y\u0026rsquo;\u0026rsquo;+py\u0026rsquo;+qy=f(x) $$\n求其通解只用求该方程的一个特解和上一节学到的求其对应齐次方程的通解，高数上册只介绍了$f(x)$的两种形式\n  $f(x)=e^{\\lambda x}P_m(x)$，其中$\\lambda$是常数，$P_m(x)$是$x$的一个$m$次多项式\n$$ P_m(x)=a_0x^m+a_1x^{m-1}+\\dots+a_{m-1}x+a_{m} $$\n  $f(x)=e^{\\lambda x}[P_l(x)cos\\omega x+Q_n(x)sin\\omega x]$，其中$\\lambda,\\omega$是常数，$\\omega\\ne0$，$P_l(x),Q_n(x)$分别是$x$的$l$次、$n$次多项式，且仅有一个可为零.\n  $f(x)=e^{\\lambda x}P_m(x)$型 $$ y^*=x^kR_m(x)e^{\\lambda x} $$\n其中 $R_m(x)$是与$P_m(x)$同次的多项式，而$k$按$\\lambda$不是特征方程(即$r^2+pr+q=0$)的根，是特征方程的单根或是特征方程的重根依次取值为0,1,2.\n其中$R_m(x)$中的每一个系数，应当代入原方程中进行计算。\n$f(x)=e^{\\lambda x}[P_l(x)cos\\omega x+Q_n(x)sin\\omega x]$型 $$ y^*=x^ke^{\\lambda x}[R^{(1)}_m(x)cos\\omega x+R^{(2)}_m(x)sin\\omega x] $$\n其中$R^{(1)}_m(x)$、$R^{(2)}_m(x)$是$m$次多项式，$m=max\\{l,n\\}$，而$k$按$\\lambda+\\omega i$(或$\\lambda-\\omega i$)不是特征方程的根、或是特征方程的单根依次取0或1\n","date":"2021-12-27T16:45:49+08:00","image":"https://kegalas.top/p/%E6%88%91%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A%E5%86%8C%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/sec_huc4e91e2fedcb5d4446570ef1353d17fa_50913_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E6%88%91%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A%E5%86%8C%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/","title":"我的高等数学上册资料整理"},{"content":" 排序 只给出归并排序，有可能在求逆序对的时候用得上。其他时候排序用sort函数即可。\n归并排序 #include \u0026lt;stdio.h\u0026gt;  void merge(long *num,long *tmp, int left, int mid_index ,int right){   int first=left, second = mid_index+1, tmp_index = left;  while(first\u0026lt;mid_index+1\u0026amp;\u0026amp;second\u0026lt;right+1){  if(*(num+first)\u0026lt;*(num+second)){  tmp[tmp_index] = *(num+first);  tmp_index++;  first++;  }  else{  tmp[tmp_index] = *(num+second);  tmp_index++;  second++;  }  }  while(first\u0026lt;mid_index+1){  tmp[tmp_index++] = *(num+first);  first++;  }  while(second\u0026lt;right+1){  tmp[tmp_index++] = *(num+second);  second++;  }  int i;  for(i=left;i\u0026lt;=right;i++){  num[i]=tmp[i];  }   return; }  void merge_sort(long *num,long *tmp, int left, int right){  int mid_index;  if(left\u0026lt;right){  mid_index = left + (right-left)/2;//这样写疑似可以避免int溢出  merge_sort(num,tmp,left,mid_index);  merge_sort(num,tmp,mid_index+1,right);  merge(num,tmp,left,mid_index,right);  }   return; }  int main(){  int num_count;  long num[20000];  long tmp[20000];  scanf(\u0026#34;%d\u0026#34;,\u0026amp;num_count);  int i;  for(i=1;i\u0026lt;=num_count;i++){  scanf(\u0026#34;%d\u0026#34;,\u0026amp;num[i]);  }   merge_sort(num,tmp,1,num_count);   for(i=1;i\u0026lt;=num_count;i++){  printf(\u0026#34;%d \u0026#34;,num[i]);  }   return 0; } 技巧 快速幂 #include \u0026lt;iostream\u0026gt;  using namespace std;  long long binpow(long long n, long long p){  long long res = 1;  while(p\u0026gt;0){  if(p\u0026amp;1){  res = res * n;  }  n *= n;  p\u0026gt;\u0026gt;=1;  }  return res;  }   int main(){  long long n,p;  cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;p;   cout\u0026lt;\u0026lt;binpow(n,p)\u0026lt;\u0026lt;endl;   return 0; } 离散化 //离散化 例如将1,500,40,1000保持相对大小不变，离散化为1,3,2,4 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt;  using namespace std;  vector\u0026lt;int\u0026gt; arr,assi;  int main(){  int n;  cin\u0026gt;\u0026gt;n;  for(int i=1;i\u0026lt;=n;i++){  int a;  cin\u0026gt;\u0026gt;a;  arr.push_back(a);  assi.push_back(a);  }  sort(assi.begin(),assi.end());  unique(assi.begin(),assi.end());   for(int i=0;i\u0026lt;n;i++){  arr[i] = upper_bound(assi.begin(),assi.end(),arr[i])-assi.begin();  }   for(int i=0;i\u0026lt;n;i++){  cout\u0026lt;\u0026lt;arr[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  }  cout\u0026lt;\u0026lt;endl;   return 0; } 字符串 KMP //kmp,luogu3375 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt;  std::vector\u0026lt;int\u0026gt; prefixFunc(std::stringstr){  //输入一个字符串，输出该字符串的前缀函数表  int n = str.length();  std::vector\u0026lt;int\u0026gt; ans(n);   for(int i=1;i\u0026lt;n;i++){  int j = ans[i-1];  while(j\u0026gt;0 \u0026amp;\u0026amp; str[i]!=str[j]) j = ans[j-1];  if(str[i]==str[j]) j++;  ans[i] = j;  }   return ans; }  int main(){  std::stringstr1,str2;  std::cin\u0026gt;\u0026gt;str1\u0026gt;\u0026gt;str2;   std::vector\u0026lt;int\u0026gt; pf = prefixFunc(str2+\u0026#34;#\u0026#34;+str1);  //注意这个#号，代表的意思是不会在str2与str1中出现的字符，作为分隔符  int n = str2.length();  int m = str1.length();  for(int i=n+1;i\u0026lt;n+m+1;i++){  if(pf[i]==n){  std::cout\u0026lt;\u0026lt;i-2*n+1\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;;  //输出str2在str1中出现的位置  //注意下标从0开始，计算在str1中出现的位置时要减去str2和分隔符  //另外这个i是匹配到的子串的最右侧  }  }   //下面不是kmp的一部分，是洛谷3375的要求  pf = prefixFunc(str2);  for(auto x:pf){  std::cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  }  std::cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;;   return 0; } 字典树(Trie) #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt;  #define MAXN 500005  using namespace std;  int nxt[MAXN][26]; int cnt;  void init(){  memset(nxt,0,sizeof(nxt));  cnt = 1; }  void insert(string s){  int cur = 1;  for(auto c:s){  if(!nxt[cur][c-\u0026#39;a\u0026#39;]){  nxt[cur][c-\u0026#39;a\u0026#39;]=++cnt;  }  cur = nxt[cur][c-\u0026#39;a\u0026#39;];  } }  bool find_prefix(string s){  int cur=1;  for(auto c:s){  if (!nxt[cur][c - \u0026#39;a\u0026#39;])  {  return false;  }   cur = nxt[cur][c - \u0026#39;a\u0026#39;];  }  return true; }  int main(){   int n;  cin\u0026gt;\u0026gt;n;  for(int i=1;i\u0026lt;=n;i++){  string s1;  cin\u0026gt;\u0026gt;s1;  insert(s1);  }  while(1){  string s1;  cin\u0026gt;\u0026gt;s1;  cout\u0026lt;\u0026lt;find_prefix(s1)\u0026lt;\u0026lt;endl;  }    return 0; } AC自动机 //AC自动机，luogu P3808  #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt;  const int MAXN = 1000005;  namespace AC{  int trie[MAXN][26], total;  int end[MAXN],fail[MAXN];   void insert(std::stringstr){  //插入模式串  int u = 0;  for(auto c:str){  if(!trie[u][c-\u0026#39;a\u0026#39;]){  trie[u][c-\u0026#39;a\u0026#39;] = ++total;  }  u = trie[u][c-\u0026#39;a\u0026#39;];  }  end[u]++;  }   std::queue\u0026lt;int\u0026gt; qu;   void buildFail(){  //建造所有fail指针  for(int i=0;i\u0026lt;26;i++){  if(trie[0][i]) qu.push(trie[0][i]);  }   while(!qu.empty()){  int u = qu.front();  qu.pop();   for(int i=0;i\u0026lt;26;i++){  if(trie[u][i]){  fail[trie[u][i]] = trie[fail[u]][i];   qu.push(trie[u][i]);  }  else{  trie[u][i] = trie[fail[u]][i];  }  }  }  }   int query(std::stringstr){  //查询应当根据题目来修改，这里是p3808的  int u = 0, res = 0;  for(auto c:str){  u = trie[u][c-\u0026#39;a\u0026#39;];  for(int j = u;j\u0026amp;\u0026amp;end[j]!=-1;j=fail[j]){  res += end[j];  end[j] = -1;  }  }   return res;  } }  int main(){  int n;  std::cin\u0026gt;\u0026gt;n;  std::stringstr;  for(int i=1;i\u0026lt;=n;i++){  std::cin\u0026gt;\u0026gt;str;  AC::insert(str);  }  AC::buildFail();  std::cin\u0026gt;\u0026gt;str;  std::cout\u0026lt;\u0026lt;AC::query(str)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;;   return 0; } 数论 扩展欧几里得 //求解ax+by=gcd(a,b)的一组解 //扩展欧几里得 #include \u0026lt;iostream\u0026gt;  using namespace std;  int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y){  if(!b){  x = 1;  y = 0;//此时ax+by=gcd(a,b)中b=0，任何数与0的最大公约数是他本身，所以ax+0y=a，x=1 y=0  return a;  }  int d = exgcd(b, a%b, x, y);  int t = x;  x = y;  y = t-(a/b)*y;  return d; }  int main(){  int a,b,x,y,z;  cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;  z = exgcd(a,b,x,y);  cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl;  //x,y的意义见开头，z即是最大公约数  return 0; } 欧几里得算法 #include \u0026lt;iostream\u0026gt;  using namespace std;  int main(){  long long a,b;  cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;  if(a\u0026lt;b){  a=a+b;  b=a-b;  a=a-b;  }   long long ans = b;   while((a%b)!=0){  long long tmp = a%b;  a = b;  b = tmp;  ans = b;  }   cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;  //返回最大公约数   return 0; } 欧拉筛 //欧拉筛 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #define MAXN 50005   using namespace std;  int main(){  int n, prime[MAXN], cnt=0;  bool is_not_prime[MAXN];  cin\u0026gt;\u0026gt;n;  //2~n中有多少个素数  memset(is_not_prime, 0, sizeof(prime));   for (int i = 2;i\u0026lt;=n;i++){  if(!is_not_prime[i]) prime[++cnt] = i;  for(int j = 1;j\u0026lt;=cnt\u0026amp;\u0026amp;i*prime[j]\u0026lt;=n;j++){  is_not_prime[i*prime[j]] = 1;  if(i%prime[j]==0) break;  }  }   for(int i = 1;i\u0026lt;=cnt;i++){  cout\u0026lt;\u0026lt;prime[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  //输出素数  }  return 0; } Miller-Rabin素数测试 //miller-rabin #include \u0026lt;iostream\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;cstdio\u0026gt;  using namespace std;  const int test_time = 10;  int qPowMod(int a, int m, int n){  if(m==0) return 1;  if(m==1) return (a%n);  long long ans = 1; //不打ll会溢出  while(m){  if(m\u0026amp;1){  ans = ans%n*a%n;  }  a = (long long)a%n*a%n;//这里不打ll会溢出导致判断错误  m\u0026gt;\u0026gt;=1;  }  return ans; }  bool millerRabin(int n) {  if (n \u0026lt; 3 || n % 2 == 0) return n == 2;  int a = n - 1, b = 0;  while (a % 2 == 0) a /= 2, ++b;  // test_time 为测试次数,建议设为不小于 8  // 的整数以保证正确率,但也不宜过大,否则会影响效率  for (int i = 1, j; i \u0026lt;= test_time; ++i) {  int x = rand() % (n - 2) + 2, v = qPowMod(x, a, n);  if (v == 1) continue;  for (j = 0; j \u0026lt; b; ++j) {  if (v == n - 1) break;  v = (long long)v * v % n;  }  if (j \u0026gt;= b) return 0;  }  return 1; }  int main(){  srand(time(NULL));  int n;  cin\u0026gt;\u0026gt;n;  if(millerRabin(n)){  cout\u0026lt;\u0026lt;\u0026#34;Probably a prime\u0026#34;\u0026lt;\u0026lt;endl;  }  else{  cout\u0026lt;\u0026lt;\u0026#34;A composite\u0026#34;\u0026lt;\u0026lt;endl;  }  return 0; } 乘法逆元 //乘法逆元 //分为扩展欧几里得法、快速幂法、线性求逆元 //ax≡1(mod b)，x为a在乘法意义上的逆元，记作a^(-1)，或者inv(a) //用扩展欧几里得法的角度看，就是求ax+by=1的整数解 //快速幂法利用费马小定理，需要b为素数  #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt;  using namespace std;  const int MAXN = 3000005;  int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y){  if(!b){  x=1;  y=0;  return a;  }  int d = exgcd(b,a%b,x,y);  int tmp = x;  x = y;  y = tmp - a/b*y;  return d;  }  void exgcd_inv(int a, int b){  int x,y;  int d = exgcd(a,b,x,y);  if(d!=1){//显然a，b要互质才会有逆元  cout\u0026lt;\u0026lt;\u0026#34;None\u0026#34;\u0026lt;\u0026lt;endl;  }  else{  cout\u0026lt;\u0026lt;(x+b)%b\u0026lt;\u0026lt;endl;//实际上是为了防止出现x为负数的情况  } }  int qPowMod(int a, int n, int b){  int ans = 1;  while(n){  if(n\u0026amp;1){  ans = ans%b*a%b;  }  a = a%b*a%b;  n\u0026gt;\u0026gt;=1;  }  return ans; }  void fermat_inv(int a, int b){  cout\u0026lt;\u0026lt;qPowMod(a,b-2,b)\u0026lt;\u0026lt;endl; }  long long inv[MAXN];  int main(){  long long a,b,n;  cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;  exgcd_inv(a,b);  //fermat_inv(a,b);   /* //线性求逆元 inv[1] = 1; for(long long i = 2;i\u0026lt;=n;i++){ //inv[i] = -(b/i)*inv[b%i]; //这样写会出现负数 inv[i] = (long long)(b-b/i)*inv[b%i]%b; } for(long long i=1;i\u0026lt;=n;i++){ printf(\u0026#34;%lld\\n\u0026#34;,inv[i]); } */   return 0; } 线性同余方程 //ax≡c (mod b)求解x //和ax+by=c等价 #include \u0026lt;iostream\u0026gt;  using namespace std;  int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y){  if(!b){  x=1;  y=0;  return a;  }  int d = exgcd(b, a%b, x, y);  int tmp=x;  x = y;  y = tmp-a/b*y;  return d; }  int linearEquation(int a, int b, int c, int \u0026amp;x, int \u0026amp;y){  int d = exgcd(a,b,x,y);  if(c%d!=0) return -1;  x = x*c/d;  y = y*c/d;   return d; }  int main(){  int a,b,c,x,y;   cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;  c=1;   int d = linearEquation(a,b,c,x,y);  //d是a,b的最大公约数   if(d==-1){  cout\u0026lt;\u0026lt;\u0026#34;None\u0026#34;\u0026lt;\u0026lt;endl;  }  else{  //cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;  //下面输出的是最小整数解  int t = b/d;  x = (x%t+t)%t;  cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl;  }   return 0; } 中国剩余定理 求解如下方程中的\\(x\\)\n\\[ \\left\\{\\begin{matrix} x \\equiv a_1(mod\\quad r_1) \\\\ x \\equiv a_2(mod\\quad r_2 \\\\ \\vdots \\\\ x \\equiv a_k(mod\\quad r_k) \\end{matrix}\\right. \\]\n#include \u0026lt;iostream\u0026gt;  using namespace std;  typedef long long ll;  const int MAXN = 10005;  long long a[MAXN],r[MAXN];  long long exgcd(ll a, ll b, ll \u0026amp;x, ll \u0026amp;y){  if(!b){  x=1;  y=0;  return a;  }  ll d = exgcd(b,a%b,x,y);  ll tmp = x;  x = y;  y = tmp - (a/b)*y;  return d; }  int main(){  int k;  cin\u0026gt;\u0026gt;k;  //共有k个方程  for(int i=1;i\u0026lt;=k;i++){  cin\u0026gt;\u0026gt;a[i]\u0026gt;\u0026gt;r[i];  //x≡ai(mod ri)  }    ll n=1,ans=0;  for(int i=1;i\u0026lt;=k;i++){  n = n * r[i];  }  for(int i=1;i\u0026lt;=k;i++){  ll m = n/r[i];  ll x,y;  exgcd(m,r[i],x,y);  ans = (ans+a[i]*m*x%n)%n;  }    cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;  //输出x的值  return 0; } 用乘法逆元计算组合数 根据\n\\[ (a/b)\\%p=(a\\times b^{-1})\\%p=[(a\\%p)\\times(b^{-1}\\%p)]\\%p \\]\n（如果加载不全，见取余运算的分配律）\n可以不用除法求出组合数。其中\\(b^{-1}\\)是\\(b\\)在模\\(p\\)意义下的逆元。\n注意阶乘和其逆元的预处理。\n#include \u0026lt;iostream\u0026gt;  #define LL longlong  const int MAXN = 200005; const int MOD = 998244353;  LL fac[MAXN]; LL invFac[MAXN];  LL qPowMod(LL a, LL n, LL b){  LL ans = 1;  while(n){  if(n\u0026amp;1){  ans = ans%b*a%b;  }  a = a%b*a%b;  n\u0026gt;\u0026gt;=1;  }  return ans; }  LL fermat_inv(LL a, LL b){  return qPowMod(a,b-2,b); }  void init(int n){  fac[0] = 1;  invFac[0] = 1;   for(int i=1;i\u0026lt;=n;i++){  fac[i] = (fac[i-1]*i)%MOD;  invFac[i] = fermat_inv(fac[i],MOD);  } }  LL comb(LL n, LL m){  if(n\u0026lt;0||m\u0026lt;0||m\u0026gt;n) return 0;  return (((fac[n]*invFac[m])%MOD)*invFac[n-m])%MOD; }  int main(){  int n,m;  std::cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;    init(n);    std::cout\u0026lt;\u0026lt;comb(n,m)\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;;   return 0; } 图论 最短路 Dijkstra #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #define MAXN 500005 #define MAXINT 0x7fffffff  using namespace std;  struct edge{  int v,w;//下一点，权 };  struct node {  int dis, u;  bool operator\u0026gt;(const node\u0026amp; a) const { return dis \u0026gt; a.dis; } };  int n,m,s;//点，边，起点  vector\u0026lt;edge\u0026gt; graph[MAXN];  int dis[MAXN];  bool tag[MAXN];  priority_queue\u0026lt;node, vector\u0026lt;node\u0026gt;, greater\u0026lt;node\u0026gt; \u0026gt; pq;  int main(){  scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;s);   for(int i=1;i\u0026lt;=m;i++){  int a,b,c;  scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c);  //起点，终点，边权  edge t;  t.v=b;  t.w=c;  graph[a].push_back(t);  }   for(int i=1;i\u0026lt;=n;i++){  dis[i] = MAXINT;  //初始化为无限远  }   dis[s]=0;  node tmp;  tmp.dis=0;  tmp.u=s;  pq.push(tmp);   while (!pq.empty())  {  int u = pq.top().u;  pq.pop();  if(tag[u]) continue;  tag[u]=1;  for(auto g : graph[u]){  int v = g.v, w = g.w;  if(dis[v]\u0026gt;dis[u]+w){  dis[v] = dis[u]+w;  tmp.dis = dis[v];  tmp.u = v;  pq.push(tmp);  }  }  }   for(int i=1;i\u0026lt;=n;i++){  printf(\u0026#34;%d\u0026#34;,dis[i]);  }   return 0; } Bellman-Ford #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt;  #define MAXN 500005 #define INF 0x6fffffff  using namespace std;  struct edge{  int v;//下一点  int w;//权 };  int n,m,s; int dis[MAXN]; vector\u0026lt;edge\u0026gt; graph[MAXN];  int main(){    cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s;   for(int i=1;i\u0026lt;=n;i++) dis[i]=INF;    for(int i=1;i\u0026lt;=m;i++){  edge tmp;  int a,b,c;  cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c;  //起点，终点，边权  tmp.v=b;  tmp.w=c;  graph[a].push_back(tmp);  }   dis[s] = 0;   bool flag;  for (int i=1;i\u0026lt;=n;i++)//松弛n-1轮，若第n轮还能松弛，就说明有负环  {  flag = 0;  for(int u=1;u\u0026lt;=n;u++){//这里看似是两层循环，实际上总数是边数，整个算法的复杂度是mn  for (auto e : graph[u]){  int w=e.w,v=e.v;  if(dis[v]\u0026gt;dis[u]+w){  dis[v]=dis[u]+w;  flag = 1;  }  }  }  if(!flag){  break;  }  }   cout\u0026lt;\u0026lt;flag\u0026lt;\u0026lt;endl;//可以输出是否有负权环   for(int i=1;i\u0026lt;=n;i++){  //if(dis[i]!=INF){  cout\u0026lt;\u0026lt;dis[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  //}  //else{  // cout\u0026lt;\u0026lt;\u0026#34;2147483647 \u0026#34;;//根据luogu P3371要输出这个数  //}    }    return 0; } SPFA /* bellman-ford的优化 只有上一次被松弛的结点，所连接的边， 才有可能引起下一次的松弛操作 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt;  #define MAXN 500005 #define INF 0x5fffffff  using namespace std;  struct edge{  int v;  int w; };  int dis[MAXN];//距离 int cnt[MAXN];//算到达本节点所要经过的边数，若cnt\u0026gt;=n，则说明有负权环 bool tag[MAXN];//用于判断是否为上次松弛过的节点的边所连的点  int n,m,s; queue\u0026lt;int\u0026gt; qu; vector\u0026lt;edge\u0026gt; graph[MAXN];  int main(){  cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s;   for(int i=1;i\u0026lt;=n;i++){  dis[i] = INF;  }   dis[s] = 0;  tag[s] = 1;   for(int i=1;i\u0026lt;=m;i++){  int a,b,c;  cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c;  //起点，终点，边权  edge tmp;  tmp.v=b;  tmp.w=c;  graph[a].push_back(tmp);  }   qu.push(s);   bool is_negative_circle = 0;   while(!qu.empty()){  if(is_negative_circle) break;  int u = qu.front();  qu.pop();  tag[u]=0;  for(auto e : graph[u]){  int v = e.v, w = e.w;  if(dis[v]\u0026gt;dis[u]+w){  dis[v]=dis[u]+w;  cnt[v]=cnt[u]+1;  if(cnt[v]\u0026gt;=n) {  is_negative_circle = 1;  break;  }  if(!tag[v]){  qu.push(v);  tag[v]=1;  }  }  }  }   cout\u0026lt;\u0026lt;is_negative_circle\u0026lt;\u0026lt;endl;//可以输出是否有负权环   for(int i=1;i\u0026lt;=n;i++){  //if(dis[i]!=INF){  cout\u0026lt;\u0026lt;dis[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  //}  //else{  // cout\u0026lt;\u0026lt;\u0026#34;2147483647 \u0026#34;;//根据luogu P3371要输出这个数  //}  }   return 0; } Floyd //floyd #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt;  #define MAXN 5005 #define MAXINT 0x3fffffff//不能设置为int的最大值，否则后面加法可能导致溢出  using namespace std;  int graph[MAXN][MAXN];  int main(){  int n,m;//点数，边数  cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;  for(int i = 1;i\u0026lt;=n;i++){  for(int j = 1;j\u0026lt;=n;j++){  graph[i][j] = MAXINT;  }  }  for(int i = 1;i\u0026lt;=n;i++){  graph[i][i] = 0;  }  for(int i=1;i\u0026lt;=m;i++){  int a,b,v;  cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;v;//起点，终点，边权  graph[a][b] = v;  }   for(int k = 1;k\u0026lt;=n;k++){  for(int i=1;i\u0026lt;=n;i++){  for(int j=1;j\u0026lt;=n;j++){  graph[i][j] = min(graph[i][j],graph[i][k]+graph[k][j]);  }  }  }    for(int i = 1;i\u0026lt;=n;i++){  for(int j=1;j\u0026lt;=n;j++){  cout\u0026lt;\u0026lt;graph[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  }  cout\u0026lt;\u0026lt;endl;  }   return 0; } 拓扑排序 //拓扑排序 //拓扑排序 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt;  using namespace std;  struct graph{  int value;  int to; };  struct point {  int in_num;  vector\u0026lt;graph\u0026gt; graph1; }point1[100];  int main(){  int n,m;  cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;   for(int i = 1;i\u0026lt;=n;i++){  point1[i].in_num=0;  }    for (int i=1;i\u0026lt;=m;i++){  int a,b,value;  cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;//起点，终点；本次是无权图  graph tmp;  tmp.to=b;  tmp.value = 0;  point1[a].graph1.push_back(tmp);  point1[b].in_num++;  }    queue\u0026lt;int\u0026gt; que;  vector\u0026lt;int\u0026gt; ans;   for (int i = 1; i \u0026lt;= n; i++)  {  if(point1[i].in_num == 0){  que.push(i);  }  }   while (!que.empty())  {  int p = que.front();  que.pop();  ans.push_back(p);  for(int i = 0;i\u0026lt;point1[p].graph1.size();i++){  int next = point1[p].graph1[i].to;  point1[next].in_num--;  if(point1[next].in_num==0){  que.push(next);  }  }   }   if(ans.size()==n){  for(int i = 0;i\u0026lt;ans.size();i++){  cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  }  }  else{  cout\u0026lt;\u0026lt;\u0026#34;none\u0026#34;;  }   return 0; } 最小生成树 Kruskal #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #define MAXN 200005  using namespace std;  int u[MAXN],v[MAXN],w[MAXN]; int r[MAXN];//临时边序号，间接排序 int find_sets[MAXN];//并查集  int cmp(const int i, const int j){return w[i]\u0026lt;w[j];}  int find(int x){return find_sets[x]==x ? x : find_sets[x] = find(find_sets[x]);}  int main(){  int n,m;//点数和边数   cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;  for(int i=1;i\u0026lt;=m;i++){  cin\u0026gt;\u0026gt;u[i]\u0026gt;\u0026gt;v[i]\u0026gt;\u0026gt;w[i];  //起点，终点，边权  }   for(int i = 1;i\u0026lt;=n;i++){  find_sets[i]=i;  }  for(int i=1;i\u0026lt;=m;i++){  r[i]=i;  }   sort(r+1,r+m+1,cmp);   int ans = 0;  //int cnt=0;   for(int i=1;i\u0026lt;=m;i++){  int tmp = r[i];  int x = find(u[tmp]);  int y = find(v[tmp]);   if(x!=y){  ans += w[tmp];  find_sets[x] = y;  //cnt++;  }  }  //计数，如果小于n-1则不连通  /* if(cnt\u0026lt;n-1){ cout\u0026lt;\u0026lt;\u0026#34;orz\u0026#34;\u0026lt;\u0026lt;endl; return 0; //如果是多个样例注意这个return 0 } */   cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;   return 0; } Prim算法 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt;  using namespace std;  const int MAXN = 5005; const int MAXM = 200005; const int INF = 0x5fffffff;  struct edge{  int v,w;   edge()=default;  edge(int v,int w):v(v),w(w){}   bool operator\u0026gt;(const edge\u0026amp; x) const {return w\u0026gt;x.w;} };  vector\u0026lt;edge\u0026gt; graph[MAXN]; bool vis[MAXN];  priority_queue\u0026lt;edge, vector\u0026lt;edge\u0026gt;, greater\u0026lt;edge\u0026gt; \u0026gt; pq;  //以下orz代表不连通  int main(){  int n,m;//点数，边数  scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m);  int ans = 0;  int cnt = 1;   for(int i=1;i\u0026lt;=m;i++){  int a,b,c;//起点，终点，边权  scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c);  graph[a].push_back(edge(b,c));  graph[b].push_back(edge(a,c));  //无向图  }   for(int i=0;i\u0026lt;graph[1].size();i++){  pq.push(graph[1][i]);  }  vis[1]=true;   while(cnt!=n\u0026amp;\u0026amp;!pq.empty()){  edge minx=pq.top();  pq.pop();  while(vis[minx.v]){  if(pq.empty()){  cout\u0026lt;\u0026lt;\u0026#34;orz\u0026#34;\u0026lt;\u0026lt;endl;  return 0;  }  minx=pq.top();  pq.pop();  }    vis[minx.v] = true;  ans+=minx.w;  cnt++;    for(int i=0;i\u0026lt;graph[minx.v].size();i++){  if(!vis[graph[minx.v][i].v])  pq.push(graph[minx.v][i]);  }  }   if(cnt\u0026lt;n){  cout\u0026lt;\u0026lt;\u0026#34;orz\u0026#34;\u0026lt;\u0026lt;endl;  }  else{  cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;  }   return 0; } 最小树形图 朱刘算法 //最小树形图，朱刘算法 //从根节点能到达其他所有点 //luogu4716 #include \u0026lt;iostream\u0026gt;  using namespace std;  const int MAXN = 105; const int MAXM = 10005; const int INF = 0x7fffffff;  struct Edge{  int u,v,w; };  Edge edge[MAXM];  int vis[MAXN],id[MAXN]; int in[MAXN],pre[MAXN]; int n,m,root;  int zhuliu(){  int ans = 0;  for(;;){  for(int i=1;i\u0026lt;=n;i++) in[i]=INF;    for(int i=1;i\u0026lt;=m;i++){  int u = edge[i].u;  int v = edge[i].v;  if(u!=v\u0026amp;\u0026amp;edge[i].w\u0026lt;in[v]){//遍历所有边，找到对每个点的最短入边  in[v] = edge[i].w;  pre[v] = u;  }  }    for(int i=1;i\u0026lt;=n;i++){  if(i!=root\u0026amp;\u0026amp;in[i]==INF){  return -1;//无解  }  }    int cnt = 0;//记录环数以及下一次循环的点数    for(int i=1;i\u0026lt;=n;i++){  vis[i] = -1;  id[i] = -1;  }    in[root] = 0;    for(int i=1;i\u0026lt;=n;i++){  if(i==root) continue;  ans += in[i];  int v=i;  while(vis[v]!=i\u0026amp;\u0026amp;id[v]==-1\u0026amp;\u0026amp;v!=root){  vis[v] = i;  v = pre[v];  }  if(v!=root\u0026amp;\u0026amp;id[v]==-1){  id[v] = ++cnt;  for(int u=pre[v];u!=v;u=pre[u]) id[u] = cnt;  }  }    if(cnt==0){//无环，得到解  break;  }    for(int i=1;i\u0026lt;=n;i++){  if(id[i]==-1) id[i]=++cnt;  }    for(int i=1;i\u0026lt;=m;i++){  int u = edge[i].u;  int v = edge[i].v;  edge[i].u = id[u];  edge[i].v = id[v];  if(edge[i].u!=edge[i].v) edge[i].w -= in[v];  }    n = cnt;  root = id[root];  }  return ans; }  int main(){  cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;root;//点数，边数，根节点序号  for(int i=1;i\u0026lt;=m;i++){  cin\u0026gt;\u0026gt;edge[i].u\u0026gt;\u0026gt;edge[i].v\u0026gt;\u0026gt;edge[i].w;  //起点，终点，边权  }  cout\u0026lt;\u0026lt;zhuliu()\u0026lt;\u0026lt;endl;  return 0; } 网络流 最大流 Ford-Fulkerson DFS实现的Ford-Fulkerson //luogu P3376 //超时 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt;  using namespace std;  typedef long long ll; typedef unsigned long long ull;  const ll INF = 0xffffffff; const int MAXM = 100005;  struct Edge{  int to;  int rev;  ll cap;  Edge()=default;  Edge(int to, ll cap, int rev):to(to),cap(cap),rev(rev){}  };  vector\u0026lt;Edge\u0026gt; G[MAXM]; bool used[MAXM];   ll dfs(int v, int t, ll f){  if(v==t) return f;  used[v] = true;  for(int i=0;i\u0026lt;G[v].size();i++){  Edge\u0026amp; e=G[v][i];  if(!used[e.to]\u0026amp;\u0026amp;e.cap\u0026gt;0){  ll d = dfs(e.to, t, min(f,e.cap));  if(d\u0026gt;0){  e.cap-=d;  G[e.to][e.rev].cap+=d;  return d;  }  }  }  return 0; }  ll max_flow(int s, int t){  ll flow = 0;  for(;;){  memset(used,0,sizeof(used));  ll f = dfs(s,t,INF);  if(f==0) return flow;  flow+=f;  } }  int main(){  int n,m;  cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;  //点数，边数  int s,t;  cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t;  //源点，汇点  for(int i=1;i\u0026lt;=m;i++){  int a,b;  ll c;  scanf(\u0026#34;%d%d%ld\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c);  //起点，终点，边容量  //cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c;  G[a].push_back(Edge(b,c,G[b].size()));//这里第三个参数实际上是反向边的编号  G[b].push_back(Edge(a,0,G[a].size()-1));  }    ll ans = max_flow(s,t);  //得到最大流  printf(\u0026#34;%ld\u0026#34;,ans);  //cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;  return 0; }  /* 4 5 4 3 4 2 30 4 3 20 2 3 20 2 1 30 1 3 40 */ EdmondsKarp #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt;  using namespace std;  typedef long long ll;  const int MAXN = 205; const ll INF = 1LL\u0026lt;\u0026lt;35;  struct Edge{  int from, to;  ll cap,flow;  Edge(int u, int v, ll c, ll f):from(u),to(v),cap(c),flow(f){} };  struct EdmondKarp{  int n,m;  vector\u0026lt;Edge\u0026gt; edges;   vector\u0026lt;int\u0026gt; G[MAXN]; //邻接表  ll a[MAXN];  ll p[MAXN];   void init(int n){  for(int i=0;i\u0026lt;n;i++){  G[i].clear();  }  edges.clear();  }   void AddEdge(int from, int to, ll cap){  edges.push_back(Edge(from, to, cap, 0));  edges.push_back(Edge(to, from, 0, 0));  m = edges.size();  G[from].push_back(m-2);  G[to].push_back(m-1);  }   int Maxflow(int s, int t){  ll flow = 0;  for(;;){  memset(a, 0 ,sizeof(a));  queue\u0026lt;ll\u0026gt; Q;  Q.push(s);  a[s] = INF;  while(!Q.empty()){  ll x=Q.front();  Q.pop();  for(int i=0;i\u0026lt;G[x].size();i++){  Edge\u0026amp; e = edges[G[x][i]];  if(!a[e.to]\u0026amp;\u0026amp;e.cap\u0026gt;e.flow){  p[e.to] = G[x][i];  a[e.to] = min(a[x], e.cap-e.flow);  Q.push(e.to);  }  }  if(a[t]) break;  }  if(!a[t]) break;  for(int u=t;u!=s;u=edges[p[u]].from){  edges[p[u]].flow+=a[t];  edges[p[u]^1].flow -= a[t];  }  flow += a[t];  }  return flow;  } };  int main(){  EdmondKarp EK;  cin\u0026gt;\u0026gt;EK.n;  //点数  int s,t;  int m;  cin\u0026gt;\u0026gt;m\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t;  //边数，源点，汇点  for(int i=1;i\u0026lt;=m;i++){  int tmp1,tmp2,tmp3;  cin\u0026gt;\u0026gt;tmp1\u0026gt;\u0026gt;tmp2\u0026gt;\u0026gt;tmp3;  //起点，终点，边容量  EK.AddEdge(tmp1,tmp2,tmp3);  }   cout\u0026lt;\u0026lt;EK.Maxflow(s,t)\u0026lt;\u0026lt;endl;   return 0; } 连通性相关 强连通分量 Tarjan算法 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt;  using namespace std;  const int MAXN = 5005; const int MAXM = 10005;  int dfn[MAXN], low[MAXN], instk[MAXN], scc[MAXN], cnt=0, cscc=0; //scc代表每个店所属的强连通分量的编号 vector\u0026lt;int\u0026gt; edges[MAXN]; stack\u0026lt;int\u0026gt; stk;  void tarjan(int u){  low[u] = dfn[u] = ++cnt;  instk[u] = 1;  stk.push(u);  for(int i=0;i\u0026lt;edges[u].size();i++){  int v = edges[u][i];  if(!dfn[v]){  tarjan(v);  low[u] = min(low[u],low[v]);  }  else if(instk[v]){  low[u] = min(low[u], dfn[v]);  }  }  if(low[u]==dfn[u]){  int top;  cscc++;  do{  top = stk.top();  stk.pop();  instk[top] = 0;  scc[top] = cscc;  }while(top!=u);  } }  int main(){  int n,m;  cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;  //点数，边数  for(int i=1;i\u0026lt;=m;i++){  int a,b;  cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;  //起点，终点  edges[a].push_back(b);  }  for(int i=1;i\u0026lt;=n;i++){  if(!dfn[i])  tarjan(i);  }  for(int i=1;i\u0026lt;=n;i++){  cout\u0026lt;\u0026lt;scc[i]\u0026lt;\u0026lt;endl;  }  return 0; } 割点 Tarjan算法 //tarjan求割点,luogu P3388 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;algorithm\u0026gt;  using namespace std;  const int MAXN = 20005; const int MAXM = 100005;  int dfn[MAXN], low[MAXN], cnt=0; vector\u0026lt;int\u0026gt; edges[MAXN]; vector\u0026lt;int\u0026gt; cut;//存储割点  void tarjan(int u, bool root = true){  int tot = 0;  low[u] = dfn[u] = ++cnt;  for(int i=0;i\u0026lt;edges[u].size();i++){  int v = edges[u][i];  if(!dfn[v]){  tarjan(v,false);  low[u] = min(low[u],low[v]);  tot += (low[v]\u0026gt;=dfn[u]);//统计满足的点的个数  }  else{  low[u] = min(low[u], dfn[v]);  }  }  if(tot\u0026gt;root){//如果是根节点，则需要有至少两个子树，否则只需要有一个子树  cut.push_back(u);  } }  int main(){  int n,m;  cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;  //点数，边数  for(int i=1;i\u0026lt;=m;i++){  int a,b;  cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;  //起点，终点  edges[a].push_back(b);  edges[b].push_back(a);  //无向图  }  for(int i=1;i\u0026lt;=n;i++){  if(!dfn[i])  tarjan(i);  }  cout\u0026lt;\u0026lt;cut.size()\u0026lt;\u0026lt;endl;  sort(cut.begin(),cut.end());  for(int i=0;i\u0026lt;cut.size();i++){  cout\u0026lt;\u0026lt;cut[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  //输出割点的编号  }  return 0; } 割边 Tarjan算法 //tarjan求割边 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;algorithm\u0026gt;  using namespace std;  const int MAXN = 20005; const int MAXM = 100005;  int dfn[MAXN], low[MAXN], cnt=0, fa[MAXN];//fa记录父节点 vector\u0026lt;int\u0026gt; edges[MAXN]; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; bridges;//存储割边  void tarjan(int u){  low[u] = dfn[u] = ++cnt;  for(int i=0;i\u0026lt;edges[u].size();i++){  int v = edges[u][i];  if(!dfn[v]){  fa[v] = u;  tarjan(v);  low[u] = min(low[u],low[v]);   if(low[v]\u0026gt;dfn[u])  bridges.emplace_back(u,v);  }  else if(fa[u]!=v){  low[u] = min(low[u], dfn[v]);  }  } }  int main(){  int n,m;  cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m;  //点数，边数  for(int i=1;i\u0026lt;=m;i++){  int a,b;  cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;  //起点，终点  edges[a].push_back(b);  edges[b].push_back(a);  //无向图  }  for(int i=1;i\u0026lt;=n;i++){  if(!dfn[i])  tarjan(i);  }  cout\u0026lt;\u0026lt;bridges.size()\u0026lt;\u0026lt;endl;  for(int i=0;i\u0026lt;bridges.size();i++){  cout\u0026lt;\u0026lt;bridges[i].first\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;bridges[i].second\u0026lt;\u0026lt;endl;  //输出割边  }  return 0; } 计算几何 二维凸包 Andrew扫描法 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt;  #define MAXN 50005  using namespace std;  struct Point{  double x,y;  Point()=default;  Point(double x, double y):x(x),y(y){}  Point operator + (Point p){  return Point(x+p.x, y+p.y);  }  Point operator - (Point p){  return Point(x-p.x, y-p.y);  }  Point operator * (double d){  return Point(x*d, y*d);  }  double dot(Point p){//点积  return x*p.x+y*p.y;  }  double det(Point p){//叉积  return x*(p.y)-(p.x)*y;  } };  int n; Point po[MAXN*2];  bool cmp(Point\u0026amp; a, Point\u0026amp; b){  if(a.x!=b.x) return a.x\u0026lt;b.x;  return a.y\u0026lt;b.y; }  vector\u0026lt;Point\u0026gt; convexHull(){  //返回凸包上的点  int k = 0;  vector\u0026lt;Point\u0026gt; qs;  for(int i=0;i\u0026lt;n;i++){  while(k\u0026gt;1\u0026amp;\u0026amp;(qs[k-1]-qs[k-2]).det(po[i]-qs[k-1])\u0026lt;=0){  qs.erase(qs.end()-1);  k--;  }  qs.push_back(po[i]);  k++;  }  for(int i=n-2,t=k;i\u0026gt;=0;i--){  while(k\u0026gt;t\u0026amp;\u0026amp;(qs[k-1]-qs[k-2]).det(po[i]-qs[k-1])\u0026lt;=0) {  qs.erase(qs.end()-1);  k--;  }  qs.push_back(po[i]);  k++;  }  qs.erase(qs.end()-1);  return qs; }  int main(){  cin\u0026gt;\u0026gt;n;  for(int i=0;i\u0026lt;n;i++){  cin\u0026gt;\u0026gt;po[i].x\u0026gt;\u0026gt;po[i].y;  //输入点的横纵坐标  }   sort(po,po+n,cmp);   for(auto p:convexHull()){  cout\u0026lt;\u0026lt;p.x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;p.y\u0026lt;\u0026lt;endl;  }   return 0; } 旋转卡壳求最远点对 //Luogu P1452 //旋转卡壳和凸包 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt;  #define MAXN 50005  using namespace std;  struct Point{  int x,y;  Point()=default;  Point(int x, int y):x(x),y(y){}  Point operator - (Point p){  return Point(x-p.x, y-p.y);  }  Point operator + (Point p){  return Point(x+p.x, y+p.y);  }  Point operator * (int d){  return Point(x*d, y*d);  }  int dot(Point p){  return x*p.x+y*p.y;  }  int det(Point p){  return x*(p.y)-y*(p.x);  } };  bool cmp(Point\u0026amp; a, Point\u0026amp; b){  if(a.x!=b.x) return a.x\u0026lt;b.x;  return a.y\u0026lt;b.y; }  int n; Point po[MAXN];  vector\u0026lt;Point\u0026gt; convexHull(){  //返回凸包上的点  vector\u0026lt;Point\u0026gt; ans;  int k = 0;  for(int i=0;i\u0026lt;n;i++){  while(k\u0026gt;1\u0026amp;\u0026amp;(ans[k-1]-ans[k-2]).det(po[i]-ans[k-1])\u0026lt;=0){  ans.erase(ans.end()-1);  k--;  }  ans.push_back(po[i]);  k++;  }  for(int i=n-2,t=k;i\u0026gt;=0;i--){  while(k\u0026gt;t\u0026amp;\u0026amp;(ans[k-1]-ans[k-2]).det(po[i]-ans[k-1])\u0026lt;=0){  ans.erase(ans.end()-1);  k--;  }  ans.push_back(po[i]);  k++;  }  ans.erase(ans.end()-1);  return ans; }  inline long long dist(Point a, Point b){//计算距离的平方  return (a-b).dot(a-b); }    void rc(vector\u0026lt;Point\u0026gt; ans){  int tn = ans.size();  int cnt=0;  if(tn==2){  cout\u0026lt;\u0026lt;dist(ans[0],ans[1])\u0026lt;\u0026lt;endl;  return;  }  int i=0,j=0;  for(int k=0;k\u0026lt;tn;k++){  if(!cmp(ans[i],ans[k])) i=k;  if(cmp(ans[j],ans[k])) j=k;  }  long long res = 0;  int si=i,sj=j;  while(i!=sj||j!=si){  res = max(res,dist(ans[i],ans[j]));  if((ans[(i+1)%tn]-ans[i]).det(ans[(j+1)%tn]-ans[j])\u0026lt;0){  i = (i+1)%tn;  }else{  j = (j+1)%tn;  }    cnt++;  }  //返回凸包最远点对的距离的平方  cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; }  int main(){  cin\u0026gt;\u0026gt;n;  vector\u0026lt;Point\u0026gt; qs;  for(int i=0;i\u0026lt;n;i++){  cin\u0026gt;\u0026gt;po[i].x\u0026gt;\u0026gt;po[i].y;  //按横纵坐标输入点对  }  sort(po,po+n,cmp);  qs = convexHull();  rc(qs);  return 0; } 平面最近点对 输入\\(n\\)个点的平面坐标，使用分治法计算最近点对，复杂度\\(O(nlogn)\\)\n//Luogu P1257 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt;  const int MAXN = 200005;  struct Node{  int x,y;  int id;   bool operator\u0026lt;(const Node\u0026amp; a) const {  if(x!=a.x) return x\u0026lt;a.x;  return y\u0026lt;a.y;  } }nodes[MAXN];  bool cmp(const Node\u0026amp; a, const Node\u0026amp; b){  return a.y\u0026lt;b.y; }  double minDist; int ansA, ansB;  inline void updAns(const Node\u0026amp; a, const Node\u0026amp; b){  double dist = sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+0.0);  if(dist\u0026lt;minDist){  minDist = dist;  //如果要记录节点  ansA = a.id;  ansB = b.id;  } }  void calcMin(int l, int r){  if(r-l\u0026lt;=3){  for(int i=l;i\u0026lt;=r;i++){  for(int j=i+1;j\u0026lt;=r;j++){  updAns(nodes[i],nodes[j]);  }  }  std::sort(nodes+l, nodes+r+1, cmp);  return;  }   int m = (l+r)\u0026gt;\u0026gt;1;  int midx = nodes[m].x;  calcMin(l,m);  calcMin(m+1,r);    //归并排序的合并，两个有序数组合并，合并之后仍然有序  std::inplace_merge(nodes+l, nodes+m+1, nodes+r+1, cmp);   static Node t[MAXN];  int tsz = 0;   for (int i = l; i \u0026lt;= r; ++i){  if (abs(nodes[i].x - midx) \u0026lt; minDist) {  for (int j = tsz - 1; j \u0026gt;= 0 \u0026amp;\u0026amp; nodes[i].y - t[j].y \u0026lt; minDist; --j)  updAns(nodes[i], t[j]);  t[tsz++] = nodes[i];  }  }  }  int main(){  int n;  std::cin\u0026gt;\u0026gt;n;  for(int i=1;i\u0026lt;=n;i++){  std::cin\u0026gt;\u0026gt;nodes[i].x\u0026gt;\u0026gt;nodes[i].y;  nodes[i].id = i;  }   std::sort(nodes+1,nodes+1+n);  minDist = 1e20;  calcMin(1,n);   printf(\u0026#34;%.4f\\n\u0026#34;,minDist);   return 0; } 组合数学 卡特兰数 第\\(n\\)个记作\\(C_n\\)\n\\(n\\)对括号形成的字符串，合法的情况数是\\(C_n\\)\n\\(n\\)个节点的二叉树，总共有\\(C_n\\)种\n\\(2n+1\\)个节点组成的满二叉树，有\\(C_n\\)种\n\\(n\\times n\\)的格点网中，从左下角格点出发，到达右上角格点，不穿过对角线的单调路径个数有\\(C_n\\)个。\n其计算公式为\n\\[ C_n = \\frac{1}{n+1}\\binom{2n}{n} \\]\n\\[ C_n=\\binom{2n}{n} - \\binom{2n}{n-1} \\]\n\\[ C_0=1,C_{n+1}=\\sum^n_{i=0}C_iC_{n-i} \\]\n\\[ C_0=1,C_{n+1}=\\frac{2(2n+1)}{n+2}C_n \\]\n#include \u0026lt;iostream\u0026gt; //前几项：1（第0项）, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796 using namespace std;  typedef long long ll; const int MAXN = 3005;  ll h[MAXN];  ll comb(int a,int b){  ll ans=1;  for(int i=1;i\u0026lt;=b;i++){  ans*=a;//数字太大会爆  a--;  }  for(int i=1;i\u0026lt;=b;i++){  ans/=i;  }  return ans; }  int main(){  int n;  cin\u0026gt;\u0026gt;n;  for(int i=1;i\u0026lt;=n;i++){  cout\u0026lt;\u0026lt;comb(2*i,i)/(i+1)\u0026lt;\u0026lt;endl;  }  cout\u0026lt;\u0026lt;\u0026#34;###\u0026#34;\u0026lt;\u0026lt;endl;  //下面是递推求法，不容易爆  h[1]=1;  cout\u0026lt;\u0026lt;h[1]\u0026lt;\u0026lt;endl;  for(int i=2;i\u0026lt;=n;i++){  h[i] = h[i-1]*(4*i-2)/(i+1);  cout\u0026lt;\u0026lt;h[i]\u0026lt;\u0026lt;endl;  }   return 0; } 稳定婚姻问题 Gale-Shapley算法 //POJ 3487 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std;  const int N = 30; const int inf = 1\u0026lt;\u0026lt;29; const int MOD = 2007;  typedef long long ll;  int couple; int maleLike[N][N], femaleLike[N][N]; int maleChoice[N], femaleChoice[N]; int maleName[N], femaleName[N]; char str[N]; queue\u0026lt;int\u0026gt;freemale;//目前单身的男人  int main(){  int t;  scanf(\u0026#34;%d\u0026#34;,\u0026amp;t);//数据组数  while(t--){  scanf(\u0026#34;%d\u0026#34;,\u0026amp;couple);//男女对数  while(!freemale.empty()){  freemale.pop();  }  for(int i=0;i\u0026lt;couple;i++){  scanf(\u0026#34;%s\u0026#34;,str);  maleName[i]=str[0]-\u0026#39;a\u0026#39;;//题目中是以小写字母给男人名字，转化为数字  freemale.push(maleName[i]);  }  sort(maleName, maleName+couple);//名字排序，便于字典序   for(int i=0;i\u0026lt;couple;i++){  scanf(\u0026#34;%s\u0026#34;,str);  femaleName[i]=str[0]-\u0026#39;A\u0026#39;;//女人名字是大写字母  }    for(int i=0;i\u0026lt;couple;i++){  scanf(\u0026#34;%s\u0026#34;,str);  for(int j=0;j\u0026lt;couple;j++){  maleLike[i][j]=str[j+2]-\u0026#39;A\u0026#39;;//男人喜好顺序由男人名字:女人名字列表给出;降序排列  }  }    //女士对男士的打分，添加虚拟人物，编号couple，为女士的初始对象  for(int i=0;i\u0026lt;couple;i++){  scanf(\u0026#34;%s\u0026#34;,str);  for(int j=0;j\u0026lt;couple;j++){  femaleLike[i][str[j+2]-\u0026#39;a\u0026#39;]=couple-j;//排名越前打分越高  }  femaleLike[i][couple]=0;  }  memset(maleChoice,0,sizeof(maleChoice));  //一开始男士的期望都是最喜欢的女士   for(int i=0;i\u0026lt;couple;i++){  femaleChoice[i]=couple;  }    while(!freemale.empty()){  int male=freemale.front();  //找出未配对的男士  int female=maleLike[male][maleChoice[male]];  //找出心意的女士  if(femaleLike[female][male]\u0026gt;femaleLike[female][femaleChoice[female]]){  //比现男友好  freemale.pop();  if(femaleChoice[female]!=couple){  //前男友再次单身，并且不能将虚拟人物加入队列  freemale.push(femaleChoice[female]);  maleChoice[femaleChoice[female]]++;  }  femaleChoice[female]=male;  //更换男友  }  else  maleChoice[male]++;  //如果被拒绝，则选择下一位  }  for(int i=0;i\u0026lt;couple;i++){  printf(\u0026#34;%c%c\\n\u0026#34;,maleName[i]+\u0026#39;a\u0026#39;, maleLike[maleName[i]][maleChoice[maleName[i]]]+\u0026#39;A\u0026#39;);  }  if(t) puts(\u0026#34;\u0026#34;);   }   return 0; } 树 树状数组 //树状数组  #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #define MAXN 500005  using namespace std;  int arr[MAXN]; int bit[MAXN];  int n,m;  inline int lowbit(int n){  return n\u0026amp;(-n); }  void update(int p, int k){  for(;p\u0026lt;=n;p+=lowbit(p)){  bit[p]+=k;  } }  long long query(int p){  int ans=0;  for(;p;p-=lowbit(p)){  ans+=bit[p];  }  return ans; }  int main(){  scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m);  //数组长度，查询数  for(int i=1;i\u0026lt;=n;i++){  scanf(\u0026#34;%d\u0026#34;,\u0026amp;arr[i]);  update(i,arr[i]);  }   for(int i=1;i\u0026lt;=m;i++){  int op;  int x,y,k;  scanf(\u0026#34;%d\u0026#34;,\u0026amp;op);  scanf(\u0026#34;%d\u0026#34;,\u0026amp;x);  if(op==1){  scanf(\u0026#34;%d\u0026#34;,\u0026amp;k);  //将单点增加k，如果想要改成修改，则可以update(x,-arr[x]+k)  update(x,k);  }  else{  scanf(\u0026#34;%d\u0026#34;,\u0026amp;y);  //输出[x,y]的数组和  cout\u0026lt;\u0026lt;query(y)-query(x-1)\u0026lt;\u0026lt;endl;  }  }  return 0; } 树状数组求逆序对 //Luogu P1908 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt;  #define LL longlong  const int MAXN = 500005;  LL arr[MAXN]; LL n;  struct Par{  LL value,id; }par[MAXN];  bool cmp(const Par\u0026amp; a,const Par\u0026amp; b){  if(a.value!=b.value) return a.value\u0026lt;b.value;  return a.id\u0026lt;b.id; }  LL bit[MAXN];  inline LL lowbit(LL n){  return n\u0026amp;(-n); }  void update(LL p, LL k){  for(;p\u0026lt;=n;p+=lowbit(p)){  bit[p]+=k;  } }  long long query(LL p){  LL ans=0;  for(;p;p-=lowbit(p)){  ans+=bit[p];  }  return ans; }  int main(){  std::cin\u0026gt;\u0026gt;n;   for(int i=1;i\u0026lt;=n;i++){  std::cin\u0026gt;\u0026gt;par[i].value;  par[i].id = i;  }   std::sort(par+1,par+1+n,cmp);   for(int i=1;i\u0026lt;=n;i++){  arr[par[i].id] = i;  }//这一步其实是离散化   LL ans = 0;   for(int i=1;i\u0026lt;=n;i++){  ans += query(arr[i]);  update(arr[i],1);  }   ans = n*(n-1)/2-ans;//本来统计的是等于或顺序对，现在反过来计算逆序对   std::cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;;   return 0; } 并查集 //并查集  #include \u0026lt;iostream\u0026gt; using namespace std;  const int MAXN = 1005;  int find_sets[MAXN];  int findf(int x){  return find_sets[x]==x ? x : find_sets[x] = findf(find_sets[x]); }  void unionSet(int x, int y){  x = findf(x);  y = findf(y);  find_sets[x] = y; }  int main(){  int n;  cin\u0026gt;\u0026gt;n;  //点数  for(int i=1;i\u0026lt;=n;i++){  find_sets[i]=i;  }  int m;  cin\u0026gt;\u0026gt;m;  //边数  for(int i=1;i\u0026lt;=m;i++){  int a,b;  cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;  find_sets[b] = a;  }  cout\u0026lt;\u0026lt;findf(5)\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;findf(8)\u0026lt;\u0026lt;endl;  unionSet(5,8);  cout\u0026lt;\u0026lt;findf(5)\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;findf(8)\u0026lt;\u0026lt;endl;  return 0; }  /* 8 6 1 2 1 3 3 4 3 5 6 7 7 8 */ 线段树 //luogu 3372 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt;  using namespace std;  typedef long long ll;  const int MAXN = 100005;  ll st[MAXN*4+2];//对于一颗线段树，n个数所组成的树最多有4n-5个节点，开大了一点 ll tag[MAXN*4+2]; ll arr[MAXN];  void build(int s, int t, int p){//区间左端点、右端点、区间编号  if(s==t){  st[p] = arr[s];  return;  }  int m = s+((t-s)\u0026gt;\u0026gt;1);//写成(s+t)\u0026gt;\u0026gt;1可能会爆  build(s,m,p*2);  build(m+1,t,p*2+1);  st[p] = st[p*2]+st[p*2+1]; }  void update(int l, int r, int s, int t, int p, ll c){//c表示加减的数值  if(l\u0026lt;=s\u0026amp;\u0026amp;t\u0026lt;=r){  st[p]+=(t-s+1)*c;  tag[p]+=c;  return;  }  ll m = s + ((t-s)\u0026gt;\u0026gt;1);  if(tag[p]\u0026amp;\u0026amp;s!=t){  st[p*2] += (m-s+1)*tag[p];  st[p*2+1] += (t-m)*tag[p];  tag[p*2] += tag[p];  tag[p*2+1]+= tag[p];  tag[p]=0;  }  if(l\u0026lt;=m) update(l, r, s, m, p*2, c);  if(r\u0026gt;m) update(l, r, m+1, t, p*2+1, c);  st[p] = st[p*2] + st[p*2+1]; }  ll query(int l, int r, int s, int t, int p){  //查询[l,r]的和  if(l\u0026lt;=s\u0026amp;\u0026amp;t\u0026lt;=r){  return st[p];  }  ll sum=0;  ll m = s+((t-s)\u0026gt;\u0026gt;1);  if(tag[p]){  st[p*2] += (m-s+1)*tag[p];  st[p*2+1] += (t-m)*tag[p];  tag[p*2] += tag[p];  tag[p*2+1]+= tag[p];  tag[p]=0;  }  if(l\u0026lt;=m) sum+=query(l,r,s,m,p*2);  if(r\u0026gt;m) sum+=query(l,r,m+1,t,p*2+1);  return sum; }  int main(){  int n,m;  scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m);  //数组长度，查询次数  for(int i=1;i\u0026lt;=n;i++){  scanf(\u0026#34;%ld\u0026#34;,\u0026amp;arr[i]);   }  build(1,n,1);   for(int i=1;i\u0026lt;=m;i++){  int ope;  cin\u0026gt;\u0026gt;ope;  if(ope==1){  int x,y,z;  scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;z);  //[x,y]加上z  update(x, y, 1, n, 1, z);  }  else{  int x,y;  scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;x,\u0026amp;y);  //查询[x,y]的和  cout\u0026lt;\u0026lt;query(x, y, 1, n, 1)\u0026lt;\u0026lt;endl;  }  }   return 0; } 单调数据结构 单调栈 给出模板，以下是一个维护栈内单调不增的代码\nint arr[MAXN]; int stk[MAXN];  int top = 0;  for(int i=1;i\u0026lt;=n;i++){  while(top\u0026amp;\u0026amp;arr[stk[top]]\u0026lt;arr[i]){  //在这里进行一些操作  top--;  }   stk[++top] = i; } 单调队列 给出滑动窗口的模板，单调队列通常会使用双端队列。滑动窗口即给出一个长度为\\(n\\)的数组，以及一个长度为\\(k\\)的窗口，从左向右滑动，求出窗口中的最小值和最大值\nint arr[MAXN];  int main(){  int n,k;  std::cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k;   for(int i=1;i\u0026lt;=n;i++){  std::cin\u0026gt;\u0026gt;arr[i];  }   std::deque\u0026lt;int\u0026gt; dq;   for(int i=1;i\u0026lt;k;i++){  while(!dq.empty()\u0026amp;\u0026amp;arr[dq.back()]\u0026gt;=arr[i]) dq.pop_back();  dq.push_back(i);  }   for(int i=k;i\u0026lt;=n;i++){  while(!dq.empty()\u0026amp;\u0026amp;arr[dq.back()]\u0026gt;=arr[i]) dq.pop_back();  dq.push_back(i);  while(dq.front()\u0026lt;=i-k) dq.pop_front();  std::cout\u0026lt;\u0026lt;arr[dq.front()]\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  }   std::cout\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;;   dq.clear();   for(int i=1;i\u0026lt;k;i++){  while(!dq.empty()\u0026amp;\u0026amp;arr[dq.back()]\u0026lt;=arr[i]) dq.pop_back();  dq.push_back(i);  }   for(int i=k;i\u0026lt;=n;i++){  while(!dq.empty()\u0026amp;\u0026amp;arr[dq.back()]\u0026lt;=arr[i]) dq.pop_back();  dq.push_back(i);  while(dq.front()\u0026lt;=i-k) dq.pop_front();  std::cout\u0026lt;\u0026lt;arr[dq.front()]\u0026lt;\u0026lt;\u0026#34; \u0026#34;;  }   return 0; } 倍增 ST表 对于经典的RMQ（即给定一个数组，求区间内的最大值）问题，有如下代码\n//luogu P3865 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt;  const int MAXN = 100005; const int LOGN = 21;  int fmax[MAXN][LOGN+1]; //fmax[a][b]表示[a,a+2^b-1]中的最大值 int logn[MAXN]; //预先计算logn  int main(){  int n,m;  //数组大小以及查询次数  scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m);   for(int i=1;i\u0026lt;=n;i++){  scanf(\u0026#34;%d\u0026#34;,\u0026amp;fmax[i][0]);  }   logn[1] = 0;  logn[2] = 1;   for(int i=3;i\u0026lt;MAXN;i++){  logn[i] = logn[i/2]+1;  //预先计算logn  }   for(int j=1;j\u0026lt;=LOGN;j++){  for(int i=1;i+(1\u0026lt;\u0026lt;j)-1\u0026lt;=n;i++){  fmax[i][j] = std::max(fmax[i][j-1],fmax[i+(1\u0026lt;\u0026lt;(j-1))][j-1]);  }  }   for(int i=1;i\u0026lt;=m;i++){  int a,b;  scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a,\u0026amp;b);  //查询[a,b]分为两部分，即[a,a+2^s-1]与[b-2^s+1,b]  int s = logn[b-a+1];  printf(\u0026#34;%d\\n\u0026#34;,std::max(fmax[a][s],fmax[b-(1\u0026lt;\u0026lt;s)+1][s]));  }   return 0; } 倍增求最近公共祖先 //luogu P3379 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstdio\u0026gt;  const int MAXN = 500005; const int LOGN = 31;  std::vector\u0026lt;int\u0026gt; edge[MAXN];//邻接表 int fa[MAXN][LOGN],deep[MAXN]; //fa[a][b]代表a的第2^b个祖先，deep是深度，根节点深度为1  void build(int v,int father){  fa[v][0] = father;  deep[v] = deep[father]+1;   for(int i=1;i\u0026lt;LOGN;i++){  fa[v][i] = fa[fa[v][i-1]][i-1];  }   for(auto v1:edge[v]){  if(v1==father) continue;  build(v1,v);  } }  int lca(int x,int y){  if(deep[x]\u0026gt;deep[y]) std::swap(x,y);  //保证y比x深   int tmp = deep[y]-deep[x];  for(int i=0;tmp;i++,tmp\u0026gt;\u0026gt;=1){  if(tmp\u0026amp;1) y=fa[y][i];  }   if(x==y) return y;   for(int i=LOGN-1;i\u0026gt;=0\u0026amp;\u0026amp;y!=x;i--){  if(fa[x][i]!=fa[y][i]){  x = fa[x][i];  y = fa[y][i];  }  }   return fa[y][0]; }  int main(){  int n,m,s;  scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;s);  //点数，询问数，根节点序号   for(int i=1;i\u0026lt;=n-1;i++){  int a,b;  scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a,\u0026amp;b);  //读入树  edge[a].push_back(b);  edge[b].push_back(a);  }   build(s,0);   for(int i=1;i\u0026lt;=m;i++){  int x,y;  scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;x,\u0026amp;y);  //查询x,y的最近公共祖先  printf(\u0026#34;%d\\n\u0026#34;,lca(x,y));  }   return 0; } 二分 二分答案 给出一个通用代码\nint l = 0; int r = MAXR;  while(l+1\u0026lt;r){  int mid = (l+r)\u0026gt;\u0026gt;1;  if(judge(mid)) l=mid;  else r = mid; }  if(judge(l)) std::cout\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; else std::cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0026#34;\\n\u0026#34;; judge函数应该根据题意写出。\n如果是浮点数的二分，则不推荐使用EPS进行精度判断（有可能会丢精度）。而是使用计数器，一般迭代100次就能保证符合题目要求。\n概率论 处理分数期望、概率 有时候，题目中的期望是一个分数\\(\\frac{P}{Q}\\)，而为了防止精度问题，往往会要求输出一个\\(R\\)，满足\n\\[ R\\times Q\\equiv P(mod\\ 998244353) \\]\n此时\n\\[ R = (P\\times Q^{-1})\\%998244353 \\]\n\\(Q^{-1}\\)是\\(Q\\)在模\\(998244353\\)意义下的乘法逆元\nC++ STL用法 std::swap 交换两个元素的内容（也可以交换数组，不重要不介绍）。复杂度：常数。\nint a,b; std::swap(a,b); 注意其中的两个参数，类型要相同。不能一个是LL一个是int。\nstd::sort 对数组、vector等进行排序。复杂度nlogn。\nint a[5]; std::vector\u0026lt;int\u0026gt; vec(5); std::sort(a,a+5); std::sort(vec.begin(),vec.end()); 注意排序范围是左闭右开区间。\n通常会按照类型的\u0026lt;操作符来进行比较。如果对结构体进行排序，可以重载运算符或者设定cmp函数。注意这两种方法一定不能是小于等于或者大于等于的运算，必须只使用小于号或者大于号（严格弱序）。\nbool cmp(const Type1\u0026amp; a, const Type2\u0026amp; b); //然后在sort中加入第三个参数 std::sort(a,a+5,cmp);  struct node{  bool operator\u0026lt;(const node\u0026amp; a); }; //不用添加cmp参数 std::lower_bound,std::upper_bound 对某个已经排序好的数组，查找第一个大于等于（lower_bound）或者大于(upper_bound)某个给定值的元素。复杂度：logn。\nint a[5]={0,1,3,4,6}; int first = std::lower_bound(a,a+5,3); 同样是左闭右开区间，第三个参数是指定的值。如果找到就会返回所查找元素的迭代器（或者指针）。找不到就会返回末尾元素的后一个指针（或者end迭代器）。\n如果需要自定义比较方法，同sort函数。\nstd::max,std::min 对于两个元素返回最大值和最小值。复杂度：准确一次比较。\nint a=1,b=2; int maxv = std::max(a,b); int minv = std::min(a,b); 同样，两个参数类型相同。自定义比较方法同sort。\nstd::abs 计算绝对值。复杂度：文档没写但应该是常数。\nint a = -1; int b = std::abs(a); 注意，函数只有float,double,long double的返回值类型。使用时如果给予整数参数会自动转换，这是否会导致精度问题有待观察。\nstd::string ::swap 将两个字符串互换。复杂度：常数。\nstd::stringstr = \u0026#34;123456\u0026#34;; std::stringstr2 = \u0026#34;456789\u0026#34;; str.swap(str2); ::begin,std::end 返回字符串的起始得带器和结尾迭代器。\nstr.begin();str.end(); ::size 返回字符串的大小。\nstr.size(); ::push_back 向字符串末尾添加一个字符，同时大小加一。复杂度：常数。\nstr.push_back(\u0026#39;a\u0026#39;); ::pop_back 将字符串末尾的字符弹出，同时大小减一。如果字符串为空则未定义。复杂度：常数。\nstr.pop_back(); ::find 在字符串中寻找某个子串是否存在。复杂度：没有规定，编译器不一定都是使用的kmp算法。\nstd::string::size_typen; std::strings = \u0026#34;this is a string\u0026#34;;  n = s.find(\u0026#34;is\u0026#34;); 如果找到则返回首个匹配的首字母位置。否则返回std::string::npos。如果是int n作为s.find的接收端，则会在找不到时接收到-1。\nstd::memset 将值复制到dest所指对象的前count个字节中。复杂度：没有规定。\nint a[20]; std::memset(a,0,sizeof(a)); 注意，赋的值不能随便取，这个函数是一个字节一个字节地去赋值的。如果取1并不会得到全部赋值为1的效果，通常只会取0和-1。\nstd::map map是有序键值对容器，通常用红黑树实现。元素的键是唯一的。\ntemplate\u0026lt;  class Key,  class T,  class Compare = std::less\u0026lt;Key\u0026gt;,  class Allocator = std::allocator\u0026lt;std::pair\u0026lt;const Key, T\u0026gt; \u0026gt; \u0026gt; class map; 可以通过迭代器来遍历\nfor(std::map\u0026lt;int,int\u0026gt;::iterator it = mp.begin();it!=mp.end();it++); //访问元素用it-\u0026gt;first和it-\u0026gt;second //或者 for(auto it:mp); //访问元素用it.first和it.second 自定义比较函数 map通常会按照key的大小关系进行升序排列。如果要自定义比较函数，则\nstruct cmp{  bool operator()(const int\u0026amp; a, const int\u0026amp; b) const{  return a\u0026gt;b;  } };  std::map\u0026lt;int,std::string,cmp\u0026gt; mp; ::empty 检测是否为空。\n::size 返回大小。\n::clear 清除所有内容。复杂度：线性。\n::erase 提供迭代器，删除迭代器所指的键值对。复杂度：常数。\nauto it = mp.begin(); mp.erase(it); ::find 寻找key等于给定值的元素，返回迭代器。如果没有找到则返回end迭代器。复杂度：对数。\nauto it = mp.find(1); ::lower_bound,::upper_bound 寻找首个大于等于(或大于，对upper_bound)给定值的key。复杂度：对数。\nauto it = mp.lower_bound(1); std::unordered_map 可以看作是无序的map，通常由哈希表实现。这意味着map中和排序有关的函数都不能使用。\nstd::set set是关联容器，含有Key类型对象的已排序集，通常用红黑树实现。\ntemplate\u0026lt;   class Key,  class Compare = std::less\u0026lt;Key\u0026gt;,  class Allocator = std::allocator\u0026lt;Key\u0026gt; \u0026gt; class set; 遍历的方式与map相同。\n使用方法 自定义比较函数,empty,size,clear,erase,find,lower_bound,upper_bound都与map相同。\nstd::unordered_set 用哈希实现，没有内部排序。\nstd::stack 栈，有先入后出特性。\n::top 访问栈顶元素，复杂度：常数。\n::empty 检查是否为空，复杂度：常数\n::size 返回元素个数，复杂度：常数\n::push 将元素推入栈，复杂度：通常和deque的push_back相同，即常数\n::pop 将栈顶弹出，复杂度：通常和deque的pop_back相同，即常数\n::emplace 在顶部原位构造元素，通常会用在栈的元素是结构体的时候，复杂度：通常和deque的emplace_back相同，即常数\nstd::queue 队列，拥有先入先出特性。\n::front 访问队首元素，复杂度：常数\n::back 访问队尾元素，复杂度：常数\n其他方法 同stack，不过push是推入队尾，pop是弹出队首。\nstd::priority_queue 优先队列，提供常数时间的最大（或最小）元素查找，以及对数时间的插入与删除。\n自定义比较方法 通常我们会重载元素的运算符来自定义\nstruct node {  int dis, u;  bool operator\u0026gt;(const node\u0026amp; a) const { return dis \u0026gt; a.dis; } };  priority_queue\u0026lt;node, vector\u0026lt;node\u0026gt;, greater\u0026lt;node\u0026gt; \u0026gt; pq; 方法 其方法与stack相同，只不过没有先入后出特性，插入元素或弹出元素后会根据大小关系进行排序，保证栈顶是最大的（或最小的）元素。\nstd::deque 双端队列，允许在队首和队尾进行插入和删除。另外，在 deque 任一端插入或删除不会非法化指向其余元素的指针或引用。通常也会用来实现单调队列。\n方法 size、empty与stack、queue相同。其pop_back、push_back、pop_front、push_front、emplace_front、emplace_back用法也类似。\nstd::vector 通常可以理解为一个可以变化长度的数组。\n声明方法 std::vector\u0026lt;int\u0026gt; vec;//声明一个初始大小为0的vector std::vector\u0026lt;int\u0026gt; vec2(n);//声明一个初始大小为n的vector，每个元素都会初始化为0 std::vector\u0026lt;int\u0026gt; vec3(n,1);//与上一个不同的是，每一个元素都会初始化为1 元素访问 vec[5];//像数组一样访问 vec.at(5);//与上一个方法的差别在会进行越界检查 vec.front();//访问第一个元素 vec.back();//访问最后一个元素 ::size 获取大小，复杂度：常数\n::empty 查看是否为空，复杂度：常数\n::push_back 向末尾添加元素，复杂度：常数\n::pop_back 把末尾元素弹出，复杂度：常数\n::emplace_back 在末尾原位构造元素，复杂度：常数\nstd::vector 这是一个特化的vector，它每一个元素所占的空间是一位，而不是sizeof(bool)（通常是一字节）。\nstd::bitset 表示一串二进制位。\n声明方法 std::bitset\u0026lt;100\u0026gt; bs;//声明一个位数为100位的bitset std::bitset\u0026lt;4\u0026gt; bs2{0xA};//声明一个四位的bitset，其值等于0xA 元素访问 同数组的访问方式。同样也可以用数组的方式进行修改。\n::all,::any,::none 检查是否全部，存在、没有元素被设置为true。\n::count 返回设置为true的数量。\n运算 bitset和bitset之间能用所有的位运算符。也可以用等号和不等号比较。\n::flip 翻转某一位的值。\n::to_string 转化为二进制数的字符串。\n::to_ulong,::to_ullong 转化为unsigned long和unsigned long long。\nstd::pair 定义一个二元组，例如std::pair\u0026lt;int,int\u0026gt;, std::pair\u0026lt;int,std::string\u0026gt;等。其定义是在\u0026lt;utility\u0026gt;中，但是也可以#include \u0026lt;algorithm\u0026gt;来使用\n元素访问 std::pair\u0026lt;int,int\u0026gt; p; p-\u0026gt;first;//访问第一个元素 p-\u0026gt;second;//访问第二个元素 ::swap 交换两个元素的内容。复杂度：没有定义。\nstd::make_pair auto p = std::make_pair(1,1);//自动推断类型为std::pair\u0026lt;int,int\u0026gt; std::tuple 定义一个多元组，可以说pair是tuple的特例。其定义是在\u0026lt;utility\u0026gt;中，但是也可以#include \u0026lt;algorithm\u0026gt;来使用\n元素访问 根据下标可以如下访问\nauto t = std::make_tuple(1, \u0026#34;Foo\u0026#34;, 3.14); std::get\u0026lt;0\u0026gt;(t);//1 std::get\u0026lt;1\u0026gt;(t);//Foo std::get\u0026lt;2\u0026gt;(t);//3.14 std::make_tuple 同pair。\n如果一个函数要返回tuple\nstd::tuple\u0026lt;int, int\u0026gt; foo_tuple()  {  return {1, -1}; // N4387 前错误  return std::tuple\u0026lt;int, int\u0026gt;{1, -1}; // 始终有效  return std::make_tuple(1, -1); // 始终有效 } 需要注意兼容性，有些编译器不支持第一种返回方式。\nstd::tie 将tuple解包。\nauto t = std::make_tuple(1,2,\u0026#34;Foo\u0026#34;); int a,b; std::stringstr; std::tie(a,b,str) = t; 当然也可以用auto，都不需要指定变量类型。\nauto[c,d,str2] = t; ","date":"2021-12-18T15:57:37+08:00","permalink":"https://kegalas.top/p/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/","title":"算法竞赛常用模板整理"},{"content":"网络设备管理 题目描述 ​\t叮叮叮！网络设备管理员欢欢在行动\n​\t欢欢就职于一家庞大的数据管理分析公司\n​\t公司有一个存储数据的庞大网络，把每个数据存储器看做一个节点，这个存储网络可以看做是一个树型结构，每天有庞大的数据流在节点之间穿梭\n​\t随着公司的发展，这个网络越来越庞大，数据的传输速度也越来越慢，通过研究，欢欢发现，每个节点的传输速度，只与与这个节点连接的节点数量有关，比如仅和一个节点连接的节点传输数据会很快，而和 100 个节点连接的节点传输数据会很慢\n​\t欢欢准备提交一份研究报告，报告将会指出，若对于网络中的所有节点，与该节点相连的节点数量不超过 d，那么网络的整体传输速度将会大幅提高。\n​\t欢欢准备通过添加新的网络设备来降低与某节点相连的节点的数量\n​\t简而言之，对于网络设备a，我们可以添加新的设备b，使得原来与a相连的若干节点断开与a的连接并与b连接，并且使a,b连接，显然，添加新的网络设备后，这个网络仍旧是一个树形结构这样通过添加若干新的网络设备，我们可以把所有网络设备的相连网络设备数量降低到不超过d台 (包括与新添加的网络设备相接的网络设备数量不超过 d)\n​\t欢欢发现，有很多种解决方案\n​\t聪明的你知道欢欢最少添加多少台网络设备吗？\n​\t注意: 欢欢添加新的设备后，网络的结构仍保持为树形结构\n输入 ​\t单组输入 ​\t第一行两个正整数 $n$, $d$ $(1\\le n\\le 10^5,3\\le d\\le n)$ ​\t接下来$n-1$行，每行两个正整数$a$,$b$ $(1\\le a, b\\le n)$，说明设备$a$与设备$b$相连接，数据保证设备网络为树形结构。\n输出 ​\t一个正整数，最小添加的网络设备数量，注意欢欢可以添加0台设备。\n样例    样例输入 样例输出     10 32 13 14 15 26 17 68 59 710 6 1    AC代码 #include \u0026lt;iostream\u0026gt;#define MAXN 100005  using namespace std; int arr[MAXN]; int main(){ int n,d; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;d; for(int i=1;i\u0026lt;n;i++){ int a,b; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a,\u0026amp;b); arr[a]+=1; arr[b]+=1; } int ans=0; for(int i=1;i\u0026lt;=n;i++){ if(arr[i]\u0026gt;d){ int tmp = (d-1)*2; if(arr[i]-tmp\u0026lt;=0){ ans+=1; } else if((arr[i]-tmp)%(d-2)==0) ans += 1 + (arr[i]-tmp)/(d-2); else ans += 1 + (arr[i]-tmp)/(d-2)+1; } } cout\u0026lt;\u0026lt;ans; return 0; } 正确性证明 先给出样例的示意图\n\r样例图\r\n其中红色数字表示与这个节点直接相连的节点的个数。显然只有1号节点连了大于3个节点，我们可以新增一个节点A，将2、3号与A相连，4、6号不变，然后将1与A相连，现在1与A连了三个节点，符合要求。不过这不是唯一的连法。\n这种有最大连接节点的结构，很容易让人回想起烷烃。显然的，饱和烷烃的碳链无论怎么排布，所连的氢原子的数目不会改变。每个碳原子也都会连四个原子。\n类比到这道题，我们要做的，就是将形如下图的点（假设上限为连3个）\n\r2\r\n变为如下的一些点，当然这里的点怎么排布都不影响，只要他最大的利用了链接上限，就是答案。\n\r3\r\n解释一下核心代码\nfor(int i=1;i\u0026lt;=n;i++){ if(arr[i]\u0026gt;d){//枚举超过链接上限的节点  int tmp = (d-1)*2; //点链两端，能“向外”链接d-1个点，必须要向“内部”链接一个点，才能构成点链，这个arr[i]-tmp得到的是还需要“向外”链接的数量。  if(arr[i]-tmp\u0026lt;=0){//特判一下，如果只用新增一个节点，并且有一个节点没有占满上限  ans+=1; } else if((arr[i]-tmp)%(d-2)==0)//内部每个节点都只能“向外”链接d-2个节点，如果能全部占满每个内部节点的上限，ans如下  ans += 1 + (arr[i]-tmp)/(d-2); else//不能占满则ans如下  ans += 1 + (arr[i]-tmp)/(d-2)+1; } ","date":"2021-11-21T14:53:54+08:00","image":"https://kegalas.top/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/1_hue13a31d22502e6414becf06d466eec8f_119570_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/","title":"算法题-网络设备管理"},{"content":"向量 题目描述 ​ 给你n个向量，请问是否可以通过旋转异或伸缩任意一个向量，使得这n个向量相加等于0向量。 ​\n​ 注意，在本题中，我们认为0向量只能伸缩为0向量，非0向量可以伸缩为0向量、方向相同长度任意的向量、方向相反长度任意的向量。\n输入 ​ 单组输入\n​ 第一行一个正整数 $n(1\\le n\\le 10^5)$，即向量的个数。\n​ 接下来$n$行，每行两个整数$x_i$, $y_i$ $(0\\le |x_i|,|y_i|\\le 10^9)$，分别代表第$i$个向量$x$轴与$y$轴的大小方向。\n数据保证\n$$\\sum_{i=1}^{n}(|x_i|+|y_i|)\\le 10^9$$\n输出 ​ 若存在满足要求的操作输出 “yes”，反之输出 “no”。\n样例    样例输入 样例输出     3\n0 0\n1 2\n4 2 no    AC代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt;typedef long long ll; #define MAXN 100005  using namespace std; struct Vec { ll x; ll y; }; Vec vec[MAXN]; int main(){ int n; cin\u0026gt;\u0026gt;n; Vec allSum; allSum.x=0;allSum.y=0; for(int i=1;i\u0026lt;=n;i++){ cin\u0026gt;\u0026gt;vec[i].x\u0026gt;\u0026gt;vec[i].y; allSum.x+=vec[i].x; allSum.y+=vec[i].y; } ll ans = 0; for(int i=1;i\u0026lt;=n;i++){ if(vec[i].x==0\u0026amp;\u0026amp;vec[i].y==0) continue; Vec tmpSum = allSum; tmpSum.x-=vec[i].x; tmpSum.y-=vec[i].y; ll dis1 = tmpSum.x*tmpSum.x+tmpSum.y*tmpSum.y; ll dis2 = vec[i].x*vec[i].x+vec[i].y*vec[i].y; if(dis1==dis2) { ans=1; break; } if(vec[i].y*tmpSum.x-tmpSum.y*vec[i].x==0) { ans=1; break; } } if(ans) cout\u0026lt;\u0026lt;\u0026#34;yes\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;no\u0026#34;; return 0; } 正确性证明 首先分析题目，出题人的表达和数据结果并不一致。“是否可以通过旋转异或伸缩任意一个向量”实际上应该是“是否可以通过旋转异或伸缩某一个向量”，从而“使得这n个向量相加等于0向量”。\n数据也就$10^5$，直接枚举就行。先将所有向量加到一起记为allSum，然后建立一个tmpSum = allSum-我们当前枚举的向量，记为v。\n然后判断这个tmpSum向量是否和v长度平方相等，是则可以通过旋转v，再相加得到0向量。判断tmpSum向量终点是否和$(0,0)$和v的终点在同一直线上,是则可以通过伸缩v来达到目的。这里判断三点共线的方法是求外积。若都为否，则不可以只对v伸缩或者旋转达到目的，枚举下一个。这里注意，我上述写的代码要将0向量略过，否则0向量总是可以通过三点共线的判断，达不到目的。\n如果枚举出一个向量可以达到目的，就输出yes。如果所有向量都达不到目的，就输出no。\n","date":"2021-11-15T22:30:41+08:00","permalink":"https://kegalas.top/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%90%91%E9%87%8F/","title":"算法题-向量"},{"content":"有限小数 题目描述 ​\t现在有一个正整数n,可以证明存在若干个正整数d使得1/n在d进制下为有限小数，输出最小的d。\n输入 ​\t单组输入 ​\t第一行一个正整数$n(2\\le n\\le 10^{12})$\n输出 ​\t一个正整数d\n样例    输入 输出     9 3   999 111    AC代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;cmath\u0026gt; using namespace std; int main(){ long long n; cin\u0026gt;\u0026gt;n; long long ans=1; long long tmp=n; //求n的质因数的乘积  for(long long i=2;i*i\u0026lt;=tmp;i++){ if(tmp%i==0){ ans*=i; while(tmp%i==0){ tmp/=i; } } } if(tmp\u0026gt;1) ans*=tmp; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } 正确性证明 ​\t若$1/n$可以在d进制表达为有限小数，那么一定有：\n​\t$$\\frac{1}{n}=\\frac{a_1}{d}+\\frac{a_2}{d^2}+\\dots+\\frac{a_m}{d^m}$$\n​\t其中$a_i\u0026lt;d(1\\le i\\le m)$，且$a$为正整数，$m$是一个正整数。将两边同乘$nd^m$得：\n​\t$$d^m=n(a_1d^{m-1}+\\dots+a_md^0)$$\n故只要$d^m$是n的倍数，$1/n$在d进制下就为有限小数。\n将n进行质因数分解，由唯一分解定理知只能分解为一种形式，设d为n的质因数的乘积，易知此时总存在m使得n|$d^m$，并且显然，这个d是最小的。\n","date":"2021-11-15T16:26:01+08:00","permalink":"https://kegalas.top/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%9C%89%E9%99%90%E5%B0%8F%E6%95%B0/","title":"算法题-有限小数"},{"content":"各种主义整理 哲学、政治、社会 绝对主义 绝对主义认为在任何一种学说里，某种观点必定是绝对正确或者绝对错误的。\n荒诞主义 “荒诞主义”是对人生的极端反叛，认为人生的意义并不存在，所以可以活得很无厘头都无所谓。\n唯美主义 唯美主义者的人生目的就是去创造和享受一切美的东西。\n利他主义 利他主义者是一种随时都在无私地为他人福利着想的人，在道德判断上，认为别人的幸福快乐比自己的来得重要。利他主义在许多思想和文化中是一种美德。\n无政府主义（安那其主义） “无政府”一词并不代表混乱、虚无或道德沦丧的状态，而是一种由自由的个体自愿结合，以建立互助、自治、反独裁主义的和谐社会。庄子被认为是最早的无政府主义者。\n人类中心主义（以人为本） 人类中心主义认为人类是地球上最核心或者最重要的物种，评价现实的真实与否依靠人类的视角。人类中心主义是环境伦理学和环境哲学的主要概念，被认为是人类为何与自然环境发生冲突的根本原因，但这种理念已经根植在大多数人类的心中。\n无神论 无神论并没有统一的哲学思想，一些无神论者可能完全否定超自然事物，但另一些无神论者可能相信诸如占星术等伪科学。无神论经常同不可知论、反神论或反有神论相混淆。无神论者是认为没有神，不可知论者是认为神的存在是不可知，而反神论者是直接明确反对有神论。\n资本主义 资本主义的特色是私人拥有生产资料，且投资活动是由个人决策左右，而非由国家所控制，经济行为则以追求利润为目标。资本主义的主要经济模式包括了自由的资本和雇佣流动、市场竞争以及价格机制的运行。\n集体主义 集体主义是主张个人从属于社会，个人利益应当服从集体、民族、阶级和国家利益的一种思想理论。\n建构主义 建构主义者认为，任何一个社会人的行为都被约定俗成的社会传统、社会习惯和个人身份来制约或改变，因此现实和我们理解现实的方式都是人造的、主观的。\n犬儒主义 犬儒主义本意是指人不应被一切世俗的事物，包括宗教、礼节、惯常的衣食住行等习俗束缚，提倡对道德的无限追求，同时过着极简朴而非物质的生活。\n现代社会中“犬儒主义”一词常被误用作比喻一些否定利他主义、自私而且毫无道德的人。\n演绎主义 科学知识的产生是通过提出假设，然后通过实验和观察到的现象和数据来证明这样一个过程。\n决定论（determinism） 决定论是哲学的一种命题，认为每个事件的发生，包括人类的认知、举止、决定和行动，都是因为先前的事而有原因地发生。\n教条主义 指那些我们所相信的、不容质疑的观念。宗教上指那些具有权威性的团体所确立的教理，信徒以此作为应该学习的真理课程。\n二元论 二元论认为世界由两种力量统治：善与恶。善是精神，是灵魂，是善的力量创造的一切东西;而恶是物质，是肉体，是恶的力量创造的一切。这两种力量对抗着，共同支配世界。\n折衷主义 折衷主义是指操作运用不同的理论、方法、风格，拣选其中最佳要素，应用在新的创作中。在艺术或建筑批评等特定领域，指挪借多种视觉资源来创作新作品。\n平均主义 平均主义要求平均分享一切社会财富，对人人应该予以同样、平等对待。\n情感主义 情感主义是 20 世纪 30 年代，英美等国最流行的一种元伦理学，它否认伦理学的科学地位，主张道德是个人情感的表达，否认道德的客观性，认为道德判断没有合理的或有效的根据，没有真假之别，不过是表示某种情感、某种愿望。\n经验主义 经验主义指相信现代科学方法，认为理论应建立于对于事物的观察，通过实验研究而后进行理论归纳，优于单纯的逻辑推理、直觉或者先入为主的概念。\n副现象论（epiphenomenalism） 副现象论认为物理世界可以影响内心世界，但是反过来却不行。\n永恒论 永恒论认为时间不过是另外一个维度，明天已经存在了，只是你还没到那里而已。过去、现在、未来都一样真实。\n幸福主义 以幸福作为人生目的和理想的人生哲学。认为幸福包括物质生活和精神生活两个方面，人有追求幸福的权利，这是人的天性，人生的意义即在对于幸福的追求。\n存在主义 存在主义认为人存在的意义无法经由理性思考而得到答案，强调个人的主观经验。\n有序主义（extropy） 有序主义是相信科技进步可以解决人类问题的超人类主义思想之一。它认为随着科技的进步，总有一天人类可以得到永生。有序主义者愿意为了这个目的而努力，比如进行调查研究，志愿测试新技术等。\n女性主义 女性主义是指主要以女性经验为来源与动机的社会理论与政治运动。在对社会关系进行批判之外，许多女性主义的支持者也着重于性别不平等的分析以及推动妇女的权利、利益与议题。\n因果论（finalism） 因果论认为任何事物的发展都由预设好的既定结果来决定。\n自由意志 自由意志是指在社会、道德、政治的限制下，人们依照其拥有的条件去自主决定是否做一件事的能力。\n快乐主义 又称享乐主义。它倾向于用纯粹生物学的或心理学的观点来解释人的行为与需要，认为人们以求得快乐为生活目的，包括肉体与心灵的快乐。\n历史论 历史论认为去理解一个历史事件，我们必须考虑到当时的大环境和历史的上下文，而不是抽象地用概念去解释。\n唯心主义 唯心主义反对现实主义的哲学观，认为在人类的认知中，我们对物体的理解与感知，独立于物体的实际存在。\n个人主义 个人主义是一种道德的、政治的和社会的哲学，认为个人利益应是决定行为的最主要因素，强调个人自由和个人权利的重要性，超越集体如国家、种族、社会组织之上。\n神秘主义 也译作密契主义，包含人类与神明或某种超自然力量结合为一的各种形式、经验、体验，并且强调这是一切宗教共有的现象。神秘主义者的基本信条是世界上存在超自然的力量或隐藏的自然力量，这种力量可以通过特殊教育或者宗教仪式获得。\n自然主义 自然主义者认为自然的和超自然的都是一回事，可以用同一套方法来研究和解释。\n虚无主义 虚无主义作为哲学主义，为怀疑主义的极致形式，认为世界、生命(特别是人类)的存在是没有客观意义、目的以及可以理解的真相的。\n客观主义 在伦理学中，客观主义认为有些事情的对错是客观存在的。\n乐观主义 乐观主义是指一种对一切事物采与正面看法的观念。乐观的人不会想到一件事的缺点与瑕疵，永远以正面的想法对待身边的一切。\n泛神论 泛神论是一种将自然界与神等同起来，以强调自然界的至高无上的哲学观点。泛神论认为神就存在于自然界一切事物之中，并没有另外的超自然的主宰或精神力量。\n观点主义 观点主义认为人思想和价值判断来自不同的内心驱动和个人视角，并没有绝对的真理，只能去融合不同的观点。\n厌世主义 厌世主义，亦即悲观主义和虚无主义，是特定人群中所形成的一种无可奈何的悲观心理的反映。\n理性主义 理性主义是建立在承认人的理性可以作为知识来源的理论基础上的一种哲学方法，认为理性高于并独立于感官感知。\n相对主义 相对主义不是一个单一的学说，而是一系列观点，其共同的主题是，经验、思想、价值总是相对于其他东西而成立的，没有什么绝对的真理或评判标准。\n怀疑论 怀疑论是一种认识论，是认识问题的一种态度，它拒绝对问题作随意的不够严格的定论，对事物的看法采取一种类于“中立”的立场，既怀疑“是”也怀疑“不是”。怀疑论的反面是迷信，或更确切地说是独断论。\n斯多葛主义 斯多葛主义认为，重要的是在任何情况下都必须保持沉着，学会情感和生理的自我控制，以求得内心的平和与力量，获得更好的生活。斯多葛主义认为它的对立面激情是“背离理性和违反自然的精神冲动”。\n结构主义 结构主义认为任何一个现象都必须在知道了语境和上下文和他们之间的相互关系后才能被真正理解。\n融合主义 融合主义倡导不同宗教信仰或哲学主张之间的融合。\n有神论 广义上的有神论认为至少存在一个神明。狭义上特指一神论信仰，认为世界有一位至高的神明，关注于宇宙与这位神明之间的关系。\n功利主义 功利主义提倡追求大多数人的最大幸福，如果需要牺牲少部分人的利益也没办法。\n生命力论（活力论） 生命力论在人类历史上存在长久的历史，现代版本是19世纪初由瑞典化学家贝采利乌斯提出的，认为生命的运作，不只依循物理及化学定律。生命有自我决定的能力。\n新柏拉图主义 新柏拉图主义认为，世界有两极，一端是被称为“上帝”的神圣之光，另一端则是完全的黑暗。但新柏拉图主义也相信，完全的黑暗并不存在，只是缺乏亮光而已。\n柏拉图主义 尤指宣称理念形式是绝对的和永恒的实在，而世界中实在的现象却是不完美的和暂时的反映。\n伊壁鸠鲁学派 伊壁鸠鲁派认为并宣扬人死魂灭，这是人类思想史上的一大进步，同时提倡寻求快乐和幸福。但他们所主张的快乐决非肉欲物质享受之乐，而是排除情感困扰后的心灵宁静之乐。伊壁鸠鲁派生活简朴而又节制，目的就是要抵制奢侈生活对一个人身心的侵袭。\n斯多亚主义 斯多葛派认为世界理性决定事物的发展变化。所谓\u0026quot;世界理性\u0026quot;，就是神性，它是世界的主宰，个人只不过是神的整体中的一分子。在社会生活中斯多葛派强调顺从天命,要安于自己在社会中所处的地位，要恬淡寡欲，只有这样才能得到幸福。\n工具主义 工具主义的实践理性观可以表达为：理性指导人们的实践，是并且只是通过告诉人们采用何种必要的手段以达到既定目的来完成的，但是这些既定目的是否合适则不受理性的批判。\n世界主义 世界主义相信所有的人类都属于一个基于同样道德观念的社群，。世界主义的社群包括一个包容性的道德规范，共享的经济体制，和一个包含所有国家的政治结构。社群之中来自世界各地的人通过彼此的敬意来建立关系。\n加速主义 指一种政治与社会理论，认为资本主义制度或历史上某种技术相关的社会进程应该被加速以产生巨大社会变革。\n国际主义 国际主义是指各国无产阶级在反对剥削制度，争取自身解放斗争中，在政治、经济、道义等方面互相支持，互相援助，坚持国际团结的思想和政治原则。国际主义体现了无产阶级的民族观，是无产阶级处理民族问题的基本原则，也是无产阶级认识和处理各国无产阶级之间、各国无产阶级政党之间以及社会主义国家之间相互关系的行为准则。资本压迫和统治的国际性，决定了无产阶级反对资产阶级的斗争，从形式上看，首先是在一国范围内进行，但从内容上看，从来就是国际性的:无产阶级只有解放全人类，才能最后解放自己。\n沙文主义 沙文主义是资产阶级侵略性的民族主义。18世纪末、19世纪初产生于法国，因法国士兵沙文（Nicolas Chauvin）狂热拥护拿破仑一世的侵略扩张政策，主张用暴力建立法兰西帝国而得名。它鼓吹法兰西民族是世界上最优秀的民族，宣扬本民族利益高于一切，煽动民族之间的仇恨，主张征服和奴役其他民族。在帝国主义时代，沙文主义是帝国主义侵略和压迫其他国家和民族的舆论工具。\n民族主义 民族主义，即指以自我民族的利益为基础而进行的思想或运动。在近代以来，民族主义推动了民族解放与平等，是现代国际社会的源泉。美国学者汉斯·科恩认为：“民族主义首先而且最重要的是应该被看作是一种思想状态。”英国学者爱德华·卡尔认为：“民族主义通常被用来表示个人、群体和一个民族内部成员的一种意识，或者是增进自我民族的力量、自由或财富的一种愿望”。民族主义通常是指以维护本民族利益和尊严为出发点的思想与行为\n民粹主义 民粹主义（populism），又译平民主义，是在19世纪的俄国兴起的一股社会思潮。民粹主义的基本理论包括：强调平民群众的价值和理想，把平民化和大众化作为政治运动和政治制度合法性的最终来源；依靠平民大众对社会进行改革，并把普通群众当作政治改革的决定性力量；通过强调诸如平民的统一、全民公决、人民的创制权等民粹主义价值，对平民大众从整体上实施有效的控制和操纵。\n法西斯主义 法西斯主义（英语：Fascism；俄语：фашизм；意大利语：Fascismo；德语：Faschismus；西班牙语：Fascismo）是一种结合了社团主义、工团主义、独裁主义、极端民族主义、中央集权形式的军国主义、反无政府主义、反自由放任的资本主义、和反共产主义政治哲学；《大英百科全书》对法西斯主义的定义：“个人的地位被压制于集体—例如：某个国家、民族、种族、或社会阶级之下的社会组织。”\n纳粹主义 纳粹主义，是德文“Nationalsozialismus”缩写“Nazismus”的音译，意译为“民族社会主义”。\n纳粹主义意识形态的精神是“属于一个民族”，纳粹主义的基本理论包括：种族优秀论，“优等种族”至上；一切领域的“领袖”原则，“领袖”是国家整体意志的代表；反对英法资本主义体系以及共产主义思想体系，抵制共产主义理论。\n种族主义 种族主义是一种自我为中心的态度，认为种族差异决定人类社会历史和文化发展，认为自己所属的团体，例如人种、民族或国家，优越于其他的团体。\n修正主义 修正主义是在共产主义运动之中歪曲、篡改、否定马克思主义的一类资产阶级思潮和政治势力，是国际工人运动中打着马克思主义旗号反对马克思主义的机会主义思潮。“修正“一词来源于拉丁文reisio，意思是“修改、重新审查”。 修正主义产生于十九世纪九十年代。其社会基础是资本主义“和平”发展时期逐步形成起来的工人贵族阶层以及补充到工人阶级队伍中的小资产阶级。\n改良主义 改良主义是一种试图以非革命手段解决资本主义社会矛盾的资产阶级和小资产阶级思潮。这种思潮宣扬阶级合作，主张在保存资本主义制度的前提下，实行局部的微小的社会改良; 反对暴力革命和无产阶级专政，主张通过法令和立法途径实行社会改革，变资本主义为“普遍福利”社会。\n社会民主主义 社会民主主义是社会思潮和社会运动。它反映和代表了各国社会党 (包括社会民主党、工党) 及其国际联合组织“社会党国际” 解决社会矛盾问题、处理政治问题的共同的基本主张、基本观点、基本理论和方法，是各国社会党思想体系的统称。\n社会民主主义思潮最初于19世纪中叶诞生于欧洲，作为对资本剥削和侮辱劳动阶级的反抗运动，迄今已存在了一个半世纪之久。在一百五十余年的风风雨雨中，社会民主主义已经历了由理论到实践，由欧洲到世界的发展过程，愈益发展壮大。\n孤立主义 孤立主义，是一种外交政策。它通常由防务和经济上的两方面政策组成。在防务上，孤立主义采取不干涉原则，即除自卫战争外不主动卷入任何外部军事冲突；在经济文化上，通过立法最大程度限制与国外的贸易和文化交流。\n单边主义 所谓单边主义是指举足轻重的特定大国，不考虑大多数国家和民众的愿望，单独或带头退出或挑战已制订或商议好了的维护国际性、地区性、集体性和平、发展、进步的规则和制度，并对全局或局部的和平、发展、进步有破坏性的影响和后果的行为与倾向。\n多边主义 多边主义原是指不完全依赖俄罗斯或者独联体内部来解决问题而是谋求多边发展利用外部世界一切可能利用的因素和机会既为自己吸收更多的发展动力又可避免单方面依赖而受制于俄罗斯。现指三个或三个以上国家之间发生联系的方式。\n实用主义 冯友兰总结的实用主义主要观点最为简洁明了。在《三松堂自序》中冯说：“实用主义的特点在于它的真理论。它的真理论实际是一种不可知论。认识来源于经验，人们所能认识的，只限于经验，至于经验的背后还有什么东西，那是不可知的，也不必问这个问题。这个问题是没有意义的，因为无论怎么说，人们总是不能走出经验范围之外而有什么认识。要解决这个问题，还得靠经验。所谓真理，无非就是对于经验的一种解释，对于复杂的经验解释得通。如果解释得通，它就是真理，对于我们有用，即有用就是真理，忽略所谓客观的真理。”如此说得之，实用二字昭然若揭。\n计算机科学 符号主义 符号主义（Symbolism）是一种基于逻辑推理的智能模拟方法，又称为逻辑主义(Logicism)、心理学派(Psychlogism)或计算机学派(Computerism)，其原理主要为物理符号系统（即符号操作系统）假设和有限合理性原理，长期以来，一直在人工智能中处于主导地位，其代表人物是纽威尔、肖、西蒙和尼尔森。\n连接主义 连接主义(connectionism)，又称为仿生学派或生理学派，其主要原理为神经网络及神经网络间的连接机制与学习算法。\n行为主义 行为主义(actionism)，又称为进化主义或控制论学派，其原理为控制论及感知-动作型控制系统。\n文艺 文学 都合主义 剧情、人物、设定等为主角服务而无视因果、设定，这就是都合主义。\n魔幻现实主义 魔幻现实主义作为拉丁美洲所特有的文学样式，它具有与众不同的鲜明而独特的特征。将新闻报道般的写实与神奇的幻想结合起来，采用模糊化技巧和神话模式，表现拉丁美洲的历史文化和现实生活。这是魔幻现实主义突出的艺术特征。\n美术 浪漫主义 这一画派摆脱了当时学院派和古典主义的羁绊，偏重于发挥艺术家自己的想象和创造，创作题材取自现实生活，中世纪传说和文学名著（如莎士比亚、但丁、歌德、拜伦的作品）等，有一定的进步性。\n印象派 不依据可靠的知识，以瞬间的印象作画。画家们是抓住一个具有特点的侧面去作画，所以他们必须疾飞画笔把颜色直接涂在画布上，他们只能多考虑画的总体效果，较少的顾及枝节细部。印象主义的以粗放的笔法作画，作品缺乏修饰，是一种对笔法较草率的画法。\n印象主义采取在户外阳光下直接描绘景物，追求以思维来揣摩光与色的变化，并将瞬间的光感依据自己脑海中的处理附之于画布之上，这种对光线和色彩的揣摩也是达到了色彩和光感美的极致。\n画家：莫奈、马奈、毕沙罗、雷诺阿、 西斯莱、德加、科罗、莫里索、巴齐约\n点彩派（新印象派） 他们不用轮廓线划分形象，而用点状的小笔触，通过合乎科学的光色规律的并置，让无数小色点在观者视觉中混合，从而构成色点组成的形象，被一些艺术评论家称作“点彩派”。\n画家：乔治·修拉、保罗·西涅克、卡米尔·毕沙罗、M. 吕斯、H.-E.克罗斯\n新艺术派 简单讲就是喜欢画些清新脱俗的花草纹样，而且喜欢勾线，还经常画得扁扁平平的。女人头上长花是常有的事，当然，驴头上也可以长。\n画家：慕夏\n野兽派 顾名思义，就是像野兽一样狂放，这一派画家基本是不调色的，颜料挤出来就直接用，而且形状也是粗矿得很。国内的幼儿园墙画深得这种风格的真传。\n画家：马蒂斯\n风格派 风格派完全拒绝使用任何的具象元素，主张用纯粹几何形的抽象来表现纯粹的精神。认为抛开具体描绘,抛开细节，才能避免个别性和特殊性，获得人类共通的纯粹精神表现。\n画家：蒙德里安\n构成主义 简单讲，这个派别特备喜欢画立体块块和几何图形，而且喜欢乱摆。\n画家：里茨斯基\n超现实主义 简单讲就是觉得现实不重要，专门画现实里没有的东西。比如，为什么驴就不能长得像鱼呢？\n画家：达利\n表现主义 表现主义是艺术家通过作品着重表现内心的情感，而忽视对描写对象形式的摹写，因此往往表现为对现实的扭曲和抽象化，这个做法尤其用来表达恐惧的情感，因此，主题欢快的表现主义作品很少见。\n画家：席勒\n抽象表现主义 抽象表现主义是指一种结合了抽象形式和表现主义画家情感价值取向的非写实性绘画风格。\n该运动存在着多样的绘画风格，画风多半大胆粗犷、尖锐且尺幅巨大。画作色彩强烈，并经常出现偶然效果，例如让油彩自然流淌而不加以限制。\n画家：波洛克\n立体派 主要目的是追求一种几何形体的美，在形式的排列组合所产生的美感。 它否定了从一个视点观察事物和表现事物的传统方法，把三度空间的画面归结成平面。因为把不同视点所观察和理解的形诉诸于画面，从而表现出时间的持续性。\n画家：毕加索\n未来派 未来派全盘否定传统文艺的价值，认为人类的文化遗产和现存的文化都是腐朽、僵死，与现时代的精神不相容的。他们的口号是“摒弃一切博物馆、图书馆和学院”，反对一切模仿的形式，反抗和谐和趣味高雅，否定艺术批评的作用。未来派的美学主张与表现主义、立体主义有相同的地方，只是他们特别强调表现运动和力量，口号更激烈，纲领更明确，虚无主义的色彩更浓郁。\n他们觉得不能只表现静态的东西，画什么都要动起来、嗨起来，所以一个驴子可能带着七八个形状各异的残影。\n画家：波丘尼\n达达主义 达达主义是20世纪初期在欧洲兴起的虚无主义运动，是一种无政府主义的艺术运动，其艺术特点如下:\n1.反传统观念，公开蔑视文学艺术的一切现有形式，反秩序，反系统化\n2.运用理性的方法抨击人类，将人性化的内容与机械原理结合起来，并使用现成品作为艺术创作\n3.艺术手法抽象怪异，完全突破了已有的艺术观念和形式的束缚，被认为是后现代主义的创作者\n4.代表画家 杜尚，法国艺术家，被誉为\u0026quot;现代艺术的守护神\u0026quot;，其代表作是《下楼梯的裸女二号》，《泉》\n波普艺术 波普艺术，一种主要源于商业美术形式的艺术风格，其特点是将大众文化的一些细节，如连环画、快餐及印有商标的包装进行放大复制。\n画家：安迪·沃霍尔\n极简主义 顾名思义就是能省就省，企图以最少的东西表达最多的含义，能用一双眼睛搞定何必要画一整头驴呢？\n画家：纽曼\n概念艺术 概念艺术就是在20世纪60年代中后期出现，其基本概念源于马塞尔·杜尚的思想：一件艺术品从根本上说是艺术家的思想，而不是有形的实物，即绘画和雕塑；有形的实物出自那种思想。这种艺术导致以观念取代实物、是艺术摆脱物质的艺术品。\n画家：杜尚\n后现代主义 是一种对现代表达方式甚至思维方式以及价值观的颠覆和反叛。\n音乐 巴洛克时期 音乐领域中的巴洛克时期，如同其他艺术领域一样，也体现了各种不同的风格。 这段时期的音乐中没有太多的思想，讲究韵律的优美。歌剧、清唱剧和大合唱是声乐方面最重要的一些新形式，而奏鸣曲、协奏曲和前奏曲则是为器乐而创作的。\n古典主义时期 其特点是：理智和情感的高度统一，深刻的思想内容与完美的艺术形式的高度统一。创作技法上，继承欧洲传统的复调与主调音乐的成就，并确立了近代奏鸣曲曲式的结构以及交响曲、协奏曲、各类室内乐的体裁和形式，对西洋音乐的发展有深远影响。\n浪漫主义时期 这个时期艺术家的创作上则表现为对主观感情的崇尚，对自然的热爱和对未来的幻想。艺术表现形式也较以前有了新的变化，出现了浪漫主义思潮与风格的形成与发展。\n\r\r\r注：本文有许多内容搜集自互联网，若有侵权请联系删除。\n","date":"2021-01-17T23:25:28Z","permalink":"https://kegalas.top/p/%E5%90%84%E7%A7%8D%E4%B8%BB%E4%B9%89%E6%95%B4%E7%90%86/","title":"各种主义整理"},{"content":"系统：Ubuntu 20.10\n今天使用Ubuntu，想安装一下deepin的qq，在网上找到以下方法：\nwget -O- https://deepin-wine.i-m.dev/setup.sh | sh 正常执行\nsudo apt-get install com.qq.im.deepin 报错：\n下列软件包有未满足的依赖关系：\rlibgirepository-1.0-1 : 破坏: python-gi (\u0026lt; 3.34.0-4~) 但是 3.30.4-1 正要被安装\rE: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。 我试着安装python-gi，同样报错，我又试着删了libgirepository-1.0-1，但是他是很多包的依赖，不敢删。\n百度搜索无果，bing搜索外国也没找到解决办法，倒是有人遇到了同样的问题。\n在ubuntu搜集信息后，发现libgirepository-1.0-1依赖于libffi7，但是apt下载不到他，只能去https://packages.ubuntu.com/zh-cn/focal/libffi7手动下载。安装完后又去https://packages.ubuntu.com/zh-cn/focal/python-gi手动下载python-gi，先后安装成功。\n再次安装qq，重启，安装成功。\n但是发现字体显示不全。找了个网站下载了simsun.ttc，放到~/.deepinwine/Deepin-QQ/drive_c/windows/Fonts/\n问题解决。\n\r图片 1\r\n","date":"2021-01-03T12:16:26Z","image":"https://kegalas.top/p/ubuntu%E5%AE%89%E8%A3%85deepin-qq%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/cover_huadd5fdafa4a185a8686ebe054dd413b9_24301_120x120_fill_q75_box_smart1.jpg","permalink":"https://kegalas.top/p/ubuntu%E5%AE%89%E8%A3%85deepin-qq%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/","title":"ubuntu安装deepin-qq时遇到的问题与解决"},{"content":" [TOC]\n不等式 均值不等式 ​ \\(H_n\\) 为调和平均数、 ​ \\(G_n\\) 为几何平均数、 ​ \\(A_n\\) 为算数平均数、 ​ \\(Q_n\\) 为平方平均数。 ​ 任意\\(x_i\u0026gt; 0\\)都成立时，有 ​ \\[H_n=\\frac{n}{\\sum\\limits_{i=1}^n\\frac{1}{x_i}}=\\frac{n}{\\frac{1}{x_1}+\\frac{1}{x_2}+\\dots+\\frac{1}{x_n}}\\] ​\\[G_n=\\sqrt[n]{\\prod_{i=1}^{n}x_i}=\\sqrt[n]{x_1 x_2 \\dots x_n}\\] ​ \\[A_n=\\frac{\\sum\\limits_{i=1}^{n}x_i}{n}=\\frac{x_1+x_2+\\dots+x_n}{n}\\] ​\\[Q_n=\\sqrt{\\frac{\\sum\\limits_{i=1}^{n}x_i^{2}}{n}}=\\sqrt{\\frac{x_1^{2}+x_2^{2}+\\dots+x_n^{2}}{n}}\\] ​\\[H_n\\leq G_n\\leq A_n\\leq Q_n\\] ​ 当且仅当\\(x_1=x_2=\\dots =x_n\\)时取等号\n对数平均不等式 ​ \\(a\\neq b\\)时，有 ​ \\[\\sqrt{ab}\u0026lt;\\frac{a-b}{lna-lnb}\u0026lt;\\frac{a+b}{2}\\]\n柯西不等式 ​ \\[\\sum\\limits_{i=1}^{n}a_i^{2}\\sum\\limits_{i=1}^{n}b_i^{2}\\geq (\\sum\\limits_{i=1}^{n}a_i b_i)^2\\] ​ 当且仅当\\(\\frac{a_1}{b_1}=\\frac{a_2}{b_2}=\\dots =\\frac{a_n}{b_n}\\)时取等号 ​ 其中二维形式如下 ​ \\[(a^2+b^2)(c^2+d^2)\\geq (ac+bd)^2\\] ​ 当且仅当\\(ad=bc\\)即\\(\\frac{a}{c}=\\frac{b}{d}\\)时取等\n排序不等式 ​ 排序不等式表示如下 ​ 设有两组数\\(a_1,a_2,\\dots,a_n\\)和\\(b_1,b_2,\\dots,b_n\\)，满足\\(a_1\\leq a_2\\leq \\dots \\leq a_n\\)且\\(b_1\\leq b_2\\leq \\dots \\leq b_n\\) ​ \\(c_1,c_2,\\dots,c_n\\)是\\(b_1,b_2,\\dots,b_n\\)的乱序排列，则有： ​ ​\\[a_1 b_n+a_2 b_{n-1}+\\dots+a_n b_1\\leq a_1 c_1+a_2 c_2+\\dots+a_n c_n\\leq a_1 b_1+a_2 b_2+\\dots+a_n b_n\\] ​ ​当且仅当\\(a_1=a_2=\\dots=a_n\\)或\\(b_1=b_2=\\dots=b_n\\)时取等号。 ​ 便于记忆，常记为： ​ 反序和\\(\\leq\\)乱序和\\(\\leq\\)顺序和\n权方和不等式 ​ 若\\(a_i\u0026gt;0\\)，\\(b_i\u0026gt;0\\)，\\(m\u0026gt;0\\)，则有 ​ \\[\\sum\\limits_{i=1}^{n}\\frac{a_i^{m+1}}{b_i^{m}}\\geq \\frac{\\left (\\sum\\limits_{i=1}^{n}a_i\\right) ^{m+1}}{\\left (\\sum\\limits_{i=1}^{n}b_i\\right) ^m}\\] ​ 即为 ​ \\[\\frac{a_1^{m+1}}{b_1^{m}}+\\frac{a_2^{m+1}}{b_2^{m}}+\\dots+\\frac{a_n^{m+1}}{b_n^{m}}\\geq \\frac{(a_1+a_2+\\dots+a_n)^{m+1}}{(b_1+b_2+\\dots+b_n)^{m}}\\] ​ 当且仅当\\(a_i=\\lambda b_i\\)时取等号 ​ 其中二维形式如下 ​ 对于正数\\(a\\)，\\(b\\)，\\(x\\)，\\(y\\)，有 ​ \\[\\frac{a^2}{x}+\\frac{b^2}{y}\\geq \\frac{(a+b)^2}{x+y}\\] ​ 当且仅当\\(a:b=x:y\\)时取等号 ​ 也有 ​ \\[\\frac{a^2}{ax}+\\frac{b^2}{by}=\\frac{a}{x}+\\frac{b}{y}\\geq \\frac{(a+b)^2}{ax+by}\\] ​ 当且仅当\\(x=y\\)时取等号\n舒尔不等式 ​ \\(a,b,c\\geq 0\\quad t\\in R\\)时，有 ​ \\[a^t (a-b)(a-c)+b^t (b-a)(b-c)+c^t (c-a)(c-b)\\geq 0\\] ​ 当且仅当\\(a=b=c\\)，或其中两个数相等且另一个等于零时，取等号。 ​特别的，当\\(t\\)为非负偶数时，此不等式对任意实数\\(a,b,c\\)成立。\n琴生不等式 ​ 设\\(f(x)\\)在区间\\(I\\)上是下凸函数，则对任意\\(x_i\\in I\\)及\\(p_i\u0026gt;0\\quad (i=1,2,\\dots,n)\\)，有 ​ \\[ \\frac{\\sum\\limits_{i=1}^{n}p_i\\cdot f(x_i)}{\\sum\\limits_{i=1}^{n}p_i}\\geq f \\left (\\frac{\\sum\\limits_{i=1}^{n}p_i\\cdot x_i}{\\sum\\limits_{i=1}^{n}p_i} \\right ) \\] ​ 其中等号当且仅当\\(x_1=x_2=\\dots=x_n\\)时成立，若\\(f(x)\\)在区间\\(I\\)上是上凸函数，则不等号反向。\n绝对值不等式 ​ \\[||a|-|b|| \\leq |a\\pm b| \\leq |a|+|b|\\]\n糖水不等式 \\[\\frac{b+c}{a+c}\u0026gt;\\frac{b}{a}(a\u0026gt;b\u0026gt;0,c\u0026gt;0)\\] \\[\\frac{b+c}{a+c}\u0026lt;\\frac{b}{a}(b\u0026gt;a\u0026gt;0,c\u0026gt;0)\\]\n函数 拉格朗日中值定理 ​ 设\\(y=f(x)\\)在\\([a,b]\\)上连续，在\\((a,b)\\)上可导，则存在\\(\\xi \\in (a,b)\\)使得 ​ \\[f^{\u0026#39;}(\\xi)=\\frac{f(b)-f(a)}{b-a}\\]\n拉格朗日乘数法 ​ 【例题】若正数\\(a,b\\)满足\\(2a+b=1\\)，则\\(\\frac{a}{2-2a}+\\frac{b}{2-b}\\)的最小值为? ​ 解：构造拉格朗日函数 ​ \\[L(a,b,\\lambda)=\\frac{a}{2-2a}+\\frac{b}{2-b}-\\lambda(2a+b-1)\\] ​令 ​ \\[\\frac{\\partial L}{\\partial a}=L_a=\\frac{1}{2(1-a)^2}-2\\lambda=0\\] ​ \\[\\frac{\\partial L}{\\partial b}=L_b=\\frac{2}{(2-b)^2}-\\lambda=0\\] ​ \\[\\frac{\\partial L}{\\partial \\lambda}=L_\\lambda=-(2a+b-1)=0\\] ​ 联立解得 ​ \\[a=\\frac{5-3\\sqrt{2}}{2},b=3\\sqrt{2}-4,\\lambda=\\frac{1}{27-18\\sqrt{2}}\\] ​从而 ​ \\[\\frac{a}{2-2a}+\\frac{b}{2-b}=\\frac{2\\sqrt{2}}{3}-\\frac{1}{2}\\] ​此即为所求的最小值。\n高次韦达定理 ​ 设\\(x_1,x_2,\\dots,x_n\\)为如下方程的根 ​ \\[a_n x^n+a_{n-1} x^{n-1}+\\dots+a_1 x+a_0=0\\] ​ 则有 ​ \\[x_1+x_2+\\dots+x_n=-\\frac{a_{n-1}}{a_n}\\] ​ \\[x_1 x_2+x_1 x_3+\\dots+x_n x_{n-1}=\\frac{a_{n-2}}{a_n}\\] ​ \\[\\dots\\] ​ \\[x_1 x_2\\dots x_n=(-1)^n \\frac{a_0}{a_n}\\] ​ 其中三次的形式如下 ​ 若\\(ax^3+bx^2+cx+d=0\\ (a\\neq 0)\\)的3个根分别为\\(x_1,x_2,x_3\\)则有 ​ \\[x_1+x_2+x_3=-\\frac{b}{a}\\] ​ \\[x_1 x_2+x_1 x_3+x_2 x_3=\\frac{c}{a}\\] ​ \\[x_1\\cdot x_2\\cdot x_3=-\\frac{d}{a}\\]\n泰勒展开 ​ 若函数\\(f(x)\\)在\\(x_0\\)存在\\(n\\)阶导数，则有 ​ \\[f(x)=f(x_0)+\\frac{f\u0026#39;(x_0)}{1!}(x-x_0)+\\frac{f\u0026#39;\u0026#39;(x_0)}{2!}(x-x_0)^2+\\dots+\\frac{f^{(n)} (x_0)}{n!}(x-x_0)^n+R_{n+1}\\] ​ 上式即为函数\\(f(x)\\)在\\(x_0\\)处的泰勒展开式，其中\\(R_{n+1}=\\frac{f^{(n+1)} (\\xi)}{(n+1)!}(x-x_0)^{n+1}\\)（其中\\(\\xi\\)介于\\(x\\)和\\(x_0\\)间）叫做拉格朗日余项。 ​ 拉格朗日余项可用于证明不等式。如： ​ \\(-1\u0026lt;x\u0026lt;1\\)时 ​ \\[\\ln(1+x)=x-\\frac{x^2}{2}+\\frac{x^3}{3}-\\frac{x^4}{4(1+\\xi)^4} (-1\u0026lt;\\xi\u0026lt;1)\\] ​ 因为\\(-\\frac{x^4}{4(1+\\xi)^4}\\leq 0\\)，所以\\(\\ln(1+x)\\leq x-\\frac{x^2}{2}+\\frac{x^3}{3}\\)\n极值点偏移 ​ 【例题】已知函数\\(f(x)=e^x-ax\\)有两个零点\\(x_1\\)和\\(x_2\\)，证明：\\(x_1 +x_2 \u0026gt;2\\) ​ \\[f(x)=e^x-ax=0\\Leftrightarrow \\frac{e^x}{x}=a\\] ​ 令\\[\\varphi(x)=\\frac{e^x}{x}\\] ​ 则\\[f(x_1)=f(x_2)\\Leftrightarrow\\varphi(x_1)=\\varphi(x_2),\\quad \\varphi\u0026#39;(x)=\\frac{(x-1)e^x}{x^2}\\] ​ 因此\\(\\varphi(x)\\)在\\((0,1)\\)单减，\\((1,+\\infty)\\)单增，不妨设\\(0\u0026lt;x_1\u0026lt;1\u0026lt;x_2\\) ​ 则\\(x_1+x_2\u0026gt;2\\Leftrightarrow x_2\u0026gt;2-x_1\\)，注意到\\(2-x_1\u0026gt;1\\) ​ \\(\\Leftrightarrow\\varphi(x_2)\u0026gt;\\varphi(2-x_1)\\)，注意到\\(\\varphi(x_1)=\\varphi(x_2)\\) ​ 则\\(\\varphi(x_1)\u0026gt;\\varphi(2-x_1)\\)，其中\\(0\u0026lt;x_1\u0026lt;1\\) ​ 令\\[g(x)=\\varphi(x)-\\varphi(2-x), \\quad 0\u0026lt;x\u0026lt;1\\] ​ 易知 ​ \\[g\u0026#39;(x)\u0026lt;0\\] ​ 所以\\(g(x)\\)在\\((0,1)\\)上单减，\\(g(x)\u0026gt;g(1)=\\varphi(1)-\\varphi(1)=0\\) ​ 即\\(\\varphi(x)-\\varphi(2-x)\u0026gt;0\\)，令\\(x=x_1\\)，Q.E.D.\n最值函数基本定理 ​ 定理一: ​ \\[min\\{a,b \\} \\leq \\frac{a+b}{2} \\leq max\\{a,b \\} \\] ​ \\[min\\{a,b\\}\\leq\\sqrt{ab}\\leq max\\{a,b\\}.(a\u0026gt;0,b\u0026gt;0)\\] ​ 定理二： ​ \\[max\\{\\left|a+b\\right|,\\left|a-b\\right| \\}=|a|+|b|\\] ​ \\[min\\{\\left|a+b\\right|,\\left|a-b\\right| \\}=||a|-|b||\\] ​ 定理三： ​ \\[max\\{|a|,|b|\\}=\\frac{|a+b|}{2}+\\frac{|a-b|}{2}\\] ​\\[min\\{|a|,|b|\\}=\\left|\\frac{|a+b|}{2}-\\frac{|a-b|}{2}\\right|\\]\n数列 不动点原理 ​ 【例题】求\\(a_1 = 1 , a_{n+1}=2a_n +1\\)的通项公式 ​ 其特征函数为\\(f(x)=2x+1\\)，令\\(f(x)=x\\),解得\\(x=-1\\) ​ 带入得\\(a_{n+1}-(-1)=2(a_n-(-1))\\)，即\\(a_{n+1}+1=2(a_n+1)\\)，之后根据等比数列可得\\(a_n=2^n -1\\)\n组合数学 容斥原理 ​ 建议根据韦恩图解题\n伯努利装错信封问题 ​ n封信与n个信封全部错位的组合数为 ​ \\[f(n)=n!\\left[ \\frac{1}{2!}-\\frac{1}{3!}+\\frac{1}{4!}-\\dots +(-1)^n \\frac{1}{n!} \\right] \\]\n向量 极化恒等式 ​ 重要恒等式:\\(4ab=(a+b)^2-(a-b)^2\\) ​ 极化恒等式:\\(4\\boldsymbol{a}\\cdot \\boldsymbol{b}=(\\boldsymbol{a}+\\boldsymbol{b})^2-(\\boldsymbol{a}-\\boldsymbol{b})^2\\)\n分点恒等式 ​ 在\\(\\triangle ABC\\)中，M为BC上一等分点 ​ 当\\(\\overrightarrow{BM}=\\lambda \\overrightarrow{MC}时\\)，有 ​ \\[\\overrightarrow{AM}=\\frac{1}{1+\\lambda}\\overrightarrow{AB}+\\frac{\\lambda}{1+\\lambda}\\overrightarrow{AC}\\]\n三点共线定理 ​ 在平面中A、B、P三点共线的充要条件是：对于该平面内任意一点O，存在唯一的实数\\(x,y\\)使得： ​ \\[\\overrightarrow{OP}=x\\overrightarrow{OA}+y\\overrightarrow{OB} \\] ​ 且 ​ \\[x+y=1\\] ​ 特别的有：当P在线段AB上时，\\(x\u0026gt;0,y\u0026gt;0\\) ​ P在线段AB之外时,\\(xy\u0026lt;0\\)\n向量中值定理 ​ 在\\(\\triangle ABC\\)中，M为BC的中点，则 ​ \\[AB^2+AC^2=2(AM^2+BM^2)\\] ​ 对应的向量公式有: ​ \\[\\boldsymbol{a}^2+\\boldsymbol{b}^2=2\\left[\\left(\\frac{\\boldsymbol{a}+\\boldsymbol{b}}{2}\\right)^2 + \\left(\\frac{\\boldsymbol{a}-\\boldsymbol{b}}{2}\\right)^2 \\right] \\]\n向量数乘余弦定理 ​ 在\\(\\triangle ABC\\)中,有 ​ \\[\\overrightarrow{AB}\\cdot \\overrightarrow{AC}=\\frac{AB^2+AC^2-BC^2}{2}\\]\n三角 和差化积 ​ \\[sin\\alpha+sin\\beta=2sin\\frac{\\alpha+\\beta}{2}\\cdot cos\\frac{\\alpha-\\beta}{2}\\] ​ \\[sin\\alpha-sin\\beta=2cos\\frac{\\alpha+\\beta}{2}\\cdot sin\\frac{\\alpha-\\beta}{2}\\] ​ \\[cos\\alpha+cos\\beta=2cos\\frac{\\alpha+\\beta}{2}\\cdot cos\\frac{\\alpha-\\beta}{2}\\] ​ \\[cos\\alpha-cos\\beta=-2sin\\frac{\\alpha+\\beta}{2}\\cdot sin\\frac{\\alpha-\\beta}{2}\\]\n积化和差 ​ \\[sin\\alpha cos\\beta=\\frac{1}{2}\\left[sin(\\alpha+\\beta)+sin(\\alpha-\\beta)\\right]\\] ​\\[cos\\alpha sin\\beta=\\frac{1}{2}\\left[sin(\\alpha+\\beta)-sin(\\alpha-\\beta)\\right]\\] ​\\[cos\\alpha cos\\beta=\\frac{1}{2}\\left[cos(\\alpha+\\beta)+cos(\\alpha-\\beta)\\right]\\] ​\\[sin\\alpha sin\\beta=-\\frac{1}{2}\\left[cos(\\alpha+\\beta)-cos(\\alpha-\\beta)\\right]\\]\n半角公式 ​ \\[sin\\frac{\\theta}{2}=\\pm \\sqrt{\\frac{1-cos\\alpha}{2}}\\] ​ \\[sin\\frac{\\theta}{2}=\\pm \\sqrt{\\frac{1+cos\\alpha}{2}}\\] ​ \\[tan\\frac{\\theta}{2}=\\pm \\sqrt{\\frac{1-cos\\alpha}{1+cos\\alpha}}=\\frac{sin\\alpha}{1+cos\\alpha}=\\frac{1-cos\\alpha}{sin\\alpha}\\]\n辅助角公式 ​ \\[asin\\theta\\pm bcos\\theta=\\sqrt{a^2+b^2}sin(\\theta\\pm\\varphi),\\quad tan\\varphi=\\frac{b}{a}\\]\n统计、概率、分布 期望、方差、标准差 ​ 数学期望：我们称\\(E\\xi = x_1 p_1+x_2 p_2+\\dots+x_n p_n\\)为离散型随机变量\\(\\xi\\)的数学期望 ​ 方差和标准差：我们称\\(D\\xi = \\sum_{i=1}^{n}(x_i-E\\xi)^2 p_i\\)为离散型随机变量\\(\\xi\\)的方差，其算数平方根\\(\\sqrt{D\\xi}=\\sigma\\xi\\)叫做离散型随机变量\\(\\xi\\)的标准差 ​ ​定理一： ​ \\[E(a\\xi+b)=aE\\xi+b\\] ​ \\[D(a\\xi+b)=a^2 D\\xi\\] ​ 定理二： ​ \\[E(a\\xi _1+b\\xi _2)=aE\\xi _1+bE\\xi _2\\]\n二项分布 ​ n次试验中事件A恰好发生k次 ​ \\[P(E) ={n \\choose k}p^k (1-p)^{n-k}\\quad k=1,2,3,\\dots\\] ​ 我们称\\(\\xi\\)服从二项分布，记作\\(\\xi \\sim B(n,p)\\) ​ 定理：\\(E\\xi = np\\), \\(D\\xi = np(1-p)\\)\n正态分布 ​ \\[f_\\xi (x)=\\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{(x-\\mu)^2}{2\\sigma ^2}} \\quad x\\in R,\\sigma\u0026gt;0\\] ​ 记作\\(\\xi \\sim N(\\mu,\\sigma ^2)\\) ​ 性质：1.其正态曲线关于\\(x=\\mu\\)对称，最高点为\\(\\frac{1}{\\sigma\\sqrt{2\\pi}}\\) ​ 2.\\(E\\xi=\\mu,D\\xi=\\sigma ^2\\) ​ 3.\\(\\sigma\\)越大，正态曲线越“矮胖”，表示分布越分散，\\(\\sigma\\)越小，正态曲线越“瘦高”，表示分布越集中\n几何分布 ​ 在n次伯努利试验中，试验k次才得到第一次成功的机率。 ​ 记为\\(P(\\xi=k)=g(k,p)=q^{k-1}p\\),其中\\(q=1-p\\)，也记为\\(\\xi \\sim GE(p)\\) ​ 定理：\\(E\\xi=\\frac{1}{p},D\\xi=\\frac{q}{p^2}\\)\n超几何分布 ​ 它描述了从有限N个物件（其中包含M个指定种类的物件）中抽出n个物件，成功抽出该指定种类的物件的次数（不放回） ​记为\\(\\eta \\sim H(n,M,N)\\) ​ \\[P ( \\eta=m ) = \\frac{\\binom{M}{m}\\cdot \\binom{N-M}{n-m}}{\\binom{N}{n}}\\quad m=0,1,2,\\dots,min \\{ n,M \\}\\]\n其中有：\n​ \\[E(X)=\\frac{nM}{N}\\]\n​ \\[D(X)=\\frac{nM}{N}\\left(1-\\frac{M}{N}\\right)\\frac{N-n}{N-1}\\]\n方程 立方和分解 ​ \\[a^3+b^3=(a+b)(a^2-ab+b^2)\\]\n立方差分解 ​ \\[a^3-b^3=(a-b)(a^2+ab+b^2)\\]\n比例性质 ​ 若\\(\\frac{a}{b}=\\frac{c}{d}\\)则有：\n​ 合比性质\n​ \\[\\frac{a+b}{b}=\\frac{c+d}{d}\\]\n​ 分比性质\n​ \\[\\frac{a-b}{b}=\\frac{c-d}{d}\\]\n​ 合分比性质\n​ \\[\\frac{a+b}{a-b}=\\frac{c+d}{c-d}\\]\n​ 等比性质\n​ \\[\\frac{a}{b}=\\frac{c}{d}=\\frac{a+c}{b+d}=\\frac{ma+nc}{mb+nd}\\]\n几何 射影定理 ​ 射影定理，又称“欧几里德定理”：在直角三角形中，斜边上的高是两条直角边在斜边射影的比例中项，每一条直角边又是这条直角边在斜边上的射影和斜边的比例中项。 ​ ​在\\(Rt\\bigtriangleup ABC\\)中,\\(\\angle ABC=90^\\circ\\),\\(BD\\)为斜边\\(AC\\)上的高，则有射影定理如下： ​ \\[BD^2=AD\\cdot CD\\] ​ \\[AB^2=AC\\cdot AD\\] ​ \\[BC^2=CD\\cdot AC\\]\n阿波罗尼斯圆 ​ 平面内到两个定点的距离之比为常数\\(k(k\\neq1)\\)的点的轨迹是圆\n角平分线定理 ​ 在\\(\\bigtriangleup ABC\\)中，\\(AM\\)为\\(\\angle BAC\\)的角平分线，\\(M\\)在\\(BC\\)上，则有： ​ \\[\\frac{AB}{AC}=\\frac{MB}{MC}\\]\n三角形五心 重心 ​ 三角形的三条边的中线交于一点，该点叫三角形的重心 ​ 重心的性质： ​ 1、重心到顶点的距离与重心到对边中点的距离之比为2:1。 ​ 2、重心和三角形任意两个顶点组成的3个三角形面积相等。即重心到三条边的距离与三条边的长成反比。 ​3、重心到三角形3个顶点距离的平方和最小。 ​ 4、在平面直角坐标系中，重心的坐标是顶点坐标的算术平均数，即其重心坐标为 ​ \\[P_1= ​ \\begin{bmatrix} ​ x_1\\\\ ​ y_1 ​ \\end{bmatrix} ​ P_2= ​ \\begin{bmatrix} ​ x_2\\\\ ​ y_2 ​ \\end{bmatrix} ​ p_3= ​ \\begin{bmatrix} ​ x_3\\\\ ​ y_3 ​ \\end{bmatrix} ​ \\] ​ \\[ ​ \\begin{bmatrix} ​ x\\\\ ​ y ​ \\end{bmatrix} ​ =\\frac{1}{3}(P_1+P_2+P_3)=\\frac{1}{3} ​ \\begin{bmatrix} ​ x_1+x_2+x_3\\\\ ​ y_1+y_2+y_3 ​ \\end{bmatrix} ​ \\] ​ 5. 以重心为起点，以三角形三顶点为终点的三条向量之和等于零向量。\n外心 ​ 三角形外接圆的圆心，叫做三角形的外心。 ​ 外心的性质： ​ 1、三角形的三条边的垂直平分线交于一点，该点即为该三角形的外心。 ​ 2、若O是\\(\\bigtriangleup\\)ABC的外心，则\\(\\angle\\)BOC=2\\(\\angle\\)A（\\(\\angle\\)A为锐角或直角）或\\(\\angle\\)BOC=360°-2\\(\\angle\\)A（\\(\\angle\\)A为钝角）。 ​ 3、当三角形为锐角三角形时，外心在三角形内部；当三角形为钝角三角形时，外心在三角形外部；当三角形为直角三角形时，外心在斜边上，与斜边的中点重合。 ​4、外心到三顶点的距离相等\n垂心 ​ 三角形的三条高（所在直线）交于一点，该点叫做三角形的垂心。 ​ 垂心的性质： ​ 1、三角形三个顶点，三个垂足，垂心这7个点可以得到6个四点圆。 ​ 2、三角形外心O、重心G和垂心H三点共线，且OG:GH=1:2。（此直线称为三角形的欧拉线（Euler line））（除正三角形） ​ 3、垂心到三角形一顶点距离为此三角形外心到此顶点对边距离的2倍。 ​ 4、垂心分每条高线的两部分乘积相等\n内心 ​ 三角形内切圆的圆心，叫做三角形的内心。 ​ 内心的性质： ​ 1、三角形的三条内角平分线交于一点。该点即为三角形的内心。 ​ 2、直角三角形的内心到边的距离等于两直角边的和与斜边的差的二分之一。 ​ 3、P为\\(\\bigtriangleup\\)ABC所在空间中任意一点，点O是ΔABC内心的充要条件是：\\(\\overrightarrow{PO}=(a×\\overrightarrow{PA} +b×\\overrightarrow{PB} +c×\\overrightarrow{PC} )/(a+b+c)\\). ​ 4、O为三角形的内心，A、B、C分别为三角形的三个顶点，延长AO交BC边于N，则有AO:ON=AB:BN=AC:CN=(AB+AC):BC ​ 5、(欧拉定理)⊿ABC中，R和r分别为外接圆为和内切圆的半径，O和I分别为其外心和内心，则\\(OI^2=R^2-2Rr\\)． ​ 6、（内角平分线分三边长度关系） ​ △ABC中，0为内心，∠A 、∠B、 ∠C的内角平分线分别交BC、AC、AB于Q、P、R，　则BQ/QC=c/b, CP/PA=a/c, BR/RA=a/b. ​ 7、内心到三角形三边距离相等。\n旁心 ​ 三角形的旁切圆（与三角形的一边和其他两边的延长线相切的圆）的圆心，叫做三角形的旁心。 ​旁心的性质： ​ 1、三角形一内角平分线和另外两顶点处的外角平分线交于一点，该点即为三角形的旁心。 ​2、每个三角形都有三个旁心。 ​ 3、旁心到三边的距离相等。\n法向量叉乘求法 ​ 已知不共线的两个向量\\(\\boldsymbol{a}=(x_1,y_1,z_1)\\),\\(\\boldsymbol{b}=(x_2,y_2,z_2)\\)\n​ 则它们所确定的平面的法向量为：\n​ \\[\\boldsymbol{n}=(y_1 z_2-z_1 y_2,z_1 x_2-x_1 z_2,x_1 y_2-y_1 x_2)\\]\n方法 主元法 ​ 【例题】对任意\\(m\\in [-1,1]\\),函数\\(f(x)=x^2+(m-4)x+4-2m\\)的值恒大于零，求\\(x\\)的取值范围。 ​ \\[f(x)=x^2+(m-4)x+4-2m=(x-2)m+x^2-4x+4\\] ​ 令 ​\\[g(m)=(x-2)m+x^2-4x+4\\] ​ 所以有 ​ \\[\\begin{cases} ​ g(-1)=(x-2)(-1)+x^2-4x+4\u0026gt;0 ​ \\\\ ​ g(1)=(x-2)\\cdot 1+x^2-4x+4\u0026gt;0 ​ \\end{cases}\\] ​ 解得$x\u0026lt;1 $或 \\(x\u0026gt;3\\)\n裂项 ​ \\[\\frac{1}{n(n+1)}=\\frac{1}{n}-\\frac{1}{n+1}\\] ​\\[\\frac{1}{n(n+1)(n+2)}=\\frac{1}{2}\\left[\\frac{1}{n(n+1)}-\\frac{1}{(n+1)(n+2)}\\right] \\] ​ \\[\\frac{1}{\\sqrt{n+1}+\\sqrt{n}}=\\sqrt{n+1}-\\sqrt{n}\\] ​\\[a_n=(a_n-a_{n-1})+(a_{n-1}-a_{n-2})+\\dots+(a_2-a_1)+a_1\\] ​\\[a_n=\\frac{a_n}{a_{n-1}}\\bullet\\frac{a_{n-1}}{a_{n-2}}\\bullet\\dots\\bullet\\frac{a_2}{a_1}\\bullet a_1\\] ​ \\[n\\cdot n!=(n+1)!-n!\\] ​ \\[C^{m}_{n}=C^{m}_{n+1}-C^{m-1}_{n}\\] ​ \\[n(n+1)=\\frac{1}{3}\\left[n(n+1)(n+2)-(n-1)n(n+1)\\right]\\] ​\\[\\frac{1}{C^{1}_{n+1}C^{2}_{n}}=\\frac{2}{(n+1)n(n-1)}=\\frac{1}{n(n-1)}-\\frac{1}{(n+1)n}\\] ​\\[\\frac{1}{2^n(2^n-1)}=\\frac{1}{2^n-1}-\\frac{1}{2^n}\\] ​\\[\\frac{n}{(n+1)!}=\\frac{1}{n!}-\\frac{1}{(n+1)!}\\]\n放缩 ​ \\[\\frac{1}{n^2}=\\frac{4}{4n^2}\u0026lt;\\frac{4}{4n^2 -1}=2\\left(\\frac{1}{2n-1}-\\frac{1}{2n+1}\\right)\\] ​ \\[\\left(1+\\frac{1}{n}\\right)^n\u0026lt;1+1+\\frac{1}{2\\times 1}+\\frac{1}{3\\times 2}+\\dots+\\frac{1}{n(n-1)}\u0026lt;\\frac{5}{2}\\] ​ \\[\\frac{1}{\\sqrt{n+2}}\u0026lt;\\frac{1}{\\sqrt{n+2}}-\\frac{1}{\\sqrt{n}}\\] ​\\[2(\\sqrt{n+1}-\\sqrt{n})\u0026lt;\\frac{1}{\\sqrt{n}}\u0026lt;2(\\sqrt{n}-\\sqrt{n-1})\\] ​\\[\\frac{2^n}{(2^n-1)^2}\u0026lt;\\frac{2^n}{(2^n-1)(2^n-2)}=\\frac{2^{n-1}}{(2^n-1)(2^{n-1}-1)}=\\frac{1}{2^{n-1}-1}-\\frac{1}{2^n-1}\\]\n​ \\[\\frac{1}{\\sqrt{n^3}}=\\frac{1}{\\sqrt{n\\cdot n^2}}\u0026lt;\\frac{1}{\\sqrt{n(n-1)(n+1)}}=\\left(\\frac{1}{\\sqrt{n(n-1)}}\\ ​ -\\frac{1}{\\sqrt{n(n+1)}}\\right)\\frac{1}{\\sqrt{n+1}-\\sqrt{n-1}}\\] ​\\[=\\left(\\frac{1}{\\sqrt{n-1}}-\\frac{1}{\\sqrt{n+1}}\\ ​ \\right)\\frac{\\sqrt{n+1}+\\sqrt{n-1}}{2\\sqrt{n}}\u0026lt;\\frac{1}{\\sqrt{n-1}}-\\frac{1}{\\sqrt{n+1}}\\]\n​ \\[\\frac{1}{\\sqrt{n(n+1)}}\u0026lt;\\sqrt{n}-\\sqrt{n-1}\\]\n​ \\[e^x\\geq x+1\\] ​ \\[e^x\\leq \\frac{1}{1-x}\\] ​ \\[ln(x+1)\\leq x\\] ​ \\[ln(x+1)\\geq \\frac{x}{x+1}\\] ​ \\[ln(x+1)\\geq x-\\frac{x^2}{2}\\] ​ \\[e^x\\geq 1+x+\\frac{x^2}{2}\\] ​ \\[tanx\\geq x+\\frac{x^2}{3}\\] ​ \\[sinx\\geq x-\\frac{x^3}{6}\\] ​ \\[sinx\\leq x\\] ​ \\[cosx\\geq 1-\\frac{x^2}{2}\\]\n","date":"2020-12-13T13:10:39Z","permalink":"https://kegalas.top/p/%E6%88%91%E7%9A%84%E9%AB%98%E4%B8%AD%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/","title":"我的高中资料整理"},{"content":"这是一个测试文档\n","date":"2020-12-13T12:30:53Z","permalink":"https://kegalas.top/p/%E6%B5%8B%E8%AF%95/","title":"测试"}]
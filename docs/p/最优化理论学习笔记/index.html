<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='最优化理论、算法的学习笔记'><title>最优化理论学习笔记</title>

<link rel='canonical' href='https://kegalas.top/p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='最优化理论学习笔记'>
<meta property='og:description' content='最优化理论、算法的学习笔记'>
<meta property='og:url' content='https://kegalas.top/p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>
<meta property='og:site_name' content='KegalaS的个人博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='大学' /><meta property='article:tag' content='数学' /><meta property='article:tag' content='最优化' /><meta property='article:published_time' content='2023-06-16T19:47:47&#43;08:00'/><meta property='article:modified_time' content='2023-06-16T19:47:47&#43;08:00'/><meta property='og:image' content='https://kegalas.top/p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cover.jpg' />
<meta name="twitter:title" content="最优化理论学习笔记">
<meta name="twitter:description" content="最优化理论、算法的学习笔记"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://kegalas.top/p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cover.jpg' />
    <link rel="shortcut icon" href="favicon-16x16.png" />

    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                <img src="/p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cover_hu54576080547634ea0a125cfdafb2aa8f_63775_800x0_resize_q75_box.jpg"
                        srcset="/p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cover_hu54576080547634ea0a125cfdafb2aa8f_63775_800x0_resize_q75_box.jpg 800w, /p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cover_hu54576080547634ea0a125cfdafb2aa8f_63775_1600x0_resize_q75_box.jpg 1600w"
                        width="800" 
                        height="510" 
                        loading="lazy"
                        alt="Featured image of post 最优化理论学习笔记" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E6%95%B0%E5%AD%A6/" >
                数学
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">最优化理论学习笔记</a>
    </h2>

    
    <h3 class="article-subtitle">
        最优化理论、算法的学习笔记
    </h3>
    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jun 16, 2023</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 29 分钟
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <h1 id="读前警示">读前警示</h1>
<p>出于Obsidian不支持\bm的标签的原因，也出于我打字方便、教科书也没用加粗的原因，从某一段开始的瞬间，很多地方都不会使用粗体来表示向量。这其实无所谓，我们可以把标量看做一维向量。我们的大部分讨论都是在向量之上的，除了部分参数是标量。大部分矩阵是大写字母。</p>
<p>阅读时应结合前后文理解一个符号是什么意思。</p>
<h1 id="数学基础概念定义">数学基础概念、定义</h1>
<h2 id="向量内积">向量内积</h2>
<p>在<span class="math inline">\(n\)</span>维线性空间<span class="math inline">\(R^n\)</span>中，<span class="math inline">\(\bm a = [a_1,a_2,\cdots,a_n]^T\in R^n,\bm b = [b_1,b_2,\cdots,b_n]^T\in R^n\)</span>，则</p>
<p><span class="math display">\[\bm a^T b = a_1b_1+a_2b_2+\cdots,a_nb_n
\]</span></p>
<p>称作向量<span class="math inline">\(\bm a,\bm b\)</span>的内积。</p>
<p>内积满足交换律，线性，以及正定性：<span class="math inline">\(\bm a^T \bm a\geq 0\)</span>，当且仅当<span class="math inline">\(\bm a=\bm 0\)</span>时，取等号。</p>
<p>其他各种性质都在线性代数中学过了，这里只是简单回顾。</p>
<h2 id="向量范数">向量范数</h2>
<p>称一个从向量空间<span class="math inline">\(R^n\)</span>到实数域<span class="math inline">\(R\)</span>的非负函数<span class="math inline">\(||\cdot||\)</span>为范数，如果它满足：</p>
<ol>
<li>正定性：对于所有的<span class="math inline">\(\bm v\in R^n\)</span>，有<span class="math inline">\(||\bm v||\geq 0\)</span>，且<span class="math inline">\(||\bm v||=0\)</span>当且仅当<span class="math inline">\(\bm v=0\)</span></li>
<li>齐次性：对于所有的<span class="math inline">\(\bm v\in R^n\)</span>和<span class="math inline">\(\alpha\in R\)</span>，有<span class="math inline">\(||\alpha\bm v||=|\alpha|||\bm v||\)</span></li>
<li>三角不等式：对于所有的<span class="math inline">\(\bm v,\bm w\in R^n\)</span>，有<span class="math inline">\(||\bm v+\bm w||\leq ||\bm v||+||\bm w||\)</span></li>
</ol>
<p>对于<span class="math inline">\(\bm v = (v_1,v_2,\cdots,v_n)^T\)</span>，常见的向量范数为<span class="math inline">\(\mathscr{l}_n\)</span>范数<span class="math inline">\((p>=1)\)</span></p>
<p><span class="math display">\[||v||_p = (|v_1|^p+|v_2|^p+\cdots+|v_3|^p)^{1/p}
\]</span></p>
<p>当<span class="math inline">\(p=\infty\)</span>时，<span class="math inline">\(\mathscr{l}_\infty\)</span>定义为</p>
<p><span class="math display">\[||v||_\infty = \max_i|v_i|
\]</span></p>
<p>一些地方也可以见到<span class="math inline">\(0\)</span>-范数，其表示分量中不为零的个数。</p>
<p>最常见的是<span class="math inline">\(2\)</span>-范数，又称欧几里得范数，常常<span class="math inline">\(||\cdot||\)</span>省略角标不写表示<span class="math inline">\(2\)</span>-范数。</p>
<h2 id="二次型">二次型</h2>
<p><span class="math inline">\(n\)</span>维二次函数可以表示如下</p>
<p><span class="math display">\[f(x_1,x_2,\cdots,x_n)=a_{11}x_1^2+a_{12}x_1x_2+\cdots+a_{1n}x_1x_n+a_{21}x_2x_1+\cdots+a_{nn}x^2_n
\]</span></p>
<p>其可以表示为向量矩阵形式</p>
<p><span class="math display">\[\sum^n_{i=1}\sum^n_{j=1}a_{ij}x_ix_j=\bm x^T A \bm x
\]</span></p>
<p>这个<span class="math inline">\(A\)</span>矩阵是个实对称矩阵，其元素<span class="math inline">\(a_{ij}=a_{ji}\)</span>，是对应的<span class="math inline">\(x_ix_j\)</span>项系数的一半（原式子出于简单起见没有把同类项合并）。</p>
<h2 id="正定矩阵">正定矩阵</h2>
<p>如果正定二次型<span class="math inline">\(f(\bm x)=\bm x^TA\bm x\)</span>，对于一组不全为零的数<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>，恒有<span class="math inline">\(f(x_1,x_2,\cdots,x_n)>0\)</span>，则称<span class="math inline">\(f\)</span>正定，<span class="math inline">\(A\)</span>为正定矩阵。若换成<span class="math inline">\(\geq\)</span>，则称为半正定矩阵，若换成<span class="math inline">\(\leq\)</span>，则称为半负定矩阵。</p>
<p>有两个判定定理</p>
<ol>
<li><span class="math inline">\(A\)</span>正定的充要条件为<span class="math inline">\(A\)</span>的特征值都大于<span class="math inline">\(0\)</span></li>
<li><span class="math inline">\(A\)</span>正定的充要条件为<span class="math inline">\(A\)</span>的所有顺序主子式都大于<span class="math inline">\(0\)</span></li>
</ol>
<h2 id="方向导数">方向导数</h2>
<p>设<span class="math inline">\(f:R^n\to R\)</span>在点<span class="math inline">\(\bm x\)</span>处可微，<span class="math inline">\(\bm p\)</span>是固定不变的非零向量，<span class="math inline">\(\bm e\)</span>是方向<span class="math inline">\(\bm p\)</span>上的单位向量，则称极限</p>
<p><span class="math display">\[\dfrac{\partial f(\bm x)}{\partial \bm p} = \lim_{t\to 0^+}\dfrac{f(\bm x+t\bm e)-f(\bm x)}{t}
\]</span></p>
<p>为函数<span class="math inline">\(f(x)\)</span>在点<span class="math inline">\(\bm x\)</span>处沿<span class="math inline">\(\bm p\)</span>方向的方向导数，记为<span class="math inline">\(\dfrac{\partial f(\bm x)}{\partial\bm p}\)</span>。当其大于零时，函数在该点沿此方向上升，小于零时沿此方向下降。</p>
<h2 id="梯度">梯度</h2>
<p>给定函数设<span class="math inline">\(f:R^n\to R\)</span>，且<span class="math inline">\(f\)</span>在点<span class="math inline">\(\bm x\)</span>的一个领域内有意义，若存在向量<span class="math inline">\(\bm g\in R^n\)</span>满足</p>
<p><span class="math display">\[\lim_{\bm p\to \bm 0}\dfrac{f(\bm x+\bm p)-f(\bm x)-\bm g^T\bm p}{||\bm p||}=0
\]</span></p>
<p>其中这个范数可以是任意向量范数，就称<span class="math inline">\(f\)</span>在点<span class="math inline">\(\bm x\)</span>可微，此时<span class="math inline">\(\bm g\)</span>是<span class="math inline">\(f\)</span>在点<span class="math inline">\(\bm x\)</span>处的梯度，记作<span class="math inline">\(\nabla f(x)\)</span>。可以计算，若令<span class="math inline">\(\bm p=\epsilon \bm e_i\)</span>，<span class="math inline">\(\bm e_i\)</span>是第<span class="math inline">\(i\)</span>个分量为<span class="math inline">\(1\)</span>的单位向量，可知<span class="math inline">\(\nabla f(x)\)</span>的第<span class="math inline">\(i\)</span>个分量即为<span class="math inline">\(\dfrac{\partial f(x)}{\partial x_i}\)</span>。因此</p>
<p><span class="math display">\[\nabla f(x) = \bigg[\dfrac{\partial f(x)}{\partial x_1},\dfrac{\partial f(x)}{\partial x_2},\cdots,\dfrac{\partial f(x)}{\partial x_n}\bigg]^T
\]</span></p>
<p>一个非常浅显的事实是，一维向量函数的梯度就是它的一阶导数。</p>
<p>梯度方向是函数在该点上升的最快方向，反方向是最速下降方向。</p>
<p>梯度与方向导数的关系为</p>
<p><span class="math display">\[\dfrac{\partial f(\bm x)}{\partial \bm p}=\nabla f(\bm x)^T\bm e
\]</span></p>
<p>其中<span class="math inline">\(\bm e\)</span>是<span class="math inline">\(\bm p\)</span>方向上的单位向量。</p>
<p><span class="math inline">\(\bigg|\dfrac{\partial f(\bm x)}{\partial \bm p}\bigg|\leq |\nabla f(\bm x)^T|\)</span></p>
<p>梯度有几条显然的性质：</p>
<ol>
<li>若<span class="math inline">\(\nabla f(\bm x)^T\bm p<0\)</span>，则<span class="math inline">\(\bm p\)</span>的方向是函数<span class="math inline">\(f\)</span>在<span class="math inline">\(\bm x\)</span>处的下降方向</li>
<li>若<span class="math inline">\(\nabla f(\bm x)^T\bm p>0\)</span>，则<span class="math inline">\(\bm p\)</span>的方向是函数<span class="math inline">\(f\)</span>在<span class="math inline">\(\bm x\)</span>处的上升方向</li>
<li>梯度正交的方向变化率为零</li>
</ol>
<h2 id="海瑟矩阵">海瑟矩阵</h2>
<p>用一个简单的比方，梯度和海瑟矩阵的关系，就相当于一阶导数和二阶导数的关系。</p>
<p>给定函数<span class="math inline">\(f:R^n\to R\)</span>，若其在点<span class="math inline">\(\bm x\)</span>处的二阶偏导数<span class="math inline">\(\dfrac{\partial^2 f(\bm x)}{\partial \bm x_i\partial \bm x_j},i,j=1,2,\cdots,n\)</span>都存在，则</p>
<p><span class="math display">\[\nabla^2f(\bm x) = 
\begin{bmatrix}
 \dfrac{\partial^2 f(\bm x)}{\partial x_1^2} & \dfrac{\partial^2 f(\bm x)}{\partial x_1\partial x_2} & \dfrac{\partial^2 f(\bm x)}{\partial x_1\partial x_3} & \cdots & \dfrac{\partial^2 f(\bm x)}{\partial x_1\partial x_n}\\
 \dfrac{\partial^2 f(\bm x)}{\partial x_2\partial x_1} & \dfrac{\partial^2 f(\bm x)}{\partial x_2^2} & \dfrac{\partial^2 f(\bm x)}{\partial x_2\partial x_3} & \cdots & \dfrac{\partial^2 f(\bm x)}{\partial x_2\partial x_n}\\
 \vdots & \vdots & \vdots &  & \vdots\\
 \dfrac{\partial^2 f(\bm x)}{\partial x_n\partial x_1} & \dfrac{\partial^2 f(\bm x)}{\partial x_n\partial x_2} & \dfrac{\partial^2 f(\bm x)}{\partial x_n\partial x_3} &  & \dfrac{\partial^2 f(\bm x)}{\partial x_n^2}
\end{bmatrix}
\]</span></p>
<p>称为<span class="math inline">\(f\)</span>在点<span class="math inline">\(x\)</span>处的海瑟矩阵。</p>
<h2 id="泰勒展开">泰勒展开</h2>
<p>给定函数<span class="math inline">\(f:R^n\to R\)</span>，具有二阶连续偏导数，则</p>
<p><span class="math display">\[f(\bm x+\bm p) = f(\bm x) + \nabla f(\bm x)^T\bm p + \dfrac{1}{2}\bm p^T\nabla^2 f(\bm x)^T\bm p + o(||\bm p||^2)
\]</span></p>
<p>其中<span class="math inline">\(o(||p||^2)\)</span>当<span class="math inline">\(||p||^2\to 0\)</span>时，是关于<span class="math inline">\(||p||^2\)</span>的高阶无穷小量。</p>
<h2 id="邻域">邻域</h2>
<p>对于任意给定的实数<span class="math inline">\(\delta>0\)</span>，满足不等式<span class="math inline">\(||\bm x-\bm x_0||<\delta\)</span>的<span class="math inline">\(\bm x\)</span>的集合称为点<span class="math inline">\(\bm x_0\)</span>的邻域，记为</p>
<p><span class="math display">\[N(\bm x_0,\delta) = \{\bm x|\ ||\bm x-\bm x_0||<\delta,\delta>0\}
\]</span></p>
<h2 id="极小点">极小点</h2>
<p>设<span class="math inline">\(f:D\subseteq R^n\to R\)</span>，若存在点<span class="math inline">\(\bm x^*\in D\)</span>和数<span class="math inline">\(\delta>0\)</span>，<span class="math inline">\(\forall \bm x\in N(\bm x^*,\delta)\cap D\)</span>，都有<span class="math inline">\(f(\bm x^*)\leq f(\bm x)\)</span>，则称<span class="math inline">\(\bm x^*\)</span>为<span class="math inline">\(f(\bm x)\)</span>的（非严格）局部极小点。</p>
<p>设<span class="math inline">\(f:D\subseteq R^n\to R\)</span>，若存在点<span class="math inline">\(\bm x^*\in D\)</span>和数<span class="math inline">\(\delta>0\)</span>，<span class="math inline">\(\forall \bm x\in N(\bm x^*,\delta)\cap D\)</span>，但<span class="math inline">\(\bm x\neq \bm x^*\)</span>，都有<span class="math inline">\(f(\bm x^*)< f(\bm x)\)</span>，则称<span class="math inline">\(\bm x^*\)</span>为<span class="math inline">\(f(\bm x)\)</span>的严格局部极小点。</p>
<p>设<span class="math inline">\(f:D\subseteq R^n\to R\)</span>，若存在点<span class="math inline">\(\bm x^*\in D\)</span>和数<span class="math inline">\(\delta>0\)</span>，<span class="math inline">\(\forall \bm x\in D\)</span>，都有<span class="math inline">\(f(\bm x^*)\leq f(\bm x)\)</span>，则称<span class="math inline">\(\bm x^*\)</span>为<span class="math inline">\(f(\bm x)\)</span>的（非严格）全局极小点。</p>
<p>设<span class="math inline">\(f:D\subseteq R^n\to R\)</span>，若存在点<span class="math inline">\(\bm x^*\in D\)</span>和数<span class="math inline">\(\delta>0\)</span>，<span class="math inline">\(\forall \bm x\in D\)</span>，但<span class="math inline">\(\bm x\neq \bm x^*\)</span>，都有<span class="math inline">\(f(\bm x^*)\leq f(\bm x)\)</span>，则称<span class="math inline">\(\bm x^*\)</span>为<span class="math inline">\(f(\bm x)\)</span>的严格全局极小点。</p>
<p>如果<span class="math inline">\(\bm x^*\)</span>是极小点并且是<span class="math inline">\(D\)</span>的内点，则<span class="math inline">\(\nabla f(\bm x^*)=0\)</span>。这是一个必要非充分条件。</p>
<p>但如果<span class="math inline">\(f\)</span>有连续二阶偏导数，<span class="math inline">\(\bm x^*\)</span>是一个驻点，并且<span class="math inline">\(\nabla^2 f(\bm x^*)\)</span>是正定的，则<span class="math inline">\(\bm x^*\)</span>是<span class="math inline">\(f(\bm x)\)</span>的严格局部极小点。</p>
<h2 id="驻点">驻点</h2>
<p>设<span class="math inline">\(f:D\subseteq R^n\to R\)</span>，<span class="math inline">\(\bm x^*\)</span>是<span class="math inline">\(D\)</span>的内点，若<span class="math inline">\(\nabla f(\bm x^*)=0\)</span>，则称<span class="math inline">\(\bm x^*\)</span>为<span class="math inline">\(f(\bm x)\)</span>的驻点。</p>
<h2 id="锥">锥</h2>
<p>设集合<span class="math inline">\(C\subset R^n\)</span>，若对<span class="math inline">\(\forall\bm x\in C\)</span>以及<span class="math inline">\(\forall \lambda\geq 0\)</span>均有<span class="math inline">\(\lambda\bm x\in C\)</span>，则称<span class="math inline">\(C\)</span>为锥</p>
<h2 id="凸组合">凸组合</h2>
<p>设<span class="math inline">\(\bm x_1,\bm x_2,\cdots,\bm x_l\)</span>是<span class="math inline">\(R^n\)</span>中的<span class="math inline">\(l\)</span>个已知点。若对于某点<span class="math inline">\(\bm x\in R^n\)</span>，存在常数<span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_l\geq 0\)</span>，且<span class="math inline">\(\sum\lambda_i=1\)</span>，使得<span class="math inline">\(\bm x=\sum\lambda_i\bm x_i\)</span>，则称<span class="math inline">\(\bm x\)</span>是<span class="math inline">\(\bm x_1,\bm x_2,\cdots,\bm x_l\)</span>的凸组合。如果<span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_l>0\)</span>且<span class="math inline">\(\sum\lambda_i=1\)</span>，则称为严格凸组合。</p>
<h2 id="凸集">凸集</h2>
<p>对于<span class="math inline">\(C\subset R^n\)</span>中的任意两个点<span class="math inline">\(\bm x_1, \bm x_2\)</span>，如果连接两个点的线段在<span class="math inline">\(C\)</span>内，则称<span class="math inline">\(C\)</span>为凸集。即</p>
<p><span class="math display">\[\bm x_1,\bm x_2\in C\Rightarrow\theta \bm x_1+(1-\theta)\bm x_2\in C,\forall 0\leq\theta\leq 1
\]</span></p>
<p><strong>定理1</strong></p>
<p>任意一组凸集的交仍然是凸集。</p>
<p>特别的，规定空集是凸集。容易验证，空间<span class="math inline">\(R^n\)</span>、半空间、超平面、直线、点、球都是凸集。</p>
<p><strong>凸集分离定理</strong></p>
<p>设<span class="math inline">\(C_1,C_2\)</span>是<span class="math inline">\(R^n\)</span>中两个非空的集合，<span class="math inline">\(H=\{\bm x|\bm p^T\bm x=\alpha\}\)</span>为超平面，如果对<span class="math inline">\(\forall\bm x\in C_1\)</span>都有<span class="math inline">\(\bm p^T\bm x\geq \alpha\)</span>，对<span class="math inline">\(\forall x\in C_2\)</span>都有<span class="math inline">\(\bm p^T\bm x\leq \alpha\)</span>（或二者正好相反），则称超平面<span class="math inline">\(H\)</span>分离集合<span class="math inline">\(C_1,C_2\)</span></p>
<h2 id="半空间">半空间</h2>
<p>设<span class="math inline">\(\bm a\in R^n,\bm a\neq\bm 0,b\in R\)</span>，则集合</p>
<p><span class="math display">\[\{\bm x|\bm a^T\bm x>b,\bm x\in R^n\}
\]</span></p>
<p>称为<span class="math inline">\(R^n\)</span>的半空间。</p>
<p>有限个半空间的交<span class="math inline">\(\{\bm x|\bm A\bm x\leq \bm b\}\)</span>称为多面集，其中<span class="math inline">\(\bm A\)</span>为<span class="math inline">\(m\times n\)</span>矩阵，<span class="math inline">\(\bm b\)</span>为<span class="math inline">\(m\)</span>维向量。</p>
<h2 id="凸函数">凸函数</h2>
<p><strong>广义实值函数</strong></p>
<p>令<span class="math inline">\(\bar R\xlongequal{\text{def}}R\cup\{\pm\infty\}\)</span>为广义实数空间，则映射<span class="math inline">\(f:R^n\to\bar R\)</span>为广义实值函数。</p>
<p>规定<span class="math inline">\(-\infty< a<+\infty,\forall a\in R\)</span>，以及<span class="math inline">\((+\infty)+(+\infty)=+\infty,(+\infty)+a=+\infty,\forall a\in R\)</span></p>
<p><strong>适当函数</strong></p>
<p>给定广义实值函数<span class="math inline">\(f\)</span>和非空集合<span class="math inline">\(\mathcal{X}\)</span>，如果存在<span class="math inline">\(x\in\mathcal{X}\)</span>使得<span class="math inline">\(f(x)<+\infty\)</span>，并且对任意的<span class="math inline">\(x\in\mathcal{X}\)</span>，都有<span class="math inline">\(f(x)>-\infty\)</span>，那么称函数<span class="math inline">\(f\)</span>关于集合<span class="math inline">\(\mathcal{X}\)</span>是适当的。</p>
<p><strong>凸函数</strong></p>
<p>设函数<span class="math inline">\(f\)</span>为适当函数，如果<span class="math inline">\(\text{dom} f\)</span>是凸集，且</p>
<p><span class="math display">\[f(\theta x+(1-\theta)y)\leq \theta f(x)+(1-\theta)f(y)
\]</span></p>
<p>对所有<span class="math inline">\(x,y\in\text{dom}f,0\leq\theta\leq 1\)</span>都成立，则称<span class="math inline">\(f\)</span>是凸函数。</p>
<p>如果<span class="math inline">\(f(\theta x+(1-\theta)y)< \theta f(x)+(1-\theta)f(y)\)</span>，则称为严格凸函数。</p>
<p><strong>性质1</strong></p>
<p>设<span class="math inline">\(f_1,f_2\)</span>是凸集<span class="math inline">\(C\)</span>上的凸函数，则函数<span class="math inline">\(f_1+f_2\)</span>在<span class="math inline">\(S\)</span>上也是凸函数。</p>
<p><strong>性质2</strong></p>
<p>设<span class="math inline">\(f\)</span>是凸集<span class="math inline">\(C\)</span>上的凸函数，则对任意的<span class="math inline">\(a\geq 0\)</span>，函数<span class="math inline">\(af\)</span>也是凸函数。</p>
<h2 id="凸函数判定">凸函数判定</h2>
<p><span class="math inline">\(f\)</span>是凸函数，当且仅当对任意的<span class="math inline">\(x\in\text{dom}f,v\in R^n,g:R\to R\)</span></p>
<p><span class="math display">\[g(t)=f(x+tv),\text{dom} g = \{t|x+tv\in\text{dom} f\}
\]</span></p>
<p>是凸函数。</p>
<p><strong>一阶条件</strong></p>
<p>对于定义在凸集上的可微函数<span class="math inline">\(f\)</span>，<span class="math inline">\(f\)</span>是凸函数当且仅当</p>
<p><span class="math display">\[f(y)\geq f(x)+\nabla f(x)^T(y-x),\forall x,y\in\text{dom}f
\]</span></p>
<p>严格凸函数则要求<span class="math inline">\(>\)</span>号。物理意义是：任意点处的切线增量不超过函数的增量。</p>
<p><strong>梯度单调性</strong></p>
<p>设<span class="math inline">\(f\)</span>为可微函数，则<span class="math inline">\(f\)</span>为凸函数当且仅当<span class="math inline">\(\text{dom}f\)</span>为凸集且<span class="math inline">\(\nabla f\)</span>为单调映射，即</p>
<p><span class="math display">\[(\nabla f(x)-\nabla f(y))^T(x-y)\geq 0,\forall x,y\in\text{dom}f
\]</span></p>
<p><strong>二阶条件</strong></p>
<p>设<span class="math inline">\(f\)</span>为定义在凸集上的二阶连续可微函数，则<span class="math inline">\(f\)</span>是凸函数当且仅当</p>
<p><span class="math display">\[\nabla^2 f(x)\succeq 0,\forall x\in\text{dom}f
\]</span></p>
<p>如果<span class="math inline">\(\succ\)</span>，则是严格凸函数。</p>
<p>或者，凸函数的充要条件是<span class="math inline">\(\nabla^2 f(x)\)</span>在<span class="math inline">\(\text{dom}f\)</span>上的任意点均半正定。</p>
<h1 id="线性规划">线性规划</h1>
<h2 id="图解法">图解法</h2>
<ol>
<li>确定可行域</li>
<li>确定目标函数的等值线及优化方向</li>
<li>平行移动目标函数等值线，通过观察得到线性规划的最优解</li>
</ol>
<p>高中已经学过很多次这个东西了，不再详细介绍。</p>
<p>注意到，图解法只适用于有两个变量的情况，更高维的情况下，要用单纯形法。</p>
<h2 id="一般形式">一般形式</h2>
<p>一般形式如下</p>
<p><span class="math display">\[\min f(x_1+x_2+\cdots+x_n) = c_1x_1+c_2x_2+\cdots+c_nx_n
\]</span></p>
<p><span class="math display">\[s.t.
\left\{\begin{matrix}
a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n = b_1\\
a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n = b_2 \\
\vdots \\
a_{m1}x_1+a_{m2}x_2+\cdots+a_{mn}x_n = b_m\\
x_1,x_2,\cdots,x_n\geq 0
\end{matrix}\right.
\]</span></p>
<p>一共包含<span class="math inline">\(n\)</span>个决策变量，<span class="math inline">\(m\)</span>个约束条件。其中对目标函数既可以求最大也可以求最小，约束条件可以是<span class="math inline">\(=,\leq,\geq\)</span>。决策变量<span class="math inline">\(x_i\)</span>通常非负，也有其他情况。<span class="math inline">\(c_j\)</span>称为价值系数，<span class="math inline">\(b_j\)</span>称为资源系数，<span class="math inline">\(a_{ij}\)</span>称为约束系数、技术系数。</p>
<p>利用矩阵，可以写作</p>
<p><span class="math display">\[\min f(x) = c^Tx
\]</span></p>
<p><span class="math display">\[s.t.
\left\{\begin{matrix}
Ax=b\\
x\geq 0
\end{matrix}\right.
\]</span></p>
<h2 id="标准形式">标准形式</h2>
<p>标准形式有四个特征</p>
<ol>
<li>目标函数求<span class="math inline">\(\min\)</span></li>
<li>约束条件两端用<span class="math inline">\(=\)</span>连接</li>
<li>所有<span class="math inline">\(b_i\)</span>非负</li>
<li>所有<span class="math inline">\(x_i\)</span>非负</li>
</ol>
<p>接下来介绍如何转换其他形式到标准形式（注意按顺序来）</p>
<p><strong>目标函数求最小值</strong></p>
<p>例如<span class="math inline">\(\min z=x_1-2x_2+3x_3\)</span>，等价于<span class="math inline">\(\max z'=-x_1+2x_2-3x_3\)</span>，其中<span class="math inline">\(z'=-z\)</span></p>
<p><strong>约束函数求最小值</strong></p>
<ol>
<li>例如<span class="math inline">\(-2x_1+6x_2-x_3\leq3\)</span>，将其转化为</li>
</ol>
<p><span class="math display">\[-2x_1+6x_2-x_3+x_s=3
\]</span></p>
<p><span class="math inline">\(x_s\)</span>表示决策中尚未使用的那部分资源，所以称之为松弛变量。<span class="math inline">\(x_s\geq 0\)</span></p>
<ol start="2">
<li>例如<span class="math inline">\(-2x_1+6x_2-x_3\ge3\)</span>，将其转化为</li>
</ol>
<p><span class="math display">\[-2x_1+6x_2-x_3-x_s=3
\]</span></p>
<p><span class="math inline">\(x_s\)</span>表示决策中超过了实际需要的部分，影次常称它为剩余变量。<span class="math inline">\(x_s\geq 0\)</span></p>
<p>由上可见，既把函数从不等式转变成了等式，并且新添加的变量也是非负的，也不影响原来的目标函数。统一整个计算过程。</p>
<p><strong><span class="math inline">\(b_i\)</span>非负</strong></p>
<p>这个只需要将约束条件两端取反即可。</p>
<p><strong><span class="math inline">\(x_i\)</span>非负</strong></p>
<ol>
<li>若<span class="math inline">\(x_i\leq 0\)</span>，则令<span class="math inline">\(x'_i=-x_i\)</span>，此时<span class="math inline">\(x'_i\geq 0\)</span></li>
<li>若<span class="math inline">\(x_i\)</span>无约束，则令<span class="math inline">\(x_i = x_i'-x_i'',x_i'\geq0,x_i''\geq0\)</span></li>
</ol>
<p>注意这里的变换要把变换也代入目标函数中</p>
<h2 id="线性规划解的基本性质">线性规划解的基本性质</h2>
<p>对于线性规划问题来说，可行解实际上是由约束条件构成的线性方程组的解。并且还满足非负约束条件，即决策变量都取非负值。</p>
<p>我们假定线性规划问题的系数矩阵<span class="math inline">\(A\)</span>的秩总等于其行数，<span class="math inline">\(rank(A)=m\)</span>。这意味着系数矩阵<span class="math inline">\(A\)</span>的各行是线性无关的，这也表明约束方程中的各个方程是相互独立的。</p>
<p>由于<span class="math inline">\(A\)</span>的秩为<span class="math inline">\(m\)</span>，所以其必有一个<span class="math inline">\(m\times m\)</span>的子矩阵为<span class="math inline">\(B\)</span>，其行列式不为零。</p>
<p>我们将<span class="math inline">\(A\)</span>的任意一个这样的子矩阵<span class="math inline">\(B\)</span>称为线性规划问题的一个基。</p>
<p>显然<span class="math inline">\(B=[p_1,p_2,\cdots,p_m]\)</span>，其中的每一个为基向量，与基向量对应的变量<span class="math inline">\(x_j\)</span>称为基变量，<span class="math inline">\(x_B = [x_1,x_2,\cdots,x_m]^T\)</span>，其余称为非基变量，<span class="math inline">\(x_N=[x_{m+1},x_{m+2},\cdots,x_n]^T\)</span>。</p>
<p>可以得到一个解<span class="math inline">\(x=[x_B^T,x_N^T]^T=[x_1,x_2,\cdots,x_m,0,\cdots,0]^T\)</span></p>
<p>称<span class="math inline">\(x\)</span>为该约束方程的基解，其中<span class="math inline">\(x_b=B^{-1}b\)</span></p>
<p>对于满足非负约束条件的<span class="math inline">\(x\geq 0\)</span>（所有分量都大于等于<span class="math inline">\(0\)</span>）的基解称为可行解，对应的基称为可行基。</p>
<p>基可行解的非零分量个数小于<span class="math inline">\(m\)</span>时，称为退化解。也就是说，不是所有基解都是可行解。</p>
<p><strong>定理1</strong></p>
<p>线性规划问题的基可行解是其可行域的顶点。</p>
<p><strong>定理2</strong></p>
<p>若可行域有界，线性规划问题的目标函数则一定在其可行域的极点上达到最优。</p>
<h2 id="单纯形法">单纯形法</h2>
<p>前面提到，可行解一定在凸集的顶点上，但是，这个顶点的数量很可能非常大。单纯形法就是在这些顶点中优化的算法</p>
<p>基本思路</p>
<ol>
<li>首先将线性规划问题化成标准形式</li>
<li>求出初始基本可行解</li>
<li>判断其是否为最优解</li>
<li>如果不是最优，则迭代到其相邻的基本可行解，并再次检验</li>
</ol>
<p>单纯形法把寻优的目标集中在所有基本可行解（即可行域顶点）中。从一个初始的基本可行解出发，寻找一条达到最优基本可行解的最佳路径。</p>
<h3 id="确定初始基本可行解">确定初始基本可行解</h3>
<p>确定初始的基本可行解等价于确定初始的可行基，一旦初始的可行基确定了，那么对应的初始基本可行解也就唯一确定.</p>
<p>方便起见，不妨设<span class="math inline">\(A\)</span>中的千<span class="math inline">\(m\)</span>个系数列向量恰好构成一个可行基，即<span class="math inline">\(A=(B|N)\)</span></p>
<p>其中<span class="math inline">\(B=[p_1,p_2,\cdots,p_m]\)</span>为基变量<span class="math inline">\(x_1,x_2,\cdots,x_m\)</span>的系数列向量构成的可行基。</p>
<p><span class="math inline">\(N = [p_{m+1},p_{m+2},\cdots,p_n]\)</span>为非基变量<span class="math inline">\(x_{m+1},x_{m+2},\cdots,x_n\)</span>的系数列向量构成的矩阵。</p>
<p>即原始问题为</p>
<p><span class="math display">\[\min z = c^Tx
\]</span></p>
<p><span class="math display">\[s.t.\left\{\begin{matrix}
Ax=b \\
x\geq 0
\end{matrix}\right.
\]</span></p>
<p>化为</p>
<p><span class="math display">\[\min z = [c_B^T,c_N^T][x_B^T,x_N^T]^T
\]</span></p>
<p><span class="math display">\[s.t.\left\{\begin{matrix}
[B,N][x_B^T,x_N^T]^T=b \\
x_B,x_N\geq 0
\end{matrix}\right.
\]</span></p>
<p>乘法后得</p>
<p><span class="math display">\[\min z = c_B^Tx_B+c_N^Tx_N
\]</span></p>
<p><span class="math display">\[s.t.\left\{\begin{matrix}
Bx_B+Nx_N=b \\
x_B,x_N\geq 0
\end{matrix}\right.
\]</span></p>
<p>计算出<span class="math inline">\(x_B = B^{-1}b-B^{-1}Nx_N\)</span>，代入目标函数中，得到</p>
<p><span class="math display">\[\min z = c_B^TB^{-1}b-(c_B^TB^{-1}N-c_N^T)x_N
\]</span></p>
<p><span class="math display">\[s.t.\left\{\begin{matrix}
x_B = B^{-1}b-B^{-1}Nx_N \\
x_B,x_N\geq 0
\end{matrix}\right.
\]</span></p>
<p>令<span class="math inline">\(x_N=\bm 0\)</span>，则<span class="math inline">\(x_B=B^{-1}b\)</span></p>
<p>所以初始的基本可行解为<span class="math inline">\(x=[x_B^T,0]^T\)</span></p>
<h3 id="判断现行的基本可行解是否最优">判断现行的基本可行解是否最优</h3>
<p>假如求得一个基本可行解为<span class="math inline">\(x=[x_B^T,0]^T\)</span>，那么</p>
<p><span class="math display">\[z = cx = [c_B^T,c_N^T][(B^{-1}b)^T,0]^T=c_B^TB^{-1}b
\]</span></p>
<p>如果检验向量<span class="math inline">\(\sigma_N\)</span>满足</p>
<p><span class="math display">\[\sigma_N^T = c_N^T - c_B^TB^{-1}N\geq 0
\]</span></p>
<p>这个基本可行解就是最优解。检验向量的各个分量称为检验数。上面的<span class="math inline">\(\geq0\)</span>是指每个分量都<span class="math inline">\(\geq 0\)</span></p>
<p><strong>特殊情况1</strong></p>
<p>如果<span class="math inline">\(\sigma_N^T\geq 0\)</span>，其中存在一个检验数<span class="math inline">\(\sigma_{m+k}=0\)</span>，则线性规划问题有无穷多最优解</p>
<p><strong>特殊情况2</strong></p>
<p><span class="math inline">\(\sigma_N^T\)</span>，其中存在一个检验数<span class="math inline">\(\sigma_{m+k}<0\)</span>，且该检验数所对应的非基变量的系数列向量的全部系数都为负数或零，则线性规划问题无有界最优解。</p>
<h3 id="基本可行解的改进基变换">基本可行解的改进——基变换</h3>
<p>如果现行的基本可行解<span class="math inline">\(x\)</span>不是最优解，即在检验向量<span class="math inline">\(σ_N^T=c_N^T－c_B^TB^{-1}N\)</span>中存在负的检验数，则需在原基本可行解<span class="math inline">\(x\)</span>的基础上寻找一个新的基本可行解，并使目标函数值有所改善。</p>
<p>具体做法是：</p>
<ol>
<li>先从检验数为负的非基变量中确定一个换入变量，使它从非基变量变成基变量，</li>
<li>再从原来的基变量中确定一个换出变量，使它从基变量变成非基变量。由此得到一个新的基本可行解。</li>
</ol>
<p><strong>换入变量的确定-最大减小原则</strong></p>
<p>假设检验向量<span class="math inline">\(\sigma_N^T = c_N^T-c_B^TB^{-1}N = [\sigma_{m+1},\sigma_{m+2},\cdots,\sigma_n]\)</span>。若其中有两个以上的检验数为负，那么为了使目标函数值下降最快，就要选取最小负检验数所对应的非基变量为换入变量。</p>
<p>即若<span class="math inline">\(\sigma_{m+k}\)</span>是最小的，那么就要把<span class="math inline">\(x_{m+k}\)</span>换入。</p>
<p><strong>换出变量的确定-最小比值原则</strong></p>
<p>如果确定<span class="math inline">\(x_{m+k}\)</span>为换入变量，方程<span class="math inline">\(x_B = B^{-1}b-B^{-1}Nx_N\Rightarrow x_B = B^{-1}b-B^{-1}p_{m+k}x_{m+k}\)</span></p>
<p>其中<span class="math inline">\(p_{m+k}\)</span>为<span class="math inline">\(A\)</span>中与<span class="math inline">\(x_{m+k}\)</span>对应的系数列向量。我们要在<span class="math inline">\(x_B = (x_1,x_2,\cdots,x_m)^T\)</span>中确定一个基变量为换出变量，可以按最小比值原则确定换出变量。</p>
<p><span class="math display">\[\theta = \min\bigg\{\dfrac{(B^{-1}b)_i}{(B^{-1}p_{m+k})_i}\bigg|(B^{-1}p_{m+k})_i>0,1\leq i\leq m\bigg\} = \dfrac{(B^{-1}b)_l}{(B^{-1}p_{m+k})_l}
\]</span></p>
<p>则选择对应的<span class="math inline">\(x_l\)</span>作为换出变量。这里的角标是因为<span class="math inline">\(B^{-1}b\)</span>和<span class="math inline">\(B^{-1}p_{m+k}\)</span>都是<span class="math inline">\(m\)</span>维向量。</p>
<h3 id="用初等变换求改进了的基本可行解旋转运算">用初等变换求改进了的基本可行解——旋转运算</h3>
<p>假设<span class="math inline">\(B\)</span>是可行基，则</p>
<p><span class="math display">\[Ax = b\Rightarrow[B,N][x_B^T,x_N^T]^T = b\Rightarrow [I,B^{-1}N][x_B^T,x_N^T]^T = B^{-1}b
\]</span></p>
<p>令非基变量<span class="math inline">\(x_N=\bm 0\)</span>，则基变量<span class="math inline">\(x_B = B^{-1}b\)</span>，基本可行解为<span class="math inline">\(x=[(B^{-1}b)^T,0]^T\)</span></p>
<p>用逆阵<span class="math inline">\(B^{-1}\)</span>左乘约束方程组的两端，等价于对方程组施以一系列的初等“行变换”。变换的结果是将系数矩阵<span class="math inline">\(A\)</span>中的可行基<span class="math inline">\(B\)</span>变换成单位矩阵<span class="math inline">\(I\)</span>，把非基变量系数列向量构成的矩阵<span class="math inline">\(N\)</span>变换成<span class="math inline">\(B^{-1}N\)</span>，把向量<span class="math inline">\(b\)</span>变换成<span class="math inline">\(B^{-1}b\)</span></p>
<p>变换前后的方程组同解。</p>
<p>且改进了的基本可行解<span class="math inline">\(X'\)</span>只是在<span class="math inline">\(X\)</span>的基变量的基础上用一个换入变量替代其中一个换出变量，其它的基变量仍然保持不变。这些基变量的系数列向量是单位矩阵<span class="math inline">\(I\)</span>中的单位向量。为了求得改进的基本可行解<span class="math inline">\(X'\)</span>，只需对增广矩阵</p>
<p><span class="math display">\[[I,B^{-1}N,B^{-1}b]
\]</span></p>
<p>施行初等行变换，将换入变量的系数列向量变换成换出变量所对应的单位向量即可。</p>
<h3 id="表格单纯形法">表格单纯形法</h3>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 199; 
			flex-basis: 479px"
	>
	<a href="/p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.jpg" data-size="1149x575">
		<img src="/p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.jpg"
			width="1149"
			height="575"
			srcset="/p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_hu150b37b5d5b459a093e4293be2a60eb6_40273_480x0_resize_q75_box.jpg 480w, /p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_hu150b37b5d5b459a093e4293be2a60eb6_40273_1024x0_resize_q75_box.jpg 1024w"
			loading="lazy"
			alt="1.jpg">
	</a>
	
	<figcaption>1.jpg</figcaption>
	
</figure></p>
<h2 id="对偶问题原理">对偶问题原理</h2>
<p>假设全是列向量。</p>
<p>设原问题<span class="math inline">\(P\)</span>为</p>
<p><span class="math display">\[\min f(x) = c^Tx
\]</span></p>
<p><span class="math display">\[s.t.
\left\{\begin{matrix}
Ax\geq b\\
x\geq 0
\end{matrix}\right.
\]</span></p>
<p>则其对偶问题<span class="math inline">\(D\)</span>为</p>
<p><span class="math display">\[\max g(y) = b^Ty
\]</span></p>
<p><span class="math display">\[s.t.
\left\{\begin{matrix}
A^Ty\leq c\\
y\geq 0
\end{matrix}\right.
\]</span></p>
<h3 id="对偶关系表">对偶关系表</h3>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 182; 
			flex-basis: 439px"
	>
	<a href="/p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.jpg" data-size="990x541">
		<img src="/p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.jpg"
			width="990"
			height="541"
			srcset="/p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2_hu9a7be74fd929d209461aa2a061968058_71131_480x0_resize_q75_box.jpg 480w, /p/%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2_hu9a7be74fd929d209461aa2a061968058_71131_1024x0_resize_q75_box.jpg 1024w"
			loading="lazy"
			alt="2.jpg">
	</a>
	
	<figcaption>2.jpg</figcaption>
	
</figure></p>
<h3 id="对偶关系定理">对偶关系定理</h3>
<p><strong>弱对偶定理</strong></p>
<p>对偶问题(max)的任何可行解<span class="math inline">\(Y^*\)</span>，其目标函数值总是不大于原问题(min)任何可行解<span class="math inline">\(X^*\)</span>的目标函数值。</p>
<p><strong>对偶定理</strong></p>
<p>假如原问题或对偶问题之一具有有限的最优解，则另一问题也具有有限的最优解，且两者响应的目标函数值相等。假如一个问题的目标函数值是无界的，则另一问题没有可行解。</p>
<p><strong>互补松弛定理</strong></p>
<p>假设<span class="math inline">\(X^*,Y^*\)</span>分别是原问题和对偶问题的可行解，<span class="math inline">\(U^*\)</span>是原问题剩余变量的值，<span class="math inline">\(V^*\)</span>是对偶问题松弛变量的值，则<span class="math inline">\(X^*,Y^*\)</span>分别为原问题和对偶问题的最优解的充要条件是</p>
<p><span class="math display">\[X^*V^*+Y^*U^* = 0
\]</span></p>
<p>这个定理还表述为如下两个形式</p>
<ol>
<li>假如一个问题的某个变量取正数，则相应问题的另外一个约束条件必取等式</li>
<li>一个问题中的约束条件不取等式，则相应于另一个问题中的变量为零</li>
</ol>
<p>说起来有些抽象，做题理解。</p>
<h1 id="一维搜索法">一维搜索法</h1>
<h2 id="概念">概念</h2>
<p>对于一维无约束优化问题</p>
<p><span class="math display">\[\min f(\alpha)
\]</span></p>
<p>求解极小点和极小值的数值迭代方法即为一维搜索方法。</p>
<p>极小点的必要条件和充分条件见前。注意我们可以用充分条件求解最小值，但是并不是所有情况都能使用，比如函数不一定二阶可微。所以我们常使用迭代法。</p>
<h2 id="基本步骤">基本步骤</h2>
<ol>
<li>确定搜索区间<span class="math inline">\([a,b]\)</span></li>
<li>在区间内寻找最小点</li>
</ol>
<p>优化算法的基本迭代公式为：</p>
<p><span class="math display">\[x^{k+1} = x^{k} + \alpha^kd^k
\]</span></p>
<p>其中<span class="math inline">\(\alpha^k\)</span>为搜索步长，<span class="math inline">\(d^k\)</span>为搜索方向。<span class="math inline">\(x^0\)</span>为人工给出的初始估计。</p>
<h2 id="终止条件">终止条件</h2>
<p><strong>两次迭代的绝对误差</strong></p>
<p><span class="math display">\[|f(x^{k+1})-f(x^k)|<\varepsilon,\quad ||x^{k+1}-x^k||<\varepsilon
\]</span></p>
<p><strong>两次迭代的相对误差</strong></p>
<p><span class="math display">\[\dfrac{|f(x^{k+1})-f(x^k)|}{|f(x^k)|}<\varepsilon,\quad \dfrac{||x^{k+1}-x^k||}{||x^k||}<\varepsilon
\]</span></p>
<p><strong>目标函数梯度的模足够小</strong></p>
<p><span class="math display">\[||\nabla f(x^k)||<\varepsilon
\]</span></p>
<h2 id="搜索区间的确定">搜索区间的确定</h2>
<h3 id="单谷峰函数">单谷（峰）函数</h3>
<p>我们选取的区间使得函数是单股（峰的），这样我们有以下定理（单谷为例）</p>
<p>设<span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上单谷，<span class="math inline">\(x^*\in[a,b]\)</span>是其极小点，<span class="math inline">\(x_1< x_2\)</span>是<span class="math inline">\([a,b]\)</span>上任意两点。则：</p>
<ul>
<li>若<span class="math inline">\(f(x_1)\geq f(x_2)\)</span>，则<span class="math inline">\(x^*\in[x_1,b]\)</span></li>
<li>否则<span class="math inline">\(x^*[a,x_2]*\)</span></li>
</ul>
<h3 id="进退算法成功-失败法">进退算法（成功-失败法）</h3>
<p>求取区间。</p>
<ol>
<li>选取初始点<span class="math inline">\(a\)</span>和步长<span class="math inline">\(h\)</span></li>
<li>计算并比较<span class="math inline">\(f(a),f(a+h)\)</span>。</li>
</ol>
<p>若<span class="math inline">\(f(a)\geq f(a+h)\)</span>，则步长加倍，计算<span class="math inline">\(f(a+3h)\)</span>。若<span class="math inline">\(f(a+h)\leq f(a+3h)\)</span>，则令<span class="math inline">\(a_1=a,a_2=a+3h\)</span>，停止运算；否则步长加倍，并重复以上（计算<span class="math inline">\(a+3h\)</span>和<span class="math inline">\(a+7h\)</span>）。</p>
<p>若<span class="math inline">\(f(a)< f(a+h)\)</span>，则步长变为<span class="math inline">\(-h\)</span>，计算<span class="math inline">\(f(a-h)\)</span>。若<span class="math inline">\(f(a-h)\geq f(a)\)</span>，则令<span class="math inline">\(a_1=a-h,a_2=a+h\)</span>，停止运算；否则步长加倍，继续后退（计算<span class="math inline">\(a-h\)</span>和<span class="math inline">\(a-3h\)</span>）。</p>
<h2 id="二分法">二分法</h2>
<p>已知区间<span class="math inline">\([a,b]\)</span>，且<span class="math inline">\(f(x)\)</span>在其中可微，求极小点</p>
<ol>
<li>计算<span class="math inline">\(x_0=\dfrac{a+b}{2}\)</span></li>
<li>若<span class="math inline">\(f'(x_0)<0\)</span>，令<span class="math inline">\(a = x_0\)</span>，转步骤<span class="math inline">\(3\)</span>。若<span class="math inline">\(f'(x_0)>0\)</span>，令<span class="math inline">\(b = x_0\)</span>，转步骤<span class="math inline">\(3\)</span>。若<span class="math inline">\(f'(x_0)=0\)</span>，停止，<span class="math inline">\(x^*=x_0\)</span>。</li>
<li>若<span class="math inline">\(|b-a|<\varepsilon\)</span>，则<span class="math inline">\(x^*=\dfrac{a+b}{2}\)</span>，停止，否则转步骤<span class="math inline">\(1\)</span></li>
</ol>
<p><strong>优点</strong></p>
<p>计算量少，而且总能收敛到一个局部极小点</p>
<p><strong>缺点</strong></p>
<p>收敛速度慢</p>
<h2 id="牛顿切线法">牛顿切线法</h2>
<ol>
<li>给定初始点<span class="math inline">\(x_0,\varepsilon>0,k=0\)</span></li>
<li>计算<span class="math inline">\(f'(x_k),f''(x_k)\)</span></li>
<li>若<span class="math inline">\(|f'(x_k)|<\varepsilon\)</span>，停止，<span class="math inline">\(x^*=x_k\)</span>，否则转步骤<span class="math inline">\(4\)</span></li>
<li>计算</li>
</ol>
<p><span class="math display">\[x_{k+1} = x_k - \dfrac{f'(x_k)}{f''(x_k)}
\]</span></p>
<p>令<span class="math inline">\(k = k+1\)</span>，转步骤<span class="math inline">\(2\)</span></p>
<p><strong>优点</strong></p>
<p>收敛快，局部二阶收敛</p>
<p><strong>缺点</strong></p>
<p>计算二阶导数工作量大。对初始点要求高，需要初始点离极小点不太远，否则有可能使极小化发散或收敛到非极小点；局部收敛。</p>
<h2 id="黄金分割法">黄金分割法</h2>
<ol>
<li>给定区间<span class="math inline">\([a,b],\varepsilon>0\)</span></li>
<li>计算<span class="math inline">\(x_1 = a+0.382(b-a),x_2 = a+0.618(b-a),f(x_1),f(x_2)\)</span></li>
<li>如果<span class="math inline">\(f(x_1)< f(x_2)\)</span>，则<span class="math inline">\(b = x_2，x_2 = x_1,f_2=f_1,x_1 = a+0.382(b-a),f_1 = f(x_1)\)</span>。否则<span class="math inline">\(a=x_1,x_1=x_2,f_1=f_2,x_2=a+0.618(b-a),f_2=f(x_2)\)</span></li>
<li>判断<span class="math inline">\(|a-b|<\varepsilon\)</span>，则跳转<span class="math inline">\(5\)</span>，否则跳转<span class="math inline">\(4\)</span></li>
<li><span class="math inline">\(x^*=0.5(a+b),f^*=f(x^*)\)</span>，终止。</li>
</ol>
<p><strong>优点</strong></p>
<p>不要求函数可微，计算量小，程序简单</p>
<p><strong>缺点</strong></p>
<p>收敛慢</p>
<h2 id="抛物线插值法">抛物线插值法</h2>
<p>以二次插值法为例</p>
<ol>
<li>设置初始区间<span class="math inline">\([x_1,x_3]\)</span>，和一中间点<span class="math inline">\(x_2\)</span>，一般为区间中点，设置<span class="math inline">\(\varepsilon>0\)</span></li>
<li>计算<span class="math inline">\(f_1,f_2,f_3\)</span>，计算</li>
</ol>
<p><span class="math display">\[\overline{x} = \dfrac{1}{2}(x_1+x_3-\dfrac{c_1}{c_2})
\]</span></p>
<p>其中</p>
<p><span class="math display">\[c_1 = \dfrac{f_1-f_3}{x_1-x_3}, c_2 = \dfrac{\dfrac{f_1-f_2}{x_1-x_2}-c_1}{x_2-x_3}
\]</span></p>
<p>计算<span class="math inline">\(f(\overline{x})\)</span></p>
<ol start="3">
<li>若<span class="math inline">\(\overline{x}< x_2\)</span>，则新区间为<span class="math inline">\([x_1,x_2]\)</span>，否则新区间为<span class="math inline">\([x_2,x_3]\)</span>。如果<span class="math inline">\(|x_2-\overline{x}|<\varepsilon\)</span>，停止迭代，进入<span class="math inline">\(4\)</span>。新中间点为<span class="math inline">\(\overline{x}\)</span>，返回<span class="math inline">\(2\)</span></li>
<li><span class="math inline">\(x^*=\overline{x},f^*=f(\overline{x})\)</span>，终止。</li>
</ol>
<p><strong>优点</strong></p>
<p>不要求函数可微，计算量小，程序简单，比黄金分割法快</p>
<p><strong>缺点</strong></p>
<p>不如黄金分割法可靠</p>
<h1 id="无约束最优化方法">无约束最优化方法</h1>
<p>本章和上章一样都是无约束问题，但是本章的函数是<span class="math inline">\(f:R^N\to R\)</span></p>
<h2 id="搜索步长准则">搜索步长准则</h2>
<h3 id="armijo准则">Armijo准则</h3>
<p>设<span class="math inline">\(d^k\)</span>是<span class="math inline">\(x^k\)</span>处的下降方向，若</p>
<p><span class="math display">\[f(x^k+\alpha d^k)\leq f(x^k)+c_1\alpha \nabla f(x^k)^Td^k
\]</span></p>
<p>则称步长<span class="math inline">\(\alpha\)</span>满足Armijo准则，其中<span class="math inline">\(c_1\in (0,1)\)</span>是一个常数（通常很小，1e-3）</p>
<p>它有一些缺点，例如<span class="math inline">\(\alpha=0\)</span>显然满足条件</p>
<h3 id="goldstein准则">Goldstein准则</h3>
<p><span class="math display">\[f(x^k+\alpha d^k)\leq f(x^k)+c\alpha \nabla f(x^k)^Td^k
\]</span></p>
<p><span class="math display">\[f(x^k+\alpha d^k)\geq f(x^k)+(1-c)\alpha \nabla f(x^k)^Td^k
\]</span></p>
<p>则称步长<span class="math inline">\(\alpha\)</span>满足Goldstein准则，其中<span class="math inline">\(c\in (0,\dfrac{1}{2})\)</span>是一个常数。</p>
<p>它克服了Armijo的困难。第一个公式保证了其有足够的下降，第二个公式保证了步长足够大。</p>
<h2 id="最速下降法">最速下降法</h2>
<p>迭代格式为</p>
<p><span class="math display">\[x^{k+1} = x^k - \alpha_k\nabla f(x^k)
\]</span></p>
<p>显然，这个方法就是选取方向<span class="math inline">\(d^k = -\nabla f(x^k)\)</span>，也就是最快下降方法。我们通常会记<span class="math inline">\(g(x) = \nabla f(x)\)</span>。</p>
<p>终止准则为<span class="math inline">\(||g(x^{k+1})||\leq \varepsilon\)</span></p>
<p><span class="math inline">\(\alpha_k\)</span>可以设定为常数，也可以用线搜索算法确定。设定为常数时不会有锯齿状况，只有线搜索出来的最优步长会锯齿。</p>
<p>最优步长为</p>
<p><span class="math display">\[t_k = \arg\min_t f(x^k-t\nabla f(x^k))
\]</span></p>
<p>线搜索得到<span class="math inline">\(\alpha_k\)</span>的方法为回退法。其满足Armijo准则。首先给定初值<span class="math inline">\(\hat{\alpha}\)</span>，回退发同步不断以指数方式缩小试探步长，找到第一个满足Armijo准则的点。</p>
<ul>
<li>选择初始步长<span class="math inline">\(\hat{\alpha}\)</span>,参数<span class="math inline">\(\gamma,c\in(0,1)\)</span>（经验上来说，选择<span class="math inline">\(\gamma\)</span>接近<span class="math inline">\(1\)</span>比如0.95，<span class="math inline">\(c\)</span>很小，比如1e-3），初始化<span class="math inline">\(\alpha\leftarrow\hat{\alpha}\)</span></li>
<li>当<span class="math inline">\(f(x^k+\alpha d^k)>f(x^k)+c\alpha\nabla f(x^k)^T d^k\)</span>时，令<span class="math inline">\(\alpha\leftarrow \gamma\alpha\)</span></li>
<li>输出<span class="math inline">\(a_k = \alpha\)</span></li>
</ul>
<p><strong>正定二次函数情况</strong></p>
<p>如果<span class="math inline">\(f(x) = \dfrac{1}{2}x^TAx+b^Tx+c\)</span></p>
<p>则最优步长为</p>
<p><span class="math display">\[\alpha_k = \dfrac{||\nabla(f^k)||^2}{\nabla f(x^k)^TA\nabla f(x^k)}
\]</span></p>
<p>也可以写作</p>
<p><span class="math display">\[\alpha_k = \dfrac{g_k^Tg_k}{g_k^TAg_k}
\]</span></p>
<p><strong>优点</strong></p>
<p>算法简单、计算量小、占用内存小</p>
<p><strong>缺点</strong></p>
<p>收敛速度慢，前后两次的搜索方向是正交的（仅限于最优步长情况），容易困在局部最优，还可能被困在鞍点</p>
<h2 id="随机梯度降">随机梯度降</h2>
<p>我们的优化目标变为了</p>
<p><span class="math display">\[\min f(x) = \dfrac{1}{N}\sum^N_{i=1}f_i(x)
\]</span></p>
<p>其中<span class="math inline">\(f_i(x)\)</span>对应第<span class="math inline">\(i\)</span>个样本的损失函数。</p>
<p>按照最速下降法的要求，</p>
<p><span class="math display">\[x^{k+1} = x^k - \alpha_k\nabla f(x^k)
\]</span></p>
<p>我们的梯度为</p>
<p><span class="math display">\[\nabla f(x^k) = \dfrac{1}{N}\sum^N_{i=1}\nabla f_i(x^k)
\]</span></p>
<p>通常，这个量会很大，我们不能简单的得到梯度。于是我们用到了随机梯度降</p>
<p><span class="math display">\[x^{k+1} = x^k - \alpha_k\nabla f_{S_k}(x^k)
\]</span></p>
<p>其中<span class="math inline">\(s_k\)</span>是从<span class="math inline">\(\{1,2,\cdots,N\}\)</span>中随机等可能的抽取的一个样本。<span class="math inline">\(\alpha_k\)</span>是步长，在人工智能算法中也叫做学习率。</p>
<p>可以推断得到</p>
<p><span class="math display">\[E_{S_k}[\nabla f_{S_k}(x^k)|x^k] = \nabla f(x^k)
\]</span></p>
<p><strong>优缺点</strong></p>
<p>同下</p>
<h2 id="小批量随机梯度降">小批量随机梯度降</h2>
<p>即抽取元素比较少的集合<span class="math inline">\(B_k\in \{1,2,\cdots,N\}\)</span></p>
<p><span class="math display">\[x^{k+1} = x^k - \dfrac{\alpha_k}{|B_k|}\sum_{s\in B_k}\nabla f_{s}(x^k)
\]</span></p>
<p>其中<span class="math inline">\(|B_k|\)</span>为元素个数，又叫batch-size。大小为1时就是随机梯度降，大小和训练样本数据一样大时，算法就是梯度下降。</p>
<p><strong>优点</strong></p>
<p>同梯度降</p>
<p><strong>缺点</strong></p>
<p>学习率选取较为困难，容易收敛到局部最优，还可能被困在鞍点</p>
<h2 id="动量法">动量法</h2>
<p><span class="math display">\[v^{k+1} = \mu_k v^k - \alpha_k\nabla f_{S_k}(x^k)
\]</span></p>
<p><span class="math display">\[x^{k+1} = x^k + v^{k+1}
\]</span></p>
<p>其中<span class="math inline">\(\mu_k\in [0,1)\)</span>，通常取<span class="math inline">\(\mu_k\geq 0.5\)</span>，代表具有较大的惯性。<span class="math inline">\(\mu_k=0\)</span>时退化成随机梯度降。</p>
<p><strong>优点</strong></p>
<p>和上一次梯度方向一致时，能很好的加速。能够跳出局部最优。在梯度改变方向的时候，能减少迭代次数</p>
<h2 id="nesterov算法">Nesterov算法</h2>
<p><span class="math display">\[v^{k+1} = \mu_k v^k - \alpha_k\nabla f_{S_k}(x^k+\mu_k v^k)
\]</span></p>
<p><span class="math display">\[x^{k+1} = x^k + v^{k+1}
\]</span></p>
<p>即提前预估了下一次参数所在的位置。</p>
<h2 id="adagrad">AdaGrad</h2>
<p>该方法可以自发调整参数。</p>
<p>令<span class="math inline">\(g^k = \nabla f_{S_k}(x^k)\)</span></p>
<p>引入向量</p>
<p><span class="math display">\[G^k = \sum^k_{i=1}g^i\odot g^i
\]</span></p>
<p>其中<span class="math inline">\(\odot\)</span>代表向量的对应分量相乘，然后再组合成新的向量。</p>
<p>迭代格式为</p>
<p><span class="math display">\[x^{k+1} = x^k-\dfrac{\alpha}{\sqrt{G^k+\varepsilon}}\odot g^k
\]</span></p>
<p><span class="math display">\[G^{k+1} = G^k  + g^{k+1}\odot g^{k+1}
\]</span></p>
<p>这里<span class="math inline">\(\alpha\)</span>为初始步长，<span class="math inline">\(\varepsilon>0\)</span>是防止除零操作。</p>
<p><strong>缺点</strong></p>
<p>随着迭代次数的增加，<span class="math inline">\(G^k\)</span>越来越大，使得<span class="math inline">\(\dfrac{\alpha}{\sqrt{G^k+\varepsilon}}\to 0\)</span>，梯度消失</p>
<h3 id="rmsprop">RMSProp</h3>
<p>为了解决学习率趋于<span class="math inline">\(0\)</span>的问题，引入一个<span class="math inline">\(\rho\in[0,1)\)</span></p>
<p><span class="math display">\[x^{k+1} = x^k-\dfrac{\alpha}{\sqrt{M^k+\varepsilon}}\odot g^k
\]</span></p>
<p><span class="math display">\[M^{k+1} = \rho M^k  + (1-\rho) g^{k+1}\odot g^{k+1}
\]</span></p>
<h3 id="adadelta">AdaDelta</h3>
<p>令</p>
<p><span class="math display">\[g'_k = \sqrt{\dfrac{\Delta x^k+\varepsilon}{M^k+\varepsilon}}\odot g^k
\]</span></p>
<p>迭代如下</p>
<p><span class="math display">\[x^{k+1} = x^k-g'_k
\]</span></p>
<p><span class="math display">\[M^{k+1} = \rho M^k  + (1-\rho) g^{k+1}\odot g^{k+1}
\]</span></p>
<p><span class="math display">\[\Delta x^{k+1} = \rho \Delta x^k + (1-\rho)g'_k\odot g'_k 
\]</span></p>
<h3 id="adam">Adam</h3>
<p>可以算是RMSProp和动量方法的缝合方法，Adam不直接使用随机梯度作为基础的更新方向，而是选择了一个动量项进行更新：</p>
<p><span class="math display">\[S^k = \rho_1 S^{k-1} + (1-\rho_1)g^k
\]</span></p>
<p>与此同时又和RMSProp相似：</p>
<p><span class="math display">\[M^k = \rho_2 M^{k-1} + (1-\rho_2) g^k\odot g^k
\]</span></p>
<p>并不使用这两个量进行更新，而是先修正</p>
<p><span class="math display">\[\hat S^k = \dfrac{S^k}{1-\rho_1^k}, \hat M^k = \dfrac{M^k}{1-\rho_2^k}
\]</span></p>
<p>这里<span class="math inline">\(\rho_1^k,\rho_2^k\)</span>是其<span class="math inline">\(k\)</span>次方。然后使用如下公式更新：</p>
<p><span class="math display">\[x^{k+1} = x^k - \dfrac{\alpha}{\sqrt{\hat M^k+\varepsilon}}\odot \hat S^k
\]</span></p>
<p>这里的参数<span class="math inline">\(\rho_1\)</span>通常选为<span class="math inline">\(0.9\)</span>，<span class="math inline">\(\rho_2\)</span>通常选为<span class="math inline">\(0.999\)</span>，全局步长<span class="math inline">\(\alpha = 0.001\)</span></p>
<h2 id="牛顿法">牛顿法</h2>
<p>牛顿法和一维搜索里面的那个基本就是一样的。</p>
<p><span class="math display">\[x^{k+1} = x^k - \dfrac{\nabla f(x^k)}{\nabla ^2f(x^k)}
\]</span></p>
<p>它的步长恒为<span class="math inline">\(1\)</span>，停止条件为<span class="math inline">\(||\nabla f(x^k)||<\varepsilon\)</span></p>
<h2 id="修正牛顿法">修正牛顿法</h2>
<p>第一个修正是修正在其步长上，我们不再使用固定步长<span class="math inline">\(1\)</span>，而是像梯度下降法一样，使用线搜索方法确定一个步长。</p>
<p>第二个修正是在海瑟矩阵上。海瑟矩阵在高维的时候既不容易计算也不容易储存，并且如果海瑟矩阵不正定，下降方向可能会很差。为此，我们求解下降方向<span class="math inline">\(d^k\)</span>时，首先确定矩阵<span class="math inline">\(E^k\)</span>使得矩阵<span class="math inline">\(B^k\xlongequal{\text{def}}\nabla^2f(x^k)+E^k\)</span>正定且条件数较小，之后求解修正的牛顿方程<span class="math inline">\(B^k d^k=-\nabla f(x^k)\)</span>得到方向<span class="math inline">\(d^k\)</span>。</p>
<p>迭代方程还是<span class="math inline">\(x^{k+1}=x^k+\alpha_kd^k\)</span></p>
<h2 id="拟牛顿法">拟牛顿法</h2>
<p>拟牛顿算法直接放弃计算海瑟矩阵，而是找到一个具有类似性质的、方便维护的矩阵去替代。</p>
<h3 id="dfp更新公式">DFP更新公式</h3>
<p>定义矩阵<span class="math inline">\(H^0=I\)</span>，其更新公式为</p>
<p><span class="math display">\[H^{k+1} = H^k + \dfrac{s^k(s^k)^T}{(y^k)^Ts^k} - \dfrac{H^ky^k(H^ky^k)^T}{(y^k)^TH^ky^k}
\]</span></p>
<p>其中<span class="math inline">\(s^k = x^{k+1}-x^k, y^ k= g^{k+1}-g^{k}\)</span></p>
<p>优化算法的迭代公式是</p>
<p><span class="math display">\[x^{k+1} = x^k - \alpha_kH^k\nabla f(x^k)
\]</span></p>
<p>其中<span class="math inline">\(\alpha_k\)</span>用线搜索确定。注意这里的<span class="math inline">\(H\)</span>直接就具有海瑟逆矩阵的性质，不用写到分母上了。</p>
<h2 id="共轭方向法">共轭方向法</h2>
<p>思想：为了克服锯齿现象，假设能够选定下一次迭代的搜索方向直指极小点<span class="math inline">\(X^*\)</span> ，那么对于二元二次函数只需依次沿搜索方向<span class="math inline">\(d^0,d^1\)</span>进行两次精确一维搜索就可以求到极小点<span class="math inline">\(X^*\)</span>。此时两个方向需要满足<span class="math inline">\((d^0)^T A d^1\)</span>（假设二元二次函数为<span class="math inline">\(f(x)=\dfrac{1}{2}x^tAx+bx+c\)</span>）</p>
<p><strong>定义1</strong></p>
<p>设<span class="math inline">\(A\in R^{n\times m}\)</span>是对称正定矩阵，<span class="math inline">\(p_1,p_2\in R^n\)</span>，如果<span class="math inline">\(p_1^TAp_2=0\)</span>，则称这两个向量是<span class="math inline">\(A\)</span>共轭（<span class="math inline">\(A\)</span>正交）的。</p>
<p>如果有限个非零向量<span class="math inline">\(p_1,p_2,\cdots,p_m\)</span>，它们任意两个不同的向量都是<span class="math inline">\(A\)</span>共轭的，则称这一组向量为<span class="math inline">\(A\)</span>共轭方向组，也称它们是一组<span class="math inline">\(A\)</span>的共轭方向。</p>
<p>注意特殊情况，当<span class="math inline">\(A=I\)</span>时，这些向量就是普通的正交向量。</p>
<p><strong>定理1</strong></p>
<p>如果<span class="math inline">\(R^n\)</span>中的非零向量<span class="math inline">\(p_1,p_2,\cdots,p_m(m\leq n)\)</span>是<span class="math inline">\(A\)</span>共轭向量组，则这<span class="math inline">\(m\)</span>个向量是线性无关的。</p>
<p><strong>定理2</strong></p>
<p>设<span class="math inline">\(n\)</span>元函数<span class="math inline">\(f(x)=\dfrac{1}{2}x^tAx+bx+c\)</span>且<span class="math inline">\(A=A^T\)</span>正定，又设<span class="math inline">\(n\)</span>维向量组<span class="math inline">\(p_1,p_2,\cdots,p_n\)</span>是<span class="math inline">\(A\)</span>共轭向量组，从任意点<span class="math inline">\(x^1\)</span>出发，依次以该向量组为搜索方向进行精确一维搜索，则</p>
<ol>
<li><span class="math inline">\(\nabla f(x^{k+1})\)</span>与<span class="math inline">\(p_1,p_2,\cdots,p_k\)</span>正交</li>
<li>最多迭代<span class="math inline">\(n\)</span>次必达到二次函数的极小点。</li>
</ol>
<p>在下降迭代法中，若取下降方向是共轭方向，所得到的方法我们称为共轭方向法。</p>
<h2 id="共轭梯度法">共轭梯度法</h2>
<p>共轭方向的选择很多，但是效果不一样。共轭梯度法是一种好的选择共轭方向的办法。</p>
<p>初始方向为</p>
<p><span class="math display">\[d^0 = -\nabla f(x^0)
\]</span></p>
<p>它的方向的更新公式是</p>
<p><span class="math display">\[d^{k+1} = -\nabla f(x^{k+1}) + \rho_k d^k
\]</span></p>
<p><span class="math display">\[\rho_k = \dfrac{\nabla f(x^{k+1}) Ad^k}{(d^k)^TAd^k}
\]</span></p>
<p>总的优化迭代公式仍然是</p>
<p><span class="math display">\[x^{k+1} = x^k + \alpha_k d^k
\]</span></p>
<p>步长仍然用线搜索确定。</p>
<h2 id="fr共轭梯度法">FR共轭梯度法</h2>
<p>简单地说，就是</p>
<p><span class="math display">\[\rho_k = \dfrac{||g^{k+1}||^2}{||g^k||^2}
\]</span></p>
<p>其他不变。在正定二次函数中，这两个计算<span class="math inline">\(\rho^k\)</span>的方法是等价的。但是这个函数看着更简单好用一些。</p>
<h1 id="有约束最优化方法">有约束最优化方法</h1>
<p>对于</p>
<p><span class="math display">\[\min f(x)
\]</span></p>
<p><span class="math display">\[s.t.
\left\{\begin{matrix}
g_i(x)\geq 0,i=1,2,\cdots,m\\
h_j(x)=0,j=1,2,\cdots,l
\end{matrix}\right.
\]</span></p>
<p>这样的有不等式和等式约束的优化问题。我们用罚函数法。其本质思想是把处于可行域之外的点，加一个惩罚项，让它搜索路径向着可行域前进。对于可行域内的点则不做惩罚。</p>
<h2 id="外点罚函数法">外点罚函数法</h2>
<p><strong>等式约束的二次罚函数</strong></p>
<p><span class="math display">\[P_E(x,\sigma) = f(x) + \dfrac{1}{2}\sigma\sum^l_{j=1}h_j^2(x)
\]</span></p>
<p>等式右边第二项称为惩罚项，其中<span class="math inline">\(\sigma>0\)</span>称为罚因子。（这里这个<span class="math inline">\(\dfrac{1}{2}\)</span>有些教材有有些没有，我不知道为什么，但我觉得没有明显影响）</p>
<p><strong>不等式约束的二次罚函数</strong></p>
<p><span class="math display">\[P_I(x,\sigma) = f(x) + \dfrac{1}{2}\sigma\sum^m_{i=1}\min\{g_i(x),0\}^2
\]</span></p>
<p>也不难理解，总之我们要使在可行域内的惩罚项设置为<span class="math inline">\(0\)</span>。注意这里是<span class="math inline">\(\min\)</span>，因为我们的不等式约束是<span class="math inline">\(\geq0\)</span>型，如果是<span class="math inline">\(\leq0\)</span>型，要么改变不等式，要么改成<span class="math inline">\(\max\)</span></p>
<p>如果约束既有不等式的又有等式的，那么直接把惩罚项加起来即可。</p>
<p><strong>计算机迭代办法</strong></p>
<ol>
<li>给定<span class="math inline">\(\sigma_0>0,x^0,k=0\)</span>。罚因子增长函数<span class="math inline">\(\rho>1\)</span></li>
<li>当未达到收敛准则时，进行以下计算</li>
</ol>
<ul>
<li>求解<span class="math inline">\(\displaystyle {x^{k+1} = \arg \min_x P(x,\sigma_k)}\)</span></li>
<li>选取<span class="math inline">\(\sigma_{k+1} = \rho\sigma_{k}\)</span></li>
<li><span class="math inline">\(k = k+1\)</span></li>
</ul>
<p><strong>解析法求解</strong></p>
<p>我们令</p>
<p><span class="math display">\[\dfrac{\partial P(x,\sigma)}{\partial x_i} = 0
\]</span></p>
<p>对于所有的<span class="math inline">\(x\)</span>的分量<span class="math inline">\(x_i\)</span>成立。然后我们求出所有<span class="math inline">\(x_i\)</span>的表达式</p>
<p><span class="math display">\[x_i = F_i(\sigma)
\]</span></p>
<p>则我们的最优解就是</p>
<p><span class="math display">\[x^*_i = \lim_{\sigma\to+\infty}F_i(\sigma)
\]</span></p>
<h2 id="内点罚函数法">内点罚函数法</h2>
<p>只适用于不等式优化的，其罚函数有两种</p>
<p><span class="math display">\[P_I(x,\sigma) = f(x) + \sigma\sum^m_{i=1}\dfrac{1}{g_i(x)}
\]</span></p>
<p>和</p>
<p><span class="math display">\[P_I(x,\sigma) = f(x) - \sigma\sum^m_{i=1}\ln(g_i(x))
\]</span></p>
<p>显然，我们需要选择的初始点要在可行域内，而外点罚函数不需要。</p>
<p><strong>计算机迭代办法</strong></p>
<ol>
<li>给定<span class="math inline">\(\sigma_0>0,x^0,k=0\)</span>。罚因子增长函数<span class="math inline">\(\rho\in(0,1)\)</span></li>
<li>当未达到收敛准则时，进行以下计算</li>
</ol>
<ul>
<li>求解<span class="math inline">\(\displaystyle {x^{k+1} = \arg \min_x P(x,\sigma_k)}\)</span></li>
<li>选取<span class="math inline">\(\sigma_{k+1} = \rho\sigma_{k}\)</span></li>
<li><span class="math inline">\(k = k+1\)</span></li>
</ul>
<p><strong>解析法求解</strong></p>
<p>我们令</p>
<p><span class="math display">\[\dfrac{\partial P(x,\sigma)}{\partial x_i} = 0
\]</span></p>
<p>对于所有的<span class="math inline">\(x\)</span>的分量<span class="math inline">\(x_i\)</span>成立。然后我们求出所有<span class="math inline">\(x_i\)</span>的表达式</p>
<p><span class="math display">\[x_i = F_i(\sigma)
\]</span></p>
<p>则我们的最优解就是</p>
<p><span class="math display">\[x^*_i = \lim_{\sigma\to0}F_i(\sigma)
\]</span></p>
<h2 id="混合罚函数法">混合罚函数法</h2>
<p>我们知道，外点罚函数可以用于等式和不等式优化，而内点罚函数可以用于不等式优化。我们可以进行一个缝合，把等式约束的用外点罚函数，把不等式优化的用内点罚函数。</p>
<p>罚函数的统一形式为</p>
<p><span class="math display">\[P(x,\sigma) = f(x) + E(x,\sigma) + I(x,\sigma)
\]</span></p>
<p>其中<span class="math inline">\(E(x,\sigma)\)</span>只有一种选择</p>
<p><span class="math display">\[E(x,\sigma) = \dfrac{1}{\sqrt{\sigma}}\sum^l_{j=1}h_j^2(x)
\]</span></p>
<p><span class="math inline">\(I(x,\sigma)\)</span>则有三种选择</p>
<p><span class="math display">\[I(x,\sigma) = \dfrac{1}{\sqrt{\sigma}}\sum^m_{i=1}\min\{g_i^2(x),0\}
\]</span></p>
<p><span class="math display">\[I(x,\sigma) = \sigma\sum^m_{i=1}\dfrac{1}{g_i(x)}
\]</span></p>
<p><span class="math display">\[I(x,\sigma) = -\sigma\sum^m_{i=1}\ln(g_i(x))
\]</span></p>
<p>进行组合即可。</p>
<p>注意内点罚函数需要起始点在可行域内。</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E5%A4%A7%E5%AD%A6/">大学</a>
        
            <a href="/tags/%E6%95%B0%E5%AD%A6/">数学</a>
        
            <a href="/tags/%E6%9C%80%E4%BC%98%E5%8C%96/">最优化</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/">
        
        

        <div class="article-details">
            <h2 class="article-title">复变函数整理</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E6%95%B4%E7%90%86/">
        
        
            <div class="article-image">
                <img src="/p/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E6%95%B4%E7%90%86/cover.8fa55b693c3d793670200f41ff6f26bf_hu60f44b771e1522f4fa1d5246713b9a75_57927_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-j6VbaTw9eTZwIA9B/28mvw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">概率论与数理统计整理</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86/">
        
        
            <div class="article-image">
                <img src="/p/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86/cover.8058b9da40e37eadf1c7ce2ecf305e93_huf80a3777f066c3f01437aeed10211fe1_29240_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-gFi52kDjfq3xx84uzzBekw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">离散数学整理</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%95%B4%E7%90%86/">
        
        
            <div class="article-image">
                <img src="/p/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%95%B4%E7%90%86/cover.393667604ec380a7df6254826bbb2062_hu670730d9bdf70a44294ca8d2a00a2ced_185066_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-OTZnYE7DgKffYlSCa7sgYg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">线性代数整理</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E6%88%91%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E5%86%8C%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/">
        
        
            <div class="article-image">
                <img src="/p/%E6%88%91%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E5%86%8C%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8-51.eb2fd26757434998c74bb25f2a91edc6_hu1c49316b400cd781c785bbdbc8d18c16_11689_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-6y/SZ1dDSZjHS7JfKpHtxg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">我的高等数学下册资料整理</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="kegalas/blogComments"
        issue-term="pathname"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2023 KegalaS的个人博客
    </section>
    
    <section class="powerby">
         <br />
        
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#读前警示">读前警示</a></li>
    <li><a href="#数学基础概念定义">数学基础概念、定义</a>
      <ol>
        <li><a href="#向量内积">向量内积</a></li>
        <li><a href="#向量范数">向量范数</a></li>
        <li><a href="#二次型">二次型</a></li>
        <li><a href="#正定矩阵">正定矩阵</a></li>
        <li><a href="#方向导数">方向导数</a></li>
        <li><a href="#梯度">梯度</a></li>
        <li><a href="#海瑟矩阵">海瑟矩阵</a></li>
        <li><a href="#泰勒展开">泰勒展开</a></li>
        <li><a href="#邻域">邻域</a></li>
        <li><a href="#极小点">极小点</a></li>
        <li><a href="#驻点">驻点</a></li>
        <li><a href="#锥">锥</a></li>
        <li><a href="#凸组合">凸组合</a></li>
        <li><a href="#凸集">凸集</a></li>
        <li><a href="#半空间">半空间</a></li>
        <li><a href="#凸函数">凸函数</a></li>
        <li><a href="#凸函数判定">凸函数判定</a></li>
      </ol>
    </li>
    <li><a href="#线性规划">线性规划</a>
      <ol>
        <li><a href="#图解法">图解法</a></li>
        <li><a href="#一般形式">一般形式</a></li>
        <li><a href="#标准形式">标准形式</a></li>
        <li><a href="#线性规划解的基本性质">线性规划解的基本性质</a></li>
        <li><a href="#单纯形法">单纯形法</a>
          <ol>
            <li><a href="#确定初始基本可行解">确定初始基本可行解</a></li>
            <li><a href="#判断现行的基本可行解是否最优">判断现行的基本可行解是否最优</a></li>
            <li><a href="#基本可行解的改进基变换">基本可行解的改进——基变换</a></li>
            <li><a href="#用初等变换求改进了的基本可行解旋转运算">用初等变换求改进了的基本可行解——旋转运算</a></li>
            <li><a href="#表格单纯形法">表格单纯形法</a></li>
          </ol>
        </li>
        <li><a href="#对偶问题原理">对偶问题原理</a>
          <ol>
            <li><a href="#对偶关系表">对偶关系表</a></li>
            <li><a href="#对偶关系定理">对偶关系定理</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#一维搜索法">一维搜索法</a>
      <ol>
        <li><a href="#概念">概念</a></li>
        <li><a href="#基本步骤">基本步骤</a></li>
        <li><a href="#终止条件">终止条件</a></li>
        <li><a href="#搜索区间的确定">搜索区间的确定</a>
          <ol>
            <li><a href="#单谷峰函数">单谷（峰）函数</a></li>
            <li><a href="#进退算法成功-失败法">进退算法（成功-失败法）</a></li>
          </ol>
        </li>
        <li><a href="#二分法">二分法</a></li>
        <li><a href="#牛顿切线法">牛顿切线法</a></li>
        <li><a href="#黄金分割法">黄金分割法</a></li>
        <li><a href="#抛物线插值法">抛物线插值法</a></li>
      </ol>
    </li>
    <li><a href="#无约束最优化方法">无约束最优化方法</a>
      <ol>
        <li><a href="#搜索步长准则">搜索步长准则</a>
          <ol>
            <li><a href="#armijo准则">Armijo准则</a></li>
            <li><a href="#goldstein准则">Goldstein准则</a></li>
          </ol>
        </li>
        <li><a href="#最速下降法">最速下降法</a></li>
        <li><a href="#随机梯度降">随机梯度降</a></li>
        <li><a href="#小批量随机梯度降">小批量随机梯度降</a></li>
        <li><a href="#动量法">动量法</a></li>
        <li><a href="#nesterov算法">Nesterov算法</a></li>
        <li><a href="#adagrad">AdaGrad</a>
          <ol>
            <li><a href="#rmsprop">RMSProp</a></li>
            <li><a href="#adadelta">AdaDelta</a></li>
            <li><a href="#adam">Adam</a></li>
          </ol>
        </li>
        <li><a href="#牛顿法">牛顿法</a></li>
        <li><a href="#修正牛顿法">修正牛顿法</a></li>
        <li><a href="#拟牛顿法">拟牛顿法</a>
          <ol>
            <li><a href="#dfp更新公式">DFP更新公式</a></li>
          </ol>
        </li>
        <li><a href="#共轭方向法">共轭方向法</a></li>
        <li><a href="#共轭梯度法">共轭梯度法</a></li>
        <li><a href="#fr共轭梯度法">FR共轭梯度法</a></li>
      </ol>
    </li>
    <li><a href="#有约束最优化方法">有约束最优化方法</a>
      <ol>
        <li><a href="#外点罚函数法">外点罚函数法</a></li>
        <li><a href="#内点罚函数法">内点罚函数法</a></li>
        <li><a href="#混合罚函数法">混合罚函数法</a></li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>

<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='本笔记会记录一些C&#43;&#43;中，自己以前不常用、不是很熟悉需要记录来复习的、新标准（相较于C&#43;&#43;11）引入的、可能有用的功能。不适合详细阅读过某一'><title>现代C&#43;&#43;学习笔记</title>

<link rel='canonical' href='https://kegalas.top/p/%E7%8E%B0%E4%BB%A3c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='现代C&#43;&#43;学习笔记'>
<meta property='og:description' content='本笔记会记录一些C&#43;&#43;中，自己以前不常用、不是很熟悉需要记录来复习的、新标准（相较于C&#43;&#43;11）引入的、可能有用的功能。不适合详细阅读过某一'>
<meta property='og:url' content='https://kegalas.top/p/%E7%8E%B0%E4%BB%A3c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>
<meta property='og:site_name' content='KegalaS的个人博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='C&#43;&#43;' /><meta property='article:tag' content='干货' /><meta property='article:published_time' content='2023-09-06T21:52:23&#43;08:00'/><meta property='article:modified_time' content='2023-09-06T21:52:23&#43;08:00'/>
<meta name="twitter:title" content="现代C&#43;&#43;学习笔记">
<meta name="twitter:description" content="本笔记会记录一些C&#43;&#43;中，自己以前不常用、不是很熟悉需要记录来复习的、新标准（相较于C&#43;&#43;11）引入的、可能有用的功能。不适合详细阅读过某一">
    <link rel="shortcut icon" href="/images/favicon.ico" />

    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E5%85%B6%E4%BB%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" >
                其他计算机科学
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/%E7%8E%B0%E4%BB%A3c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">现代C&#43;&#43;学习笔记</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Sep 06, 2023</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 55 分钟
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <p>本笔记会记录一些<code>C++</code>中，自己以前不常用、不是很熟悉需要记录来复习的、新标准（相较于<code>C++11</code>）引入的、可能有用的功能。不适合详细阅读过某一本<code>C++</code>大部头教材的人，比较适合对于<code>C++</code>的知识只停留在算法竞赛的人。</p>
<p>本文的内容大多是我看了<code>cppreference</code>、<code>hackingcpp.com</code>、<code>freegeektime.com</code>、知乎和各类博客网站的文章、部分经典教材后，加上自己的理解，写作而成的。</p>
<h1 id="stdendl">std::endl</h1>
<p><code>std::endl</code>会立即刷新字符缓冲区，然后输出。但是<code>'\n'</code>不会。如果频繁地使用<code>std::endl</code>换行可能会导致性能问题，除非你非常确定这条消息在换行后必须要立即输出。</p>
<h1 id="stdclog">std::clog</h1>
<p>其写入字符到<code>stderr</code>中，但不是立即输出。而<code>std::cerr</code>会立即输出和刷新<code>stderr</code>。</p>
<h1 id="三路比较-运算符">&lt;=&gt;（三路比较 ）运算符</h1>
<p>这个运算符是<code>C++20</code>引入的，</p>
<ul>
<li>如果a&lt;b，那么(a&lt;=&gt;b) &lt; 0</li>
<li>如果a&gt;b，那么(a&lt;=&gt;b) &gt; 0</li>
<li>如果a和b相等或等价，那么(a&lt;=&gt;b) == 0</li>
</ul>
<p>其实<code>&lt;=&gt;</code>返回的是<code>std::strong_ordering</code>类型，某些时候给自己的类重载多种比较运算符会简单不少。其中a&lt;b时返回<code>std::strong_ordering::less</code>，a == b时返回<code>std::strong_ordering::equal</code>，a&gt;b时返回<code>std::strong_ordering::greater</code>。</p>
<h1 id="stdnumeric_limitst">std::numeric_limits&lt;T&gt;</h1>
<p>这个命名空间包含在&lt;limits&gt;头文件里，其可以给出一个基本数据类型的数据范围，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>numeric_limits<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>lowest();<span style="color:#75715e">//给出T的最小取值（有符号时为绝对值最大的负数）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>numeric_limits<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>min();<span style="color:#75715e">//对于整数，给出最小取值，对于浮点数，给出最小的正数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>numeric_limits<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>max();<span style="color:#75715e">//给出T的最大取值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>numeric_limits<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>epsilon();<span style="color:#75715e">//浮点数给出最小精度，比如第一个大于1的数和1的差
</span></span></span></code></pre></div><h1 id="大括号初始化变量">大括号初始化变量</h1>
<p>我们可以用如下方法初始化变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.5f</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> b {<span style="color:#ae81ff">1.5f</span>};
</span></span></code></pre></div><p>第一种是传统方法，第二种方法有一点好处是，在隐式的基本类型转换中，如果类型收窄（Type Narrowing）会给出Warning，甚至会直接给出error。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.5f</span>;<span style="color:#75715e">//编译器无warning
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">float</span> f <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.5f</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> j {f};<span style="color:#75715e">//编译器产生warning，有时候类型收窄确实可能导致错误。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> k {<span style="color:#ae81ff">2.5f</span>};<span style="color:#75715e">//编译器会直接给出error
</span></span></span></code></pre></div><p>如果你确定类型收窄是你需要的，那么用显式的强制类型转换。</p>
<h1 id="nodiscard修饰">[[nodiscard]]修饰</h1>
<p><code>C++17</code>引入。这个修饰是给函数使用的，如果函数有返回值，并且希望返回值不会被忽略，就可以使用这个修饰。</p>
<p>比如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">normalize</span>(vec3f <span style="color:#f92672">&amp;</span> v);<span style="color:#75715e">//把v变成单位向量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vec3f <span style="color:#a6e22e">normalized</span>(vec3f <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> v);<span style="color:#75715e">//返回v的单位向量，但v不变
</span></span></span></code></pre></div><p>这组可能分辨不清的函数，我们就可以把第二个函数加上这个修饰，编译器会在返回值没有被接收的时候发出warning。</p>
<h1 id="vector扩容初步">vector扩容（初步）</h1>
<p>这里是一个简易版本的介绍，后续可能会专门出博客来详细解析<code>STL</code>的各种容器与算法（TODO）。</p>
<p>我们要首先明白<code>vector</code>的内存布局是怎样的。一般来说，除非你在全局变量里面声明<code>vector</code>，不然<code>vector</code>对象都是在栈中的。但是<code>vector</code>的内容（即<code>buffer</code>）却是分布在堆里。</p>
<p>首先我们区分一下<code>size</code>和<code>capacity</code>，前者是<code>vector</code>里面拥有的元素的个数，后者是<code>vector</code>可以放多少元素。</p>
<p>当<code>size=capacity</code>时，此时如果我们进行<code>push_back</code>，容量不够，不能放进去。之后<code>vector</code>就要进行扩容。此时，实际上的内存不是在<code>buffer</code>后面再给你新分配一些，与前面的连起来。而是重新找一块更大的内存，将原来的<code>buffer</code>整体复制到堆中的新位置，再把新的插入元素放到最后。栈中的<code>vector</code>对象则简单的把指向的<code>buffer</code>地址改成新的即可（当然还有修改<code>size</code>和<code>capacity</code>）。</p>
<p>每次扩容，<code>capacity</code>会变为原来大小的<span class="math inline">\(1.1\)</span>至<span class="math inline">\(2\)</span>倍。</p>
<p>由于扩容的时候要复制，这是很大的开销。所以如果你提前知道数据个数的具体、或者大概的范围，那么最好使用<code>vector&lt;int&gt; vec(n);</code>或者<code>vec.reserve(n);</code>（区别是前者会有<code>n</code>个初值为<code>0</code>的元素，后者没有元素，只有<code>capacity==n</code>；当然<code>resize(n)</code>时，如果新大小大于原来的大小，会把多出来的空间用<code>0</code>填补）来提前给够空间。如果你不确定那么没有什么办法，大概只能这样。</p>
<p>另外，扩容之后，之前的迭代器、指针都可能会失效。包括指向vector对象的指针和指向元素的指针。</p>
<h1 id="auto与c-like字符串字面量">auto与“C-Like”字符串字面量</h1>
<p><code>auto a = &quot;test&quot;;</code>这个语句，<code>a</code>不会是<code>std::string</code>类型，而是<code>char const[]</code>类型。这也就意味着你也无法使用<code>auto b = &quot;123&quot;+&quot;456&quot;;</code>。</p>
<h1 id="stdstring的字符串字面量">std::string的字符串字面量</h1>
<p>这个特性是在<code>C++14</code>引入的。<code>auto s = &quot;test&quot;s;</code>，在原来的基础上，字符串后面加上<code>s</code>，即可推断为<code>std::string</code>类型。</p>
<p>不过使用之前要先<code>using namespace std::string_literals;</code></p>
<h1 id="原始字符串字面量">原始字符串字面量</h1>
<p>其用法为<code>R&quot;(此处填入原始字符串)&quot;</code>，这里面的原始字符串，不需要转义符，原本是什么，直接输出出来就是什么，而且转行也会被输出出来。这在我们的字符串是Windows目录时可能会比较方便，例如<code>auto s = R&quot;(C:\Windows\SysWOW64\IME\SHARED)&quot;</code>，不需要再像以前一样，给每个<code>\</code>换成<code>\\</code>了。</p>
<p>另外，<code>auto s = R&quot;(C:\Windows\SysWOW64\IME\SHARED)&quot;</code>还是被推断为<code>char const[]</code>，在<code>C++14</code>之后，声明<code>using namespace std::string_literals;</code>，之后<code>auto s = R&quot;(C:\Windows\SysWOW64\IME\SHARED)&quot;s;</code>可以推断为<code>std::string</code></p>
<h1 id="stdstring_view">std::string_view</h1>
<p><code>C++17</code>引入的功能，具体的用法和应该使用的地方都和<code>std::string const &amp;</code>差不多，都是对于一个<code>string</code>的只读，并且不开额外空间。区别是，<code>const &amp;</code>版本是建立了对原<code>string</code>的引用。<code>string</code>和<code>vector</code>很像，都是对象和<code>buffer</code>分开，而<code>std::string_view</code>就是一个对原<code>string</code>的<code>buffer</code>的只读的工具。推荐在新版本<code>C++</code>中使用这个功能。</p>
<p>比<code>const &amp;</code>有一个好处，如果用在函数参数里，而传入的是字符串字面量，则<code>const &amp;</code>会有一次复制操作，而<code>string_view</code>没有。</p>
<p>但是，如果你不在函数参数里使用，而是</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string_view sv2 {<span style="color:#e6db74">&#34;std::string Literal&#34;</span>s};
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> sv2;
</span></span></code></pre></div><p>则是错误的，因为字符串对象已经被销毁。所以推荐只在函数参数里使用。</p>
<h1 id="函数参数什么时候用const-">函数参数什么时候用const &amp;?</h1>
<p>可能会有人在第一次学习到用<code>const &amp;</code>来修饰形参，觉得这东西简直太好了，可以不用花费额外开销去复制。但其实不总是这样。</p>
<p>如果你传入的数据是<code>double</code>，<code>int</code>等开销本来就很小的变量，根本就不需要用<code>const &amp;</code>，那反而还会增加开销。</p>
<ul>
<li>在变量复制开销本来就很小时，不需要修饰符</li>
<li>如果你想要防止自己不小心修改了变量，只加<code>const</code>即可</li>
<li>如果你想要修改实参，则显然必须加且只加<code>&amp;</code>传入引用（例如swap函数）</li>
<li>如果你传入的复制开销很大（例如一个图片类），又不需要修改，加<code>const &amp;</code></li>
</ul>
<h1 id="左值纯右值亡值">左值、纯右值、亡值</h1>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 153; 
			flex-basis: 367px"
	>
	<a href="/p/%E7%8E%B0%E4%BB%A3c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.jpg" data-size="736x481">
		<img src="/p/%E7%8E%B0%E4%BB%A3c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.jpg"
			width="736"
			height="481"
			srcset="/p/%E7%8E%B0%E4%BB%A3c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2_hu4143b18d484754e5bf722b972f62f72c_22580_480x0_resize_q75_box.jpg 480w, /p/%E7%8E%B0%E4%BB%A3c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2_hu4143b18d484754e5bf722b972f62f72c_22580_1024x0_resize_q75_box.jpg 1024w"
			loading="lazy"
			alt="2.jpg">
	</a>
	
	<figcaption>2.jpg</figcaption>
	
</figure></p>
<p>曾经是只有左值和右值的。左值意味着可以取地址，而右值意味着不可以取地址。叫左值右值则是因为左值一般在赋值号左边，而右值在右边。</p>
<p>现代C++中，值类别必定属于三者其一：左值、亡值、纯右值。</p>
<p><strong>左值（lvalue）</strong></p>
<p>左值是有标识符、可以取地址的表达式。例如变量名、函数名确定的值。返回类型为左值引用的函数返回的值（除了自定义的，还有赋值运算符、<code>++a</code>、<code>--a</code>）。字符串字面量（<code>const char*</code>类型的左值）</p>
<p><strong>纯右值（prvalue）</strong></p>
<p>右值正好相反，就是没有标识符、不可获取地址的表达式。例如字面常量（除了字符串字面量），操作符的临时结果（例如<code>a=b+c;</code>中的<code>b+c</code>）（其实可以归类为下一条的），函数的返回值（除了返回左值引用和右值引用的）（例如<code>x++</code>）。</p>
<p>但是，右值引用变量，是一个左值。因为它再怎么说也是一个变量。</p>
<p><strong>亡值（xvalue）</strong></p>
<p>可以看作是有名字、有地址的右值，跟无名的纯右值区分开。所以实际上<code>std::move(x)</code>这样的函数，返回的是亡值。返回类型是对象的右值引用的函数调用，返回的也都是亡值。</p>
<p><strong>泛左值（glvalue）</strong></p>
<p>即左值和亡值。其特点是有标识符，有地址。但左值不可移动而亡值可移动。</p>
<p><strong>右值（rvalue）</strong></p>
<p>即纯右值和亡值。其特点是可移动。但亡值有标识符和地址而纯右值没有。</p>
<p><strong>&amp;引用</strong></p>
<p><code>&amp;</code>只能引用左值。也就是说<code>void fun(int &amp; a);</code>这个函数，你传入<code>fun(1);</code>会编译失败，但是<code>int &amp; b=c;fun(b);</code>是可以编译成功的。引用本身是个左值。</p>
<p><strong>const &amp;引用</strong></p>
<p><code>const &amp;</code>既可以引用左值，又可以引用右值。其本身是一个左值。</p>
<p><strong>&amp;&amp;引用</strong></p>
<p>即右值引用，只能绑定右值。本身是个左值。</p>
<p>如果函数重载里只有<code>const &amp;</code>，那么传入右值会调用这个函数重载。如果重载有<code>&amp;&amp;</code>形式的，那么会优先调用<code>&amp;&amp;</code>形式的重载。这种特性允许了移动构造函数的存在。</p>
<p><strong>转发引用（万能引用）</strong></p>
<p>这个只会出现在模板中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> f(T<span style="color:#f92672">&amp;&amp;</span> x){                  <span style="color:#75715e">// x 是转发引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">g</span>(std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(x)); <span style="color:#75715e">// 从而能被转发
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>见后写的完美转发部分。</p>
<h1 id="右值引用或常左值引用延长生命周期">右值引用（或常左值引用）延长生命周期</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string s1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;test&#34;</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s2 <span style="color:#f92672">=</span> s1<span style="color:#f92672">+</span>s1; <span style="color:#75715e">// 这个右值的生命周期被延长到和s2一样，但是不可修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>string <span style="color:#f92672">&amp;&amp;</span> s3 <span style="color:#f92672">=</span> s1<span style="color:#f92672">+</span>s1; <span style="color:#75715e">// 同上，但是可修改
</span></span></span></code></pre></div><p>但是，延长生命周期只能对纯右值使用，而不能对亡值使用。例如<code>A &amp;&amp; x = std::move(y)</code>，此时对<code>x</code>进行解引用，是未定义行为。因为<code>y</code>已经析构。</p>
<h1 id="移动语义">移动语义</h1>
<p>把一头大象从一台冰箱里移动到另一台冰箱里需要几步？C++曾经的做法是，首先完整地在冰箱B里复制一个一模一样的大象，然后蒸发掉冰箱A中的大象。</p>
<p>正常人的想法是，把大象从A中拉出来，把大象推进B冰箱中，关上冰箱门。</p>
<p>C++11的移动语义实现了这个正常人的想法。例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v1{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">6</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v2(std<span style="color:#f92672">::</span>move(v1));
</span></span></code></pre></div><p>可以把<code>v1</code>移动到<code>v2</code>中，而非拷贝一个一样的到<code>v2</code>中。发挥了关键作用的是<code>std::move</code>和其对应的移动构造（和移动赋值）函数。</p>
<p>注意，<code>std::move</code>仅仅是将一个值强制转换到右值（亡值），而不进行其他操作。真正的移动行为是在移动构造（和移动赋值）函数中实现的。</p>
<h1 id="小心返回引用的函数">小心返回引用的函数</h1>
<p>例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> fun(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> x<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> y;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>显然<code>y</code>的生命周期只能持续到函数结束，返回的引用就指向了一个无效的内存，这个要特别小心。但是如果你通过<code>new</code>分配了一个对象，再返回引用，则是可以的，这个对象的生命周期持续到你手动使用<code>delete</code>或者程序结束。不过并不推荐总是这样做，有时最好直接返回值。</p>
<h1 id="引用可能会像迭代器一样失效">引用可能会像迭代器一样失效</h1>
<p>比如对<code>vector</code>进行的操作会涉及<code>capacity</code>的修改，比如在<code>set</code>中进行插入和删除操作，这些是会使原来的迭代器无效的。这同时会使引用失效。就比如我们介绍过<code>vector</code>在扩容时会复制元素到新的内存，原来的引用指向的内存就会被释放，变成无效内存，此时再进行操作是<code>UB</code>。</p>
<h1 id="不要用引用来延长函数返回值的生命周期">不要用引用来延长函数返回值的生命周期</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> fun(){...}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> v <span style="color:#f92672">=</span> fun();<span style="color:#75715e">//现在fun的返回值的周期延长到和v一样，通常不会造成问题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> v2 <span style="color:#f92672">=</span> fun()[<span style="color:#ae81ff">0</span>];<span style="color:#75715e">//这是最危险的情况，fun的返回值其实生命周期已结束，v2引用的元素已经变成了无效内存，对v2的操作是UB
</span></span></span></code></pre></div><p>鉴于上述情况，最好不要用引用接受函数返回值，直接用传值的方式更好。</p>
<h1 id="structclass的大括号初值">struct/class的大括号初值</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">St</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> y;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>St st{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2.0</span>};<span style="color:#75715e">//也可以St st = {1, 2.0};
</span></span></span></code></pre></div><p>像这样，用大括号给结构体、类赋初值，其顺序和结构体内部声明的顺序要一致。</p>
<h1 id="类拷贝copy">类拷贝（copy）</h1>
<p>C++与Java、Python等不同，在下面的例子中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> x,y;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Point p1{<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">2.0</span>};
</span></span><span style="display:flex;"><span>Point p2 <span style="color:#f92672">=</span> p1;
</span></span></code></pre></div><p>用到了<code>p2 = p1</code>这一语句。在Java和Python中，<code>p1</code>、<code>p2</code>现在都指向同一个对象<code>Point(1.0, 2.0)</code>，而其本身并不是对象。在C++中，<code>p2</code>把<code>p1</code>的所有内容拷贝赋值给自己，它们两个是两个不同的对象（即使内容相等）。</p>
<p>在C++中，拷贝默认是深拷贝，而Java和Python中是浅拷贝。如果要在C++里面使用浅拷贝，则使用<code>Point &amp; p3 = p1</code>即可（也可以用指针）。</p>
<p>除了是否新建一个对象以外，这两者的生命周期也不同。C++的对象在<code>p1</code>销毁时就销毁了，而在Java中<code>p1</code>销毁之后，由于还有<code>p2</code>指向这个对象，所以对象本身不会销毁。如果所有指向全都销毁，那么垃圾回收机制才会销毁这个对象。</p>
<p>另外，通常“相等”的概念也不同。在Java中，对两个对象变量使用<code>==</code>运算符，如果它们指向不同的对象，则不相等，否则相等。在C++中，我们一般会重载<code>==</code>运算符，判断两者的内容是否相等。</p>
<h2 id="拷贝构造函数">拷贝构造函数</h2>
<p>todo</p>
<h2 id="赋值构造函数">赋值构造函数</h2>
<p>todo</p>
<h1 id="argc-argv">argc, argv</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[]){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>main函数可以带两个参数，按照传统我们把第一个参数叫<code>argc</code>，第二个参数叫<code>argv</code>。argc是一个整数，代表命令行中参数的个数，argv是每个参数的字符串。</p>
<p>命令行中参数通常由空格分开，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./g++.exe 1.cpp -o 1.exe -Wall
</span></span></code></pre></div><p>其中有五个参数，第一个为可运行文件本身的路径，后面的为运行它的参数。意味着argc等于5，argv存有五个字符串。一般我们会用atoi把字符串里的数字转化为int类型。</p>
<h1 id="file-stream">file stream</h1>
<p>在NOIP、NOI等竞赛中，一般会用freopen函数。这是一个C的函数，如果要更C++一点，我们会使用file stream。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fstream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ofstream os{<span style="color:#e6db74">&#34;1.txt&#34;</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(os.good()){<span style="color:#75715e">//在每次使用时都应该确保good
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        os<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;hello world</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如上为写数据时的使用例子。可以看到和cout的用法很像。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;fstream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ifstream is{<span style="color:#e6db74">&#34;2.txt&#34;</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(is.good()){<span style="color:#75715e">//在每次使用时都应该确保good
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">double</span> x,y;
</span></span><span style="display:flex;"><span>        is<span style="color:#f92672">&gt;&gt;</span>x<span style="color:#f92672">&gt;&gt;</span>y;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>x<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">&lt;&lt;</span>y<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如上为读数据的例子。可以看到和cin的用法很像。</p>
<p>另外，例如写到末尾还是覆盖，是文本还是二进制，这些都是可以设置的。具体参考<a class="link" href="https://zh.cppreference.com/w/cpp/header/fstream"  target="_blank" rel="noopener"
    >https://zh.cppreference.com/w/cpp/header/fstream</a>，这里简短的给出几个常用的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>ofstream os{<span style="color:#e6db74">&#34;out.txt&#34;</span>, std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>app}; <span style="color:#75715e">//append而不是覆盖
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>ifstream is2{<span style="color:#e6db74">&#34;in.tga&#34;</span>, std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>binary}; <span style="color:#75715e">//写二进制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>ofstream os2{<span style="color:#e6db74">&#34;out.tga&#34;</span>, std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>binary}; <span style="color:#75715e">//读二进制
</span></span></span></code></pre></div><h1 id="重载和运算符">重载&laquo;和&raquo;运算符</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Vec</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> x,y;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>istream<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&gt;&gt;</span>(std<span style="color:#f92672">::</span>istream<span style="color:#f92672">&amp;</span> is, Vec<span style="color:#f92672">&amp;</span> v){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> is<span style="color:#f92672">&gt;&gt;</span>v.x<span style="color:#f92672">&gt;&gt;</span>v.y;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> os, Vec<span style="color:#f92672">&amp;</span> v){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> os<span style="color:#f92672">&lt;&lt;</span>v.x<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">&lt;&lt;</span>v.y;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>Vec(<span style="color:#ae81ff">2.0</span>,<span style="color:#ae81ff">3.0</span>)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;<span style="color:#75715e">//可以像对int一样使用cin cout
</span></span></span></code></pre></div><p>主要是方便打印、输入数据，例如你在编写一个数值计算库，需要用到很多向量、矩阵的输出。</p>
<h1 id="类成员初始化">类成员初始化</h1>
<p>在C++ 11以前，我们初始化类成员一般只能在构造函数里进行，如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Vec</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> x,y;
</span></span><span style="display:flex;"><span>    Vec()<span style="color:#f92672">:</span>y(<span style="color:#ae81ff">0</span>),x(<span style="color:#ae81ff">0</span>){}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>其中<code>:</code>后面跟着的这个叫做初始化列表，成员后跟着的括号里面的写入初始值，即可完成初始化。</p>
<p>注意，初始化列表里面的赋值顺序并不是初始化列表写出来的顺序，而是按照成员变量的声明顺序。例如上例，是先初始化x，再初始化y。这有时会导致UB，建议绝大部分时候，都要保持两者顺序一致。</p>
<p>当然你也有可能这样写</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Vec(<span style="color:#66d9ef">int</span> x_, <span style="color:#66d9ef">int</span> y_){ <span style="color:#75715e">//而不是写:x(x_),y(y_)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    x <span style="color:#f92672">=</span> x_;
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> y_;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这其实能看出一个C++程序员的水平。对于int、double这种内置类型还好。但如果x、y是class，那么<code>=</code>意味着拷贝赋值，意味着可能会先构造一个新的对象实例，再拷贝给x和y。而是用初始化列表，则会直接调用构造函数，总体上少了拷贝这一个步骤。</p>
<p>在C++ 11之后，我们也可以这样给初始值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Vec</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> x<span style="color:#f92672">=</span><span style="color:#ae81ff">0.0</span>, y<span style="color:#f92672">=</span><span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>    Vec(){}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="explicit关键字">explicit关键字</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cl</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">explicit</span> <span style="color:#a6e22e">Cl</span>(<span style="color:#66d9ef">int</span> n_)<span style="color:#f92672">:</span>n(n_){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span> (Cl a) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foo(<span style="color:#ae81ff">1</span>);  <span style="color:#75715e">//隐式调用Cl的构造函数，但因为其构造函数是explicit的，会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>foo(Cl(<span style="color:#ae81ff">1</span>));<span style="color:#75715e">//正常
</span></span></span></code></pre></div><p>个人认为这主要是方便强调一下传入的数据的类型，可能在调试环节比较有用。</p>
<h1 id="构造函数相互调用">构造函数相互调用</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Class Vec{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> x, y;
</span></span><span style="display:flex;"><span>    Vec()<span style="color:#f92672">:</span>Vec(<span style="color:#ae81ff">0</span>){}
</span></span><span style="display:flex;"><span>    Vec(<span style="color:#66d9ef">double</span> a)<span style="color:#f92672">:</span>Vec(a,a){}
</span></span><span style="display:flex;"><span>    Vec(<span style="color:#66d9ef">double</span> x_, <span style="color:#66d9ef">double</span> y_)<span style="color:#f92672">:</span>x(x_),y(y_){}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="在c里最好用nullptr而不是null">在C++里最好用nullptr而不是null</h1>
<p>C++和C语言的<code>NULL</code>定义是不同的，在C++中<code>#define NULL 0</code>，而在C中<code>#define NULL ((void*)0)</code>。不得不这样改的原因是：C++不支持<code>void*</code>的隐式转换。可见NULL就是一个数字0，它会有如下问题</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">int</span> n){}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>n){}
</span></span></code></pre></div><p>此时如果你调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>foo(NULL);
</span></span></code></pre></div><p>则会有二义性问题。编译可能会无法通过。用nullptr则不会有这个问题。</p>
<p>当然，有时候我们会有以下三种写法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(p){}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(p<span style="color:#f92672">!=</span>NULL){}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(p<span style="color:#f92672">!=</span><span style="color:#66d9ef">nullptr</span>){}
</span></span></code></pre></div><p>这更多的是一种风格问题，争论这个似乎是无用的。但是之前的二义性还是要小心的。</p>
<p>如果你懒得管，那么就永远使用nullptr。</p>
<h1 id="c四种类型转换">C++四种类型转换</h1>
<p>之前有隐式转换、C风格强制转换<code>(int)a</code>、函数风格转换<code>int(a)</code>，C++提供了四个新的类型转换来规避老的显式转换的一些问题。这四种转换是关键词，而非stl库。</p>
<ul>
<li><code>static_cast&lt;type&gt;(exp)</code>，将<code>exp</code>转换为<code>type</code>类型。没有运行时类型检查来保证转换的安全性。主要用于基本类型的转化，例如<code>double</code>转<code>int</code>。</li>
<li><code>dynamic_cast&lt;type&gt;(exp)</code>，主要用于子类父类指针之间的转化，见后。</li>
<li><code>const_cast&lt;type&gt;(exp)</code>，用于修改变量的<code>cv</code>属性。<code>type</code>和<code>exp</code>应当具有同样的“类型”，只是<code>cv</code>修饰不同。</li>
<li><code>reinterpret_cast&lt;type&gt;(exp)</code>，用于将指针地址转为整数，或者反过来。</li>
</ul>
<p>在子类父类指针的转换中，<code>static_cast</code>把子类指针转为父类指针是安全的，而反过来向下转换是不安全的。而<code>dynamic_cast</code>两者都可以进行。上行时等价于<code>static_cast</code>，下行时加入了类型检查的功能，更加安全</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Derive<span style="color:#f92672">*</span> d1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derive();
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;d1: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> d1 <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>Base<span style="color:#f92672">*</span> b1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>Base<span style="color:#f92672">*&gt;</span>(d1);
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;b1: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> b1 <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 这里的内存地址和上面的是一样的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Base<span style="color:#f92672">*</span> b2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Base();
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;b2: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> b2 <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>Derive<span style="color:#f92672">*</span> d2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>Derive<span style="color:#f92672">*&gt;</span>(b2);
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;d2: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> d2 <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 这里是nullptr，而非b2的地址。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果使用是父类引用转化为子类引用，会抛出std::bad_cast
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 只有当b2本来就指向一个Derive时，转化才会成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果是static_cast，则不会抛出，也不会在失败时nullptr。只有当b2指向Derive时，程序才会符合预期。否则之后可能会调用不存在的成员。
</span></span></span></code></pre></div><h1 id="cv限定符">cv限定符</h1>
<p>即<code>const</code>和<code>volatile</code>类型限定符，其中<code>const</code>用于定义类型为常量类型，<code>volatile</code>用于定义易变类型。</p>
<p><code>const</code>意味着，这种对象不能被修改。直接修改时，编译报错。间接修改时（如通过指针修改），行为未定义。</p>
<p><code>volatile</code>意味着，每次对该变量的访问都可能造成副作用。编译器不应该对其进行优化（例如连续两次读取优化为一次）。例如，不能简单地放到寄存器里应对多次连续访问，而是每次访问都要去内存里面去取，防止其值变化（例如被外部设备修改）。间接通过非<code>volatile</code>变量访问<code>volatile</code>变量是未定义的。</p>
<p><code>const volatile</code>，从前面的定义看得出来，这两个限定符不冲突，可以同时使用。</p>
<p>函数类型本身不存在<code>cv</code>限定，但是函数可以返回<code>cv</code>限定类型，也有“cv限定函数”类型。如果有任何 cv 限定符被添加到到函数类型的别名，那么它会被忽略。</p>
<p><code>cv</code>限定函数指的是在非静态成员函数中使用的<code>cv</code>限定。例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> foo() {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() <span style="color:#66d9ef">const</span> {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() <span style="color:#66d9ef">volatile</span> {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">volatile</span> {}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>这个可以用于函数重载，其重载决议取决于<code>*this</code>的类型，如果<code>*this</code>是<code>const</code>的，那么调用<code>foo()</code>调用的就是<code>void foo() const {}</code>，以此类推。或者说<code>A const a;</code>调用的也是这个函数。<code>const</code>的成员函数意味着不能修改内部变量，除非有<code>mutable</code>修饰。</p>
<p>注意，我个人觉得把<code>const</code>称作常量是有些误导的，应该称作不变量。并不是所有<code>const</code>都可以用在常量表达式、模板实参中的。例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> sz <span style="color:#f92672">=</span> n;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, sz<span style="color:#f92672">&gt;</span> ar; <span style="color:#75715e">// 报错
</span></span></span></code></pre></div><p>这里的<code>sz</code>仍然是运行时确定的，并不是一个编译期常量。真正应该被叫做常量的应该是<code>constexpr</code>，见后。</p>
<h1 id="mutable和const的成员函数">mutable和const的成员函数</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Vec</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> x,y;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">mutable</span> sth;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sth2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        sth<span style="color:#f92672">++</span>;<span style="color:#75715e">//不会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bar</span>() <span style="color:#66d9ef">const</span>{
</span></span><span style="display:flex;"><span>        sth2<span style="color:#f92672">++</span>;<span style="color:#75715e">//会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>把类成员函数用const修饰（放在参数列表之后），意味着，这个函数声称不会改变类内的所有成员变量的值。如果你想让几个特例可以修改，那么就把那个特例变量声明为mutable的即可。</p>
<h1 id="const与指针">const与指针</h1>
<p>众所周知，在指针类型的声明里，const放的位置不同会导致语义的不同。主要是指针是否可变，以及指针指向的内容是否可变。 如下表</p>
<table>
<thead>
<tr>
<th>声明</th>
<th>所指内容可变？</th>
<th>指针本身可变？</th>
</tr>
</thead>
<tbody>
<tr>
<td>T *</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>T const *</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>T * const</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>T const * const</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>简单来说就是const在星号右边则指针自己不可变，在左边则所指内容不可变。也可以理解为，const修饰的是它左边的东西。要么修饰指针（即星号），要么修饰值（即T）</p>
<p>所以说，我更推荐<code>T const</code>的写法，而不是<code>const T</code>。但是我们也要知道，<code>const T *</code>是修饰值不可变。</p>
<h1 id="成员函数引用限定符">成员函数引用限定符</h1>
<p>类似于<code>cv</code>限定的成员函数。不过引用限定不影响<code>*this</code>的性质，<code>*this</code>都是左值表达式。可以和<code>cv</code>限定同时使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">S</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>() <span style="color:#f92672">&amp;</span>  { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;左值</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>() <span style="color:#f92672">&amp;&amp;</span> { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;右值</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    S s;
</span></span><span style="display:flex;"><span>    s.f();            <span style="color:#75715e">// 打印“左值”
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>move(s).f(); <span style="color:#75715e">// 打印“右值”
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    S().f();          <span style="color:#75715e">// 打印“右值”
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h1 id="constexpr">constexpr</h1>
<p>有<code>constexpr</code>修饰的变量是一个真正的编译期确定的常量。有<code>constexpr</code>修饰的函数，在传入的参数都是编译期常量时，返回一个编译期常量。也就是说，这种函数也可以当做普通函数来使用，只不过返回的值是不是编译期常量，是根据传入的参数来决定的。</p>
<p><code>constexpr</code>声明的对象成员蕴含<code>const</code>，函数声明中的<code>constexpr</code>蕴含了<code>inline</code>。</p>
<p>举个例子，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> foo(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>array<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, n<span style="color:#f92672">&gt;</span> ar;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="智能指针">智能指针</h1>
<p>C++11后只有三种智能指针，<code>unique_ptr</code>，<code>shared_ptr</code>，<code>weak_ptr</code>。还有一种<code>auto_ptr</code>已经移除。智能指针可以方便管理资源的所有权，以及提供对于资源的RAII。</p>
<p><code>unique_ptr</code>，如同名字一样，是独占资源的。在实现上，他只能移动构造和赋值，而不能拷贝构造和赋值，保证了其所有权无法复制，同一时间只能有一个<code>unique_ptr</code>拥有该资源的所有权。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> p <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_unique<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;*</span>p<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; <span style="color:#75715e">// 输出1
</span></span></span></code></pre></div><p>这里的<code>p</code>就独占了一个<code>int</code>对象的所有权。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> p2 <span style="color:#f92672">=</span> p; <span style="color:#75715e">// 报错，无法拷贝构造
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> p3 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(p); <span style="color:#75715e">// 可以编译，p3获得所有权而p失去所有权
</span></span></span></code></pre></div><p>在<code>make_unique</code>时（C++14之后），相当于调用了<code>unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...))</code>。然后在<code>unique_ptr</code>生命周期结束（和所有权转移）时，会自动调用删除器来释放资源。默认的删除器通过<code>delete</code>实现，即对其包装的指针进行<code>delete</code>。</p>
<p><code>shared_ptr</code>，也如同名字一样，允许多个<code>shared_ptr</code>拥有同一个资源。在实现上，他可以移动构造移动赋值，也可以拷贝构造和拷贝赋值。其RAII的实现方法是，加入一个引用计数器，表明有多少<code>shared_ptr</code>在使用这个资源，每次复制时计数器加一，每当一个<code>shared_ptr</code>析构时计数器减一。如果计数器归零，那么销毁分配的对象。</p>
<p><code>weak_ptr</code>，它的出现是为了解决<code>shared_ptr</code>中的一个问题。假如我们有一个双向链表，它支持多个线程来读数据，所以我们理所当然地使用<code>shared_ptr</code>来管理其中的指针（例如<code>next</code>和<code>prev</code>）。但是在某种情况下就有问题，假设我们在局部作用域分配了一个链表，插入两个元素，然后就等待作用域结束后析构。此时会发生内存泄漏，为什么呢？</p>
<p>我们就分析这两个节点的引用计数。其中第一个节点被<code>head</code>和第二个节点的<code>prev</code>指针指向，而第二个节点被<code>tail</code>和第一个节点的<code>next</code>指针指向。当<code>list</code>析构时，<code>list</code>只包含<code>head</code>和<code>tail</code>指针，这两个<code>shared_ptr</code>析构，将两个节点的计数器各减一，但是两个节点仍然互相有指针指向对面，所以两个节点的计数器都为一。所以两个节点无法自动销毁，造成内存泄漏。</p>
<p><code>weak_ptr</code>的思想在于，创建一个弱引用，不增加引用计数器的值。当我们需要使用被管理的对象时，手动转换成<code>shared_ptr</code>（此时计数器加一），再进行使用。而使用结束后再变回弱引用（计数器减一）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>weak_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> wp;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> sp <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_shared<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">42</span>);
</span></span><span style="display:flex;"><span>    wp <span style="color:#f92672">=</span> sp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>wp.use_count()<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;<span style="color:#75715e">// 输出1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> spt <span style="color:#f92672">=</span> wp.lock()) <span style="color:#75715e">// 需要手动转化shared_ptr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;*</span>spt<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>wp.use_count()<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;<span style="color:#75715e">// 输出0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span>(std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> spt <span style="color:#f92672">=</span> wp.lock()) <span style="color:#75715e">// spt为nullptr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;*</span>spt<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span></code></pre></div><p>对于上面所说的链表，只需要把内部的<code>next</code>和<code>prev</code>换成<code>weak_ptr</code>即可解决问题。</p>
<h1 id="make_shared和make_unique">make_shared和make_unique</h1>
<p><a class="link" href="https://zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique"  target="_blank" rel="noopener"
    >https://zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique</a>，其中指出，<code>make_unique</code>和<code>unique_ptr&lt;T&gt;(new ...)</code>是等价的。但我觉得下面关于<code>make_shared</code>的几点也适用于<code>make_unique</code></p>
<p>而<a class="link" href="https://zh.cppreference.com/w/cpp/memory/shared_ptr/make_shared"  target="_blank" rel="noopener"
    >https://zh.cppreference.com/w/cpp/memory/shared_ptr/make_shared</a>中指出，<code>make_shared</code>和<code>shared_ptr&lt;T&gt;(new ...)</code>是有略微的区别的：</p>
<ol>
<li>因为<code>shared_ptr</code>有引用计数器，所以使用<code>shared_ptr&lt;T&gt;(new ...)</code>会先<code>new</code>出一个对象，然后再<code>new</code>一个控制块。这就是两次<code>new</code>，并且这两次的内存是可能不连续的。而<code>make_shared</code>只进行一次<code>new</code>并且控制块和对象连续分配（标准推荐而非强制）</li>
<li><code>make_shared</code>创造出来的资源，在所有<code>shared_ptr</code>生命期结束后，如果还有<code>weak_ptr</code>引用，则该资源会持续存在，直到所有<code>weak_ptr</code>结束。</li>
<li>如果当前语境可以访问非公开构造函数，那么<code>shared_ptr&lt;T&gt;(new ...)</code>可以正常使用。但<code>make_shared</code>只能调用公开的构造函数。</li>
<li><code>make_shared</code>不能自定义删除器</li>
<li><code>make_shared</code>使用<code>::new</code>，如果类重载了<code>new</code>运算符，则不同于<code>shared_ptr&lt;T&gt;(new ...)</code></li>
</ol>
<h1 id="placement-new">placement new</h1>
<p><code>A *p = new A;</code>完成了两个操作首先是在堆上分配了一块内存，然后将<code>A</code>在这块内存上默认构造。</p>
<p>而placement new做的操作是，给定一块内存的首地址，在这块内存上构造对象。这样，我们就可以在栈上构造对象了。这样做的好处可以参考内存池，如果有一块内存可以复用，就不用反复分配内存了，节约开销。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> mem[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span>A <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> (mem) A;
</span></span></code></pre></div><h1 id="this指针">this指针</h1>
<p>有点类似于Python里的self参数，都是只能用在类里的。是一个指向对象自己的指针。</p>
<h1 id="析构函数的析构顺序">析构函数的析构顺序</h1>
<p>在析构函数执行完毕后，类成员变量的析构顺序，是按照其声明顺序的反方向进行的。</p>
<h1 id="有时候可以尝试集中处理exception">有时候可以尝试集中处理Exception</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">handle_errors</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span>; <span style="color:#75715e">//必要的，进行re-throw
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">catch</span>(...){}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">catch</span>(...){}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">catch</span>(...){}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(...){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">catch</span>(...){
</span></span><span style="display:flex;"><span>        handle_errors();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bar</span>(...){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">catch</span>(...){
</span></span><span style="display:flex;"><span>        handle_errors();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这可以复用代码，尤其是你的东西可能会抛出一样的exception的时候。</p>
<h1 id="raii思想和其对于exception内存泄漏的保护">RAII思想和其对于Exception内存泄漏的保护</h1>
<p>RAII是Resource Acquisition Is Initialization的缩写，意为资源获取就是初始化。</p>
<p>其要求，对象在构造函数中获取资源，在析构函数中释放资源。为什么这是好的呢？他可以减少你管理内存的工作量，你不需要手动去到处写delete来释放内存。它会在对象生命周期结束的时候自动释放，也就避免了内存泄漏。</p>
<p>而对于Exception，它也可以很好的保护内存。C++的Exception在throw的时候，保证可以释放创建的局部对象。于是就可以自动释放内存，而不用担心是否在throw前正确处理了内存。</p>
<p>像C语言这样的东西，申请完内存需要free才能释放，如果在函数中提前返回了，无法运行到free这一行，那么内存就泄漏了。如下例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(...);
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(...){
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>; <span style="color:#75715e">// 这里没有释放内存，产生泄漏
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">free</span>(a);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>所以如果C++调用了某个C库，又没有很好的释放内存，就可能会造成泄漏。如果你想避免这个，可能可以尝试用C++的类包装一下，提供析构函数。</p>
<p>上例在exception结构中类似下例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span>...;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(...){
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> ...;<span style="color:#75715e">// 这里没有释放内存，产生泄漏。但是如果有析构函数则可以避免
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> a;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>另外，RAII也就要求你，不能在析构函数本身中出现提前的throw。</p>
<h1 id="noexcept修饰">noexcept修饰</h1>
<p>修饰函数时，如果给出noexcept，则意味着你保证：</p>
<ul>
<li>函数的操作不会失败</li>
<li>从外部来看，任何Exception是不可见的。或者说所有Exception都在内部处理了。</li>
</ul>
<p>如果noexcept函数还是抛出了一个Exception，那么程序会终止。</p>
<p>我们可以给noexcept提供一个条件，满足条件是函数才是noexcept的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>() <span style="color:#66d9ef">noexcept</span>(n<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">9</span>){...} <span style="color:#75715e">// 当n&lt;9时noexcept
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bar</span>() <span style="color:#66d9ef">noexcept</span>( <span style="color:#66d9ef">noexcept</span>(foo) ){...} <span style="color:#75715e">// 当foo是noexcept时，bar是noexcept
</span></span></span></code></pre></div><h1 id="注意给assert的参数加上括号">注意给assert的参数加上括号</h1>
<p>因为assert其实是宏，所以</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>assert(min(a,b)<span style="color:#f92672">==</span>a); <span style="color:#75715e">//不好
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>assert((min(a,b)<span style="color:#f92672">==</span>a)); <span style="color:#75715e">//好
</span></span></span></code></pre></div><p>否则，宏替换可能会出问题，而且你无法察觉。</p>
<h1 id="static_assert">static_assert</h1>
<p>assert是给运行时用的，而static_assert就是给编译时用的。</p>
<pre tabindex="0"><code>static_assert(bool_exp, &#34;msg&#34;); // C++11可用
static_assert(bool_exp); //C++17可用
</code></pre><h1 id="用-dndbug忽略所有assert">用-DNDBUG忽略所有assert</h1>
<p>这是g++的编译选项，只需使用这个参数即可</p>
<pre tabindex="0"><code>g++ -DNDBUG ...
</code></pre><h1 id="编译器warning的编译参数">编译器warning的编译参数</h1>
<p>默认编译并不会打开很多warning，在生产环境中，推荐使用</p>
<pre tabindex="0"><code>-Wall -Wextra -Wpedantic -Wshadow -Werror -fsanitize=undefined,address
</code></pre><p>来开启更多warning。</p>
<h1 id="cmake使用">Cmake使用</h1>
<p>TODO</p>
<h1 id="doctestcatch2gtest使用">doctest/catch2/gtest使用</h1>
<p>TODO</p>
<h1 id="不要在调试的时候到处写coutcerr">不要在调试的时候到处写cout、cerr</h1>
<p>首先这会干扰到原本的代码逻辑，你删除的时候可能会删错、忘删。另外，这并不适合写测试样例来检测是否正确，更好的办法是，定义一个函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">log</span>(std<span style="color:#f92672">::</span>ostream<span style="color:#f92672">&amp;</span> os, ...) {...}
</span></span></code></pre></div><p>把要输出测试的东西放到ostream里，方便测试样例获取</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>ostringstream oss;
</span></span><span style="display:flex;"><span>log(oss, ...);
</span></span><span style="display:flex;"><span>ASSERT_STREQ(oss.str(), <span style="color:#e6db74">&#34;123&#34;</span>);
</span></span></code></pre></div><p>如果要调试最好使用GDB等工具。</p>
<h1 id="gdb使用">GDB使用</h1>
<p>TODO</p>
<h1 id="使用gclang检测内存错误使用未定义行为等">使用g++/clang检测内存错误使用、未定义行为等</h1>
<p>即之前介绍到的，只需要添加<code>-fsanitize=undefined,address</code>编译选项即可。在运行的时候，如果出现这种错误，就会提供报错信息。</p>
<h1 id="使用valgrind检测内存泄漏死锁问题等">使用valgrind检测内存泄漏、死锁问题等</h1>
<p>我们首先编译好程序，然后通过</p>
<pre tabindex="0"><code>valgrind [options] ./program [program options]
</code></pre><p>来执行检查。可选参数有</p>
<ul>
<li><code>--tool=memcheck</code>，用来检查内存泄漏、对无效内存读写等</li>
<li><code>--tool=helgrind</code>，用来检查死锁</li>
<li><code>--leak-check=full</code>，用来显示内存泄漏的详细信息</li>
<li><code>-v/--verbose</code>，用来显示额外信息</li>
</ul>
<h1 id="使用end迭代器的值是未定义行为">使用end迭代器的值是未定义行为</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> vec.end();
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;*</span>it; <span style="color:#75715e">// UB
</span></span></span></code></pre></div><h1 id="stddistance">std::distance</h1>
<p>求得左闭右开区间<code>[it1, it2)</code>的大小。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> x <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>distance(std<span style="color:#f92672">::</span>begin(vec), std<span style="color:#f92672">::</span>end(vec)); <span style="color:#75715e">// 3
</span></span></span></code></pre></div><p>如果满足老式随机访问迭代器，那么复杂度是常数。否则复杂度为线性。</p>
<h1 id="所有序列容器都是所谓的regular-types">所有序列容器都是所谓的regular types</h1>
<p>也即下面四个特点：</p>
<ol>
<li>深可拷贝：在拷贝赋值、拷贝构造的时候，都是把容器内的每个值拷贝到新容器中</li>
<li>深可赋值：即给容器内的元素赋值时，都是把源数据进行拷贝（而非移动）</li>
<li>深可比较：即两个容器相等时，当且仅当每个元素相等</li>
<li>深所有权：容器析构时会析构所有元素</li>
</ol>
<h1 id="stdspan">std::span</h1>
<p>C++20引入的功能。span对于vector、array，相当于string_view对于string。声明方法如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>span<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#75715e">// 声明一个可修改的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>span<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&gt;</span> <span style="color:#75715e">// 声明一个不可更改的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>span<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5</span><span style="color:#f92672">&gt;</span> <span style="color:#75715e">// 声明一个固定大小的，大小需要是编译期常数
</span></span></span></code></pre></div><p>和string_view一样，推荐只用在函数参数中。对于字面量，也会存在访问已经销毁的对象的问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(std<span style="color:#f92672">::</span>span<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span><span style="color:#f92672">&gt;</span> s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>};
</span></span><span style="display:flex;"><span>foo(v);
</span></span><span style="display:flex;"><span>foo({v.begin()<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, v.end()});
</span></span></code></pre></div><p>span可以使用size、empty等获取大小信息，可以通过<code>[]</code>获取数据。对于比较两个span是否相同，和其他序列容器略有不同</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>sv.data() <span style="color:#f92672">==</span> sw.data();  <span style="color:#75715e">// 对比sv和sw是否是同一个内存位置上的对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>ranges<span style="color:#f92672">::</span>equal(sv,sw);  <span style="color:#75715e">// 对比sv和sw的值是否都相同
</span></span></span></code></pre></div><h1 id="map和set查询元素是否存在的新方法">Map和Set查询元素是否存在的新方法</h1>
<p>在C++20之后，引入了<code>contains</code>函数。如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> s{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (s.contains(<span style="color:#ae81ff">7</span>)) {<span style="color:#960050;background-color:#1e0010">…</span>} 
</span></span></code></pre></div><p>比起<code>find</code>简单，比<code>count</code>不用转换类型。</p>
<h1 id="用equal_range获取multiset中所有给定值">用equal_range获取multiset中所有给定值</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>multiset<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> s {<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">6</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> e4 <span style="color:#f92672">=</span> s.equal_range(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>(e4.first)
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>(e4.second);<span style="color:#75715e">// e4.first是第一个元素的迭代器，e4.second是最后一个元素之后的元素的迭代器
</span></span></span></code></pre></div><h1 id="不要用迭代器遍历unordered_map和unordered_set">不要用迭代器遍历unordered_map和unordered_set</h1>
<p>这两个容器的begin和end迭代器指向的是bucket，而不是元素。所以用迭代器遍历是不能达到目的的。但是可以使用<code>for(auto x:ust)</code>来遍历</p>
<h1 id="map和set的判断元素相同的依据">map和set的判断元素相同的依据</h1>
<p>这两个容器一样，都不是按照equal的意义去判断两个元素是否相同，而是按照equivalent去判断。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>a<span style="color:#f92672">==</span>b <span style="color:#75715e">// equal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">!</span>(a<span style="color:#f92672">&lt;</span>b) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>(b<span style="color:#f92672">&lt;</span>a) <span style="color:#75715e">// equivalent
</span></span></span></code></pre></div><p>所以说，我们只要重载小于运算符，就可以让map和set运行起来，不需要大于和等于运算符。</p>
<h1 id="自定义unordered容器的哈希函数">自定义unordered容器的哈希函数</h1>
<p>一般都会新建一个类，重定义其函数调用运算符，返回值是size_t。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyHash</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">constexpr</span> std<span style="color:#f92672">::</span>size_t
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">operator</span> () (A <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> a) <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>unordered_set<span style="color:#f92672">&lt;</span>A, MyHash<span style="color:#f92672">&gt;</span> s;
</span></span></code></pre></div><p>默认使用的是<code>std::hash&lt;Key&gt;</code>，设计新哈希时，可以考虑把自定义类型的各个成员变量的<code>std::hash</code>组合起来，形成新哈希。</p>
<h1 id="标准库算法的执行策略">标准库算法的执行策略</h1>
<p>在C++17之后，许多标准库里的算法都可以选择执行策略，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>sort(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par, begin(v), end(v), cmp);
</span></span></code></pre></div><p>这是<code>sort</code>函数的又一个重载，其函数声明为</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExecutionPolicy</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RandomIt</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Compare</span> <span style="color:#f92672">&gt;</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> sort( ExecutionPolicy<span style="color:#f92672">&amp;&amp;</span> policy,  
</span></span><span style="display:flex;"><span>           RandomIt first, RandomIt last, Compare comp );
</span></span></code></pre></div><p>其中执行策略有四种：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>seq <span style="color:#75715e">// 算法的执行不能并行化、向量化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par <span style="color:#75715e">// 算法的执行可以并行化，但是不能向量化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par_unseq <span style="color:#75715e">// 算法的执行可以并行化、向量化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>unseq <span style="color:#75715e">// 算法的执行不可以并行化，但是可以向量化。C++20后可用
</span></span></span></code></pre></div><p>并行执行时，算法本身不会避免数据竞争，这是程序员需要考虑的事，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>for_each(std<span style="color:#f92672">::</span>execution<span style="color:#f92672">::</span>par, std<span style="color:#f92672">::</span>begin(a), std<span style="color:#f92672">::</span>end(a), [<span style="color:#f92672">&amp;</span>](<span style="color:#66d9ef">int</span> i)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  v.push_back(i<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 错误：数据竞争
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>});
</span></span></code></pre></div><h1 id="新for循环反向遍历的方法">新for循环反向遍历的方法</h1>
<p>C++20可用，让<code>for(:)</code>也能反向遍历。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> x : v <span style="color:#f92672">|</span> std<span style="color:#f92672">::</span>views<span style="color:#f92672">::</span>reverse) { cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>; }
</span></span></code></pre></div><h1 id="泛型lambda">泛型Lambda</h1>
<p>泛型lambda不需要<code>template</code>，只需要用<code>auto</code>即可，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>[] (<span style="color:#66d9ef">auto</span> a, <span style="color:#66d9ef">auto</span> b){ <span style="color:#66d9ef">return</span> a<span style="color:#f92672">+</span>b;}
</span></span><span style="display:flex;"><span>[] (<span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> b){ <span style="color:#66d9ef">return</span> a<span style="color:#f92672">+</span>b;}
</span></span></code></pre></div><h1 id="stdmemcpy的重叠问题">std::memcpy的重叠问题</h1>
<p><code>memcpy</code>的定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">memcpy</span>( <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> dest, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> src, std<span style="color:#f92672">::</span>size_t count );
</span></span></code></pre></div><p>其把<code>src</code>中的字节复制到<code>dest</code>中，但是，如果<code>src+count&gt;dest</code>，就会出现重叠的问题。根据cppreference，这是未定义的。此时我们要使用<code>std::memmove</code>。它可以规避这个问题，标准规定其要如同复制字符到临时数组，再从该数组到<code>dest</code>一般发生复制。</p>
<p>同时，cppreference补充说，尽管说明了“如同”使用临时缓冲区，此函数的实际实现并不会带来二次复制或额外内存的开销。对于小<code>count</code>，它可能加载并写入寄存器；对于更大的内存块，常用方法是若目标在源之前开始，则从缓冲区开始正向复制，否则从末尾反向复制，完全无重叠时回落到更高效的<code>std::memcpy</code>。</p>
<p>我自己看过gnu实现的标准库，确实是这样。内存中，若<code>dest</code>在<code>src</code>之前，就正向复制，否则，逆向复制类似于如下的循环</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>count<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>    dest[i] <span style="color:#f92672">=</span> src[i];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="stdcopy的重叠问题">std::copy的重叠问题</h1>
<p>类似于上一节的纯C库，这个C++库也有这个问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InputIt</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OutputIt</span> <span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>OutputIt copy( InputIt first, InputIt last,
</span></span><span style="display:flex;"><span>               OutputIt d_first );
</span></span></code></pre></div><p>如果<code>d_first</code>在<code>[first, last)</code>中，行为未定义。此时用<code>std::copy_backward</code>替代（如果<code>d_last</code>在<code>[first, last)</code>中，则未定义，应该用<code>std::copy</code>）。</p>
<h1 id="stdrandom_shuffle随机重排数组">std::random_shuffle随机重排数组</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v {<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">8</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>random_shuffle(begin(v)<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>, begin(v)<span style="color:#f92672">+</span><span style="color:#ae81ff">7</span>);  
</span></span></code></pre></div><p>在pytorch中打乱数据集用到了类似的东西。</p>
<h1 id="stdfill">std::fill</h1>
<p>在某种意义上是比<code>memset</code>好的，<code>memset</code>是按字节赋值的，而<code>std::fill</code>是按元素赋值。比如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>fill(arr, arr<span style="color:#f92672">+</span><span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">100000</span>);
</span></span></code></pre></div><p>这个是memset不方便做到的。</p>
<h1 id="stdgenerate">std::generate</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> gen <span style="color:#f92672">=</span> [i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>]() <span style="color:#66d9ef">mutable</span> { i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>; <span style="color:#66d9ef">return</span> i; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>generate(begin(v)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, begin(v)<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>, gen);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> x : v) { cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>; }  <span style="color:#75715e">// 0 2 4 6 8 0 0
</span></span></span></code></pre></div><p>即在迭代器的这个范围内，每个元素使用一次<code>gen</code>并对其赋值。</p>
<h1 id="stdtransform">std::transform</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InputIt</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OutputIt</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UnaryOp</span> <span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>OutputIt transform( InputIt first1, InputIt last1,
</span></span><span style="display:flex;"><span>                    OutputIt d_first, UnaryOp unary_op );
</span></span></code></pre></div><p>对每一个<code>[first1, last1)</code>中的元素使用一元函数<code>unary_op</code>，然后将值依次赋值给<code>d_first</code>开始的元素。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InputIt1</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InputIt2</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OutputIt</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BinaryOp</span> <span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>OutputIt transform( InputIt1 first1, InputIt1 last1, InputIt2 first2,
</span></span><span style="display:flex;"><span>                    OutputIt d_first, BinaryOp binary_op );
</span></span></code></pre></div><p>对每一个<code>[first1, last1)</code>中的元素，和<code>first2</code>开始的对应元素，使用二元函数<code>binary_op</code>，然后将值依次赋值给<code>d_first</code>开始的元素。</p>
<h1 id="stdaccumulate和stdreduce">std::accumulate和std::reduce</h1>
<p>二者都是进行<code>[first, last)</code>的加和（或自定义运算）的操作，区别在于<code>std::reduce</code>是可以并行化的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>reduce(v.begin(), v.end()); <span style="color:#75715e">// 执行累加，返回累加和，初值默认为T()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>reduce(v.begin(), v.end(), <span style="color:#ae81ff">1.0</span>, std<span style="color:#f92672">::</span>multiplies<span style="color:#f92672">&lt;&gt;</span>{}); <span style="color:#75715e">// 第三个参数为初值，第四个参数为运算。这里就是累乘
</span></span></span></code></pre></div><h1 id="stdtuple">std::tuple</h1>
<p>可以说是一个扩展维度的<code>std::pair</code>。使用例如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>tuple<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> t{<span style="color:#ae81ff">1.2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;a&#39;</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&gt;</span>(t);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>(t);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span><span style="color:#f92672">&gt;</span>(t);
</span></span></code></pre></div><p>比<code>std::array</code>好的地方在于其可以有不同的元素类型。但是，用作函数返回值、参数可能不是一个很好的想法。因为可读性较差，不如<code>struct</code>。</p>
<p><code>std::tie</code>可以返回左值引用的元组。如下场景会比较好用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">S</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string s;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> d;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">const</span> S<span style="color:#f92672">&amp;</span> lhs, <span style="color:#66d9ef">const</span> S<span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">noexcept</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 比较 lhs.n 与 rhs.n,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 然后为 lhs.s 与 rhs.s,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 然后为 lhs.d 与 rhs.d
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 返回这个次序中第一个不相等的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 或者当所有元素都相等时返回 false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>tie(lhs.n, lhs.s, lhs.d) <span style="color:#f92672">&lt;</span> std<span style="color:#f92672">::</span>tie(rhs.n, rhs.s, rhs.d);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>以及，拆包函数返回值，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>tuple<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> foo(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0.3</span>};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a, b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> c;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>tie(a, b, c) <span style="color:#f92672">=</span> foo(); <span style="color:#75715e">// 或者可以写 auto [a, b, c] = foo()，只不过前者可以在c++11后使用，后者只能在c++17后使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="stdoptional">std::optional</h1>
<p>C++17引入的新工具，在以前，我们生成新的资源时，通常会返回指向该资源的指针。如果返回的是<code>nullptr</code>，则说明分配失败。更现代的方法是使用<code>std::optional</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>optional<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> create(<span style="color:#66d9ef">bool</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (b)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;test&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {}; <span style="color:#75715e">// 等价于返回 std::nullopt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>检测返回的东西是否有效，可以像<code>bool</code>类型一样使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> r <span style="color:#f92672">=</span> create(true);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(r){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>也可以使用<code>r.has_value()</code>。如果要使用其包装的值，则可以使用如下两种办法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>r<span style="color:#f92672">-&gt;</span>push_back(<span style="color:#e6db74">&#39;b&#39;</span>); <span style="color:#75715e">// 像指针一样使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>r.value().push_back(<span style="color:#e6db74">&#39;c&#39;</span>); <span style="color:#75715e">// 把值拿出来，再使用
</span></span></span></code></pre></div><h1 id="stdvariant">std::variant</h1>
<p>是在C++17提供的一种类型安全的联合体。一个 <code>std::variant</code> 的实例在任意时刻要么保有它的可选类型之一的值，要么在错误情况下无值。<code>union</code>的问题是，如果成员之一需要析构函数来释放资源，那么<code>union</code>定义的变量在结束生命周期时，不会自动调用析构函数。或者类似于，三个成员分别为<code>int,double,char*</code>的<code>union</code>，其被分配了一个<code>new char[]</code>给<code>char *</code>，那么在生命周期末尾时，不会自动调用<code>delete []</code>去释放空间。<code>std::variant</code>的出现解决了这个问题</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>variant<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">double</span>, std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> x, y;
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>y <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;test&#34;</span>;
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.0</span>;
</span></span></code></pre></div><p><code>std::variant</code>的变量在同时只能拥有一个具体的类型。如上，<code>x</code>不是<code>int</code>，就是<code>double</code>或者<code>std::string</code>。不过，可以方便地通过重新赋值的方式改变其具体类型。如果要知道当前的是哪种类型，可以通过</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>x.index()
</span></span></code></pre></div><p>来获取，是<code>int</code>就返回<code>0</code>，<code>double</code>就返回<code>1</code>，即为声明时的下标，以此类推。</p>
<p>获取值可以用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>(x);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>(x);
</span></span></code></pre></div><p>来获取当前的值。如果试图获取非当前类型的值，就会抛出异常</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(x); <span style="color:#75715e">// x 含 double 而非 int：会抛出异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">catch</span> (<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>bad_variant_access<span style="color:#f92672">&amp;</span> ex)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> ex.what() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果获取本就不可能存在的值，则会编译报错，例如<code>std::get&lt;float&gt;, std::get&lt;3&gt;</code>。当然，不想抛异常的话，可以使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>i <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>get_if<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&amp;</span>x);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(i<span style="color:#f92672">==</span><span style="color:#66d9ef">nullptr</span>){}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>{}
</span></span></code></pre></div><h1 id="stdany">std::any</h1>
<p>实现了一种类似于<code>python</code>的动态类型，可以把任何可复制构造类型的单个值放在里面。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>any a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> a.type().name() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>any_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(a) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> a.type().name() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>any_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>(a) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> a.type().name() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>any_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>(a) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span></code></pre></div><p>有点类似于C语言中的<code>void *</code>，想赋值什么就赋值什么，需要的时候再转成具体类型（对应这里的<code>std::any_cast&lt;...&gt;(...)</code>）。当然，这里可能会有转换失败的场景，会抛出异常。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>any_cast<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span>(a) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">catch</span> (<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>bad_any_cast<span style="color:#f92672">&amp;</span> e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> e.what() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以通过<code>has_value</code>来检测有没有值，<code>reset</code>来清除值。</p>
<h1 id="c构建模型">C++构建模型</h1>
<p>基本上都是继承C语言的框架，C++的源码文件也分为头文件<code>.h, .hpp</code>和翻译单元（Translation Units，TUs）<code>.cpp, .cc, .cxx</code>两部分。编译成可执行文件的流程，可以看下图</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 286; 
			flex-basis: 688px"
	>
	<a href="/p/%E7%8E%B0%E4%BB%A3c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.jpg" data-size="671x234">
		<img src="/p/%E7%8E%B0%E4%BB%A3c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.jpg"
			width="671"
			height="234"
			srcset="/p/%E7%8E%B0%E4%BB%A3c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_huec27c099c6d2527504f841f0674fe5a6_19744_480x0_resize_q75_box.jpg 480w, /p/%E7%8E%B0%E4%BB%A3c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_huec27c099c6d2527504f841f0674fe5a6_19744_1024x0_resize_q75_box.jpg 1024w"
			loading="lazy"
			alt="1.jpg">
	</a>
	
	<figcaption>1.jpg</figcaption>
	
</figure></p>
<p>预处理器一般是进行文本替换的，就是把翻译单元中<code>#define</code>，<code>#include</code>的内容换成对应的内容等操作。然后送进编译阶段，将翻译单元转换成汇编，再转成目标文件。最后通过链接器将各个目标文件链接成可执行文件（主要负责将机器码组合，以及确定函数调用的地址等）。</p>
<p>可以通过</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>g++ -E A.cpp -o A.i <span style="color:#75715e"># 生成预处理后的结果</span>
</span></span><span style="display:flex;"><span>g++ -S A.cpp -o A.s <span style="color:#75715e"># 生成编译后的汇编代码</span>
</span></span><span style="display:flex;"><span>g++ -c A.cpp -o A.o <span style="color:#75715e"># 生成编译后的目标文件</span>
</span></span></code></pre></div><h1 id="重复include导致的编译错误">重复include导致的编译错误</h1>
<p>重复<code>include</code>会导致重复定义，从而无法通过编译，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// a.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(){}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// b.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;a.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bar</span>(){
</span></span><span style="display:flex;"><span>    foo();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// c.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;a.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;b.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    foo();
</span></span><span style="display:flex;"><span>    bar();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在预处理过后，<code>c.cpp</code>就会变成</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//这部分来源于a.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(){}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//这部分来源于b.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(){}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bar</span>(){
</span></span><span style="display:flex;"><span>    foo();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    foo();
</span></span><span style="display:flex;"><span>    bar();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>于是<code>foo()</code>就重复定义了，编译报错。一般来说处理办法是</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// a.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifndef A_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define A_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(){}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// b.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#ifndef B_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define B_H
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;a.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bar</span>(){
</span></span><span style="display:flex;"><span>    foo();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span></code></pre></div><p>这样在其他文件里就可以随意<code>include</code>了。</p>
<h1 id="重复include导致的链接报错">重复include导致的链接报错</h1>
<p>发生在如下情况</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// foo.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(){}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// a.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;foo.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bar1</span>(){
</span></span><span style="display:flex;"><span>    foo();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// b.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;foo.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bar2</span>(){
</span></span><span style="display:flex;"><span>    foo();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果，最终需要把<code>a.cpp</code>和<code>b.cpp</code>链接在一起形成一个可执行文件，那么，由于两个目标文件中都有一份<code>foo()</code>的完整定义，链接器就不知道具体调用的是哪个<code>foo</code>，产生报错。</p>
<p>解决办法：</p>
<ol>
<li>新建一个<code>foo.cpp</code>，头文件中只声明，<code>foo.cpp</code>中定义，让其他两个目标文件来链接它</li>
<li>使用<code>inline</code></li>
<li>使用<code>namespace{}</code>（匿名）</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(){}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(){}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中前一种被称作<code>External Linkage</code>，后面这两种称为<code>Internal Linkage</code></p>
<p>类似的，<code>static</code>类型的成员变量（但其实大部分<code>static</code>并不是外部链接），也是默认进行外部链接，需要把定义和声明分在两个文件里。否则需要使用<code>static inline</code>变量，才可以直接在头文件里定义。</p>
<p>具体有哪些东西是外部链接，哪些东西是内部链接，可以看<a class="link" href="https://zh.cppreference.com/w/cpp/language/storage_duration"  target="_blank" rel="noopener"
    >https://zh.cppreference.com/w/cpp/language/storage_duration</a></p>
<h1 id="使用namespace来防止命名冲突">使用namespace来防止命名冲突</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> n1{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">set</span>{...};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> n2{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">set</span>{...};
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如上，区分了两种不同的<code>set</code>，也和<code>std::set</code>区分开。</p>
<p><code>namespace</code>可以嵌套。可以通过<code>using n1::set</code>，来免去前置的命名空间说明，直接使用<code>set</code>来表示<code>n1</code>中的<code>set</code>。可以使用<code>using namespace n1</code>来导入整个<code>n1</code>中的东西。区别相当于python中的<code>from n1 import set</code>和<code>from n1 import *</code>之间的区别。</p>
<p>可以使用<code>using sc = std::chrono</code>来给命名空间取别名，当然我也常用<code>using LL = long long</code>来给类型取别名。</p>
<h1 id="inline-namespace">inline namespace</h1>
<p>标准的描述是：命名空间内的声明将在它的外围命名空间可见。例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> n1{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">namespace</span> current{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{...};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">namespace</span> old{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{...};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>n1<span style="color:#f92672">::</span>A a; <span style="color:#75715e">// 调用的current的A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>n1<span style="color:#f92672">::</span>old<span style="color:#f92672">::</span>A aa;
</span></span></code></pre></div><p>用在这里，可以说是一种嵌套命名空间中的默认值，默认使用最新版本。</p>
<h1 id="friend">friend</h1>
<p><code>friend</code>关键词提供了一种让其他类、函数访问自己私有成员的方法。例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(A <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>标准规定，如果在非局部的类定义中，定义一个友元函数（而非仅仅声明），那么他是一个非成员函数。可以通过函数名直接从外部调用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bar</span>(){} <span style="color:#75715e">// 非成员函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bar();<span style="color:#75715e">// 直接调用
</span></span></span></code></pre></div><h1 id="public-protected-private">public, protected, private</h1>
<p>用在成员声明时，<code>public</code>声明的成员可在任意位置访问；<code>protected</code>成员只能被该类成员、友元、子类的成员和友元访问；<code>private</code>成员只能被该类成员和友元访问。注意这里说的都是类的成员，而不要求必须是同一个实例才能访问自己的<code>private</code>成员，同一类的各个实例可以访问各自的<code>private</code></p>
<p>用在继承时，代表了三种继承方式。<code>public</code>继承时，保留父类的成员访问说明符；<code>protected</code>继承时，父类的<code>public</code>成员在子类中转为<code>protected</code>；<code>private</code>继承时，所有父类成员在子类中都是<code>private</code>的。注意，如果不提供继承方式，则默认为<code>private</code>继承。</p>
<h1 id="override标识符">override标识符</h1>
<p>这是一个可选的标识符，使用或者不使用并不影响子类函数是否复写基类函数。只要签名一致，并且该父类函数是<code>virtual</code>函数，就会复写。但是，他是一种检测手段，写在子类函数中，如果忘写<code>virtual</code>，或者签名不一致，就会编译报错（因为没有复写任何函数）。</p>
<h1 id="析构函数务必声明为virtual">析构函数务必声明为virtual</h1>
<p>原因是，如果使用父类指针指向子类实例，在析构时，应当通过多态来调用子类的析构函数。如果没有声明为<code>virtual</code>，那么就会调用父类的析构函数，从而无法对子类析构，从而内存泄漏。</p>
<h1 id="final标识符">final标识符</h1>
<p><code>class A final : public B{};</code>代表这个类<code>A</code>无法被继承</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> B{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> print() <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">final</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>代表这个<code>print</code>无法被子类复写。</p>
<h1 id="不要继承成员变量组合优于继承">不要继承成员变量，组合优于继承</h1>
<p>这是一种设计规范，即父类不应该设置成员变量。原因在于，子类并不一定会用上所有的父类成员变量，这会导致浪费内存。并且，子类实现可能和父类成员变量有冲突。与直接在父类中定义数据相反，我们应该单独定义一个数据的类。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 只定义一些函数接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Data</span>{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Data d_;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 假设C无须数据，就不需要声明
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><h1 id="不要在构造函数里调用virtual函数">不要在构造函数里调用virtual函数</h1>
<p>我们都知道，构造的时候会从父类一路构造下来。所以，如果在构造函数里调用<code>virtual</code>函数，则会调用父类的函数。</p>
<h1 id="不能被继承的成员函数">不能被继承的成员函数</h1>
<p>分别是构造函数、析构函数、赋值运算符、友元函数。</p>
<p>不过构造函数可以委托构造，并且在构造子类时，会从祖先一路构造下来。析构子类时，会从子类往上析构所有祖先。</p>
<h1 id="rtti">RTTI</h1>
<p>全称Runtime type identification，即运行时类型识别。如果我们想要知道父类指针具体指向了哪种对象，就需要用到这个东西。这里用到的关键词是<code>typeid</code></p>
<p>如果指针指向的是同一种对象，那么<code>typeid(a)==typeid(b)</code>。如果指向不同的子类对象，或者一个指向父类一个指向子类，那么<code>typeid(a)!=typeid(b)</code>。用<code>typeid(a).name()</code>可以输出具体类型的名字，不过这个名字被编译器加工过，不是你声明的类名。</p>
<h1 id="c四个异常安全等级">C++四个异常安全等级</h1>
<p>从子集到超集排列的话</p>
<ol>
<li>不抛出。函数始终不会抛出异常。c++中<code>noexcept</code>表示此等级，析构函数默认是<code>noexcept</code>的。<code>swap</code>、移动构造函数、及为提供强异常保证所使用的其他函数，都被期待为不会失败（函数总是成功）。</li>
<li>强异常保证。如果函数抛出异常，那么程序的状态会恰好被回滚到该函数调用前的状态。（例如 std::vector::push_back）。</li>
<li>基本异常保证。如果函数抛出异常，那么程序处于某个有效状态。不泄漏任何资源，且所有对象的不变式都保持完好。</li>
<li>无异常保证。如果函数抛出异常，那么程序可能不会处于有效的状态：可能已经发生了资源泄漏、内存损坏，或其他摧毁不变式的错误。</li>
</ol>
<h1 id="普通构造和拷贝构造是可以抛异常的但是移动构造和析构最好noexcept">普通构造和拷贝构造是可以抛异常的，但是移动构造和析构最好noexcept</h1>
<p><a class="link" href="https://isocpp.org/wiki/faq/exceptions#ctor-exceptions"  target="_blank" rel="noopener"
    >https://isocpp.org/wiki/faq/exceptions#ctor-exceptions</a>，<a class="link" href="https://isocpp.org/wiki/faq/exceptions#ctors-can-throw"  target="_blank" rel="noopener"
    >https://isocpp.org/wiki/faq/exceptions#ctors-can-throw</a></p>
<p>这里说明，当你无法正确初始化时，就可以抛出异常。如果构造函数通过抛出异常来结束，那么与对象本身相关联的内存就会被清理掉——不存在内存泄漏。另外，如果在抛出之前，构造函数已经进行了一些在失败时需要修改的操作，也是需要恢复的。更好的办法是使用<code>shared_ptr</code>之类的包装类，在失败时会自动恢复原状。</p>
<p>移动构造函数只是推荐<code>noexcept</code>，但是析构理应<code>noexcept</code>，否则会出现很多糟糕的情况。</p>
<p>当析构失败的时候，上面的网站提到，最好就是记录日志，终止程序，但是不要抛异常。</p>
<h1 id="vector的元素最好有noexcept的移动构造函数">vector的元素最好有noexcept的移动构造函数</h1>
<p>因为<code>vector</code>通常有强异常保证，如果元素不拥有<code>noexcept</code>的移动构造函数，那么<code>vector</code>就会用拷贝构造函数。这在<code>vector</code>内部的元素移动时会有很大的性能开销。</p>
<h1 id="copy--swap">copy &amp; swap</h1>
<p>具体可看<a class="link" href="https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279550#3279550"  target="_blank" rel="noopener"
    >https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279550#3279550</a>，我这里也简单解释下。</p>
<p>这里以一个拷贝赋值运算符为例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>array<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(array <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> other){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">this</span><span style="color:#f92672">==&amp;</span>other) <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> [] data_;
</span></span><span style="display:flex;"><span>    data_ <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    size_ <span style="color:#f92672">=</span> other.size_;
</span></span><span style="display:flex;"><span>    data_ <span style="color:#f92672">=</span> mSize_ <span style="color:#f92672">?</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[size_] <span style="color:#f92672">:</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>copy(other.data_, other.data_ <span style="color:#f92672">+</span> size_, data_);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里有几个问题：</p>
<ol>
<li>首先是判断是否自赋值。众所周知，条件分支会降低CPU的效率，而实际工程中，出现自赋值的情况是比较少的，所以CPU的周期被白白浪费在了这个判断上。</li>
<li>这不提供强异常保证。如果<code>new</code>的时候失败了，不仅自己的<code>size_</code>被改了，自己之前的<code>data_</code>更是消失了。无法再分配失败之后保持之前的状态。</li>
<li>代码整体和拷贝构造函数很像，累赘。</li>
</ol>
<p>更好的方法如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">array</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">void</span> swap(array<span style="color:#f92672">&amp;</span> first, array<span style="color:#f92672">&amp;</span> second) <span style="color:#66d9ef">noexcept</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>swap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        swap(first.size_, second.size_);
</span></span><span style="display:flex;"><span>        swap(first.data_, second.data_);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    array(array <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> other)<span style="color:#f92672">:</span> size_(other.size_), 
</span></span><span style="display:flex;"><span>                                data_(size_<span style="color:#f92672">?</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[size_]<span style="color:#f92672">:</span><span style="color:#66d9ef">nullptr</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>copy(other.data_, other.data_ <span style="color:#f92672">+</span> size_, data_);
</span></span><span style="display:flex;"><span>    } <span style="color:#75715e">// 即使分配失败，也不会内存泄漏，更不会改变原有的状态（因为没有原有的状态）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    array<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(array other){ <span style="color:#75715e">// 在参数中拷贝构造了，少写代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        swap(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>, other); 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>size_t size_;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> data_;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>在<code>c++11</code>之后还可以方便地实现移动构造</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>array(array <span style="color:#f92672">&amp;&amp;</span> other) <span style="color:#66d9ef">noexcept</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span> array(){
</span></span><span style="display:flex;"><span>    swap(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>, other);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="实参依赖查找adl">实参依赖查找（ADL）</h1>
<p>简单理解来说，如果在函数调用的上下文中找不到该函数的定义，C++就会从实参的命名空间中查找该函数的定义。例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;测试</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; <span style="color:#75715e">// 全局命名空间中没有 operator&lt;&lt;，但 ADL 检验 std 命名空间，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                           <span style="color:#75715e">// 因为左实参在 std 命名空间中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                           <span style="color:#75715e">// 并找到 std::operator&lt;&lt;(std::ostream&amp;, const char*)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span>(std<span style="color:#f92672">::</span>cout, <span style="color:#e6db74">&#34;测试</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); <span style="color:#75715e">// 同上，用函数调用记法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 然而，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// 错误：&#39;endl&#39; 未在此命名空间中声明。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                       <span style="color:#75715e">// 这不是对 endl() 的函数调用，所以不适用 ADL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span>    endl(std<span style="color:#f92672">::</span>cout); <span style="color:#75715e">// OK：这是函数调用：ADL 检验 std 命名空间，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                     <span style="color:#75715e">// 因为 endl 的实参在 std 中，并找到了 std::endl
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span>    (endl)(std<span style="color:#f92672">::</span>cout); <span style="color:#75715e">// 错误：&#39;endl&#39; 未在此命名空间声明。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                       <span style="color:#75715e">// 子表达式 (endl) 不是函数调用表达式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h1 id="完美转发引用折叠">完美转发，引用折叠</h1>
<p>正如前面所说，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> f(T<span style="color:#f92672">&amp;&amp;</span> x){                  <span style="color:#75715e">// x 是转发引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    g(std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(x)); <span style="color:#75715e">// 从而能被转发
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>模板中的<code>T&amp;&amp;</code>是一个转发引用。当我们传入<code>int &amp; a</code>时，<code>T</code>实际上就是<code>int &amp;</code>，于是函数调用就变成了<code>int &amp; &amp;&amp;</code>这样的类型，此时它是左值引用还是右值引用呢？这就要引入类型折叠。</p>
<p>C++规定：<code>type &amp; &amp;, type &amp; &amp;&amp;, type &amp;&amp; &amp;</code>都变成左值引用<code>type &amp;</code>，只有<code>type &amp;&amp; &amp;&amp;</code>仍然是右值引用<code>type &amp;&amp;</code>。那如果我们</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">g</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> x) { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;int &amp;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">g</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;&amp;</span> x) { std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;int &amp;&amp;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> f(T<span style="color:#f92672">&amp;&amp;</span> x) {
</span></span><span style="display:flex;"><span>    g(x);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>    f(a); <span style="color:#75715e">// 打印int &amp;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    f(std<span style="color:#f92672">::</span>move(a)); <span style="color:#75715e">// 还是打印int &amp;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>这样进行调用，<code>x</code>可能是左值引用或者右值引用，但是<code>x</code>自己作为一个变量，它是左值。我们就无法把右值的参数传递给<code>g()</code>，就无法调用<code>g(int &amp;&amp;)</code>，只会调用到<code>g(int &amp;)</code>。</p>
<p>为了解决这个问题，C++使用<code>std::forward&lt;T&gt;(x)</code>来保持值类型不变，来传递参数。就如同开头的代码。此时就可以分别打印出<code>int &amp;</code>和<code>int &amp;&amp;</code>了。</p>
<p>另外，转发引用会保留实参的<code>cv</code>属性。</p>
<p>注意</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> f1(T<span style="color:#f92672">&amp;&amp;</span> x);                 <span style="color:#75715e">// x 是转发引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> f2(T<span style="color:#f92672">&amp;&amp;</span> x);                 <span style="color:#75715e">// x 是转发引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">B</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f3</span>(U<span style="color:#f92672">&amp;&amp;</span> x);                 <span style="color:#75715e">// 这个x不是转发引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> f4(T<span style="color:#f92672">&amp;&amp;</span> x);                 <span style="color:#75715e">// x 是转发引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>用上形参包，完美转发例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">Args</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> f(Args<span style="color:#f92672">&amp;&amp;</span>... args){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>pari<span style="color:#f92672">&lt;</span>T, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>{std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>Args<span style="color:#f92672">&gt;</span>(args)..., <span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="模板类暴露类型给外部">模板类暴露类型给外部</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> value_type <span style="color:#f92672">=</span> T; <span style="color:#75715e">// 外部可以使用typename Point::value_type;来获取类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    T x;
</span></span><span style="display:flex;"><span>    T y;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="类模板实参推导指引">类模板实参推导指引</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 模板的声明
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">container</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    container(T t) {}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Iter</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    container(Iter beg, Iter end);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 额外的推导指引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Iter</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>container(Iter b, Iter e) <span style="color:#f92672">-&gt;</span> container<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>iterator_traits<span style="color:#f92672">&lt;</span>Iter<span style="color:#f92672">&gt;::</span>value_type<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>container <span style="color:#a6e22e">c</span>(<span style="color:#ae81ff">7</span>); <span style="color:#75715e">// OK：用隐式生成的指引推导出 T=int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> v <span style="color:#f92672">=</span> {<span style="color:#75715e">/* ... */</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> d <span style="color:#f92672">=</span> container(v.begin(), v.end()); <span style="color:#75715e">// OK：推导出 T=double
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>container e{<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>}; <span style="color:#75715e">// 错误：std::iterator_traits&lt;int&gt;::value_type 不存在
</span></span></span></code></pre></div><p>总而言之，通过对构造函数里传入的参数进行分析，得到类模板的实参。但有时候隐式生成的推导指引没有那么厉害，看不透用户的想法。此时就需要一个额外的用户定义的推导指引。如上面的代码，我们把<code>container(Iter b, Iter e)</code>这样的构造函数，推导出其实参为<code>typename std::iterator_traits&lt;Iter&gt;::value_type</code>。这样就能正确实例化模板了。</p>
<p>用户定义的推导指引必须指名一个类模板，且必须在类模板的同一语义作用域（可以是命名空间或外围类）中引入，而且对于成员类模板必须拥有同样的访问，但推导指引不会成为该作用域的成员。</p>
<p>推导指引不是函数且没有函数体。推导指引不会被名字查找所找到，并且除了在推导类模板实参时与其他推导指引之间的重载决议之外不会参与重载决议。不能在同一翻译单元中为同一类模板再次声明推导指引。</p>
<h1 id="模板实例化和模板特化">模板实例化和模板特化</h1>
<p>以前我没分清楚这两个东西。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>A<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a;
</span></span></code></pre></div><p>上面这个代码叫做模板实例化。没有实例化的模板不会作为汇编指令生成。只有当实际调用到这个模板类、模板函数的时候，才会生成一个匹配的类、函数，生成汇编指令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>上面的代码叫做模板特化。就是把其中的一种情况拿出来，单独有自己的逻辑。在模板实例化的时候，会先查找最特殊的模板。可以通过只声明、不定义、另外定义特化的方式来限制类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>以上代码，声明<code>A&lt;int&gt;, A&lt;double&gt;</code>的变量都会成功，而<code>A&lt;float&gt;</code>则会报错。</p>
<h1 id="模板最好都写在头文件里">模板最好都写在头文件里</h1>
<p>如果不全写在头文件里会有什么问题呢？见下例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// B.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> foo(T x);
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// B.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;B.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> B<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>foo(T x){
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>x<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// A.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;B.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	B<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> b;
</span></span><span style="display:flex;"><span>	b.foo(<span style="color:#ae81ff">666</span>);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如上，我们把<code>B</code>中函数的定义和声明分离了。此时我们用<code>g++ A.cpp B.cpp -o .\A.exe</code>编译，链接器会报错：</p>
<pre tabindex="0"><code>x86_64-w64-mingw32/bin/ld.exe: C:\Users\Kegalas\AppData\Local\Temp\ccCn8we2.o:A.cpp:(.text+0x1a): undefined reference to `B&lt;int&gt;::foo(int)&#39;
collect2.exe: error: ld returned 1 exit status
</code></pre><p>未定义？我们看看汇编后的代码是什么</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>	<span style="color:#a6e22e">.file</span>	<span style="color:#e6db74">&#34;A.cpp&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">.text</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">.def</span>	<span style="color:#66d9ef">__main</span><span style="color:#75715e">;	.scl	2;	.type	32;	.endef
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">.globl</span>	<span style="color:#66d9ef">main</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">.def</span>	<span style="color:#66d9ef">main</span><span style="color:#75715e">;	.scl	2;	.type	32;	.endef
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">.seh_proc</span>	<span style="color:#66d9ef">main</span>
</span></span><span style="display:flex;"><span>main:
</span></span><span style="display:flex;"><span>.LFB0:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pushq</span>	%rbp
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">.seh_pushreg</span>	%rbp
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">movq</span>	%rsp, %rbp
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">.seh_setframe</span>	%rbp, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">subq</span>	<span style="color:#66d9ef">$48</span>, %rsp
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">.seh_stackalloc</span>	<span style="color:#ae81ff">48</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">.seh_endprologue</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">call</span>	<span style="color:#66d9ef">__main</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">leaq</span>	-<span style="color:#ae81ff">1</span>(%rbp), %rax
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">movl</span>	<span style="color:#66d9ef">$666</span>, %edx
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">movq</span>	%rax, %rcx
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">call</span>	<span style="color:#66d9ef">_ZN1BIiE3fooEi</span> <span style="color:#75715e"># 调用b.foo(666)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">movl</span>	<span style="color:#66d9ef">$0</span>, %eax
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">addq</span>	<span style="color:#66d9ef">$48</span>, %rsp
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">popq</span>	%rbp
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ret</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">.seh_endproc</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">.ident</span>	<span style="color:#e6db74">&#34;GCC: (Rev7, Built by MSYS2 project) 13.1.0&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">.def</span>	<span style="color:#66d9ef">_ZN1BIiE3fooEi</span><span style="color:#75715e">;	.scl	2;	.type	32;	.endef
</span></span></span></code></pre></div><p>这里好像没有什么问题，直接去调用了<code>foo</code>，然后我们来看看<code>B.cpp</code>的汇编</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>	.file	<span style="color:#e6db74">&#34;B.cpp&#34;</span>
</span></span><span style="display:flex;"><span>	.text
</span></span><span style="display:flex;"><span>	.section .rdata,<span style="color:#e6db74">&#34;dr&#34;</span>
</span></span><span style="display:flex;"><span>_ZNSt8__detail30__integer_to_chars_is_unsignedIjEE:
</span></span><span style="display:flex;"><span>	.byte	<span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>_ZNSt8__detail30__integer_to_chars_is_unsignedImEE:
</span></span><span style="display:flex;"><span>	.byte	<span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>_ZNSt8__detail30__integer_to_chars_is_unsignedIyEE:
</span></span><span style="display:flex;"><span>	.byte	<span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	.ident	<span style="color:#e6db74">&#34;GCC: (Rev7, Built by MSYS2 project) 13.1.0&#34;</span>
</span></span></code></pre></div><p>什么？里面居然没有<code>_ZN1BIiE3fooEi</code>这个符号？为什么呢？前面也提到过，只有当模板被实例化的时候，才会生成对应的汇编指令。这里的问题正是，没有实例化。</p>
<p><code>A.cpp</code>中<code>include</code>了<code>B.h</code>，确实在<code>B&lt;int&gt; b</code>的时候对类模板进行了实例化。但是，类模板里面的成员函数只是声明！没有实际定义。而在编译<code>B.cpp</code>的时候，就没有类似于<code>B&lt;int&gt; b</code>这样的东西对它进行实例化了（<code>A.cpp</code>和<code>B.cpp</code>不是同一个翻译单元）。于是<code>void B&lt;T&gt;::foo(T x)</code>就没有进行实例化，也就没有实际的汇编指令，也就没有<code>_ZN1BIiE3fooEi</code>这个符号。所以链接的时候就提示无法找到定义。</p>
<p>应该怎么做？我们只需要显式实例化即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// B.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;B.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> B<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>foo(T x){
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>x<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>;
</span></span></code></pre></div><p>即加上了最后一行。再来看看现在的汇编代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>	.file	<span style="color:#e6db74">&#34;B.cpp&#34;</span>
</span></span><span style="display:flex;"><span>	.text
</span></span><span style="display:flex;"><span>	.section .rdata,<span style="color:#e6db74">&#34;dr&#34;</span>
</span></span><span style="display:flex;"><span>.LC0:
</span></span><span style="display:flex;"><span>	.ascii <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\12\0</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	.section	.text<span style="color:#960050;background-color:#1e0010">$</span>_ZN1BIiE3fooEi,<span style="color:#e6db74">&#34;x&#34;</span>
</span></span><span style="display:flex;"><span>	.linkonce discard
</span></span><span style="display:flex;"><span>	.align <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>	.globl	_ZN1BIiE3fooEi
</span></span><span style="display:flex;"><span>	.def	_ZN1BIiE3fooEi;	.scl	<span style="color:#ae81ff">2</span>;	.type	<span style="color:#ae81ff">32</span>;	.endef
</span></span><span style="display:flex;"><span>	.seh_proc	_ZN1BIiE3fooEi
</span></span><span style="display:flex;"><span>_ZN1BIiE3fooEi:
</span></span><span style="display:flex;"><span>.LFB2470:
</span></span><span style="display:flex;"><span>	pushq	<span style="color:#f92672">%</span>rbp
</span></span><span style="display:flex;"><span>	.seh_pushreg	<span style="color:#f92672">%</span>rbp
</span></span><span style="display:flex;"><span>	movq	<span style="color:#f92672">%</span>rsp, <span style="color:#f92672">%</span>rbp
</span></span><span style="display:flex;"><span>	.seh_setframe	<span style="color:#f92672">%</span>rbp, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	subq	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">32</span>, <span style="color:#f92672">%</span>rsp
</span></span><span style="display:flex;"><span>	.seh_stackalloc	<span style="color:#ae81ff">32</span>
</span></span><span style="display:flex;"><span>	.seh_endprologue
</span></span><span style="display:flex;"><span>	movq	<span style="color:#f92672">%</span>rcx, <span style="color:#ae81ff">16</span>(<span style="color:#f92672">%</span>rbp)
</span></span><span style="display:flex;"><span>	movl	<span style="color:#f92672">%</span>edx, <span style="color:#ae81ff">24</span>(<span style="color:#f92672">%</span>rbp)
</span></span><span style="display:flex;"><span>	movl	<span style="color:#ae81ff">24</span>(<span style="color:#f92672">%</span>rbp), <span style="color:#f92672">%</span>eax
</span></span><span style="display:flex;"><span>	movl	<span style="color:#f92672">%</span>eax, <span style="color:#f92672">%</span>edx
</span></span><span style="display:flex;"><span>	movq	.refptr._ZSt4cout(<span style="color:#f92672">%</span>rip), <span style="color:#f92672">%</span>rax
</span></span><span style="display:flex;"><span>	movq	<span style="color:#f92672">%</span>rax, <span style="color:#f92672">%</span>rcx
</span></span><span style="display:flex;"><span>	call	_ZNSolsEi
</span></span><span style="display:flex;"><span>	movq	<span style="color:#f92672">%</span>rax, <span style="color:#f92672">%</span>rcx
</span></span><span style="display:flex;"><span>	leaq	.LC0(<span style="color:#f92672">%</span>rip), <span style="color:#f92672">%</span>rax
</span></span><span style="display:flex;"><span>	movq	<span style="color:#f92672">%</span>rax, <span style="color:#f92672">%</span>rdx
</span></span><span style="display:flex;"><span>	call	_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
</span></span><span style="display:flex;"><span>	nop
</span></span><span style="display:flex;"><span>	addq	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">32</span>, <span style="color:#f92672">%</span>rsp
</span></span><span style="display:flex;"><span>	popq	<span style="color:#f92672">%</span>rbp
</span></span><span style="display:flex;"><span>	ret
</span></span><span style="display:flex;"><span>	.seh_endproc
</span></span><span style="display:flex;"><span>	.section .rdata,<span style="color:#e6db74">&#34;dr&#34;</span>
</span></span><span style="display:flex;"><span>_ZNSt8__detail30__integer_to_chars_is_unsignedIjEE:
</span></span><span style="display:flex;"><span>	.byte	<span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>_ZNSt8__detail30__integer_to_chars_is_unsignedImEE:
</span></span><span style="display:flex;"><span>	.byte	<span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>_ZNSt8__detail30__integer_to_chars_is_unsignedIyEE:
</span></span><span style="display:flex;"><span>	.byte	<span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	.ident	<span style="color:#e6db74">&#34;GCC: (Rev7, Built by MSYS2 project) 13.1.0&#34;</span>
</span></span><span style="display:flex;"><span>	.def	_ZNSolsEi;	.scl	<span style="color:#ae81ff">2</span>;	.type	<span style="color:#ae81ff">32</span>;	.endef
</span></span><span style="display:flex;"><span>	.def	_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc;	.scl	<span style="color:#ae81ff">2</span>;	.type	<span style="color:#ae81ff">32</span>;	.endef
</span></span><span style="display:flex;"><span>	.section	.rdata<span style="color:#960050;background-color:#1e0010">$</span>.refptr._ZSt4cout, <span style="color:#e6db74">&#34;dr&#34;</span>
</span></span><span style="display:flex;"><span>	.globl	.refptr._ZSt4cout
</span></span><span style="display:flex;"><span>	.linkonce	discard
</span></span><span style="display:flex;"><span>.refptr._ZSt4cout:
</span></span><span style="display:flex;"><span>	.quad	_ZSt4cout
</span></span></code></pre></div><p>可见<code>_ZN1BIiE3fooEi:</code>已经在其中了。</p>
<p>不过本小节的标题是“模板最好都写在头文件里”，我们不可能显式实例化所有可能情况。一切的罪魁祸首可能就是头文件中只进行了声明，而没有定义。于是无法正常实例化。我们应该做的，就是把定义放在头文件里。实际上包括stl在内的很多模板库都是<code>head-only</code>的。</p>
<p>不过如果我们要限制用户只能使用特定的几种类型，分离定义和声明，显式实例化这几种特定的类型，是可以考虑的。</p>
<h1 id="auto类型推断">auto类型推断</h1>
<p><code>auto x = y</code>，会抛弃<code>y</code>的<code>cv</code>、引用类别。例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>j <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> k <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> x <span style="color:#f92672">=</span> i; <span style="color:#75715e">// int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> y <span style="color:#f92672">=</span> j; <span style="color:#75715e">// int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> z <span style="color:#f92672">=</span> k; <span style="color:#75715e">// int
</span></span></span></code></pre></div><p>我们可以根据自己的需求去加<code>cv</code>和引用类别</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> x <span style="color:#f92672">=</span> i; <span style="color:#75715e">// int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>y <span style="color:#f92672">=</span> i; <span style="color:#75715e">// int &amp;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> y <span style="color:#f92672">=</span> i; <span style="color:#75715e">// int const &amp;
</span></span></span></code></pre></div><p>注意，C++11下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> x <span style="color:#f92672">=</span> {<span style="color:#ae81ff">3</span>}; <span style="color:#75715e">// 推断为std::initializer_list&lt;int&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> y{<span style="color:#ae81ff">3</span>}; <span style="color:#75715e">// 推断为std::initializer_list&lt;int&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> z{<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}; <span style="color:#75715e">// 推断为std::initializer_list&lt;int&gt;
</span></span></span></code></pre></div><p>这其实是不符合我们的直觉的，在C++17后，第二行被推断为<code>int</code>，而第三行报错。</p>
<h1 id="decltype">decltype</h1>
<p>和<code>auto</code>不同，不会抛弃<code>cv</code>和引用。如果实参是没有括号的标识表达式或没有括号的类成员访问表达式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>j <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> k <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> T1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">decltype</span>(i); <span style="color:#75715e">// int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> T2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">decltype</span>(j); <span style="color:#75715e">// int &amp;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> T3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">decltype</span>(k); <span style="color:#75715e">// int const &amp;
</span></span></span></code></pre></div><p>并且，可以用<code>decltype</code>保留<code>auto</code>中会去除的<code>cv</code>和引用，例如（C++14）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>j <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> k <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) x <span style="color:#f92672">=</span> i; <span style="color:#75715e">// int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) y <span style="color:#f92672">=</span> j; <span style="color:#75715e">// int &amp;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) z <span style="color:#f92672">=</span> k; <span style="color:#75715e">// int const &amp;
</span></span></span></code></pre></div><p>如果<code>decltype</code>的实参是类型为<code>T</code>的任何其他表达式。表达式为亡值时，产生<code>T&amp;&amp;</code>；为左值时，产生<code>T&amp;</code>；纯右值时产生<code>T</code></p>
<h1 id="stddeclval">std::declval</h1>
<p>将任意类型<code>T</code>转换为（右值）引用类型，使得在 decltype 说明符的操作数中不必经过构造函数就能使用成员函数。</p>
<p>注意，<code>std::declval</code>只能用于不求值语境，且不要求有定义；求值包含此函数的表达式是错误的。此函数不能被调用，因此不会返回值。返回类型是<code>T&amp;&amp;</code>，除非<code>T</code>是（可有<code>cv</code>限定的）void，此时返回类型是<code>T</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;utility&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Default</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">foo</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">NonDefault</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    NonDefault() <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">foo</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">decltype</span>(Default().foo()) n1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;                   <span style="color:#75715e">// n1 的类型是 int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//  decltype(NonDefault().foo()) n2 = n1;               // 错误：无默认构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">decltype</span>(std<span style="color:#f92672">::</span>declval<span style="color:#f92672">&lt;</span>NonDefault<span style="color:#f92672">&gt;</span>().foo()) n2 <span style="color:#f92672">=</span> n1; <span style="color:#75715e">// n2 的类型是 int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;n1 = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> n1 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;n2 = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> n2 <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="type_traits库">type_traits库</h1>
<p><a class="link" href="https://zh.cppreference.com/w/cpp/header/type_traits"  target="_blank" rel="noopener"
    >https://zh.cppreference.com/w/cpp/header/type_traits</a></p>
<p>有很多用于判断类型特性的模板。例如<code>is_const, is_class, is_pointer, is_pod, is_unsigned</code>等等。太多不能一一介绍，见上面的链接。使用方法都是类似的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> foo(T <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span> check <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>is_unsigned<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value; <span style="color:#75715e">// C++11
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span> check2 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>is_unsigned_v<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>;<span style="color:#75715e">// C++17后
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>除了判断类型的，还有转换类型的。如<code>add_const, remove_const, make_signed</code>。这里主要讲一下<code>decay</code>和<code>result_of</code></p>
<p><code>decay</code>就是将变量的指针、引用、<code>cv</code>全部去掉，得到纯的<code>T</code>类型，如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;type_traits&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> U<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span> is_decay_equ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>is_same_v<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>decay_t<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>, U<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// c++14可用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// c++11为typename std::decay&lt;T&gt;::type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static_assert</span>
</span></span><span style="display:flex;"><span>    (
</span></span><span style="display:flex;"><span>        is_decay_equ<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">!</span> is_decay_equ<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        is_decay_equ<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        is_decay_equ<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;&amp;</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        is_decay_equ<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        is_decay_equ<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">2</span>], <span style="color:#66d9ef">int</span><span style="color:#f92672">*&gt;</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">!</span> is_decay_equ<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">4</span>][<span style="color:#ae81ff">2</span>], <span style="color:#66d9ef">int</span><span style="color:#f92672">*&gt;</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">!</span> is_decay_equ<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">4</span>][<span style="color:#ae81ff">2</span>], <span style="color:#66d9ef">int</span><span style="color:#f92672">**&gt;</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        is_decay_equ<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">4</span>][<span style="color:#ae81ff">2</span>], <span style="color:#66d9ef">int</span>(<span style="color:#f92672">*</span>)[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        is_decay_equ<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>(<span style="color:#66d9ef">int</span>), <span style="color:#66d9ef">int</span>(<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>result_of</code>得到某个可调用对象的返回值的类型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">S</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">int</span>) { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1.0</span>; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>result_of<span style="color:#f92672">&lt;</span>S(<span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>)<span style="color:#f92672">&gt;::</span>type d <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>; <span style="color:#75715e">// d 拥有 double 类型
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">char</span> c, <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> a){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0.1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>result_of<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(<span style="color:#f92672">&amp;</span>f)(<span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>)<span style="color:#f92672">&gt;::</span>type d <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;
</span></span></code></pre></div><p><code>invoke_result</code>是在C++17后加入的，用以取代<code>result_of</code>，后者已经在C++17中废弃，C++20中移除。语法略有不同，主要是没有括号。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>invoke_result<span style="color:#f92672">&lt;</span>S,<span style="color:#66d9ef">char</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;&gt;::</span>type b <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>invoke_result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(f), <span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;&gt;::</span>type d <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;
</span></span></code></pre></div><h1 id="crtp">CRTP</h1>
<p>奇特重现模板模式（Curiously Recurring Template Pattern, CRTP）是一种惯用手法。</p>
<p>主要就是父类是一个模板类，而子类继承父类，并且在模板实参里面填写子类。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Y</span> {};
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">X</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Y<span style="color:#f92672">&lt;</span>X<span style="color:#f92672">&gt;</span> {};
</span></span></code></pre></div><p>主要用来实现编译期多态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Base</span> { <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">name</span>() { (<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>Derived<span style="color:#f92672">*&gt;</span>(<span style="color:#66d9ef">this</span>))<span style="color:#f92672">-&gt;</span>impl(); } };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">D1</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base<span style="color:#f92672">&lt;</span>D1<span style="color:#f92672">&gt;</span> { <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">impl</span>() { std<span style="color:#f92672">::</span>puts(<span style="color:#e6db74">&#34;D1::impl()&#34;</span>); } };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">D2</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base<span style="color:#f92672">&lt;</span>D2<span style="color:#f92672">&gt;</span> { <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">impl</span>() { std<span style="color:#f92672">::</span>puts(<span style="color:#e6db74">&#34;D2::impl()&#34;</span>); } };
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Base&lt;D1&gt; b1; b1.name(); // 未定义行为
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// Base&lt;D2&gt; b2; b2.name(); // 未定义行为
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    D1 d1; d1.name();
</span></span><span style="display:flex;"><span>    D2 d2; d2.name();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以看<a class="link" href="https://zhuanlan.zhihu.com/p/460497652"  target="_blank" rel="noopener"
    >https://zhuanlan.zhihu.com/p/460497652</a>学一些使用例。</p>
<h1 id="typename消歧">typename消歧</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> type;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typename</span> B<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>type a; <span style="color:#75715e">// 在C++不那么先进的版本，不加typename会报错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>这被称作待决名的typename消歧义符，因为<code>B&lt;T&gt;::type</code>一般会被理解为静态成员。这里它作为一个<code>typedef</code>，需要我们用<code>typename</code>来消除歧义。</p>
<h1 id="sfinae">SFINAE</h1>
<p>“替换失败不是错误” (Substitution Failure Is Not An Error)</p>
<p>首先举个例子，即函数重载中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(A <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span>) {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(B <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bar</span>() {
</span></span><span style="display:flex;"><span>  foo(A());
</span></span><span style="display:flex;"><span>  foo(B());
</span></span><span style="display:flex;"><span>  foo(C());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中<code>foo(A());</code>匹配<code>void foo(B const&amp;) {}</code>失败了，但是不报错。而匹配<code>void foo(A const&amp;) {}</code>成功了，所以调用了这个重载。<code>foo(B());</code>两个都能匹配成功，但是<code>void foo(B const&amp;) {}</code>更特殊，所以调用这个重载。而<code>foo(C());</code>的所有匹配的失败了，才会进行编译报错。</p>
<p>模板替换也是类似的，一个模板替换失败了，并不会直接导致编译错误，编译器会继续查询其他可以替换的模板，只要有一个成功，编译就可以通过。用cppreference的话来说：</p>
<pre><code>在函数模板的重载决议中会应用此规则：当模板形参在替换成显式指定的类型或推导出的类型失败时，从重载集中丢弃这个特化，而非导致编译失败。
</code></pre>
<p>例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> t;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> foo(<span style="color:#66d9ef">typename</span> T<span style="color:#f92672">::</span>t);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> foo(T);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bar</span>(){
</span></span><span style="display:flex;"><span>    foo<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">10</span>); <span style="color:#75715e">// 调用第一个重载，第二个重载匹配失败，因为10不能被隐式转化为A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    foo<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">10</span>); <span style="color:#75715e">// 调用第二个重载，第一个重载匹配失败，因为int没有t成员
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>这只是最简单的使用例子，更为复杂一点的，STL提供了<code>std::enable_if</code>，来在编译时求值，从而开启或关闭某个特定的函数重载。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">bool</span> B, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">enable_if</span>;
</span></span></code></pre></div><p>如果<code>B</code>是<code>true</code>，那么<code>enable_if</code>含有<code>typedef type</code>，否则不含有。</p>
<p>使用例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> destroy(
</span></span><span style="display:flex;"><span>    T<span style="color:#f92672">*</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>enable_if<span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>is_trivially_destructible<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&gt;::</span>type<span style="color:#f92672">*</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;销毁可平凡析构的 T</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里，如果<code>T</code>不是可平凡析构的，那么他就没有<code>type</code>这个成员，匹配就会失败，这个模板就会从重载集中移除。</p>
<p>C++11中还添加了一个表达式SFINAE，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">X</span> {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Y</span> { Y(X){} }; <span style="color:#75715e">// X 可以转换到 Y
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> f(T t1, T t2) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">decltype</span>(t1 <span style="color:#f92672">+</span> t2); <span style="color:#75715e">// 重载 #1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span>X <span style="color:#a6e22e">f</span>(Y, Y);                               <span style="color:#75715e">// 重载 #2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span>X x1, x2;
</span></span><span style="display:flex;"><span>X x3 <span style="color:#f92672">=</span> f(x1, x2);  <span style="color:#75715e">// 推导在 #1 上失败（表达式 x1+x2 非良构）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                   <span style="color:#75715e">// 重载集中只有 #2，调用它
</span></span></span></code></pre></div><p>这里由于<code>X</code>没有重载加法运算符，所以重载1的<code>decltype(t1 + t2)</code>非良构。在C++11时，这会被SFINAE使用，而在之前，这会直接导致编译错误。</p>
<h1 id="极简concept">极简concept</h1>
<p>如果我们要限定<code>template</code>里面的泛型<code>T</code>的性质，要怎么做呢？<code>C++20</code>提供了一个新的方法，即<code>concept</code></p>
<p>他有很多种使用方法，例如假设我们要求一个类型是可排序的，我们假设这个<code>concept</code>叫做<code>Sortable</code>，以有以下几种使用方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">requires</span> Sortable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> sort(T<span style="color:#f92672">&amp;</span> s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> sort(T<span style="color:#f92672">&amp;</span> s) <span style="color:#66d9ef">requires</span> Sortable<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> ; <span style="color:#75715e">// 换了下位置而已
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>Sortable T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> sort(T<span style="color:#f92672">&amp;</span> s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sort</span>(Sortable <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> s); <span style="color:#75715e">// 当然也可以用在返回值上，据说Stroustrup最喜欢这种
</span></span></span></code></pre></div><p>如何定义一个概念（<code>concept</code>）？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span> <span style="color:#960050;background-color:#1e0010">模板形参列表</span> <span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> <span style="color:#960050;background-color:#1e0010">概念名</span> <span style="color:#960050;background-color:#1e0010">属性</span> <span style="color:#960050;background-color:#1e0010">﻿</span>(<span style="color:#960050;background-color:#1e0010">可选</span>) <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">约束表达式</span>;
</span></span></code></pre></div><p>其中这个约束表达式，是一个在编译期可以被eval为bool的表达式或者编译期函数。如果代入模板形参，可以得到<code>true</code>的值，则返回成功，否则不成功。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> always_satisfied <span style="color:#f92672">=</span> true;  <span style="color:#75715e">// 永远成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> integral <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>is_integral_v<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>; <span style="color:#75715e">// 整型时成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> signed_integral <span style="color:#f92672">=</span> integral<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;&amp;</span> std<span style="color:#f92672">::</span>is_signed_v<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>; <span style="color:#75715e">// 满足两者时成功
</span></span></span></code></pre></div><p>这里，一个概念不能提到自己，也不能用另一个概念来约束这个概念，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> integral <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>is_integral_v<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>integral T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> signed_integral <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>is_signed_v<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>;
</span></span></code></pre></div><p>就是不行的。必须通过逻辑运算（包括与、或、非）得到复合的概念。同样的，requires语句也可以加入逻辑运算</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">requires</span> Integral<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;&amp;</span> std<span style="color:#f92672">::</span>is_signed_v<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>T add(T a, T b);
</span></span></code></pre></div><p>可以通过<code>requires</code>语句定义概念</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> Addable <span style="color:#f92672">=</span> <span style="color:#66d9ef">requires</span> (T a, T b) { a<span style="color:#f92672">+</span>b; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">requires</span> <span style="color:#66d9ef">requires</span> (T x) { x <span style="color:#f92672">+</span> x; } <span style="color:#75715e">// ad-hoc式定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>T <span style="color:#a6e22e">add</span>(T a, T b) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>它不会检查是否返回<code>true</code>，只要里面的表达式合法，就可以成功。我们还可以写出</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> cpt1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">requires</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typename</span> C<span style="color:#f92672">::</span>value_type;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typename</span> C<span style="color:#f92672">::</span>iterator;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>C<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>这样的代码，来判断其符不符合这样的使用方法。</p>
<h1 id="变长实参">变长实参</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdarg&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">add_nums</span>(<span style="color:#66d9ef">int</span> count...)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>va_list args;
</span></span><span style="display:flex;"><span>    va_start(args, count);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> count; <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">+=</span> va_arg(args, <span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span>    va_end(args);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> add_nums(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">50</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里<code>int count...</code>就是一个变长实参的声明。我们通过<code>cstdarg</code>中的函数来访问变长实参，首先要用<code>std::va_list</code>来声明一个变量，用来访问实参。然后通过<code>va_start</code>来开启遍历，其中第一个参数为<code>std::va_list</code>，第二个参数为我们的变长实参。之后我们用<code>va_arg</code>来访问下一个实参，传入的是<code>std::va_list</code>和希望转为的类型。用<code>va_end</code>来结束遍历。</p>
<h1 id="形参包">形参包</h1>
<p>这里指的是变长模板形参，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">Types</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Tuple</span> {};
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>Tuple<span style="color:#f92672">&lt;&gt;</span> t0;           <span style="color:#75715e">// Types 不包含实参
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Tuple<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> t1;        <span style="color:#75715e">// Types 包含一个实参：int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Tuple<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;</span> t2; <span style="color:#75715e">// Types 包含两个实参：int 与 float
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Tuple<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&gt;</span> error;       <span style="color:#75715e">// 错误：0 不是类型
</span></span></span></code></pre></div><p>在有模板实参推导后，可以使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">Types</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> f(Types... args);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>f();       <span style="color:#75715e">// OK：args 不包含实参
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>f(<span style="color:#ae81ff">1</span>);      <span style="color:#75715e">// OK：args 包含一个实参：int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>f(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1.0</span>); <span style="color:#75715e">// OK：args 包含两个实参：int 与 double
</span></span></span></code></pre></div><p>上面的<code>Types... args</code>是一个包展开。后随省略号且其中至少有一个形参包的名字的模式会被展开_﻿成零个或更多个逗号分隔的模式实例 ，其中形参包的名字按顺序被替换成包中的各个元素。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">Us</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> f(Us... pargs) {}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">Ts</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> g(Ts... args)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    f(<span style="color:#f92672">&amp;</span>args...); <span style="color:#75715e">// “&amp;args...” 是包展开
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                 <span style="color:#75715e">// “&amp;args” 是它的模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>g(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0.2</span>, <span style="color:#e6db74">&#34;a&#34;</span>); <span style="color:#75715e">// Ts... args 会展开成 int E1, double E2, const char* E3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// &amp;args... 会展开成 &amp;E1, &amp;E2, &amp;E3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// Us... 会展开成 int* E1, double* E2, const char** E3
</span></span></span></code></pre></div><p><code>sizeof...</code>运算符，用于获取形参包的长度，例如<code>sizeof...(args)</code>，在上例中返回<code>3</code></p>
<h1 id="内存池和allocators">内存池和Allocators</h1>
<p>todo</p>
<h1 id="线程池">线程池</h1>
<p>todo</p>
<h1 id="pimpl">PIMPL</h1>
<p>Pointer to implementation，也就是指向实现的指针。具体来说，我们不再在某个类中直接定义它的变量，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// A.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    A();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x, y;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//A.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>A<span style="color:#f92672">::</span>A() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> A<span style="color:#f92672">::</span>foo(){}
</span></span></code></pre></div><p>而是，我们加一个私有的<code>struct</code>和<code>unique_ptr</code>，在这个<code>struct</code>中去定义它的变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    A();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Impl</span>;
</span></span><span style="display:flex;"><span>    unique_ptr<span style="color:#f92672">&lt;</span>Impl<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> p_;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//A.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span><span style="color:#f92672">::</span>Impl{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x, y;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>A<span style="color:#f92672">::</span>A()<span style="color:#f92672">:</span>p_(make_unique<span style="color:#f92672">&lt;</span>Impl<span style="color:#f92672">&gt;</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)){}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> A<span style="color:#f92672">::</span>foo(){} <span style="color:#75715e">// 对p_中的变量进行种种操作
</span></span></span></code></pre></div><p>这样做有什么好处？如果是之前的代码，当我们修改这个类的成员变量时，所有<code>#include</code>了这个头文件的翻译单元都要重新编译，大大增加了编译时间。而后者，其成员变量是在翻译单元中，我们只需要重新编译这个<code>cpp</code>，然后在链接的时候重新链接即可。</p>
<p>目前来说，上面的代码还无法通过编译，因为析构函数需要知道完整的类型，而<code>Impl</code>是不完整的类型，所以我们也需要把析构函数拿出来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//A.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>A<span style="color:#f92672">::~</span>A()<span style="color:#f92672">=</span><span style="color:#66d9ef">default</span>;
</span></span></code></pre></div><p>类似的，你也需要把其他构造函数移出来。</p>
<h1 id="返回值优化">返回值优化</h1>
<p>推荐在函数返回对象的时候，直接在<code>return</code>语句上构造对象。例如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>A <span style="color:#a6e22e">foo</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> A(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> a <span style="color:#f92672">=</span> foo();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（大多数）编译器即使关闭优化，也只会调用一次构造函数，而不会有复制和移动。如果改成</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>A <span style="color:#a6e22e">foo</span>(){
</span></span><span style="display:flex;"><span>    A a(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>则部分编译器可能就不会只调用一次构造了，可能会进行移动。如果</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>A <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>    A a1;
</span></span><span style="display:flex;"><span>    A a2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(x<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">3</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a2;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这样更复杂的情况，编译器可能都不能进行返回值优化了。</p>
<p>所以，还是推荐直接在<code>return</code>语句中构造对象（如果可能）</p>
<h1 id="多继承">多继承</h1>
<p>虽然争议颇多，但是C++确实支持多继承</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B1</span>{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B2</span>{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> B1, <span style="color:#66d9ef">public</span> B2{}
</span></span></code></pre></div><p>如上，类<code>D</code>同时继承了<code>B1,B2</code>，而<code>D</code>的构造函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>D()<span style="color:#f92672">:</span>B1(), B2(){}
</span></span></code></pre></div><p>其构造顺序，类似于之前提到的构造顺序，其并不是以初始化列表的顺序进行的，而是以继承的顺序进行的。</p>
<p>在多继承下有命名冲突的问题，需要用<code>::</code>来指定使用哪个继承</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B1</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> foo(){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B2</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> foo(){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> B1, <span style="color:#66d9ef">public</span> B2{};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bar</span>(){
</span></span><span style="display:flex;"><span>    D d;
</span></span><span style="display:flex;"><span>    d.foo(); <span style="color:#75715e">// 错误，不知道使用B1还是B2的foo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    d.B1<span style="color:#f92672">::</span>foo();
</span></span><span style="display:flex;"><span>    d.B2<span style="color:#f92672">::</span>foo();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>菱形继承是多继承的一种特殊情况，如</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> age <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B1</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> B{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B2</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> B{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> B1, <span style="color:#66d9ef">public</span> B2{};
</span></span></code></pre></div><p>这里<code>D</code>间接地继承了<code>B</code>两次，有什么问题呢？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>D d;
</span></span><span style="display:flex;"><span>d.age <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span></code></pre></div><p>上面这个肯定会报错，和之前的多继承一样，无法区分是使用哪一个<code>age</code>变量。如果我们加上<code>::</code>呢？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>D d;
</span></span><span style="display:flex;"><span>d.B1<span style="color:#f92672">::</span>age <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>d.B2<span style="color:#f92672">::</span>age <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>d.B1<span style="color:#f92672">::</span>age<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>d.B2<span style="color:#f92672">::</span>age<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span></code></pre></div><p>这里会输出<code>10</code>和<code>20</code>，而不是两个<code>20</code>。这虽然在代码意义上是对的，但是很显然我们是想要这个<code>d</code>只有一个<code>age</code>。这里我们就可以引入虚继承。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B1</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span> B{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B2</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span> B{};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> B1, <span style="color:#66d9ef">public</span> B2{};
</span></span></code></pre></div><p>此时，<code>d.age, d.B1::age, d.B2::age</code>都可以通过编译，并且三者指向的是同一个变量。</p>
<p>这些东西编译器是怎么实现的呢？可以参考下面的对象模型介绍文章。</p>
<h1 id="对象模型">对象模型</h1>
<p><a class="link" href="https://www.cnblogs.com/QG-whz/p/4909359.html"  target="_blank" rel="noopener"
    >https://www.cnblogs.com/QG-whz/p/4909359.html</a></p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
        
            <a href="/tags/%E5%B9%B2%E8%B4%A7/">干货</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/inferior/c&#43;&#43;%E5%B9%B6%E5%8F%91%E6%94%AF%E6%8C%81%E5%BA%93%E7%94%A8%E6%B3%95%E9%80%9F%E6%9F%A5/">
        
        

        <div class="article-details">
            <h2 class="article-title">C&#43;&#43;并发支持库用法速查</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/inferior/cmu154452023fall%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%84%E4%BB%B6%E5%8A%9F%E8%83%BD%E9%80%9F%E6%9F%A5/">
        
        
            <div class="article-image">
                <img src="/inferior/cmu154452023fall%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%84%E4%BB%B6%E5%8A%9F%E8%83%BD%E9%80%9F%E6%9F%A5/cover.4a3e3d21403f8cdcc27c3a88db92c416_hub2bee36093f48e478e5566d6bf8cc572_110686_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-Sj49IUA/jNzCfDqI25LEFg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">CMU15445(2023 Fall)数据库组件功能速查</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E5%9C%A8%E6%A0%A1%E5%9B%AD%E7%BD%91%E4%B8%AD%E7%94%A8ssh%E8%BF%9E%E6%8E%A5%E5%AE%BF%E8%88%8D%E7%94%B5%E8%84%91/">
        
        

        <div class="article-details">
            <h2 class="article-title">在校园网中用ssh连接宿舍电脑</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E4%B8%BAhugo%E5%AE%89%E8%A3%85goldmark-mathjax%E6%8F%92%E4%BB%B6%E6%9D%A5%E6%9B%B4%E5%A5%BD%E5%9C%B0%E6%94%AF%E6%8C%81%E8%BE%93%E5%85%A5%E5%85%AC%E5%BC%8F/">
        
        

        <div class="article-details">
            <h2 class="article-title">为Hugo安装goldmark-mathjax插件来更好地支持输入公式</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/msys2mingw64cygwin%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB%E6%B5%85%E8%B0%88/">
        
        

        <div class="article-details">
            <h2 class="article-title">MSYS2,MinGW64,Cygwin的使用区别浅谈</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="kegalas/blogComments"
        issue-term="pathname"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2024 KegalaS的个人博客
    </section>
    
    <section class="powerby">
         <br />
        
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#stdendl">std::endl</a></li>
    <li><a href="#stdclog">std::clog</a></li>
    <li><a href="#三路比较-运算符">&lt;=&gt;（三路比较 ）运算符</a></li>
    <li><a href="#stdnumeric_limitst">std::numeric_limits&lt;T&gt;</a></li>
    <li><a href="#大括号初始化变量">大括号初始化变量</a></li>
    <li><a href="#nodiscard修饰">[[nodiscard]]修饰</a></li>
    <li><a href="#vector扩容初步">vector扩容（初步）</a></li>
    <li><a href="#auto与c-like字符串字面量">auto与“C-Like”字符串字面量</a></li>
    <li><a href="#stdstring的字符串字面量">std::string的字符串字面量</a></li>
    <li><a href="#原始字符串字面量">原始字符串字面量</a></li>
    <li><a href="#stdstring_view">std::string_view</a></li>
    <li><a href="#函数参数什么时候用const-">函数参数什么时候用const &amp;?</a></li>
    <li><a href="#左值纯右值亡值">左值、纯右值、亡值</a></li>
    <li><a href="#右值引用或常左值引用延长生命周期">右值引用（或常左值引用）延长生命周期</a></li>
    <li><a href="#移动语义">移动语义</a></li>
    <li><a href="#小心返回引用的函数">小心返回引用的函数</a></li>
    <li><a href="#引用可能会像迭代器一样失效">引用可能会像迭代器一样失效</a></li>
    <li><a href="#不要用引用来延长函数返回值的生命周期">不要用引用来延长函数返回值的生命周期</a></li>
    <li><a href="#structclass的大括号初值">struct/class的大括号初值</a></li>
    <li><a href="#类拷贝copy">类拷贝（copy）</a>
      <ol>
        <li><a href="#拷贝构造函数">拷贝构造函数</a></li>
        <li><a href="#赋值构造函数">赋值构造函数</a></li>
      </ol>
    </li>
    <li><a href="#argc-argv">argc, argv</a></li>
    <li><a href="#file-stream">file stream</a></li>
    <li><a href="#重载和运算符">重载&laquo;和&raquo;运算符</a></li>
    <li><a href="#类成员初始化">类成员初始化</a></li>
    <li><a href="#explicit关键字">explicit关键字</a></li>
    <li><a href="#构造函数相互调用">构造函数相互调用</a></li>
    <li><a href="#在c里最好用nullptr而不是null">在C++里最好用nullptr而不是null</a></li>
    <li><a href="#c四种类型转换">C++四种类型转换</a></li>
    <li><a href="#cv限定符">cv限定符</a></li>
    <li><a href="#mutable和const的成员函数">mutable和const的成员函数</a></li>
    <li><a href="#const与指针">const与指针</a></li>
    <li><a href="#成员函数引用限定符">成员函数引用限定符</a></li>
    <li><a href="#constexpr">constexpr</a></li>
    <li><a href="#智能指针">智能指针</a></li>
    <li><a href="#make_shared和make_unique">make_shared和make_unique</a></li>
    <li><a href="#placement-new">placement new</a></li>
    <li><a href="#this指针">this指针</a></li>
    <li><a href="#析构函数的析构顺序">析构函数的析构顺序</a></li>
    <li><a href="#有时候可以尝试集中处理exception">有时候可以尝试集中处理Exception</a></li>
    <li><a href="#raii思想和其对于exception内存泄漏的保护">RAII思想和其对于Exception内存泄漏的保护</a></li>
    <li><a href="#noexcept修饰">noexcept修饰</a></li>
    <li><a href="#注意给assert的参数加上括号">注意给assert的参数加上括号</a></li>
    <li><a href="#static_assert">static_assert</a></li>
    <li><a href="#用-dndbug忽略所有assert">用-DNDBUG忽略所有assert</a></li>
    <li><a href="#编译器warning的编译参数">编译器warning的编译参数</a></li>
    <li><a href="#cmake使用">Cmake使用</a></li>
    <li><a href="#doctestcatch2gtest使用">doctest/catch2/gtest使用</a></li>
    <li><a href="#不要在调试的时候到处写coutcerr">不要在调试的时候到处写cout、cerr</a></li>
    <li><a href="#gdb使用">GDB使用</a></li>
    <li><a href="#使用gclang检测内存错误使用未定义行为等">使用g++/clang检测内存错误使用、未定义行为等</a></li>
    <li><a href="#使用valgrind检测内存泄漏死锁问题等">使用valgrind检测内存泄漏、死锁问题等</a></li>
    <li><a href="#使用end迭代器的值是未定义行为">使用end迭代器的值是未定义行为</a></li>
    <li><a href="#stddistance">std::distance</a></li>
    <li><a href="#所有序列容器都是所谓的regular-types">所有序列容器都是所谓的regular types</a></li>
    <li><a href="#stdspan">std::span</a></li>
    <li><a href="#map和set查询元素是否存在的新方法">Map和Set查询元素是否存在的新方法</a></li>
    <li><a href="#用equal_range获取multiset中所有给定值">用equal_range获取multiset中所有给定值</a></li>
    <li><a href="#不要用迭代器遍历unordered_map和unordered_set">不要用迭代器遍历unordered_map和unordered_set</a></li>
    <li><a href="#map和set的判断元素相同的依据">map和set的判断元素相同的依据</a></li>
    <li><a href="#自定义unordered容器的哈希函数">自定义unordered容器的哈希函数</a></li>
    <li><a href="#标准库算法的执行策略">标准库算法的执行策略</a></li>
    <li><a href="#新for循环反向遍历的方法">新for循环反向遍历的方法</a></li>
    <li><a href="#泛型lambda">泛型Lambda</a></li>
    <li><a href="#stdmemcpy的重叠问题">std::memcpy的重叠问题</a></li>
    <li><a href="#stdcopy的重叠问题">std::copy的重叠问题</a></li>
    <li><a href="#stdrandom_shuffle随机重排数组">std::random_shuffle随机重排数组</a></li>
    <li><a href="#stdfill">std::fill</a></li>
    <li><a href="#stdgenerate">std::generate</a></li>
    <li><a href="#stdtransform">std::transform</a></li>
    <li><a href="#stdaccumulate和stdreduce">std::accumulate和std::reduce</a></li>
    <li><a href="#stdtuple">std::tuple</a></li>
    <li><a href="#stdoptional">std::optional</a></li>
    <li><a href="#stdvariant">std::variant</a></li>
    <li><a href="#stdany">std::any</a></li>
    <li><a href="#c构建模型">C++构建模型</a></li>
    <li><a href="#重复include导致的编译错误">重复include导致的编译错误</a></li>
    <li><a href="#重复include导致的链接报错">重复include导致的链接报错</a></li>
    <li><a href="#使用namespace来防止命名冲突">使用namespace来防止命名冲突</a></li>
    <li><a href="#inline-namespace">inline namespace</a></li>
    <li><a href="#friend">friend</a></li>
    <li><a href="#public-protected-private">public, protected, private</a></li>
    <li><a href="#override标识符">override标识符</a></li>
    <li><a href="#析构函数务必声明为virtual">析构函数务必声明为virtual</a></li>
    <li><a href="#final标识符">final标识符</a></li>
    <li><a href="#不要继承成员变量组合优于继承">不要继承成员变量，组合优于继承</a></li>
    <li><a href="#不要在构造函数里调用virtual函数">不要在构造函数里调用virtual函数</a></li>
    <li><a href="#不能被继承的成员函数">不能被继承的成员函数</a></li>
    <li><a href="#rtti">RTTI</a></li>
    <li><a href="#c四个异常安全等级">C++四个异常安全等级</a></li>
    <li><a href="#普通构造和拷贝构造是可以抛异常的但是移动构造和析构最好noexcept">普通构造和拷贝构造是可以抛异常的，但是移动构造和析构最好noexcept</a></li>
    <li><a href="#vector的元素最好有noexcept的移动构造函数">vector的元素最好有noexcept的移动构造函数</a></li>
    <li><a href="#copy--swap">copy &amp; swap</a></li>
    <li><a href="#实参依赖查找adl">实参依赖查找（ADL）</a></li>
    <li><a href="#完美转发引用折叠">完美转发，引用折叠</a></li>
    <li><a href="#模板类暴露类型给外部">模板类暴露类型给外部</a></li>
    <li><a href="#类模板实参推导指引">类模板实参推导指引</a></li>
    <li><a href="#模板实例化和模板特化">模板实例化和模板特化</a></li>
    <li><a href="#模板最好都写在头文件里">模板最好都写在头文件里</a></li>
    <li><a href="#auto类型推断">auto类型推断</a></li>
    <li><a href="#decltype">decltype</a></li>
    <li><a href="#stddeclval">std::declval</a></li>
    <li><a href="#type_traits库">type_traits库</a></li>
    <li><a href="#crtp">CRTP</a></li>
    <li><a href="#typename消歧">typename消歧</a></li>
    <li><a href="#sfinae">SFINAE</a></li>
    <li><a href="#极简concept">极简concept</a></li>
    <li><a href="#变长实参">变长实参</a></li>
    <li><a href="#形参包">形参包</a></li>
    <li><a href="#内存池和allocators">内存池和Allocators</a></li>
    <li><a href="#线程池">线程池</a></li>
    <li><a href="#pimpl">PIMPL</a></li>
    <li><a href="#返回值优化">返回值优化</a></li>
    <li><a href="#多继承">多继承</a></li>
    <li><a href="#对象模型">对象模型</a></li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>

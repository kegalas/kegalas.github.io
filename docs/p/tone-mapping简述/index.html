<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='如何显示HDR （注：本人对显示器技术了解有限，这一部分可能不够准确。另外，国内外网络上关于这些东西的说明实在太少，结合了我的一些个人理解，我'><title>Tone Mapping简述</title>

<link rel='canonical' href='https://kegalas.uk/p/tone-mapping%E7%AE%80%E8%BF%B0/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='Tone Mapping简述'>
<meta property='og:description' content='如何显示HDR （注：本人对显示器技术了解有限，这一部分可能不够准确。另外，国内外网络上关于这些东西的说明实在太少，结合了我的一些个人理解，我'>
<meta property='og:url' content='https://kegalas.uk/p/tone-mapping%E7%AE%80%E8%BF%B0/'>
<meta property='og:site_name' content='KegalaS的个人博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='大学' /><meta property='article:tag' content='人工智能' /><meta property='article:tag' content='计算机视觉' /><meta property='article:tag' content='图形学' /><meta property='article:published_time' content='2025-02-15T14:43:24&#43;08:00'/><meta property='article:modified_time' content='2025-02-15T14:43:24&#43;08:00'/><meta property='og:image' content='https://kegalas.uk/cover.jpg' />
<meta name="twitter:title" content="Tone Mapping简述">
<meta name="twitter:description" content="如何显示HDR （注：本人对显示器技术了解有限，这一部分可能不够准确。另外，国内外网络上关于这些东西的说明实在太少，结合了我的一些个人理解，我"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://kegalas.uk/cover.jpg' />
    <link rel="shortcut icon" href="/images/favicon.ico" />

    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/tone-mapping%E7%AE%80%E8%BF%B0/">
                
                    <img src="/cover.jpg" loading="lazy" alt="Featured image of post Tone Mapping简述" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" >
                图形学
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/tone-mapping%E7%AE%80%E8%BF%B0/">Tone Mapping简述</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Feb 15, 2025</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 11 分钟
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <h1 id="如何显示hdr">如何显示HDR</h1>
<p>（注：本人对显示器技术了解有限，这一部分可能不够准确。另外，国内外网络上关于这些东西的说明实在太少，结合了我的一些个人理解，我尽量做到不自我矛盾）</p>
<p>白色<span class="math inline">\([255,255,255]\)</span>、红色<span class="math inline">\([255,0,0]\)</span>这样的颜色是怎么显示在屏幕上的呢？首先，将其转化为标准化的<span class="math inline">\([1.0, 1.0, 1.0]\)</span>、<span class="math inline">\([1.0, 0.0, 0.0]\)</span>，然后发送到显示器，显示器中分别显示RGB三种颜色的灯泡就会按照这个值去发出特定的亮度，这个特定的亮度由电光转换（EOTF）函数决定，在SDR显示器中，这个函数通常是gamma传递函数</p>
<p><span class="math display">\[Y = E^\gamma
\]</span></p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 108; 
			flex-basis: 259px"
	>
	<a href="/p/tone-mapping%E7%AE%80%E8%BF%B0/1.jpg" data-size="365x337">
		<img src="/p/tone-mapping%E7%AE%80%E8%BF%B0/1.jpg"
			width="365"
			height="337"
			srcset="/p/tone-mapping%E7%AE%80%E8%BF%B0/1_hu4d988d9e5993e7af8bb8d46a2379b0c6_21162_480x0_resize_q75_box.jpg 480w, /p/tone-mapping%E7%AE%80%E8%BF%B0/1_hu4d988d9e5993e7af8bb8d46a2379b0c6_21162_1024x0_resize_q75_box.jpg 1024w"
			loading="lazy"
			alt="1.jpg">
	</a>
	
	<figcaption>1.jpg</figcaption>
	
</figure></p>
<p>这里<span class="math inline">\(E\)</span>是我们给予的颜色值<span class="math inline">\([0, 1]\)</span>，而<span class="math inline">\(Y\)</span>是标准化的亮度值<span class="math inline">\([0,1]\)</span>，其中<span class="math inline">\(0\)</span>代表灯泡的最低亮度，而<span class="math inline">\(1\)</span>代表灯泡的最高亮度。<span class="math inline">\(\gamma\)</span>就是我们说的gamma值，一般会取<span class="math inline">\(2.2\)</span>。一般来说，SDR显示器的最高亮度定义为<span class="math inline">\(100\)</span>nits，所以</p>
<p><span class="math display">\[F_D = 100Y = 100E^\gamma
\]</span></p>
<p>其中<span class="math inline">\(F_D\)</span>是显示器理论上会发出的亮度值。</p>
<p>HDR的含义是高动态范围，要求我们能够显示更高的亮度，即超越<span class="math inline">\(100\)</span>nits达到<span class="math inline">\(400\)</span>、<span class="math inline">\(1000\)</span>甚至更高的nits。虽然理论上来说你确实可以将<span class="math inline">\(F_D = 400Y\)</span>来适应更高的亮度，但是使用其他曲线能够更好的符合人眼感知特性（以及其他原因，见后）。特别的，在HDR领域用的最多的是PQ曲线和HLG曲线，这里我们主要讲PQ：</p>
<p><span class="math display">\[F_D = 10000\left(\dfrac{\max[(E^{1/m_2}-c_1),0]}{c_2-c_3\cdot E^{1/m_2}}\right)^{1/m_1}
\]</span></p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 112; 
			flex-basis: 270px"
	>
	<a href="/p/tone-mapping%E7%AE%80%E8%BF%B0/2.png" data-size="664x590">
		<img src="/p/tone-mapping%E7%AE%80%E8%BF%B0/2.png"
			width="664"
			height="590"
			srcset="/p/tone-mapping%E7%AE%80%E8%BF%B0/2_hucb57838621395c217f2c74f1db6ee6d9_41157_480x0_resize_box_3.png 480w, /p/tone-mapping%E7%AE%80%E8%BF%B0/2_hucb57838621395c217f2c74f1db6ee6d9_41157_1024x0_resize_box_3.png 1024w"
			loading="lazy"
			alt="2.jpg">
	</a>
	
	<figcaption>2.jpg</figcaption>
	
</figure></p>
<p>具体的参数数值可以在<a class="link" href="https://en.wikipedia.org/wiki/Perceptual_quantizer"  target="_blank" rel="noopener"
    >https://en.wikipedia.org/wiki/Perceptual_quantizer</a>找到。由公式和图像可知，PQ曲线最高支持到10000nits亮度。</p>
<p>PQ曲线是同样的，那对于只有400nits亮度的显示屏如何显示1.0大小的信号呢？答案是：不要使用1.0大小的信号。通过某一些方法（见后，即tonemapping）将1.0大小的信号缩放到0.7左右，并且视频、图像文件里都只存0.7以下的数字。</p>
<p>实际上这并不是乱说的，HDR视频制作过程中metadata确实会有记录视频制作时的显示器亮度，以及视频播放时显示器的亮度（至少HDR Vivid确实有），这对于HDR的合理播放至关重要。</p>
<p>接下来我们再来说说位深。从刚刚的描述中你也注意到，我们完全可以用<span class="math inline">\([0,255]\)</span>来表示HDR的所有亮度值<span class="math inline">\([0,1]\)</span>啊，为什么我们经常说HDR必须用上<span class="math inline">\(10\)</span>bit呢？</p>
<p>我们先以简单的线性视角来看，如果要量化<span class="math inline">\([0,100]\)</span>nits这个区间，我们使用<span class="math inline">\(8\)</span>位深度，那么就是用<span class="math inline">\(256\)</span>个数去表示<span class="math inline">\([0,100]\)</span>，每两个连续的量化之间的差异是<span class="math inline">\(100/256\approx 0.4\)</span>。而如果我们要量化<span class="math inline">\([0,10000]\)</span>nits这个区间，那么差异就是<span class="math inline">\(10000/256\approx40\)</span>，大了一百倍，这造成的结果就是渐变变化跨度太大，有“条带”现象的出现。举个例子如下，从左到右量化精度越来越高，两个连续量化之间的差异越来越小。</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 163; 
			flex-basis: 392px"
	>
	<a href="/p/tone-mapping%E7%AE%80%E8%BF%B0/3.jpg" data-size="1015x621">
		<img src="/p/tone-mapping%E7%AE%80%E8%BF%B0/3.jpg"
			width="1015"
			height="621"
			srcset="/p/tone-mapping%E7%AE%80%E8%BF%B0/3_hua217a8ec1bbbbf5071b4d26b53ab773e_33672_480x0_resize_q75_box.jpg 480w, /p/tone-mapping%E7%AE%80%E8%BF%B0/3_hua217a8ec1bbbbf5071b4d26b53ab773e_33672_1024x0_resize_q75_box.jpg 1024w"
			loading="lazy"
			alt="3.jpg">
	</a>
	
	<figcaption>3.jpg</figcaption>
	
</figure></p>
<p>问题是10bit用来量化10000nits他仍然有<span class="math inline">\(10000/1024\approx 10\)</span>的连续差异啊？为什么HDR显示器10bit甚至8抖10bit就可以满足要求？这时我们就要脱离出线性的视角，实际上，在PQ域里，100nits对应的信号值是<span class="math inline">\(0.5081\)</span>，而10000nits对应的是<span class="math inline">\(1.0\)</span>。这就意味着我们使用10bit位深，来量化<span class="math inline">\([0,1.0]\)</span>这个区间，虽然<span class="math inline">\([0,511]\)</span>负责量化<span class="math inline">\([0,0.5]\)</span>，而<span class="math inline">\([512, 1023]\)</span>负责量化<span class="math inline">\([0.5, 1.0]\)</span>，但是将其使用PQ曲线转化后，实际上<span class="math inline">\([0, 511]\)</span>量化了<span class="math inline">\([0, 100]\)</span>nits，而<span class="math inline">\([512, 1023]\)</span>量化了<span class="math inline">\([100, 10000]\)</span>nits。换句话说，亮度越低的地方量化误差越小。</p>
<p>根据<a class="link" href="https://en.wikipedia.org/wiki/High-dynamic-range_television#Transfer_function"  target="_blank" rel="noopener"
    >https://en.wikipedia.org/wiki/High-dynamic-range_television#Transfer_function</a>所说，想要避免条带问题，在PQ域量化完整的10000nits需要至少12bits。而我们一般的HDR显示器也就支持到400nits，好一点的1000nits，用10bit来量化这些亮度低的地方完全足够。</p>
<p>回到之前的问题，为什么不再用gamma曲线了呢？除了人眼感知的一些因素，还因为gamma域中的10000nits量化要避免条带问题，至少需要15bit的位深。所以说白了，其实传递函数是对于量化亮度的分配规则（虽然gamma最初来源于CRT显示器的物理特性），将人眼最敏感的那部分区域用最多的空间去表示，而其他不敏感的地方用较少的空间区表示。</p>
<p>接下来还有颜色空间的问题。HDR10这样的标准确实规定了颜色空间必须是Rec2020，但是从上面的介绍中你也认识到，要显示HDR和颜色空间没有什么关系，你就算只支持灰度显示也可以HDR。不过，你若想将HDR映射到SDR显示器上显示，你仍然需要在tonemapping过后将Rec2020转到Rec709，防止SDR显示器显示有偏差的颜色。</p>
<h1 id="tone-mapping的作用">Tone Mapping的作用</h1>
<p>最初是没有HDR显示器的，Tone mapping的作用是将用各种技术捕捉到的具有高亮度的图像，恰当的显示在SDR显示器上。通常来说，一张照片中的很大部分内容都在<span class="math inline">\([0,100]\)</span>nits之间，可以被SDR显示器正常显示，而只有很少一部分（例如太阳直射），具有很高的亮度，比如1000nits。而Tone mapping要做的事是，保留大部分正常显示的内容亮度不降低太少，而大幅度降低过于亮的部分。例如，我们可以用<span class="math inline">\([0,80]\)</span>nits来显示原来<span class="math inline">\([0,100]\)</span>的内容，而使用<span class="math inline">\([80, 100]\)</span>nits显示所有大于100nits的内容。</p>
<p>你可能会说这和刚刚提到的EOTF很像，都是在限定的范围内合理分配数值。那我们可不可以直接将PQ域的数据转换到线性域，再从线性域转换到Gamma域呢？答案是可以，但是不够好。借用论文<a class="link" href="https://www.sciencedirect.com/science/article/pii/S1051200423001100"  target="_blank" rel="noopener"
    >High Dynamic Range Image Tone Mapping: Literature review and performance benchmark</a>中的一张图（本文之后的内容也会极大程度参考该综述）</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 170; 
			flex-basis: 408px"
	>
	<a href="/p/tone-mapping%E7%AE%80%E8%BF%B0/4.jpg" data-size="1213x712">
		<img src="/p/tone-mapping%E7%AE%80%E8%BF%B0/4.jpg"
			width="1213"
			height="712"
			srcset="/p/tone-mapping%E7%AE%80%E8%BF%B0/4_hud25faf95cd4b7588858ba3015aed4756_136735_480x0_resize_q75_box.jpg 480w, /p/tone-mapping%E7%AE%80%E8%BF%B0/4_hud25faf95cd4b7588858ba3015aed4756_136735_1024x0_resize_q75_box.jpg 1024w"
			loading="lazy"
			alt="4.jpg">
	</a>
	
	<figcaption>4.jpg</figcaption>
	
</figure></p>
<p>使用不同的Tone mapping效果是不一样的。上面的gamma曲线的图像明显是不如Drago曲线的，也就是说，gamma曲线对于HDR源的压缩还不够好，因为它毕竟只是为了SDR源而设计的。</p>
<p>在不同地方，Tone mapping曲线的目标可能是不一样的。例如在图形渲染当中，为了符合更好的物理规律，镜面反射+漫反射+环境光的亮度可能会大于1.0，这里的Tone mapping目的在于将<span class="math inline">\([0, +\infty]\)</span>的亮度映射到<span class="math inline">\([0, 1]\)</span>之间，然后再去gamma校正。而对于HDR Vivid这样的视频处理，其规则为：PQ域-线性域-Tone mapping-Gamma域，首先转化为<span class="math inline">\([0,1]\)</span>之间的标准化亮度，然后Tone mapping负责将这个<span class="math inline">\([0,1]\)</span>映射到另一个<span class="math inline">\([0,1]\)</span>上，更符合Gamma域的颜色分布，然后进行伽马校正。</p>
<p>通常，Tone mapping是在“亮度”上进行的，而非分别在RGB上做（当然也有），在改变亮度后再进行“颜色恢复”，形式如下</p>
<p><span class="math display">\[C' = \left(\dfrac{C}{L}\right)^s T
\]</span></p>
<p>其中，<span class="math inline">\(C\)</span>是指原图中某个像素的RGB通道中的任意一个的数值，而<span class="math inline">\(C'\)</span>则是其对应的Tone mapping后的结果数值。<span class="math inline">\(L\)</span>是该像素的亮度，而<span class="math inline">\(T\)</span>是<span class="math inline">\(L\)</span>使用Tone mapping曲线计算出来的结果，<span class="math inline">\(s\)</span>是颜色补偿参数，一般会取<span class="math inline">\(1\)</span>，如果小于<span class="math inline">\(1\)</span>就会欠饱和。所以，面向亮度进行的Tone mapping就是在研究如何将<span class="math inline">\(L\)</span>转换成<span class="math inline">\(T\)</span>。</p>
<p>首先先谈一谈如何计算某个像素的亮度值。这通常很经验，要么就是根据某种人眼的生物学研究，但是有几个形式用的比较多，最多的可能是：</p>
<p><span class="math display">\[L = 0.2959R + 0.5870G + 0.1140B
\]</span></p>
<p>即RGB的加权平均（事实上，人眼确实对绿色的亮度最敏感）。而像HDR Vivid这样的体系会使用<span class="math inline">\(L=\max\{R,G,B\}\)</span>。虽然没有确切证据证据，但是前者恰好是RGB转YUV中Y的定义，而后者正好是RGB转HSV中V的定义。</p>
<h1 id="只考虑单个像素亮度的tmo">只考虑单个像素亮度的TMO</h1>
<p>（注：TMO是Tone Mapping Operator）</p>
<p>如果我们整张图只用一根曲线，并且只考虑某个像素自己的信息，那么这也可以叫做Global TMO。</p>
<p>例如，<strong>极简化</strong>的Reinhard方法可以被写作</p>
<p><span class="math display">\[T = \dfrac{L}{1+L}
\]</span></p>
<p>其将<span class="math inline">\([0,+\infty]\)</span>映射到<span class="math inline">\([0, 1]\)</span>上。更多的这种用在游戏领域的GTMO可以看<a class="link" href="https://zhuanlan.zhihu.com/p/21983679"  target="_blank" rel="noopener"
    >https://zhuanlan.zhihu.com/p/21983679</a>，它们的显著特点就是形式简单，速度超快。（另外他这里面全是RGB上直接做的，而Reinhard的<a class="link" href="https://dl.acm.org/doi/abs/10.1145/3596711.3596781"  target="_blank" rel="noopener"
    >原论文</a>取的是<span class="math inline">\(L=0.27R+0.67G+0.06B\)</span>）</p>
<p>这样的单根曲线很多时候是根据人眼视觉系统（human visual system, HVS）的特性来设计的，例如论文<a class="link" href="https://onlinelibrary.wiley.com/doi/abs/10.1111/1467-8659.00689"  target="_blank" rel="noopener"
    >Adaptive logarithmic mapping for displaying high contrast scenes</a>中，就使用了</p>
<p><span class="math display">\[L_d = \dfrac{L_{dmax}\cdot 0.01}{\log_{10}(L_{wmax}+1)}\cdot\dfrac{\log(L_w+1)}{\log\left(2+\left(\left(\dfrac{L_w}{L_{wmax}}\right)^{\dfrac{\log(b)}{\log(0.5)}}\right)\cdot 8\right)}
\]</span></p>
<p>这样的公式，这里的<span class="math inline">\(L_w\)</span>就是映射前的亮度，<span class="math inline">\(L_d\)</span>就是映射后的亮度，而<span class="math inline">\(L_{dmax}\)</span>一般取100代表显示器的最大亮度，<span class="math inline">\(b\)</span>是可调参数。</p>
<p>还有一种方法是根据直方图来的，例如<a class="link" href="https://www.sciencedirect.com/science/article/pii/S0031320309004518"  target="_blank" rel="noopener"
    >Tone-mapping High Dynamic Range Images by Novel Histogram Adjustment</a>可以被<strong>极简化</strong>的写作</p>
<p><span class="math display">\[D(I) = (D_{max}-D_{min})\times \dfrac{\log(I+\tau)-\log(I_{min}+\tau)}{\log(I_{max}+\tau)-\log(I_{min}+\tau)}+D_{min}
\]</span></p>
<p>其中<span class="math inline">\(D_{max}, D_{min}\)</span>是显示器的最大最小亮度，而<span class="math inline">\(I_{max}, I_{min}\)</span>是场景中的最大最小亮度。（注：曲线对于同一张图片是固定的，不同位置的像素拥有相同的输入就有相同的输出）</p>
<p>也有研究者引入了聚类算法，对不同的类别进行统计，决定该图像的映射曲线使用什么参数。</p>
<p>这类GTMO的问题在于，其对于局部对比度的保护不好。尤其是在特别亮和特别暗的地方，这些曲线倾向于将它们映射到非常接近的亮度，而一个像素和其周围的像素亮度通常是接近的，使用GTMO就丢失了局部对比度。</p>
<h1 id="考虑周围像素亮度值的tmo">考虑周围像素亮度值的TMO</h1>
<p>为了解决局部对比度的问题，Local TMO就被提出了。GTMO理论上同一张图片里相同的亮度会被映射成相同的结果，但LTMO就允许映射成不同的结果，来保护局部的对比度。</p>
<p>考虑空间上的信息的研究中比较著名的是<strong>完全体</strong>版<a class="link" href="https://dl.acm.org/doi/abs/10.1145/3596711.3596781"  target="_blank" rel="noopener"
    >Reinhard</a>，在传统的摄影技法中，摄影师能够通过调整曝光时间来将结果中的暗的地方增亮，亮的地方变暗，从而让结果包含更多有效信息。Reinhard方法通过自动的方法来进行这种操作。作者使用高斯滤波器来找到这种局部对比度差异大的像素，然后通过提亮被亮像素包围的暗像素，减暗被暗像素包围的亮像素，并且他们变化的幅度不会太大，来实现降低整体的亮度的同时保证局部对比度。</p>
<p>而在频域的信息上来做的最著名的是<a class="link" href="https://dl.acm.org/doi/abs/10.1145/566570.566574"  target="_blank" rel="noopener"
    >Durand &amp; Dorsey</a>方法，原文大篇幅在讲滤波，我看不懂，但是其LTMO的思路如下（参考自<a class="link" href="https://zhuanlan.zhihu.com/p/573894977"  target="_blank" rel="noopener"
    >https://zhuanlan.zhihu.com/p/573894977</a>）</p>
<ol>
<li>通过我们之前加权求和方法计算图片的亮度图，并且将其进行对数运算，得到<strong>对数域</strong>亮度图<span class="math inline">\(L\)</span></li>
<li>在<span class="math inline">\(L\)</span>上进行双边滤波，得到<span class="math inline">\(B\)</span>，即代表了基础层，我们需要压缩这部分</li>
<li>计算细节信息层（局部对比度就在这里）<span class="math inline">\(D=L-B\)</span></li>
<li>以某种方法压缩<span class="math inline">\(B\)</span>，例如直接乘以常数，或者使用某种GTMO（我试过真的可以，不过要先从对数域转换回去，之后再转换回来），得到压缩后的结果<span class="math inline">\(B'\)</span></li>
<li>重新算出全图亮度<span class="math inline">\(L'=B'+D+\beta\)</span>，这里的<span class="math inline">\(\beta\)</span>是曝光补偿参数，可调。</li>
<li>将<span class="math inline">\(L'\)</span>从对数域转回去，得到了新的亮度，然后使用我们之前说的颜色恢复方法恢复回去就可以了。</li>
</ol>
<p>当然，这里的细节层也不是不可以增强或者压缩，看自己的选择。这种方法的原理是利用了双边滤波的特性，其可以保护边缘信息，而将其他变化平缓的部分取均值，从而我们可以通过计算出基础层<span class="math inline">\(B\)</span>，然后用用<span class="math inline">\(L-B\)</span>得到细节层<span class="math inline">\(D\)</span>。实际上这个<span class="math inline">\(D\)</span>就是将原图中的边缘信息去除，然后留下平缓部分的“差异”，也就是“局部对比度”。</p>
<p>之前用双边滤波可能会有点性能问题，但是双边网格被发明后，再加上现在电脑的算力提升，这种方法也是逐渐可以用到游戏里了，例如<a class="link" href="https://advances.realtimerendering.com/s2021/jpatry_advances2021/index.html#/125"  target="_blank" rel="noopener"
    >对马岛之魂</a>中，就应用了这种技术，其算法我认为本质上和上文的是相同的：</p>
<p><span class="math display">\[I_o=c\times (B-M) + d\times (I_i-B) + M
\]</span></p>
<p>上面这些全在<strong>对数域</strong>，<span class="math inline">\(I_o, I_i\)</span>就是输出和输入亮度，<span class="math inline">\(B\)</span>是滤波得到的基础层，<span class="math inline">\(M\)</span>是亮度的中值。<span class="math inline">\(c\)</span>是调整对比度的可调参数，<span class="math inline">\(d\)</span>是调整细节的参数。</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 168; 
			flex-basis: 405px"
	>
	<a href="/p/tone-mapping%E7%AE%80%E8%BF%B0/6.jpg" data-size="574x340">
		<img src="/p/tone-mapping%E7%AE%80%E8%BF%B0/6.jpg"
			width="574"
			height="340"
			srcset="/p/tone-mapping%E7%AE%80%E8%BF%B0/6_huf5f553ec2db9ab23c0d1891afbb9f3a2_13554_480x0_resize_q75_box.jpg 480w, /p/tone-mapping%E7%AE%80%E8%BF%B0/6_huf5f553ec2db9ab23c0d1891afbb9f3a2_13554_1024x0_resize_q75_box.jpg 1024w"
			loading="lazy"
			alt="6.jpg">
	</a>
	
	<figcaption>6.jpg</figcaption>
	
</figure></p>
<p>双边滤波的问题是会有光晕问题。作者给出的解释如下</p>
<p><figure 
	
		class="gallery-image" 
		style="
			flex-grow: 214; 
			flex-basis: 515px"
	>
	<a href="/p/tone-mapping%E7%AE%80%E8%BF%B0/7.jpg" data-size="1286x599">
		<img src="/p/tone-mapping%E7%AE%80%E8%BF%B0/7.jpg"
			width="1286"
			height="599"
			srcset="/p/tone-mapping%E7%AE%80%E8%BF%B0/7_hu70f0d20628d8dbcf7d8f34ff26d89e4f_101894_480x0_resize_q75_box.jpg 480w, /p/tone-mapping%E7%AE%80%E8%BF%B0/7_hu70f0d20628d8dbcf7d8f34ff26d89e4f_101894_1024x0_resize_q75_box.jpg 1024w"
			loading="lazy"
			alt="7.jpg">
	</a>
	
	<figcaption>7.jpg</figcaption>
	
</figure></p>
<p>我认为作者的意思是想说，在减少对比度的同时，增加细节，就会让这根曲线从“大体上单增”，变成了一个“大体上先增后减再增“的曲线，正是这种奇怪的过渡使得光晕产生。</p>
<p>而作者给出的解决办法就是混合使用高斯滤波和双边滤波。大概40%的双边，60%的高斯，而且高斯核必须足够大。</p>
<h1 id="考虑像素颜色值的tmo">考虑像素颜色值的TMO</h1>
<p>我们之前说的颜色恢复并不是那么准确，像那样改亮度实际上是会稍微影响到色度的。</p>
<p>TODO</p>
<h1 id="深度学习的tmo">深度学习的TMO</h1>
<h2 id="基于gan的方法">基于GAN的方法</h2>
<p>TODO</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E5%A4%A7%E5%AD%A6/">大学</a>
        
            <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a>
        
            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a>
        
            <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="has-image">
    <a href="/p/grabcut-interactive-foreground-extraction-using-iterated-graph-cuts%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB%E4%B8%8E%E5%A4%8D%E7%8E%B0/">
        
        
            <div class="article-image">
                <img src="/p/grabcut-interactive-foreground-extraction-using-iterated-graph-cuts%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB%E4%B8%8E%E5%A4%8D%E7%8E%B0/cover.719f06f8145a0ec2fc378d5f11233592_huf62d2c95a51769be2a7aa0d894297a77_82581_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-cZ8G&#43;BRaDsL8N41fESM1kg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">GrabCut— Interactive Foreground Extraction Using Iterated Graph Cuts论文精读与复现</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/deep-bilateral-learning-for-real-time-image-enhancement%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB/">
        
        
            <div class="article-image">
                <img src="/p/deep-bilateral-learning-for-real-time-image-enhancement%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB/cover.c544671fcae18b2974e28dcd19d110e3_hu21346ed4a71566f3cd713a52c023a686_153701_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-xURnH8rhiyl04o3NGdEQ4w==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Deep Bilateral Learning for Real Time Image Enhancement论文速读</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/appprop-all-pairs-appearance-space-edit-propagation%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB%E4%B8%8E%E5%A4%8D%E7%8E%B0/">
        
        
            <div class="article-image">
                <img src="/p/appprop-all-pairs-appearance-space-edit-propagation%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB%E4%B8%8E%E5%A4%8D%E7%8E%B0/cover.a6dc0aea3fa6a380f9f56b9bac533904_hueda4c761f5117f950ea670cd72a10b0b_71812_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-ptwK6j&#43;mo4D59WubrFM5BA==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">AppProp: All-Pairs Appearance-Space Edit Propagation论文精读与复现</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/rectangling-panoramic-images-via-warping%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB%E4%B8%8E%E5%A4%8D%E7%8E%B0/">
        
        
            <div class="article-image">
                <img src="/p/rectangling-panoramic-images-via-warping%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB%E4%B8%8E%E5%A4%8D%E7%8E%B0/cover.383f9c251b2b8f8107d60d2e28590acd_hu803811e1d9d935a6e60dd50dca480090_178188_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-OD&#43;cJRsrj4EH1g0uKFkKzQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Rectangling Panoramic Images via Warping论文精读与复现</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/unified-medical-image-pre-training-in-language-guided-common-semantic-space%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB/">
        
        
            <div class="article-image">
                <img src="/p/unified-medical-image-pre-training-in-language-guided-common-semantic-space%E8%AE%BA%E6%96%87%E9%80%9F%E8%AF%BB/cover.8ed5ad32c94fbb733ed30623d84a42b3_hu7db9f684ad4dbfbdeb174bd533317f2a_62839_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-jtWtMslPu3M&#43;0wYj2EpCsw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">Unified Medical Image Pre Training in Language Guided Common Semantic Space论文速读</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="kegalas/blogComments"
        issue-term="pathname"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2025 KegalaS的个人博客
    </section>
    
    <section class="powerby">
         <br />
        
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#如何显示hdr">如何显示HDR</a></li>
    <li><a href="#tone-mapping的作用">Tone Mapping的作用</a></li>
    <li><a href="#只考虑单个像素亮度的tmo">只考虑单个像素亮度的TMO</a></li>
    <li><a href="#考虑周围像素亮度值的tmo">考虑周围像素亮度值的TMO</a></li>
    <li><a href="#考虑像素颜色值的tmo">考虑像素颜色值的TMO</a></li>
    <li><a href="#深度学习的tmo">深度学习的TMO</a>
      <ol>
        <li><a href="#基于gan的方法">基于GAN的方法</a></li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>

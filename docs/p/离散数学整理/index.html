<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='离散数学有关定义定理整理'><title>离散数学整理</title>

<link rel='canonical' href='https://kegalas.top/p/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='离散数学整理'>
<meta property='og:description' content='离散数学有关定义定理整理'>
<meta property='og:url' content='https://kegalas.top/p/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86/'>
<meta property='og:site_name' content='KegalaS的个人博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='离散数学' /><meta property='article:tag' content='大学' /><meta property='article:tag' content='数学' /><meta property='article:published_time' content='2022-06-06T08:44:57&#43;08:00'/><meta property='article:modified_time' content='2022-06-06T08:44:57&#43;08:00'/><meta property='og:image' content='https://kegalas.top/p/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86/cover.jpg' />
<meta name="twitter:title" content="离散数学整理">
<meta name="twitter:description" content="离散数学有关定义定理整理"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://kegalas.top/p/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86/cover.jpg' />
    <link rel="shortcut icon" href="favicon-16x16.png" />

    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86/">
                <img src="/p/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86/cover_huf80a3777f066c3f01437aeed10211fe1_29240_800x0_resize_q75_box.jpg"
                        srcset="/p/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86/cover_huf80a3777f066c3f01437aeed10211fe1_29240_800x0_resize_q75_box.jpg 800w, /p/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86/cover_huf80a3777f066c3f01437aeed10211fe1_29240_1600x0_resize_q75_box.jpg 1600w"
                        width="800" 
                        height="515" 
                        loading="lazy"
                        alt="Featured image of post 离散数学整理" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E6%95%B0%E5%AD%A6/" >
                数学
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%95%B4%E7%90%86/">离散数学整理</a>
    </h2>

    
    <h3 class="article-subtitle">
        离散数学有关定义定理整理
    </h3>
    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jun 06, 2022</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 40 分钟
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    

<h2 id="命题逻辑">命题逻辑</h2>
<h3 id="联结词">联结词</h3>
<ol type="1">
<li>否定联结词</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(P\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\neg
P\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>合取联结词</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(P\)</span></th>
<th style="text-align: center;"><span class="math inline">\(Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P\wedge
V\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<ol start="3" type="1">
<li>析取联结词</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(P\)</span></th>
<th style="text-align: center;"><span class="math inline">\(Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P\vee
V\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<ol start="4" type="1">
<li>条件联结词</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(P\)</span></th>
<th style="text-align: center;"><span class="math inline">\(Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P\to
V\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<ol start="5" type="1">
<li>双条件联结词</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(P\)</span></th>
<th style="text-align: center;"><span class="math inline">\(Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P\leftrightarrow V\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<h4 id="联结词的运算优先级">联结词的运算优先级</h4>
<p>从高到低依次为，否定、合取、析取、条件、双条件</p>
<h3 id="命题公式">命题公式</h3>
<h4 id="一些定义">一些定义</h4>
<p><strong>定义1，命题变元与常元</strong></p>
<p>用于代表取值为真<span class="math inline">\((T、1)\)</span>或假<span class="math inline">\((F、0)\)</span>之一的变量，称为命题变元，通常用大写字母或带下标或上标的大写字母表示，如<span class="math inline">\(P、Q、R、P_1、P_2\)</span>等。将<span class="math inline">\(T\)</span>和<span class="math inline">\(F\)</span>称为命题常元。</p>
<p>通常把由命题常元、命题变元、联结词以及括弧组成的式子称为表达式,但是只有按照特定组合规则所形成的表达式才有实际意义。</p>
<p><strong>定义2，命题公式</strong></p>
<p>命题合式公式(简称命题公式):</p>
<p>(1)(基础)单个命题常元或命题变元是命题合式公式</p>
<p>(2)(归纳)如果A和B是命题公式,则<span class="math inline">\(\neg
A\)</span>、<span class="math inline">\((A\wedge B)\)</span>、<span class="math inline">\((A\vee B)\)</span>、<span class="math inline">\((A\to B)\)</span>、<span class="math inline">\((A\leftrightarrow B)\)</span>是命题合式公式。</p>
<p>(3)(极小性)只有有限次地应用条款(1)和(2)生成的表达式オ是命题合式公式</p>
<p><strong>定义3，子公式</strong></p>
<p>若<span class="math inline">\(B\)</span>是命题公式<span class="math inline">\(A\)</span>的一个连续段且<span class="math inline">\(B\)</span>也是命题公式,则称<span class="math inline">\(B\)</span>是<span class="math inline">\(A\)</span>的个子公式。</p>
<h4 id="命题公式的赋值">命题公式的赋值</h4>
<p>对于有<span class="math inline">\(n\)</span>个变元的公式，有<span class="math inline">\(2^n\)</span>种不同赋值。</p>
<p><strong>永真式（重言式）</strong></p>
<p>一个命题公式在任何赋值下，其真值都为<span class="math inline">\(T\)</span>，则称这个公式为永真式（重言式）</p>
<p><strong>永假式（矛盾式）</strong></p>
<p>一个命题公式在任何赋值下，其真值都为<span class="math inline">\(F\)</span>，则称这个公式为永假式（矛盾式）</p>
<p><strong>偶然式</strong></p>
<p>既不是永真式也不是永假式，则为偶然式</p>
<p><strong>可满足式</strong></p>
<p>一个命题公式至少有一个赋值，使其真值为<span class="math inline">\(T\)</span>，则称这个公式为可满足式。也即永真式和偶然式都是可满足式。不是可满足式的称为矛盾式。</p>
<h3 id="逻辑等价与蕴含">逻辑等价与蕴含</h3>
<h4 id="等价">等价</h4>
<p><strong>定义</strong></p>
<p>给定两个命题公式<span class="math inline">\(A\)</span>和<span class="math inline">\(B4\)</span>,设<span class="math inline">\(P_1,P_2,\cdots,P_n\)</span>为所有出现在A和B中的命题变元，但<span class="math inline">\(P_i\)</span>不一定在<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>中同时出现，若对于<span class="math inline">\(P_1,P_2,\cdots,P_n\)</span>的任一赋值,<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>的真值都相同，则称<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>逻辑等价，记做<span class="math inline">\(A\Leftrightarrow B\)</span>,读做“<span class="math inline">\(A\)</span>等价于<span class="math inline">\(B\)</span>”。</p>
<p>下面列出常见的命题等价公式</p>
<p><img src="1.3.3-1.jpg" alt="1.3.3-1"/> <img src="1.3.3-2.jpg" alt="1.3.3-2"/></p>
<p>几个定理</p>
<p><strong>定理1（代入规则）</strong></p>
<p>设<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>是命题公式，其中<span class="math inline">\(A\)</span>是重言式，<span class="math inline">\(P\)</span>是<span class="math inline">\(A\)</span>中的命题变元，如果将<span class="math inline">\(A\)</span>中每一处出现的P均用B代入，则所得命题公式<span class="math inline">\(A\)</span>仍然是一个重言式</p>
<p><strong>定理2</strong></p>
<p>设<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>是命题公式，则<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>逻辑等价,当且仅当<span class="math inline">\(A\leftrightarrow B\)</span>是一个重言式。</p>
<p><strong>定理3（替换规则）</strong></p>
<p>设<span class="math inline">\(A\)</span>、<span class="math inline">\(X\)</span>、<span class="math inline">\(Y\)</span>是命题公式，<span class="math inline">\(X\)</span>是<span class="math inline">\(A\)</span>的子公式,且有<span class="math inline">\(X\Leftrightarrow Y\)</span>。如果将<span class="math inline">\(A\)</span>中的<span class="math inline">\(X\)</span>用<span class="math inline">\(Y\)</span>来替换(不必每一处都替换)，则所得到的公式<span class="math inline">\(B\)</span>与<span class="math inline">\(A\)</span>等价,即<span class="math inline">\(B\Leftrightarrow A\)</span>。</p>
<p><strong>定理4（传递规则）</strong></p>
<p>设<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>、<span class="math inline">\(C\)</span>是命题公式，若<span class="math inline">\(A\Leftrightarrow B\)</span>且<span class="math inline">\(B\Leftrightarrow C\)</span>,则有<span class="math inline">\(A\Leftrightarrow C\)</span>。</p>
<h4 id="蕴含">蕴含</h4>
<p>设<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>是命题公式，如果<span class="math inline">\(A\to B\)</span>是一个重言式,则称<span class="math inline">\(A\)</span>蕴含<span class="math inline">\(B\)</span>,记做<span class="math inline">\(A\Rightarrow B\)</span>。</p>
<p>一些常见的蕴含公式</p>
<figure>
<img src="1.3.7-1.jpg" alt="1.3.7-1"/>
<figcaption aria-hidden="true">1.3.7-1</figcaption>
</figure>
<figure>
<img src="1.3.7-2.jpg" alt="1.3.7-2"/>
<figcaption aria-hidden="true">1.3.7-2</figcaption>
</figure>
<p>证明蕴含式<span class="math inline">\(A\Rightarrow
B\)</span>的一些方法：</p>
<ol type="1">
<li>肯定前件法。假设<span class="math inline">\(A\)</span>为<span class="math inline">\(T\)</span>，如果能够推出<span class="math inline">\(B\)</span>为<span class="math inline">\(T\)</span>，则有<span class="math inline">\(A\Rightarrow B\)</span></li>
<li>否定后件法。假设<span class="math inline">\(B\)</span>为<span class="math inline">\(F\)</span>，如果能够推出<span class="math inline">\(A\)</span>为<span class="math inline">\(F\)</span>，则有<span class="math inline">\(A\Rightarrow B\)</span></li>
</ol>
<p>几个定理</p>
<p><strong>定理1</strong></p>
<p>设<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>是任意两个命题公式，<span class="math inline">\(A\Leftrightarrow B\)</span>当且仅当<span class="math inline">\(A\Rightarrow B\)</span>且<span class="math inline">\(B\Rightarrow A\)</span>.</p>
<p>几个性质</p>
<p><strong>性质1</strong></p>
<p>设<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>是命题公式，如果<span class="math inline">\(A\Rightarrow B\)</span>且<span class="math inline">\(A\)</span>是重言式，则<span class="math inline">\(B\)</span>也是重言式</p>
<p><strong>性质2</strong></p>
<p>蕴含关系是传递的，即<span class="math inline">\(A\Rightarrow
B\)</span>且<span class="math inline">\(B\Rightarrow C\)</span>，则<span class="math inline">\(A\Rightarrow C\)</span>.</p>
<p><strong>性质3</strong></p>
<p>如果<span class="math inline">\(A\Rightarrow B\)</span>且<span class="math inline">\(A\Rightarrow C\)</span>，则<span class="math inline">\(A\Rightarrow B\wedge C\)</span></p>
<p><strong>性质4</strong></p>
<p>如果<span class="math inline">\(A\Rightarrow C\)</span>且<span class="math inline">\(B\Rightarrow C\)</span>，则<span class="math inline">\(A\vee B\Rightarrow C\)</span></p>
<h3 id="对偶式">对偶式</h3>
<p><strong>定义</strong></p>
<p>设有命题公式<span class="math inline">\(A\)</span>，其中仅含有联结词<span class="math inline">\(\neg,\vee,\wedge\)</span>，如果将<span class="math inline">\(A\)</span>中的<span class="math inline">\(\vee\)</span>替换为<span class="math inline">\(\wedge\)</span>，<span class="math inline">\(\wedge\)</span>替换为<span class="math inline">\(\vee\)</span>，常元<span class="math inline">\(T,F\)</span>也互相替换，所得到的公式记为<span class="math inline">\(A^*\)</span>，则称<span class="math inline">\(A^*\)</span>为<span class="math inline">\(A\)</span>的对偶式。</p>
<p>显然有，<span class="math inline">\(A\)</span>也是<span class="math inline">\(A^*\)</span>的对偶式，并且<span class="math inline">\((A^*)^*=A\)</span></p>
<p>几个定理</p>
<p><strong>定理1</strong></p>
<p>设<span class="math inline">\(A\)</span>和<span class="math inline">\(A^*\)</span>是对偶公式，其中仅含有联结词<span class="math inline">\(\neg,\vee,\wedge\)</span>；<span class="math inline">\(P_1,P_2,\cdots,P_n\)</span>是出现在<span class="math inline">\(A\)</span>和<span class="math inline">\(A^*\)</span>中的所有命题变元，于是有</p>
<p><span class="math display">\[
\neg A(P_1,P_2,\cdots,P_n)\Leftrightarrow A^*(\neg P_1,\neg
P_2,\cdots,\neg P_n)
\]</span></p>
<p><span class="math display">\[
A(\neg P_1,\neg P_2,\cdots,\neg P_n)\Leftrightarrow\neg
A^*(P_1,P_2,\cdots,P_n)
\]</span></p>
<p><strong>定理2</strong></p>
<p>设<span class="math inline">\(A,B\)</span>是命题公式，则有</p>
<ol type="1">
<li>如果<span class="math inline">\(A\Leftrightarrow B\)</span>，则<span class="math inline">\(A^*\Leftrightarrow B^*\)</span></li>
<li>如果<span class="math inline">\(A\Rightarrow B\)</span>，则<span class="math inline">\(B^*\Rightarrow A^*\)</span></li>
</ol>
<h3 id="范式">范式</h3>
<h4 id="析取范式和合取范式">析取范式和合取范式</h4>
<p><strong>析取式</strong></p>
<p>仅由若干命题变元和若干命题变元之否定通过联结词<span class="math inline">\(\vee\)</span>构成的命题公式。</p>
<p><strong>合取式</strong></p>
<p>仅由若干命题变元和若干命题变元之否定通过联结词<span class="math inline">\(\wedge\)</span>构成的命题公式。</p>
<p><strong>析取范式</strong></p>
<p>一个命题公式被称为析取范式，当且仅当它具有如下形式</p>
<p><span class="math display">\[
A_1\vee A_2\vee\cdots\vee A_n
\]</span></p>
<p>其中<span class="math inline">\(A_1,A_2,\cdots,A_n\)</span>是合取式。</p>
<p><strong>合取范式</strong></p>
<p>一个命题公式被称为合取范式，当且仅当它具有如下形式</p>
<p><span class="math display">\[
A_1\wedge A_2\wedge\cdots\wedge A_n
\]</span></p>
<p>其中<span class="math inline">\(A_1,A_2,\cdots,A_n\)</span>是析取式。</p>
<h4 id="主析取范式">主析取范式</h4>
<p><strong>极小项</strong></p>
<p>一个含<span class="math inline">\(n\)</span>个命题变元的合取式，如果其中每个变元和其否定不同时存在，但两者之一必须出现且仅出现一次，则称该合取式为极小项。</p>
<p><span class="math inline">\(n\)</span>个命题变元<span class="math inline">\(P_1,P_2,\cdots,P_n\)</span>可构成<span class="math inline">\(2^n\)</span>个不同的极小项，其形式为：</p>
<p><span class="math display">\[
\tilde{P_1}\wedge \tilde{P_2}\wedge\cdots\wedge \tilde{P_n}
\]</span></p>
<p>其中<span class="math inline">\(\tilde{P_i}\)</span>或者是<span class="math inline">\(P_i\)</span>，或者是<span class="math inline">\(\neg P_i\)</span></p>
<p>可以用<span class="math inline">\(n\)</span>位二进制编码表示极小项，例如</p>
<p><span class="math display">\[
m_{010}=\neg P_1\wedge P_2\wedge\neg P_3
\]</span></p>
<p>有如下三个性质：</p>
<ol type="1">
<li>每一个极小项当其编码与赋值相同时，其真值为<span class="math inline">\(T\)</span>，在其余<span class="math inline">\(2^n-1\)</span>种赋值下其真值均为<span class="math inline">\(F\)</span>.</li>
<li>任意两个不同的极小项的合取式永假。</li>
<li>所有极小项的析取式永真。</li>
</ol>
<p><strong>主析取范式</strong></p>
<p>设<span class="math inline">\(P_1,P_2,\cdots,P_n\)</span>是命题公式<span class="math inline">\(A\)</span>中包含的所有命题变元，若由<span class="math inline">\(P_1,P_2,\cdots,P_n\)</span>的若干极小项析取所构成的析取范式与<span class="math inline">\(A\)</span>等价，则称该析取范式是<span class="math inline">\(A\)</span>的主析取范式。</p>
<p>有如下定理</p>
<p><strong>定理1</strong></p>
<p>在一个命题公式<span class="math inline">\(A\)</span>的真值表中，使<span class="math inline">\(A\)</span>的真值为<span class="math inline">\(T\)</span>的所有赋值所对应的极小项构成的析取范式即为<span class="math inline">\(A\)</span>的主析取范式。</p>
<h4 id="主合取范式">主合取范式</h4>
<p><strong>极大项</strong></p>
<p>一个含<span class="math inline">\(n\)</span>个命题变元的析取式，如果其中每个变元和其否定不同时存在，但两者之一必须出现且仅出现一次，则称改合取式为极大项。</p>
<p><span class="math inline">\(n\)</span>个命题变元<span class="math inline">\(P_1,P_2,\cdots,P_n\)</span>可构成<span class="math inline">\(2^n\)</span>个不同的极小项，其形式为：</p>
<p><span class="math display">\[
\tilde{P_1}\vee \tilde{P_2}\vee\cdots\vee \tilde{P_n}
\]</span></p>
<p>其中<span class="math inline">\(\tilde{P_i}\)</span>或者是<span class="math inline">\(P_i\)</span>，或者是<span class="math inline">\(\neg P_i\)</span></p>
<p>可以用<span class="math inline">\(n\)</span>位二进制编码表示极大项，例如</p>
<p><span class="math display">\[
M_{101}=\neg P_1\vee P_2\vee\neg P_3
\]</span></p>
<p>（编码注意与极小项意义相反）</p>
<p>有如下三个性质：</p>
<ol type="1">
<li>每一个极大项当其真值赋值与编码相同时，其真值为<span class="math inline">\(F\)</span>，在其余<span class="math inline">\(2^n-1\)</span>种赋值下其真值均为<span class="math inline">\(T\)</span>.</li>
<li>任意两个不同的极大项的析取式永真。</li>
<li>所有极大项的合取式永假。</li>
</ol>
<p><strong>主合取范式</strong></p>
<p>设<span class="math inline">\(P_1,P_2,\cdots,P_n\)</span>是命题公式<span class="math inline">\(A\)</span>中包含的所有命题变元，若由<span class="math inline">\(P_1,P_2,\cdots,P_n\)</span>的若干极大项合取所构成的合取范式与<span class="math inline">\(A\)</span>等价，则称该合取范式是<span class="math inline">\(A\)</span>的主合取范式。</p>
<p>有如下定理</p>
<p><strong>定理1</strong></p>
<p>在一个命题公式<span class="math inline">\(A\)</span>的真值表中，使<span class="math inline">\(A\)</span>的真值为<span class="math inline">\(F\)</span>的所有赋值所对应的极大项构成的合取范式即为<span class="math inline">\(A\)</span>的主合取范式。</p>
<p><strong>定理</strong></p>
<p>设<span class="math inline">\(A\)</span>的主析取范式的各个极小项的下标转为十进制，组成的集合为<span class="math inline">\(S_1\{i_1,i_2,\cdots,i_k\}\)</span>；主合取范式的各个极大项的下标转为十进制，组成的集合为<span class="math inline">\(S_2=\{j_1,j_2,\cdots,j_t\}\)</span>，则有</p>
<p><span class="math display">\[
S_1\cap S_2=\phi
\]</span></p>
<p><span class="math display">\[
S_1\cup S_2=\{0,1,2,\cdots,2^n-1\}
\]</span></p>
<h4 id="范式的计算">范式的计算</h4>
<p>除了可以用真值表来算，还可以通过德摩根定律等将“<span class="math inline">\(\to\)</span>”等不是析取、合取、否定的联结词转化，直到只剩析取、合取、否定。再通过添加、删除括号转化为主合取范式或主析取范式。</p>
<h3 id="命题逻辑的推理理论">命题逻辑的推理理论</h3>
<h4 id="推理规则">推理规则</h4>
<ol type="1">
<li>P规则：在推导过程中，前提可以在任何步骤引入。</li>
<li>T规则：在推导过程中，如果由已经推出的一个或多个公式蕴含<span class="math inline">\(S\)</span>，则公式<span class="math inline">\(S\)</span>可以引入到推导过程中。</li>
</ol>
<h4 id="证明方法">证明方法</h4>
<ol type="1">
<li>无义证明法。如果能证明<span class="math inline">\(P\)</span>恒为假，则有<span class="math inline">\(P\to Q\)</span>恒为真，即<span class="math inline">\(P\Rightarrow Q\)</span></li>
<li>平凡证明法。如果能证明<span class="math inline">\(Q\)</span>恒为真，则有<span class="math inline">\(P\to Q\)</span>恒为真，即<span class="math inline">\(P\Rightarrow Q\)</span></li>
<li>直接证明法。从一组前提出发，利用公认的推理规则，逻辑演绎得到有效结论。</li>
<li>归谬法（即反证法）。</li>
</ol>
<p><strong>定理</strong></p>
<p><span class="math inline">\(H_1,H_2,\cdots,H_m,C\)</span>是公式，如果存在公式<span class="math inline">\(R\)</span>，使得<span class="math inline">\(H_1,H_2,\cdots,H_m,\neg C\Rightarrow R\wedge\neg
R\)</span>，则有<span class="math inline">\(H_1,H_2,\cdots,H_m\Rightarrow C\)</span></p>
<ol start="5" type="1">
<li>CP规则法。</li>
</ol>
<p><span class="math inline">\(H_1,H_2,\cdots,H_n,R,C\)</span>是命题公式，根据输出律<span class="math inline">\(E_{22}\)</span>推知</p>
<p><span class="math display">\[
(H_1\wedge H_2\wedge\cdots\wedge H_n)\to(R\to
C)\Leftrightarrow(H_1\wedge H_2\wedge\cdots\wedge H_n\wedge R)\to C
\]</span></p>
<p>因此，如果能够证明<span class="math inline">\(H_1,H_2,\cdots,H_n,R\Rightarrow
C\)</span>，则有<span class="math inline">\(H_1,H_2,\cdots,H_n\Rightarrow R\to C\)</span></p>
<h2 id="谓词逻辑">谓词逻辑</h2>
<h3 id="谓词和量词">谓词和量词</h3>
<h4 id="谓词">谓词</h4>
<p>刻画单个个体的特性或者多个个体间关系的模式称为谓词。</p>
<h4 id="量词">量词</h4>
<ol type="1">
<li>全称量词<span class="math inline">\(\forall\)</span></li>
<li>存在量词<span class="math inline">\(\exist\)</span></li>
</ol>
<p><strong>几个规则</strong></p>
<p>应当使用<span class="math inline">\(\forall x(H(x)\to
D(x))\)</span>，而不能表示为<span class="math inline">\(\forall
x(H(x)\wedge D(x))\)</span>。</p>
<p>应当使用<span class="math inline">\(\exist x(H(x)\wedge
D(x))\)</span>，而不能表示为<span class="math inline">\(\exist x(H(x)\to
D(x))\)</span>。</p>
<h3 id="谓词公式">谓词公式</h3>
<p><strong>定义</strong></p>
<p>谓词逻辑的合式公式（简称谓词公式）可由以下步骤生成 1.
原子公式（不出现联结词和量词的单个谓词）是谓词公式。 2. 如果<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>是谓词公式，则<span class="math inline">\(\neg A,(A\wedge B),(A\vee B),(A\to
B),(A\leftrightarrow B)\)</span>是谓词公式 3. 如果<span class="math inline">\(A\)</span>是谓词公式，并且<span class="math inline">\(A\)</span>中有未被量化的个体变元<span class="math inline">\(x\)</span>，则<span class="math inline">\(\forall
xA(x)\)</span>和<span class="math inline">\(\exist
xA(x)\)</span>是谓词公式。 4.
只有有限次应用步骤1、2、3所得到的的公式才是谓词公式。</p>
<p><strong>子公式</strong></p>
<p>若<span class="math inline">\(B\)</span>是谓词公式<span class="math inline">\(A\)</span>的一个连续段且<span class="math inline">\(B\)</span>也是谓词公式，则称<span class="math inline">\(B\)</span>是<span class="math inline">\(A\)</span>的一个子公式。</p>
<p><strong>辖域</strong></p>
<p>紧跟<span class="math inline">\(\forall x\)</span>和<span class="math inline">\(\exist
x\)</span>之后的最小的子公式称为该量词的辖域。</p>
<p><strong>约束变元</strong></p>
<p>在<span class="math inline">\(\forall x\)</span>和<span class="math inline">\(\exist x\)</span>辖域内<span class="math inline">\(x\)</span>的一切出现称之为约束出现，这个<span class="math inline">\(x\)</span>叫做约束变元。</p>
<p><strong>自由变元</strong></p>
<p>个体变元的非约束出现称为自由出现，自由出现的个体变元称为自由变元。</p>
<p><strong>约束变元的换名规则</strong></p>
<ol type="1">
<li>对某个约束变元换名时，需对量词的作用变元以及该量词辖域内所有受该量词约束的约束变元一起换名。</li>
<li>换名后的变元符号应是量词辖域内未出现的符号，最好是整个公式中未出现的符号。</li>
</ol>
<h3 id="谓词验算的永真公式">谓词验算的永真公式</h3>
<h4 id="谓词公式的赋值">谓词公式的赋值</h4>
<p><strong>定义1</strong></p>
<p>对于一个谓词公式，若给它指定一个个体域<span class="math inline">\(E\)</span>，再给所有谓词符均指派出确定的关系(具体的特性或关系)，给所有命题变元指派出确定命题(或者指定<span class="math inline">\(T\)</span>或<span class="math inline">\(F\)</span>)，并为所有自由变元（注意不包含约束变元）分别指派<span class="math inline">\(E\)</span>上确定的个体，则称为对谓词公式的一个赋值(指派或结识)。谓词公式经过赋值之后就变成了具有确定真值的命题。</p>
<p><strong>定义2</strong></p>
<p>设<span class="math inline">\(A\)</span>是谓词公式，如果对于特定论域<span class="math inline">\(E\)</span>上的任何赋值，<span class="math inline">\(A\)</span>的真值都为真，则称谓词公式<span class="math inline">\(A\)</span>在<span class="math inline">\(E\)</span>上永真;如果对于特定论域<span class="math inline">\(E\)</span>上的任何赋值，<span class="math inline">\(A\)</span>的真值都为假，则称谓词公式<span class="math inline">\(A\)</span>在<span class="math inline">\(E\)</span>上永假;若特定论域<span class="math inline">\(E\)</span>上存在一种赋值，使得<span class="math inline">\(A\)</span>的真值都为真，则称谓词公式<span class="math inline">\(A\)</span>在<span class="math inline">\(E\)</span>上可满足。</p>
<p><strong>定义3</strong></p>
<p>设<span class="math inline">\(A\)</span>是谓词公式，如果对于任何赋值，<span class="math inline">\(A\)</span>的真值都为真，则称谓词公式<span class="math inline">\(A\)</span>是永真式;如果对于任何赋值，<span class="math inline">\(A\)</span>的真值都为假，则称谓词公式<span class="math inline">\(A\)</span>是永假式;若存在一种赋值，使得<span class="math inline">\(A\)</span>的真值为真，则称谓词公式<span class="math inline">\(A\)</span>是可满足式。</p>
<h4 id="谓词演算的基本永真式">谓词演算的基本永真式</h4>
<ol type="1">
<li>命题逻辑的等价式和蕴含式可在谓词逻辑中推广使用</li>
<li>量词的否定律</li>
</ol>
<p><span class="math display">\[
\neg\forall xP(x)\Leftrightarrow \exist x\neg P(x)
\]</span></p>
<p><span class="math display">\[
\neg\exist xP(x)\Leftrightarrow \forall x\neg P(x)
\]</span></p>
<ol start="3" type="1">
<li>量词辖域的扩张与收缩律</li>
</ol>
<figure>
<img src="2.3.2.3.jpg" alt="2.3.2.3"/>
<figcaption aria-hidden="true">2.3.2.3</figcaption>
</figure>
<ol start="4" type="1">
<li>量词的分配律</li>
</ol>
<p><img src="2.3.2.4-1.jpg" alt="2.3.2.4-1"/> <img src="2.3.2.4-2.jpg" alt="2.3.2.4-2"/></p>
<ol start="5" type="1">
<li>多重量词律</li>
</ol>
<p><img src="2.3.2.5-1.jpg" alt="2.3.2.5-1"/> <img src="2.3.2.5-2.jpg" alt="2.3.2.5-2"/></p>
<ol start="6" type="1">
<li>其他</li>
</ol>
<p><span class="math inline">\(\forall xP(x)\Rightarrow
P(y)\)</span>，<span class="math inline">\(y\)</span>是论域中的任一确定个体。</p>
<p><span class="math inline">\(P(y)\Rightarrow\exist
xP(x)\)</span>，<span class="math inline">\(y\)</span>是论域中的某个确定个体。</p>
<p><span class="math inline">\(\forall xP(x)\Rightarrow\exist
xP(x)\)</span></p>
<h3 id="谓词逻辑的推理理论">谓词逻辑的推理理论</h3>
<ol type="1">
<li>存在指定原则（ES）</li>
</ol>
<p><span class="math display">\[
\frac{\exist xP(x)}{\therefore P(a)}
\]</span></p>
<p><span class="math inline">\(a\)</span>是个体常元，注意所指定的个体常元要使得谓词为真。</p>
<ol start="2" type="1">
<li>全称指定原则（US）</li>
</ol>
<p><span class="math display">\[
\frac{\forall xP(x)}{\therefore P(y)}
\]</span></p>
<p><span class="math inline">\(y\)</span>是自由变元，也可以指定到个体常元<span class="math inline">\(a\)</span></p>
<p><span class="math display">\[
\frac{\forall xP(x)}{\therefore P(a)}
\]</span></p>
<p>注意如果同时指定<span class="math inline">\(\exist
xP(x)\)</span>和<span class="math inline">\(\forall
xQ(x)\)</span>，应当先指定<span class="math inline">\(P(a)\)</span>，再指定<span class="math inline">\(Q(a)\)</span>，才能保证两者都为真。</p>
<ol start="3" type="1">
<li>存在推广原则（EG）</li>
</ol>
<p><span class="math display">\[
\frac{P(a)}{\therefore\exist xP(x) }
\]</span></p>
<ol start="4" type="1">
<li>全称推广原则（UG）</li>
</ol>
<p><span class="math display">\[
\frac{\Gamma\Rightarrow P(x)}{\therefore\Gamma\Rightarrow\forall xP(x)}
\]</span></p>
<p><span class="math inline">\(\Gamma\)</span>是已知公理和前提的合取，<span class="math inline">\(\Gamma\)</span>中没有自由变元<span class="math inline">\(x\)</span>的出现。</p>
<h2 id="集合">集合</h2>
<h3 id="集合的表示方法">集合的表示方法</h3>
<ol type="1">
<li>列举法</li>
<li>描述法：用自然语言或谓词描述集合中元素的共同特征。</li>
<li>归纳定义法（见后）</li>
</ol>
<h3 id="集合间的关系">集合间的关系</h3>
<p><strong>外延性公理</strong></p>
<p>两个集合<span class="math inline">\(A,B\)</span>相等，记为<span class="math inline">\(A=B\)</span>，当且仅当它们有相同的元素，即</p>
<p><span class="math display">\[
A=B\Leftrightarrow \forall x(x\in A\leftrightarrow x\in B)
\]</span></p>
<p>两个集合不相等，通常记为<span class="math inline">\(A\neq
B\)</span></p>
<p><strong>子集</strong></p>
<p>设<span class="math inline">\(A、B\)</span>是任意的两个集合，若集合<span class="math inline">\(A\)</span>的每个元素都是集合<span class="math inline">\(B\)</span>的元素，则称<span class="math inline">\(A\)</span>为<span class="math inline">\(B\)</span>的子集或称<span class="math inline">\(B\)</span>包含<span class="math inline">\(A\)</span>,记为<span class="math inline">\(A\subseteq B\)</span>或<span class="math inline">\(B\supseteq A\)</span>，用逻辑公式表示为</p>
<p><span class="math display">\[
A\subseteq B\Leftrightarrow\forall x(x\in A\to x\in B)
\]</span></p>
<p>如果<span class="math inline">\(A\)</span>不是<span class="math inline">\(B\)</span>的子集，通常记为<span class="math inline">\(A\nsubseteq B\)</span></p>
<p><strong>真子集</strong></p>
<p>如果集合<span class="math inline">\(A\)</span>的每一个元素都属于<span class="math inline">\(B\)</span>，但集合<span class="math inline">\(B\)</span>中至少有一个元素不属于<span class="math inline">\(A\)</span>，则称<span class="math inline">\(A\)</span>为<span class="math inline">\(B\)</span>的真子集，记为<span class="math inline">\(A\subset B\)</span>，用逻辑公式表示为</p>
<p><span class="math display">\[
A\subset B\Leftrightarrow\forall x(x\in A\to x\in B)\wedge \exist y(y\in
B\wedge y\notin A)\Leftrightarrow(A\subseteq B)\wedge(A\neq B)
\]</span></p>
<p><strong>全集</strong></p>
<p>在一定范围内所有事物组成的集合称为该范围内的全集记为<span class="math inline">\(U\)</span>，用逻辑公式表示为</p>
<p><span class="math display">\[
U = \{x|P(x)\vee\neg P(x)\}
\]</span></p>
<p>其中，<span class="math inline">\(P(x)\)</span>是任意的谓词</p>
<p><strong>空集</strong></p>
<p>不含任何元素的集合称为空集，记为<span class="math inline">\(\phi\)</span>，用逻辑公式表示为</p>
<p><span class="math display">\[
\phi = \{x|P(x)\wedge\neg P(x)\}
\]</span></p>
<p>其中，<span class="math inline">\(P(x)\)</span>是任意的谓词，并且显然有<span class="math inline">\(|\phi|=0\)</span></p>
<p>几个定理</p>
<p><strong>定理1</strong></p>
<p>空集是任一集合的子集，并且是任何非空集合的真子集。</p>
<p><strong>定理2</strong></p>
<p>设<span class="math inline">\(A,B,C\)</span>是集合，若<span class="math inline">\(A\subseteq B\)</span>且<span class="math inline">\(B\subseteq C\)</span>，则<span class="math inline">\(A\subseteq C\)</span>。</p>
<p><strong>定理3</strong></p>
<p>集合<span class="math inline">\(A,B\)</span>相等的充要条件是<span class="math inline">\(A,B\)</span>互为子集。</p>
<p><strong>定理3.1</strong></p>
<p>对于任何集合<span class="math inline">\(A\)</span>，有<span class="math inline">\(A\subseteq A\)</span></p>
<p><strong>定理4</strong></p>
<p>空集是唯一的。</p>
<h3 id="集合的运算">集合的运算</h3>
<p><strong>集合的交，交集</strong></p>
<p><span class="math display">\[
A\cap B = \{x|x\in A\wedge x\in B\}
\]</span></p>
<p><strong>集合的并，并集</strong></p>
<p><span class="math display">\[
A\cup B = \{x|x\in A\vee x\in B\}
\]</span></p>
<p><strong>集合的差，相对补集</strong></p>
<p><span class="math display">\[
A-B=\{x|x\in A\wedge x\notin B\}
\]</span></p>
<p><strong>集合的补，绝对补集</strong></p>
<p><span class="math display">\[
\bar{A}=U-A=\{x|x\in U\wedge x\notin A\}
\]</span></p>
<p><strong>集合的对称差</strong></p>
<p><span class="math display">\[
A\oplus B=(A-B)\cup(B-A)=\{x|(x\in A\wedge x\notin B)\vee(x\in B\wedge
x\notin A)\}
\]</span></p>
<p><strong>集合的环积</strong></p>
<p><span class="math display">\[
A\otimes B=\overline{A\oplus B}=(A\cap
B)\cup(\bar{A}\cap\bar{B})=\{x|(x\in A\wedge x\in B)\vee(x\notin A\wedge
x\notin B)\}
\]</span></p>
<p>满足如下运算律</p>
<figure>
<img src="3.2.1.jpg" alt="3.2.1"/>
<figcaption aria-hidden="true">3.2.1</figcaption>
</figure>
<p><strong>幂集</strong></p>
<p>给定集合<span class="math inline">\(A\)</span>，由<span class="math inline">\(A\)</span>所有子集为元素构成的集合，称为<span class="math inline">\(A\)</span>的幂集，记作<span class="math inline">\(\rho(A)\)</span>。若<span class="math inline">\(|A|=n\)</span>，则有<span class="math inline">\(|\rho(A)=2^n|\)</span></p>
<h3 id="容斥原理">容斥原理</h3>
<p><strong>定理1</strong></p>
<p>设<span class="math inline">\(A_1,A_2\)</span>是有限集合，其元素个数分别为<span class="math inline">\(|A_1|,|A_2|\)</span>，则<span class="math inline">\(|A_1\cup A_2|=|A_1|+|A_2|-|A_1\cap
A_2|\)</span></p>
<p><strong>容斥原理</strong></p>
<p>将上式推广，得</p>
<p><span class="math display">\[
|A_1\cup A_2\cup\cdots\cup A_n|=\sum_{i=1}^n|A_i|-\sum_{1\leq i&lt;j\leq
n}|A_i\cap A_j|+\\
\sum_{1\leq i&lt;j&lt;k\leq n}|A_i\cap A_j\cap
A_k|-\cdots+(-1)^{n+1}|A_1\cap A_2\cap\cdots\cap A_n|
\]</span></p>
<h3 id="归纳证明">归纳证明</h3>
<h4 id="集合的归纳定义">集合的归纳定义</h4>
<ol type="1">
<li>基础条款：指出某些事物属于<span class="math inline">\(S\)</span>，其功能是给集合<span class="math inline">\(S\)</span>指定初始元素使其不为空。</li>
<li>归纳条款：指出由集合<span class="math inline">\(S\)</span>中的已有元素构造新元素的办法。</li>
<li>极小性条款：断言一个事物除非能有限次应用基础条款和归纳条款构成，否则它不在集合<span class="math inline">\(S\)</span>中。</li>
</ol>
<h4 id="归纳法证明">归纳法证明</h4>
<ol type="1">
<li>基础步骤。对于基础条款中的指定的每个初始元素<span class="math inline">\(t\)</span>，证明命题<span class="math inline">\(P(t)\)</span>为真。</li>
<li>归纳步骤。证明如果事物<span class="math inline">\(x,y,\cdots\)</span>有<span class="math inline">\(P\)</span>性质，那么用归纳条款指定的方法组合它们所得的新元素也具有性质<span class="math inline">\(P\)</span></li>
</ol>
<h4 id="数学归纳法">数学归纳法</h4>
<p><strong>第一原理</strong></p>
<ol type="1">
<li>（归纳基础）证明<span class="math inline">\(P(0)\)</span>为真（可以用任何办法）</li>
<li>（归纳假设）任取<span class="math inline">\(n(n\ge0)\)</span>，假设<span class="math inline">\(P(n)\)</span>为真。</li>
<li>（归纳推理）由<span class="math inline">\(P(n)\)</span>为真，推出<span class="math inline">\(P(n+1)\)</span>也为真。</li>
</ol>
<p><strong>第二原理</strong></p>
<ol type="1">
<li>（归纳基础）证明<span class="math inline">\(P(0)\)</span>为真（可以用任何办法）</li>
<li>（归纳假设）假设对任意的<span class="math inline">\(n&lt;k\)</span>，均有<span class="math inline">\(P(k)\)</span>为真。</li>
<li>（归纳推理）证明<span class="math inline">\(P(n)\)</span>也为真。</li>
</ol>
<h3 id="集合的笛卡尔积">集合的笛卡尔积</h3>
<p><strong>序偶</strong></p>
<p>两个元素<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>组成的具有固定次序的序列称为序偶或二元组，记为<span class="math inline">\(&lt;a,b&gt;\)</span>。对于序偶<span class="math inline">\(&lt;a,b&gt;\)</span>，<span class="math inline">\(a\)</span>称为第<span class="math inline">\(1\)</span>元素，<span class="math inline">\(b\)</span>称为第<span class="math inline">\(2\)</span>元素。</p>
<p><strong>序偶的相等</strong></p>
<p>两个序偶<span class="math inline">\(&lt;a,b&gt;\)</span>和<span class="math inline">\(&lt;c,d&gt;\)</span>相等，记为<span class="math inline">\(&lt;a,b&gt;=&lt;c,d&gt;\)</span>，当且仅当<span class="math inline">\(a=c\)</span>且<span class="math inline">\(b=d\)</span>。</p>
<p><strong>笛卡尔积（叉积）</strong></p>
<p><span class="math display">\[
A\times B=\{&lt;a,b&gt;|a\in A,b\in B\}
\]</span></p>
<p>对于多个集合，有</p>
<p><span class="math display">\[
A_1\times A_2\times\cdots\times A_n=\{&lt;a_1,a_2, \cdots,a_n&gt;|a_i\in
A_i,1\leq i\leq n\}
\]</span></p>
<p>其中<span class="math inline">\(A\times A\times\cdots\times
A\)</span>（<span class="math inline">\(n\)</span>个）可以记作<span class="math inline">\(A^n\)</span></p>
<p>规定<span class="math inline">\(&lt;a_1,a_2,
\cdots,a_n&gt;=&lt;&lt;a_1,a_2,
\cdots,a_{n-1}&gt;,a_n&gt;\)</span>，而不等于<span class="math inline">\(&lt;a_1,&lt;a_2,
\cdots,a_n&gt;&gt;\)</span>等等其他序偶。</p>
<p>关于笛卡尔积有如下定理</p>
<p><strong>定理1</strong></p>
<ol type="1">
<li><span class="math inline">\(A\times(B\cup C)=(A\times B)\cup(A\times
C)\)</span></li>
<li><span class="math inline">\(A\times(B\cap C)=(A\times B)\cap(A\times
C)\)</span></li>
<li><span class="math inline">\((A\cup B)\times C=(A\times
C)\cup(B\times C)\)</span></li>
<li><span class="math inline">\((A\cap B)\times C=(A\times
C)\cap(B\times C)\)</span></li>
</ol>
<p><strong>定理2</strong></p>
<p>如果<span class="math inline">\(A_i(i=1,2,\cdots,n)\)</span>都是有限集合，那么</p>
<p><span class="math display">\[
|A_1\times A_2\times\cdots\times
A_n|=|A_1|\cdot|A_2|\cdot\cdots\cdot|A_n|
\]</span></p>
<h3 id="二元关系">二元关系</h3>
<h4 id="关系的定义">关系的定义</h4>
<p>两个集合<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>的笛卡儿积<span class="math inline">\(A\times B\)</span>的任一子集<span class="math inline">\(R\)</span>,称为集合<span class="math inline">\(A\)</span>到<span class="math inline">\(B\)</span>上的二元关系。二元关系<span class="math inline">\(R\)</span>是由序偶构成的集合，若<span class="math inline">\(&lt;x,y&gt;\in R\)</span>，则称<span class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>有<span class="math inline">\(R\)</span>关系，也记为<span class="math inline">\(xRy\)</span>;否则,<span class="math inline">\(&lt;x,y&gt;\notin R\)</span>，称<span class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>没有<span class="math inline">\(R\)</span>关系，也记为<span class="math inline">\(x\cancel{R}y\)</span>。</p>
<p>设<span class="math inline">\(R\)</span>是集合<span class="math inline">\(A\)</span>到<span class="math inline">\(B\)</span>的二元关系。集合<span class="math inline">\(A\)</span>称为<span class="math inline">\(R\)</span>的前域，集合<span class="math inline">\(B\)</span>称为<span class="math inline">\(R\)</span>的陪域。集合<span class="math inline">\(\{x|(\exist y)(&lt;x,y&gt;\in
R)\}\)</span>称为<span class="math inline">\(R\)</span>的定义域，记为<span class="math inline">\(domR\)</span>。集合<span class="math inline">\(\{y|(\exist x)(&lt;x,y&gt;)\in
R)\}\)</span>称为<span class="math inline">\(R\)</span>的值域，记为<span class="math inline">\(ranR\)</span>。显然, <span class="math inline">\(domR\subseteq A\)</span>和<span class="math inline">\(ranR\subseteq B\)</span>。</p>
<h4 id="关系的表示">关系的表示</h4>
<ol type="1">
<li>关系矩阵</li>
</ol>
<p><span class="math display">\[
r_{ij}=
\left\{\begin{matrix}
1, if&lt;a_i,b_j&gt;\in R\\
0, if&lt;a_i,b_j&gt;\notin R
\end{matrix}\right.
\]</span></p>
<ol start="2" type="1">
<li>关系图</li>
</ol>
<figure>
<img src="3.6.2.jpg" alt="3.6.2"/>
<figcaption aria-hidden="true">3.6.2</figcaption>
</figure>
<h4 id="关系的运算">关系的运算</h4>
<p>所有集合的运算对于二元关系同样适用。</p>
<p><strong>复合运算</strong></p>
<p>设<span class="math inline">\(R\)</span>为集合<span class="math inline">\(A\)</span>到<span class="math inline">\(B\)</span>的二元关系，<span class="math inline">\(S\)</span>为<span class="math inline">\(B\)</span>到<span class="math inline">\(C\)</span>的二元关系，令</p>
<p><span class="math display">\[
R\circ S=\{&lt;a,c&gt;|a\in A\wedge c\in C\wedge(\exist b)(b\in
B\wedge&lt;a,b&gt;\in R\wedge &lt;b,c&gt;\in S)\}
\]</span></p>
<p>称<span class="math inline">\(R\circ S\)</span>为<span class="math inline">\(R\)</span>与<span class="math inline">\(S\)</span>的复合关系。</p>
<p>复合运算可以通过关系的矩阵的运算来实现</p>
<p><span class="math display">\[
\bm{M}_{R\circ S}=\bm{M}_R\odot\bm{M}_S
\]</span></p>
<p>其中<span class="math inline">\(\odot\)</span>是布尔乘法运算，<span class="math inline">\(c_{ij}=\bigvee_{k=1}^{n}(a_{ik}\wedge
b_{kj})\)</span></p>
<p>复合运算有如下定理</p>
<p><strong>定理1</strong></p>
<p><span class="math inline">\((R\circ S)\circ T=R\circ(S\circ
T)\)</span></p>
<p><strong>关系的逆，逆关系</strong></p>
<p><span class="math display">\[
R^{-1}=\{&lt;b,a&gt;|&lt;a,b&gt;\in R\}
\]</span></p>
<p>关系矩阵即为原矩阵的转置</p>
<p>关系图即将箭头反向</p>
<p>有如下定理</p>
<p><strong>定理1</strong></p>
<ol type="1">
<li><span class="math inline">\((R^{-1})^{-1}=R\)</span></li>
<li><span class="math inline">\((R_1\cup R_2)^{-1}=R_1^{-1}\cup
R_2^{-1}\)</span></li>
<li><span class="math inline">\((R_1\cap R_2)^{-1}=R_1^{-1}\cap
R_2^{-1}\)</span></li>
<li><span class="math inline">\((\overline{R})^{-1}=\overline{R^{-1}}\)</span>，其中<span class="math inline">\(\overline{R}=(A\times B)-R\)</span>，<span class="math inline">\(\overline{R^{-1}}=(B\times
A)-R^{-1}\)</span>。</li>
<li><span class="math inline">\((R_1-R_2)^{-1}=R_1^{-1}-R_2^{-1}\)</span></li>
</ol>
<p><strong>定理2</strong></p>
<p><span class="math display">\[
(R\circ S)^{-1}=S^{-1}\circ R^{-1}
\]</span></p>
<h3 id="集合上的二元关系及其特性">集合上的二元关系及其特性</h3>
<h4 id="集合上的二元关系">集合上的二元关系</h4>
<p>集合<span class="math inline">\(A\)</span>与<span class="math inline">\(A\)</span>的笛卡尔积<span class="math inline">\(A\times A\)</span>的子集称为<span class="math inline">\(A\)</span>上的二元关系。</p>
<p><strong>相等关系</strong></p>
<p><span class="math display">\[
I_A=\{&lt;a,a&gt;|a\in A\}
\]</span></p>
<p><strong><span class="math inline">\(R\)</span>的幂次</strong></p>
<p>设<span class="math inline">\(R\)</span>是<span class="math inline">\(A\)</span>上的二元关系，<span class="math inline">\(n\in Z^+\)</span>，称<span class="math inline">\(R\circ R\circ\cdots\circ R\)</span>(n个)为<span class="math inline">\(R\)</span>的<span class="math inline">\(n\)</span>次幂。记为<span class="math inline">\(R^n\)</span></p>
<p>约定<span class="math inline">\(R^0=I_A\)</span></p>
<p>有如下定理</p>
<p><strong>定理1</strong></p>
<ol type="1">
<li><span class="math inline">\(R^m\circ R^n=R^{m+n}\)</span></li>
<li><span class="math inline">\((R^m)^n=R^{mn}\)</span></li>
</ol>
<p><strong>定理2</strong></p>
<p>设存在<span class="math inline">\(i,j\in R\)</span>，使得<span class="math inline">\(R^i=R^j\)</span>，则有</p>
<ol type="1">
<li>对任意<span class="math inline">\(k\ge 0,
R^{i+k}=R^{j+k}\)</span></li>
<li>对任意<span class="math inline">\(k,m\ge 0,
R^{i+md+k}=R^{i+k}\)</span>，其中<span class="math inline">\(d=j-i\)</span></li>
<li>记<span class="math inline">\(S=\{R_0,R^1,\cdots,R^{j-1}\}\)</span>，对于任意<span class="math inline">\(n\in N\)</span>，均有<span class="math inline">\(R^n\in S\)</span></li>
</ol>
<h4 id="二元关系的特性">二元关系的特性</h4>
<ol type="1">
<li>自反性。对于<span class="math inline">\(A\)</span>中的每个元素<span class="math inline">\(a\)</span>，都有<span class="math inline">\(aRa\)</span>，则称<span class="math inline">\(R\)</span>在<span class="math inline">\(A\)</span>上是自反的。</li>
<li>反自反性。对于<span class="math inline">\(A\)</span>中的每个元素<span class="math inline">\(a\)</span>，都有<span class="math inline">\(a\cancel{R}a\)</span>。空集上的空关系即是自反的也是反自反的。</li>
<li>对称性。对于任意<span class="math inline">\(a,b\in
A\)</span>，若有<span class="math inline">\(aRb\)</span>，则必有<span class="math inline">\(bRa\)</span>。</li>
<li>反对称性。对于任意<span class="math inline">\(a,b\in
A\)</span>，若有<span class="math inline">\(aRb\)</span>且<span class="math inline">\(bRa\)</span>，则必有<span class="math inline">\(a=b\)</span>。若关系图上只有零个或多个自回路，则既是对称的，又是反对称的。</li>
<li>传递性。对于任意<span class="math inline">\(a,b,c\in
A\)</span>，若<span class="math inline">\(aRb,bRc\)</span>则必有<span class="math inline">\(aRc\)</span>。</li>
</ol>
<h3 id="关系的闭包运算">关系的闭包运算</h3>
<p>设<span class="math inline">\(R\)</span>是集合<span class="math inline">\(A\)</span>上的二元关系，如果<span class="math inline">\(A\)</span>上另外一个二元关系<span class="math inline">\(R&#39;\)</span>满足： 1. <span class="math inline">\(R&#39;\)</span>是自反的（对称的，传递的） 2. <span class="math inline">\(R&#39;\subseteq R\)</span> 3. 对于<span class="math inline">\(A\)</span>上任何自反的（对称的，传递的）关系<span class="math inline">\(R&#39;&#39;\)</span>，若<span class="math inline">\(R&#39;&#39;\subseteq R\)</span>，有<span class="math inline">\(R&#39;&#39;\subseteq R&#39;\)</span>，则称<span class="math inline">\(R&#39;\)</span>是<span class="math inline">\(R\)</span>的自反（对称，传递）闭包，记为<span class="math inline">\(r(R)(s(R),t(R))\)</span>。</p>
<p>有如下定理</p>
<p><strong>定理1</strong></p>
<ol type="1">
<li><span class="math inline">\(R\)</span>是自反的当且仅当<span class="math inline">\(r(R)=R\)</span></li>
<li><span class="math inline">\(R\)</span>是对称的当且仅当<span class="math inline">\(s(R)=R\)</span></li>
<li><span class="math inline">\(R\)</span>是传递的当且仅当<span class="math inline">\(t(R)=R\)</span></li>
</ol>
<p><strong>定理2</strong></p>
<ol type="1">
<li><span class="math inline">\(r(R)=R\cup I_A\)</span></li>
<li><span class="math inline">\(s(R)=R\cup R^{-1}\)</span></li>
<li><span class="math inline">\(t(R)=\bigcup_{i=1}^{\infty}R^i\)</span></li>
</ol>
<p><strong>定理3</strong></p>
<p>假设<span class="math inline">\(|A|=n\)</span>，那么<span class="math inline">\(t(R)=\bigcup_{i=1}^{n}R^i\)</span></p>
<p><strong>定理4</strong></p>
<ol type="1">
<li>如果<span class="math inline">\(R\)</span>是自反的，那么<span class="math inline">\(s(R),t(R)\)</span>也是自反的。</li>
<li>如果<span class="math inline">\(R\)</span>是对称的，那么<span class="math inline">\(r(R),t(R)\)</span>也是对称的。</li>
<li>如果<span class="math inline">\(R\)</span>是传递的，那么<span class="math inline">\(r(R)\)</span>也是传递的。</li>
</ol>
<p><strong>定理5</strong></p>
<ol type="1">
<li><span class="math inline">\(sr(R)=rs(R)\)</span>，（<span class="math inline">\(sr(R)=s(r(R))\)</span>以下运算顺序相同）。</li>
<li><span class="math inline">\(tr(R)=rt(R)\)</span></li>
<li><span class="math inline">\(ts(R)\subseteq st(R)\)</span></li>
</ol>
<h3 id="等价关系">等价关系</h3>
<h4 id="集合的划分">集合的划分</h4>
<p>给定非空集合<span class="math inline">\(A\)</span>和集合簇<span class="math inline">\(\pi=\{A_1,A_2,\cdots,A_m\}\)</span>，如果</p>
<ol type="1">
<li><span class="math inline">\(A_i\subseteq A\)</span>且<span class="math inline">\(A_i\neq\phi\)</span></li>
<li><span class="math inline">\(A=\bigcup_{i=1}^{m}A_i\)</span></li>
<li><span class="math inline">\(A_i\cap A_j=\phi, i\neq j\)</span></li>
</ol>
<p>那么称<span class="math inline">\(\pi\)</span>是<span class="math inline">\(A\)</span>的一个划分，若<span class="math inline">\(\pi\)</span>满足1.2.则称<span class="math inline">\(\pi\)</span>是<span class="math inline">\(A\)</span>的一个覆盖。</p>
<h4 id="等价关系和等价类">等价关系和等价类</h4>
<p><strong>等价关系</strong></p>
<p><span class="math inline">\(R\)</span>是<span class="math inline">\(A\)</span>上的二元关系，若<span class="math inline">\(R\)</span>是自反的、对称的、传递的，则称<span class="math inline">\(R\)</span>是等价关系。</p>
<p><strong>等价类</strong></p>
<p>设<span class="math inline">\(R\)</span>是非空集合<span class="math inline">\(A\)</span>上的等价关系，对于任意<span class="math inline">\(a\in A\)</span>，称集合<span class="math inline">\([a]_R=\{x|x\in A,xRa\}\)</span>为<span class="math inline">\(a\)</span>关于<span class="math inline">\(R\)</span>的等价类，<span class="math inline">\(a\)</span>称为等价类<span class="math inline">\([a]_R\)</span>的代表元素。如果等价类个数有限，则<span class="math inline">\(R\)</span>的不同等价类的个数叫做<span class="math inline">\(R\)</span>的秩，否则秩是无限的。</p>
<p>有如下定理</p>
<p><strong>定理1</strong></p>
<p>设<span class="math inline">\(R\)</span>是非空集合<span class="math inline">\(A\)</span>上的等价关系，对于<span class="math inline">\(a,b\in A\)</span>有<span class="math inline">\(aRb\)</span>，当且仅当<span class="math inline">\([a]_R=[b]_R\)</span></p>
<p><strong>商集</strong></p>
<p>设<span class="math inline">\(R\)</span>是集合<span class="math inline">\(A\)</span>上的等价关系，由<span class="math inline">\(R\)</span>确定的所有等价类组成的集合，称为集合<span class="math inline">\(A\)</span>上关于<span class="math inline">\(R\)</span>的商集，记为<span class="math inline">\(A/R\)</span></p>
<p><span class="math display">\[
A/R = \{[x]_R|x\in A\}
\]</span></p>
<p>有如下定理</p>
<p><strong>定理1</strong></p>
<ol type="1">
<li>任取<span class="math inline">\(x\in A\)</span>，<span class="math inline">\([x]_R\neq\phi\)</span></li>
<li>任取<span class="math inline">\(x,y\in A\)</span>，要么<span class="math inline">\([x]_R=[y]_R\)</span>，要么<span class="math inline">\([x]_R\cap[y]_R=\phi\)</span></li>
<li><span class="math inline">\(\bigcup_{x\in A}[x]_R=A\)</span></li>
</ol>
<p><strong>定理2</strong></p>
<p>设<span class="math inline">\(\pi\)</span>是非空集合<span class="math inline">\(A\)</span>的一个划分，则<span class="math inline">\(A\)</span>上的二元关系<span class="math inline">\(R=\bigcup_{B\in\pi} B\times B\)</span>是<span class="math inline">\(A\)</span>上的等价关系（称为由划分<span class="math inline">\(\pi\)</span>诱导的<span class="math inline">\(A\)</span>上的等价关系）。</p>
<p><strong>定理3</strong></p>
<p>设<span class="math inline">\(R_1\)</span>和<span class="math inline">\(R_2\)</span>是非空集合<span class="math inline">\(A\)</span>上的等价关系，则<span class="math inline">\(R_1=R_2\Leftrightarrow A/R_1=A/R_2\)</span></p>
<p><strong>定理4</strong></p>
<p>设<span class="math inline">\(R\)</span>是非空集合<span class="math inline">\(A\)</span>上的任意一个等价关系,<span class="math inline">\(\pi\)</span>是<span class="math inline">\(A\)</span>的任意一个划分，那么<span class="math inline">\(R\)</span>诱导出<span class="math inline">\(\pi\)</span>当且仅当<span class="math inline">\(\pi\)</span>诱导出<span class="math inline">\(R\)</span>。即说明等价关系和集合的划分是一一对应的。</p>
<h3 id="序关系">序关系</h3>
<h4 id="偏序集合的概念与表示">偏序集合的概念与表示</h4>
<p><strong>偏序</strong></p>
<p>如果<span class="math inline">\(A\)</span>上的关系<span class="math inline">\(R\)</span>是自反的，反对称的和传递的，那么<span class="math inline">\(R\)</span>是<span class="math inline">\(A\)</span>上的偏序，通常用符号<span class="math inline">\(\preceq\)</span>表示，称序偶<span class="math inline">\(&lt;A,\preceq&gt;\)</span>为偏序集合。通常用<span class="math inline">\(x\prec y\)</span>表示<span class="math inline">\(x\preceq y\)</span>且<span class="math inline">\(x\neq y\)</span></p>
<p><strong>可比与不可比</strong></p>
<p>在偏序集合<span class="math inline">\(&lt;A,\preceq&gt;\)</span>中，对于元素<span class="math inline">\(a,b\in A\)</span>，如果<span class="math inline">\(a\preceq b\)</span>或者<span class="math inline">\(b\preceq a\)</span>，那么称<span class="math inline">\(a\)</span>或<span class="math inline">\(b\)</span>是可比的，否则不可比的。</p>
<p><strong>盖住</strong></p>
<p>在偏序集合<span class="math inline">\(&lt;A,\preceq&gt;\)</span>中，对于<span class="math inline">\(x,y\in A\)</span>，如果<span class="math inline">\(x\prec y\)</span>且没有其他元素<span class="math inline">\(z\in A\)</span>满足<span class="math inline">\(x\prec z\prec y\)</span>，则称<span class="math inline">\(y\)</span>盖住<span class="math inline">\(x\)</span></p>
<p><strong>哈斯图</strong></p>
<figure>
<img src="3.10.1.jpg" alt="3.10.1"/>
<figcaption aria-hidden="true">3.10.1</figcaption>
</figure>
<p><strong>链</strong></p>
<p>设<span class="math inline">\(&lt;A,\preceq&gt;\)</span>是一个偏序集合，<span class="math inline">\(B\subseteq A\)</span>。如果<span class="math inline">\(B\)</span>中的任意两个元素都是可比的，那么称<span class="math inline">\(B\)</span>为<span class="math inline">\(&lt;A，\preceq&gt;\)</span>中的链，<span class="math inline">\(B\)</span>中元素的个数称为该链的长度。如果<span class="math inline">\(B\)</span>中的任意两个不同的元素都是不可比的，那么称<span class="math inline">\(B\)</span>为<span class="math inline">\(&lt;A，\preceq&gt;\)</span>中的反链。</p>
<h4 id="偏序集合中的特殊元素">偏序集合中的特殊元素</h4>
<p><strong>极大元</strong></p>
<p>设<span class="math inline">\(&lt;A，\preceq&gt;\)</span>是偏序集合，且<span class="math inline">\(B\subseteq A\)</span>。如果<span class="math inline">\(b\in B\)</span>，且<span class="math inline">\(B\)</span>中不存在元素<span class="math inline">\(x\)</span>，使得<span class="math inline">\(x\neq
b\)</span>且<span class="math inline">\(b\preceq x\)</span>，那么<span class="math inline">\(b\)</span>称为<span class="math inline">\(B\)</span>的极大元。</p>
<p><strong>极小元</strong></p>
<p>设<span class="math inline">\(&lt;A，\preceq&gt;\)</span>是偏序集合，且<span class="math inline">\(B\subseteq A\)</span>。如果<span class="math inline">\(b\in B\)</span>，且<span class="math inline">\(B\)</span>中不存在元素<span class="math inline">\(x\)</span>，使得<span class="math inline">\(x\neq
b\)</span>且<span class="math inline">\(x\preceq b\)</span>，那么<span class="math inline">\(b\)</span>称为<span class="math inline">\(B\)</span>的极小元。</p>
<p><strong>最大元</strong></p>
<p>设<span class="math inline">\(&lt;A，\preceq&gt;\)</span>是偏序集合，且<span class="math inline">\(B\subseteq A\)</span>。如果<span class="math inline">\(b\in B\)</span>，对于任意元素<span class="math inline">\(x\in B\)</span>，均有<span class="math inline">\(x\preceq b\)</span>，那么<span class="math inline">\(b\)</span>称为<span class="math inline">\(B\)</span>的最大元。</p>
<p><strong>最小元</strong></p>
<p>设<span class="math inline">\(&lt;A，\preceq&gt;\)</span>是偏序集合，且<span class="math inline">\(B\subseteq A\)</span>。如果<span class="math inline">\(b\in B\)</span>，对于任意元素<span class="math inline">\(x\in B\)</span>，均有<span class="math inline">\(b\preceq x\)</span>，那么<span class="math inline">\(b\)</span>称为<span class="math inline">\(B\)</span>的最小元。</p>
<p>有如下定理</p>
<p><strong>定理1</strong></p>
<p>设<span class="math inline">\(&lt;A，\preceq&gt;\)</span>是偏序集合，且<span class="math inline">\(B\subseteq A\)</span>。如果<span class="math inline">\(B\)</span>有最大（最小元），那么它是唯一的。</p>
<p><strong>上界</strong></p>
<p>设<span class="math inline">\(&lt;A，\preceq&gt;\)</span>是偏序集合，且<span class="math inline">\(B\subseteq A\)</span>。如果<span class="math inline">\(a\in A\)</span>，对于任意元素<span class="math inline">\(b\in B\)</span>，均有<span class="math inline">\(b\preceq a\)</span>，那么<span class="math inline">\(a\)</span>称为<span class="math inline">\(B\)</span>的上界。</p>
<p><strong>下界</strong></p>
<p>设<span class="math inline">\(&lt;A，\preceq&gt;\)</span>是偏序集合，且<span class="math inline">\(B\subseteq A\)</span>。如果<span class="math inline">\(a\in A\)</span>，对于任意元素<span class="math inline">\(b\in B\)</span>，均有<span class="math inline">\(a\preceq b\)</span>，那么<span class="math inline">\(a\)</span>称为<span class="math inline">\(B\)</span>的下界。</p>
<p><strong>最小上界（上确界）</strong></p>
<p>设<span class="math inline">\(&lt;A，\preceq&gt;\)</span>是偏序集合，且<span class="math inline">\(B\subseteq A\)</span>。<span class="math inline">\(a\)</span>为<span class="math inline">\(B\)</span>的上界，若对<span class="math inline">\(B\)</span>的任意上界<span class="math inline">\(a&#39;\)</span>均有<span class="math inline">\(a\preceq a&#39;\)</span>，则称<span class="math inline">\(a\)</span>为<span class="math inline">\(B\)</span>的最小上界或上确界。</p>
<p><strong>最大下界（下确界）</strong></p>
<p>设<span class="math inline">\(&lt;A，\preceq&gt;\)</span>是偏序集合，且<span class="math inline">\(B\subseteq A\)</span>。<span class="math inline">\(a\)</span>为<span class="math inline">\(B\)</span>的下界，若对<span class="math inline">\(B\)</span>的任意下界<span class="math inline">\(a&#39;\)</span>均有<span class="math inline">\(a&#39;\preceq a\)</span>，则称<span class="math inline">\(a\)</span>为<span class="math inline">\(B\)</span>的最大下界或下确界。</p>
<p>有如下定理</p>
<p><strong>定理1</strong></p>
<p>若<span class="math inline">\(B\)</span>有最小上界（最大下界），那么它是唯一的。</p>
<p><strong>定理2</strong></p>
<p>设<span class="math inline">\(&lt;A，\preceq&gt;\)</span>是偏序集合，且<span class="math inline">\(B\subseteq A\)</span>。</p>
<ol type="1">
<li>若<span class="math inline">\(b\)</span>是<span class="math inline">\(B\)</span>的最大元，则<span class="math inline">\(b\)</span>是<span class="math inline">\(B\)</span>的极大元。</li>
<li>若<span class="math inline">\(b\)</span>是<span class="math inline">\(B\)</span>的最大元，则<span class="math inline">\(b\)</span>是<span class="math inline">\(B\)</span>的最小上界。</li>
<li><span class="math inline">\(b\in B\)</span>，若<span class="math inline">\(b\)</span>是<span class="math inline">\(B\)</span>的上界，当且仅当<span class="math inline">\(b\)</span>是<span class="math inline">\(B\)</span>的最小上界。</li>
<li>若<span class="math inline">\(b\)</span>是<span class="math inline">\(B\)</span>的最小元，则<span class="math inline">\(b\)</span>是<span class="math inline">\(B\)</span>的极小元。</li>
<li>若<span class="math inline">\(b\)</span>是<span class="math inline">\(B\)</span>的最小元，则<span class="math inline">\(b\)</span>是<span class="math inline">\(B\)</span>的最大下界。</li>
<li><span class="math inline">\(b\in B\)</span>，若<span class="math inline">\(b\)</span>是<span class="math inline">\(B\)</span>的下界，当且仅当<span class="math inline">\(b\)</span>是<span class="math inline">\(B\)</span>的最大下界。</li>
</ol>
<p><strong>定理3</strong></p>
<p>设<span class="math inline">\(&lt;A，\preceq&gt;\)</span>是非空有限偏序集，则<span class="math inline">\(A\)</span>中必存在极大元和极小元。</p>
<p><strong>定理4</strong></p>
<p>设<span class="math inline">\(&lt;A，\preceq&gt;\)</span>是偏序集合，如果<span class="math inline">\(A\)</span>中最长链的长度为<span class="math inline">\(n\)</span>，则<span class="math inline">\(A\)</span>中元素能划分为<span class="math inline">\(n\)</span>个互不相交的反链。</p>
<h4 id="线序和良序">线序和良序</h4>
<p>设<span class="math inline">\(&lt;A，\preceq&gt;\)</span>是偏序集合，如果任取<span class="math inline">\(a,b\in A\)</span>，都有<span class="math inline">\(a\preceq b\)</span>或者<span class="math inline">\(b\preceq a\)</span>，那么称<span class="math inline">\(\preceq\)</span>为<span class="math inline">\(A\)</span>上的线序或全序。称<span class="math inline">\(&lt;A，\preceq&gt;\)</span>为线序集合，称<span class="math inline">\(A\)</span>为链。</p>
<p>如果<span class="math inline">\(A\)</span>上的一个二元关系<span class="math inline">\(R\)</span>是一个线序，且<span class="math inline">\(A\)</span>的每一非空子集都有最小元，那么称<span class="math inline">\(R\)</span>为<span class="math inline">\(A\)</span>上的良序，称<span class="math inline">\(&lt;A,R&gt;\)</span>为良序集合。</p>
<p>有如下定理</p>
<p><strong>定理</strong></p>
<p>每一有限线序集合都是良序集合。</p>
<h2 id="函数与无限集合">函数与无限集合</h2>
<h3 id="函数的定义">函数的定义</h3>
<p>注意对于每个<span class="math inline">\(x\in
A\)</span>，都只和唯一一个<span class="math inline">\(y\in
Y\)</span>有<span class="math inline">\(f\)</span>关系。<span class="math inline">\(y\)</span>是<span class="math inline">\(x\)</span>的函数值或像，<span class="math inline">\(x\)</span>是<span class="math inline">\(y\)</span>的原像。</p>
<p>定义域必须是整个前域，值域可以不是整个陪域。一般<span class="math inline">\(X,Y\)</span>指的是前域和陪域。</p>
<p><strong>函数相等</strong></p>
<p><span class="math inline">\(f:A\to B\)</span>, <span class="math inline">\(g:C\to D\)</span>，如果<span class="math inline">\(A=C,B=D\)</span>，且对于所有的<span class="math inline">\(x\in A\)</span>有<span class="math inline">\(f(x)=g(x)\)</span>，则称<span class="math inline">\(f,g\)</span>相等，记作<span class="math inline">\(f=g\)</span></p>
<p><strong>多元函数</strong></p>
<p>前域是<span class="math inline">\(n\)</span>个集合的笛卡尔积，称为<span class="math inline">\(n\)</span>元函数，像记作<span class="math inline">\(f(x_1,x_2,\cdots,x_n)\)</span></p>
<h4 id="递归定义的函数">递归定义的函数</h4>
<p>前域是归纳定义的集合时，可以采用递归定义方法来定义函数。规则是：用已经得到的元素函数值和给定的函数来计算新元素的函数值。</p>
<h3 id="特殊函数">特殊函数</h3>
<p><strong>单射</strong></p>
<p>任取<span class="math inline">\(x_1,x_2\in X\)</span>，如果<span class="math inline">\(x_1\neq x_2\)</span>，那么<span class="math inline">\(f(x_1)\neq f(x_2)\)</span>，则称<span class="math inline">\(f\)</span>为单射函数，也称一对一函数。</p>
<p><strong>满射</strong></p>
<p>若任取<span class="math inline">\(y\in Y\)</span>，存在<span class="math inline">\(x\in X\)</span>，使得<span class="math inline">\(f(x)=y\)</span>，则称为满射函数。</p>
<p><strong>双射</strong></p>
<p>既是单射又是满射，称为双射函数。也称一一对应函数。</p>
<p>有如下定理</p>
<p><strong>定理1</strong></p>
<p>设<span class="math inline">\(X,Y\)</span>是有限集合，<span class="math inline">\(f:X\to Y\)</span></p>
<ol type="1">
<li>若<span class="math inline">\(f\)</span>是单射，则必有<span class="math inline">\(|X|\leq|Y|\)</span></li>
<li>若<span class="math inline">\(f\)</span>是满射，则必有<span class="math inline">\(|X|\ge|Y|\)</span></li>
<li>若<span class="math inline">\(f\)</span>是双射，则必有<span class="math inline">\(|X|=|Y|\)</span></li>
</ol>
<p><strong>定理2</strong></p>
<p>设<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>是有限集合，<span class="math inline">\(f\)</span>是从集合<span class="math inline">\(X\)</span>到<span class="math inline">\(Y\)</span>的函数。若<span class="math inline">\(|X|=|Y|\)</span>，则<span class="math inline">\(f\)</span>是单射，当且仅当<span class="math inline">\(f\)</span>是满射。</p>
<p><strong>常数函数</strong></p>
<p>存在<span class="math inline">\(c\in Y\)</span>，对任意<span class="math inline">\(x\in X\)</span>,<span class="math inline">\(f(x)=c\)</span></p>
<p><strong>恒等函数</strong></p>
<p><span class="math inline">\(f(x)=x\)</span></p>
<p><strong>置换（排列）</strong></p>
<p>对于函数<span class="math inline">\(f:X\to X\)</span>，若<span class="math inline">\(f\)</span>是双射的，则称<span class="math inline">\(f\)</span>为<span class="math inline">\(X\)</span>上的置换或排列。<span class="math inline">\(X\)</span>上的恒等函数称为恒等置换或者幺置换。<span class="math inline">\(|X|=n\)</span>时称为<span class="math inline">\(n\)</span>次置换，<span class="math inline">\(|X|\)</span>无限时称为无限次置换。</p>
<p>通常写成</p>
<p><span class="math display">\[
P=
\begin{pmatrix}
x_1 &amp; x_2 &amp; \cdots &amp; x_n\\
f(x_1) &amp; f(x_2) &amp; \cdots &amp; f(x_n)  
\end{pmatrix}
\]</span></p>
<h3 id="复合函数和逆函数">复合函数和逆函数</h3>
<p>类似于关系的复合运算</p>
<p>但是注意书写顺序。<span class="math inline">\(g\diamond
f\)</span>和<span class="math inline">\(f\circ
g\)</span>的顺序正好相反</p>
<p><strong>定理1</strong></p>
<p><span class="math inline">\(f:X\to Y,g:Y\to Z\)</span>，那么<span class="math inline">\(g\diamond f\)</span>是<span class="math inline">\(X\)</span>到<span class="math inline">\(Z\)</span>的函数。</p>
<p><strong>定理2</strong></p>
<p><span class="math inline">\(h\diamond(g\diamond f)=(h\diamond
g)\diamond f\)</span></p>
<ol type="1">
<li><span class="math inline">\(f^0=I_x\)</span></li>
<li><span class="math inline">\(f^{n+1}=f\diamond f^n\)</span></li>
</ol>
<p><strong>定理3</strong></p>
<p><span class="math inline">\(f:X\to Y,g:Y\to Z\)</span></p>
<ol type="1">
<li>若<span class="math inline">\(f,g\)</span>满射，则<span class="math inline">\(g\diamond f\)</span>满射。</li>
<li>若<span class="math inline">\(f,g\)</span>单射，则<span class="math inline">\(g\diamond f\)</span>单射。</li>
<li>若<span class="math inline">\(f,g\)</span>双射，则<span class="math inline">\(g\diamond f\)</span>双射。</li>
<li>若<span class="math inline">\(g\diamond f\)</span>满射，则<span class="math inline">\(g\)</span>满射</li>
<li>若<span class="math inline">\(g\diamond f\)</span>单射，则<span class="math inline">\(f\)</span>单射</li>
<li>若<span class="math inline">\(g\diamond f\)</span>双射，则<span class="math inline">\(g\)</span>满射，<span class="math inline">\(f\)</span>单射。</li>
</ol>
<h4 id="逆函数">逆函数</h4>
<p>设<span class="math inline">\(f\)</span>是双射函数，则<span class="math inline">\(f^{-1}=\{&lt;y,x&gt;|&lt;x,y&gt;\in
f\}\)</span>。显然逆函数也是双射函数。</p>
<p><strong>定理1</strong></p>
<ol type="1">
<li><span class="math inline">\((f^{-1})^{-1}=f\)</span></li>
<li><span class="math inline">\(f^{-1}\diamond f=I_X\)</span></li>
<li><span class="math inline">\(f\diamond f^{-1}=I_X\)</span></li>
</ol>
<p><strong>定理2</strong></p>
<p><span class="math inline">\((g\diamond f)^{-1}=f^{-1}\diamond
g^{-1}\)</span></p>
<h3 id="可数与不可数集合">可数与不可数集合</h3>
<h4 id="集合的基数">集合的基数</h4>
<p><strong>基数</strong></p>
<p>度量<span class="math inline">\(A\)</span>大小的数称为基数或势，记为<span class="math inline">\(|A|\)</span>。</p>
<p><strong>等势</strong></p>
<p>若<span class="math inline">\(A\)</span>到<span class="math inline">\(B\)</span>能建立起双射函数，则称<span class="math inline">\(A,B\)</span>等势，记为<span class="math inline">\(A\sim B\)</span>，或<span class="math inline">\(|A|=|B|\)</span></p>
<p><strong>定理1</strong></p>
<p>等势是任何集合簇上的等价关系。即是自反的、对称的、传递的。</p>
<p><strong>有限集合、无限集合</strong></p>
<p>含有有限个（包含0）元素的集合称为有限集合，不是有限集合的称为无限集合。</p>
<p><strong>定理1</strong></p>
<p>有限集合的任意子集是有限集合。无限集合的超集是无限集合。</p>
<p><strong>定理2</strong></p>
<p>无限集合存在与其等势的真子集。</p>
<h4 id="可数集">可数集</h4>
<p>与自然数集<span class="math inline">\(N\)</span>等势的集合称为可数无限集合，简称可数集。可数集的基数用<span class="math inline">\(\alef_0\)</span>表示。</p>
<p>有限集和可数集通称为至多可数集。</p>
<p><strong>枚举</strong></p>
<p>设<span class="math inline">\(A\)</span>是一个集合，如果<span class="math inline">\(f\)</span>是从<span class="math inline">\(N\)</span>或从<span class="math inline">\(N_k=\{0,1,2,\cdots,k-1\}\)</span>到<span class="math inline">\(A\)</span>的一个满射函数，则称<span class="math inline">\(f\)</span>为<span class="math inline">\(A\)</span>的一个枚举。如果<span class="math inline">\(f\)</span>是双射的，则称为无重复枚举，否则称为重复枚举。</p>
<p><strong>定理1</strong></p>
<p>一个无限集合<span class="math inline">\(A\)</span>是可数集，当且仅当存在<span class="math inline">\(A\)</span>的枚举。</p>
<p><strong>定理2</strong></p>
<p>可数无限集的任一无限子集是可数集。</p>
<p><strong>定理3</strong></p>
<p>任意两个可数集的并是可数集。</p>
<p><strong>定理4</strong></p>
<p><span class="math inline">\(N\times N\)</span>是可数集。</p>
<p><strong>定理5</strong></p>
<p>可数个可数集的并是可数集。</p>
<h4 id="不可数集">不可数集</h4>
<p>与自然数集不等势的无限集称为不可数集</p>
<p><strong>定理1</strong></p>
<p>实数集的子集<span class="math inline">\((0,1)\)</span>是不可数集</p>
<h3 id="基数的比较">基数的比较</h3>
<p><strong>Zemelo三歧性定理</strong></p>
<p>以下三条恰有一条成立</p>
<ol type="1">
<li>|A|&lt;|B|</li>
<li>|A|&gt;|B|</li>
<li>|A|=|B|</li>
</ol>
<p><strong>Cantor-Schroder-Bernstein定理</strong></p>
<p><span class="math inline">\(|A|\leq|B|\)</span>且<span class="math inline">\(|A|\ge|B|\)</span>，则<span class="math inline">\(|A|=|B|\)</span></p>
<p><strong>定理3</strong></p>
<p>设<span class="math inline">\(A\)</span>是任意有限集合，则<span class="math inline">\(|A|&lt;\alef_0&lt;\alef\)</span></p>
<p><strong>定理4</strong></p>
<p>任意无限集合必定存在可数无限子集</p>
<p><strong>定理5</strong></p>
<p><span class="math inline">\(\alef_0\)</span>是最小的无限集基数</p>
<p><strong>Cantor定理</strong></p>
<p><span class="math inline">\(|M|&lt;|\rho (M)|\)</span></p>
<h2 id="图论">图论</h2>
<h3 id="图的基本概念">图的基本概念</h3>
<p>按边是否有方向，图可以分为有向图、无向图和混合图。</p>
<p>设<span class="math inline">\(G\)</span>是一个有向图，如果将<span class="math inline">\(G\)</span>中的每条边的方向去掉就能得到一个无向图<span class="math inline">\(G&#39;\)</span>，则称<span class="math inline">\(G&#39;\)</span>为<span class="math inline">\(G\)</span>的底图。</p>
<p><strong>邻接点</strong></p>
<p>关联于同一条边的两个结点被称为邻接点。</p>
<p><strong>邻接边</strong></p>
<p>关联于一个结点的两条边被称为邻接边。</p>
<p><strong>孤立结点</strong></p>
<p>不与任何结点邻接的结点称之为孤立节点</p>
<p><strong>零图</strong></p>
<p>仅由若干个孤立节点构成的图称为零图。</p>
<p><strong>平凡图</strong></p>
<p>仅由单个孤立节点组成的图称为平凡图。</p>
<p><strong>平行边</strong></p>
<p><span class="math inline">\(e_1=e_2=\{u,v\}\)</span>，若<span class="math inline">\(e_1,e_2\)</span>是两条不同的边，则称<span class="math inline">\(e_1,e_2\)</span>为平行边。</p>
<p><strong>自回路（环）</strong></p>
<p><span class="math inline">\(e=\{u,u\}\)</span></p>
<p><strong>多重图</strong></p>
<p>有平行边的图。</p>
<p><strong>线图</strong></p>
<p>不含平行边的图。</p>
<p><strong>简单图</strong></p>
<p>不含自回路的图。</p>
<h4 id="结点的度数">结点的度数</h4>
<p>与结点<span class="math inline">\(v\)</span>关联的边数称为结点<span class="math inline">\(v\)</span>的度数（无向图），记为<span class="math inline">\(deg(v)\)</span>。</p>
<p>如果是有向图，则以结点<span class="math inline">\(v\)</span>为终点的边数称为入度<span class="math inline">\(deg^-(v)\)</span>，为始点的边数称为出度<span class="math inline">\(deg^+(v)\)</span>。显然有<span class="math inline">\(deg(v)=deg^-(v)+deg^+(v)\)</span></p>
<p>有如下定理</p>
<p><strong>握手定理</strong></p>
<p>任何图中，所有节点的度数之和等于边数的两倍。</p>
<p><strong>定理2</strong></p>
<p>任何图中，奇数度的节点必有偶数个。</p>
<p><strong>定理3</strong></p>
<p>任何有向图中，所有节点的入度等于所有节点的出度。</p>
<h4 id="特殊图">特殊图</h4>
<p><strong>无向完全图</strong></p>
<p>无向简单图中，任何两个不同结点间都恰有一条边相连。<span class="math inline">\(n\)</span>个结点的无向完全图记为<span class="math inline">\(K^n\)</span>。</p>
<p><strong>有向完全图</strong></p>
<p>有向图<span class="math inline">\(G=&lt;V,E&gt;\)</span>满足<span class="math inline">\(E=V\times V\)</span>。记为<span class="math inline">\(D_n\)</span>。</p>
<p><strong>二部图</strong></p>
<p>非零图，节点集合<span class="math inline">\(V\)</span>可以划分成两个不相交的子集<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>，使<span class="math inline">\(G\)</span>中的每一条边的一个端点在<span class="math inline">\(X\)</span>中而另一个端点在<span class="math inline">\(Y\)</span>中，则称<span class="math inline">\(G\)</span>为二部图，记为<span class="math inline">\(G=&lt;X,E,Y&gt;\)</span></p>
<p>可以通过标号法确定一个图是不是二部图。</p>
<p>二部图必无自回路，但可以有平行边。</p>
<h4 id="子图与补图">子图与补图</h4>
<p><strong>子图</strong></p>
<p>设<span class="math inline">\(G=&lt;V,E&gt;\)</span>，<span class="math inline">\(G&#39;=&lt;V&#39;,E&#39;&gt;\)</span>，若有<span class="math inline">\(E&#39;\subseteq E\)</span>且<span class="math inline">\(V&#39;\subseteq V\)</span>，则称<span class="math inline">\(G&#39;\)</span>是<span class="math inline">\(G\)</span>的子图。</p>
<p><strong>生成子图</strong></p>
<p><span class="math inline">\(V&#39;=V\)</span>时，<span class="math inline">\(G&#39;\)</span>是<span class="math inline">\(G\)</span>的生成子图。</p>
<p><strong>导出子图</strong></p>
<p>设<span class="math inline">\(G&#39;\)</span>是<span class="math inline">\(G\)</span>的子图，<span class="math inline">\(V&#39;\)</span>仅由<span class="math inline">\(E&#39;\)</span>中边相关联的结点组成，则称<span class="math inline">\(G&#39;\)</span>为由边集<span class="math inline">\(E&#39;\)</span>导出的子图。</p>
<p><strong>补图</strong></p>
<p>给定一个图<span class="math inline">\(G\)</span>，由<span class="math inline">\(G\)</span>中所有的结点及所有能使<span class="math inline">\(G\)</span>成为完全图的添加边组成的图，称为<span class="math inline">\(G\)</span>相对于完全图的补图，简称为<span class="math inline">\(G\)</span>的补图，记为<span class="math inline">\(\bar{G}\)</span>。</p>
<h4 id="图的同构">图的同构</h4>
<p>设<span class="math inline">\(G=&lt;V,E&gt;,G&#39;=&lt;V&#39;,E&#39;&gt;\)</span>，如果存在双射函数<span class="math inline">\(f:V\to V&#39;,g:E\to
E&#39;\)</span>，对于任何<span class="math inline">\(e\in E,e=[v_i,
v_j]\)</span>当且仅当<span class="math inline">\(g(e)=[f(v_i),f(v_j)]\)</span>。则称<span class="math inline">\(G,G&#39;\)</span>同构，记作<span class="math inline">\(G\cong G&#39;\)</span>。</p>
<p>相互同构的图只是画法不同或者结点与边的命名不同而已。</p>
<p>两幅图同构的必要条件</p>
<ol type="1">
<li>结点数相同</li>
<li>边数相同</li>
<li>度数相同的结点数目相同</li>
</ol>
<h3 id="图的连通性">图的连通性</h3>
<h4 id="路和回路">路和回路</h4>
<p><strong>通路</strong></p>
<p>经过的结点不重复的路。</p>
<p><strong>迹</strong></p>
<p>经过的边不重复的路。回路为闭迹，非回路为开迹。</p>
<p><strong>圈</strong></p>
<p>除始点和终点外没有相同结点的闭迹称为圈。长度为<span class="math inline">\(k\)</span>的圈称为<span class="math inline">\(k\)</span>圈，又可根据<span class="math inline">\(k\)</span>分为奇圈和偶圈。</p>
<p><strong>定理1</strong></p>
<p>在一个具有<span class="math inline">\(n\)</span>个节点的图中，如果两个结点连通，则两个结点间必有一条长度小于<span class="math inline">\(n\)</span>的路（也存在小于<span class="math inline">\(n\)</span>的通路）。</p>
<p><strong>定理2</strong></p>
<p>在一个具有<span class="math inline">\(n\)</span>个节点的图中，如果存在闭迹，则必存在一条长度小于等于<span class="math inline">\(n\)</span>的圈。</p>
<p><strong>定理3</strong></p>
<p>设<span class="math inline">\(G\)</span>是一个无向图，若<span class="math inline">\(G\)</span>中每个结点的度数大于等于<span class="math inline">\(2\)</span>，<span class="math inline">\(G\)</span>中必含有圈。</p>
<p><strong>定理4</strong></p>
<p><span class="math inline">\(G=&lt;V,E&gt;\)</span>是无向图，<span class="math inline">\(|E|&gt;0\)</span>，<span class="math inline">\(G\)</span>是二部图当且仅当<span class="math inline">\(G\)</span>中不含有奇圈。</p>
<h4 id="无向图的连通性">无向图的连通性</h4>
<p><strong>割点与割点集</strong></p>
<p>删除某个结点和其相连边后，图变成不连通的，则称为割点。删除某个点集中的所有点和所连接边，图变成不连通的，并且删除该点集的任意真子集图仍然连通，则称这个点集为割点集。</p>
<p><strong>k连通</strong></p>
<p>由<span class="math inline">\(G\)</span>产生一个不连通子图最少需要删去<span class="math inline">\(k\)</span>个结点。则称<span class="math inline">\(G\)</span>为<span class="math inline">\(k\)</span>连通图。</p>
<p><strong>定理1</strong></p>
<p>无向图中，一个结点是割点，当且仅当存在两个结点间的每条路都要通过该节点。</p>
<p><strong>割边与割边集</strong></p>
<p>与割点相似。</p>
<p><strong>k边连通</strong></p>
<p>与<span class="math inline">\(k\)</span>连通相似。</p>
<p><strong>定理1</strong></p>
<p>无向图中，一条边是割边，当且仅当它不包含在任一圈中。</p>
<h4 id="有向图的连通性">有向图的连通性</h4>
<p><strong>强连通，单侧连通，弱连通</strong></p>
<p>强连通则是两个结点双向可达。单侧连通则是单向可达。若联通则是看成无向图。</p>
<p><strong>定理1</strong></p>
<p>有向图是强连通的，当且仅当它存在一条回路，至少包含每个结点一次。</p>
<h4 id="最短路">最短路</h4>
<p>见算法竞赛模板。</p>
<h3 id="图的矩阵表示">图的矩阵表示</h3>
<h4 id="邻接矩阵">邻接矩阵</h4>
<p><strong><span class="math inline">\(AA^T\)</span></strong></p>
<p><span class="math inline">\(G\)</span>中刚好有<span class="math inline">\(b_{ij}\)</span>个结点，从<span class="math inline">\(v_i\)</span>和<span class="math inline">\(v_j\)</span>均有边引出到这些节点。</p>
<p><strong><span class="math inline">\(A^TA\)</span></strong></p>
<p><span class="math inline">\(G\)</span>中刚好有<span class="math inline">\(b_{ij}\)</span>个结点，以这些节点为始边，既有边到<span class="math inline">\(v_i\)</span>又有边到<span class="math inline">\(v_j\)</span>。</p>
<p><strong><span class="math inline">\(A\times A\)</span></strong></p>
<p>从<span class="math inline">\(v_i\)</span>到<span class="math inline">\(v_j\)</span>的路，长度为2的有<span class="math inline">\(b_{ij}\)</span>条。</p>
<p>同理可知<span class="math inline">\(A^{(m)}\)</span>的含义。</p>
<h4 id="可达矩阵">可达矩阵</h4>
<p><span class="math inline">\(P(G)=A^{(0)}\vee A^{(1)}\vee\cdots\vee
A^{(n-1)}\)</span></p>
<p><strong>定理</strong></p>
<ol type="1">
<li>无向图是连通图，当且仅当可达矩阵所有元素都为1.</li>
<li>有向图是强连通图，当且仅当可达矩阵所有元素都为1.</li>
<li>有向图是单侧连通图，当且仅当<span class="math inline">\(P\vee
P^T\)</span>所有元素都为1.</li>
<li>有向图是弱连通图，当且仅当以<span class="math inline">\(A\vee
A^T\)</span>作为邻接矩阵求出来的可达矩阵<span class="math inline">\(P&#39;\)</span>所有元素都为1.</li>
</ol>
<h4 id="求传递闭包的快速算法">求传递闭包的快速算法</h4>
<p>设<span class="math inline">\(R\)</span>是集合<span class="math inline">\(V\)</span>上的二元关系，<span class="math inline">\(n\in \bm{Z}^+\)</span>，对于任意<span class="math inline">\(a,b\in V,&lt;a,b&gt;\in
R^n\)</span>，当且仅当<span class="math inline">\(R\)</span>的关系图<span class="math inline">\(G=&lt;V,E&gt;\)</span>中存在从<span class="math inline">\(a\)</span>到<span class="math inline">\(b\)</span>有长度为<span class="math inline">\(n\)</span>的有向路。</p>
<p>设<span class="math inline">\(\bm{M}_R\)</span>是<span class="math inline">\(V\)</span>上二元关系<span class="math inline">\(R\)</span>的关系矩阵，则</p>
<p><span class="math display">\[
\bm{M}_{t(R)}=\bm{M}_R\vee\bm{M}_R^{(2)}\vee\cdots\vee\bm{M}_R^{(n)}
\]</span></p>
<h3 id="欧拉图与汉密尔顿图">欧拉图与汉密尔顿图</h3>
<h4 id="欧拉图">欧拉图</h4>
<p><strong>欧拉路（欧拉迹）</strong></p>
<p>包含图中所有边的开迹。</p>
<p><strong>欧拉回路</strong></p>
<p>包含图中所有边的闭迹。</p>
<p><strong>欧拉图</strong></p>
<p>包含欧拉回路的图称为欧拉图。</p>
<p><strong>定理1</strong></p>
<p>无向图是欧拉图当且仅当图是连通的并且每个结点的度均为偶数。</p>
<p>无向图中存在一条欧拉路，当且仅当图是联通的，并且图中恰有两个奇数度的点。并且这两个点是起点和终点。</p>
<p><strong>定理2</strong></p>
<p>有向图是欧拉图，当且仅当它是联通的，并且每个结点的出度等于入度。</p>
<p>有向图有欧拉路，当且仅当它是联通的，并且除了两个结点以外都出度等于入度，这两个结点必须一个出度比入度大一，另一个入度比出度大一。</p>
<h4 id="汉密尔顿图">汉密尔顿图</h4>
<p>包含图中每个结点一次且仅一次的通路称为汉密尔顿路。包含图中每个结点一次且仅一次的圈叫汉密尔顿回路。含汉密尔顿回路的图叫做汉密尔顿图。</p>
<p><strong>定理1（必要条件）</strong></p>
<p>若<span class="math inline">\(G\)</span>是汉密尔顿图，则对于结点集<span class="math inline">\(V\)</span>的每一个非空子集<span class="math inline">\(S\)</span>都有</p>
<p><span class="math display">\[
\omega(G-S)\leq|S|
\]</span></p>
<p>其中<span class="math inline">\(\omega(G-S)\)</span>表示<span class="math inline">\(G\)</span>删除<span class="math inline">\(S\)</span>中所有结点后得到的连通分支的个数。</p>
<p><strong>定理2（必要条件）</strong></p>
<p>设<span class="math inline">\(G=&lt;X,E,Y&gt;\)</span>是无向连通二部图，其中<span class="math inline">\(|X|=m,|Y|=n\)</span>，若<span class="math inline">\(m\neq n\)</span>，则必不是汉密尔顿图。</p>
<p>若<span class="math inline">\(|m-n|&gt;1\)</span>，则必不存在汉密尔顿路。</p>
<p><strong>定理3（充分条件）</strong></p>
<p>设<span class="math inline">\(G=&lt;V,E&gt;\)</span>是含有<span class="math inline">\(n(n\ge3)\)</span>个节点的简单无向图，如果<span class="math inline">\(G\)</span>中的任何两个不同结点的度数之和都大于等于<span class="math inline">\(n-1\)</span>，则<span class="math inline">\(G\)</span>中存在汉密尔顿路。</p>
<p>如果都大于等于<span class="math inline">\(n\)</span>，则存在汉密尔顿回路。</p>
<h3 id="平面图">平面图</h3>
<p><strong>平面嵌入</strong></p>
<p>将一个平面图<span class="math inline">\(G\)</span>重新排列得到边不相交的图<span class="math inline">\(G&#39;\)</span>，<span class="math inline">\(G&#39;\)</span>称为一个平面嵌入。</p>
<p><strong>面的次数</strong></p>
<p>面<span class="math inline">\(r\)</span>的边界回路长度称为面的次数，记作<span class="math inline">\(deg(r)\)</span></p>
<p><strong>定理1</strong></p>
<p>连通平面图，所有面的次数之和等于边数的两倍</p>
<p><strong>定理2</strong></p>
<p>连通平面图，有<span class="math inline">\(n\)</span>个节点，<span class="math inline">\(m\)</span>条边，<span class="math inline">\(r\)</span>个面，则有<span class="math inline">\(n-m+r=2\)</span>成立。</p>
<p>若<span class="math inline">\(n\ge3\)</span>，则<span class="math inline">\(m\leq3n-6\)</span></p>
<p>若每个面至少由<span class="math inline">\(k\)</span>边围成，则有<span class="math inline">\(m\leq\frac{k(n-2)}{k-2}\)</span></p>
<p><strong>同胚</strong></p>
<p>给定两个图<span class="math inline">\(G_1\)</span>和<span class="math inline">\(G_2\)</span>，如果它们本身是同构的，或者通过反复插入度为2的结点(在某边上嵌入结点)或反复删除度为2的结点(仅去除结点,其关联边拼接)后，能够使<span class="math inline">\(G_1\)</span>和<span class="math inline">\(G_2\)</span>同构，则称<span class="math inline">\(G_1\)</span>和<span class="math inline">\(G_2\)</span>在<span class="math inline">\(2\)</span>度结点内同构，亦称同胚。</p>
<p><strong>库拉托夫斯基定理</strong></p>
<p>一个图是平面图，当且仅当它不包含与<span class="math inline">\(K_{3,3}\)</span>和<span class="math inline">\(K_5\)</span>同胚的子图。</p>
<h3 id="图的着色">图的着色</h3>
<h4 id="图的结点着色">图的结点着色</h4>
<p><strong>正常着色</strong></p>
<p>无向图，给每个结点指定一种颜色，若满足邻接的两个结点颜色不同，则称为正常着色。</p>
<p><strong>可k-着色</strong></p>
<p>可以用<span class="math inline">\(k\)</span>种不同的颜色给无向图正常着色。</p>
<p><strong>k色图</strong></p>
<p>对无向图正常着色所需要的最少的颜色数，称为顶着色数，简称色数，记为<span class="math inline">\(\mathcal{X}(G)\)</span>。色数为<span class="math inline">\(k\)</span>的图称为<span class="math inline">\(k\)</span>色图</p>
<p><strong>Welch Powell着色法</strong></p>
<ol type="1">
<li>将图<span class="math inline">\(G\)</span>中的结点按度数递减的次序进行排列。</li>
<li>用一种与已着色结点所着颜色不同的新的颜色<span class="math inline">\(C\)</span>对排列最前的尚未着色的节点着色，并按排列次序对与前面已着上颜色<span class="math inline">\(C\)</span>的结点均不相邻的每一结点着同样的颜色<span class="math inline">\(C\)</span>。</li>
<li>重复2知道着色结束。</li>
</ol>
<p><strong>定理1</strong></p>
<p>任何图均满足<span class="math inline">\(\mathcal{X}(G)\leq
\Delta(G)+1\)</span>。<span class="math inline">\(\Delta(G)=max\{d(u)|u\in V\}\)</span></p>
<p><strong>定理2</strong></p>
<p><span class="math inline">\(\mathcal{X}(G)=2\)</span>，当且仅当<span class="math inline">\(G\)</span>是二部图。</p>
<h4 id="平面图的着色">平面图的着色</h4>
<p><strong>对偶图</strong></p>
<p>设<span class="math inline">\(G=&lt;V,E&gt;\)</span>是平面图，<span class="math inline">\(G&#39;\)</span>是<span class="math inline">\(G\)</span>的一个平面嵌入，<span class="math inline">\(F(G&#39;)\)</span>是<span class="math inline">\(G&#39;\)</span>的面集合。构造图<span class="math inline">\(G^*\)</span>，若<span class="math inline">\(G^*\)</span>的结点集合<span class="math inline">\(V(G^*)=F(G&#39;)\)</span>，且任取两个结点<span class="math inline">\(f_1,f_2\in V(G^*)\)</span>，<span class="math inline">\(f_1\)</span>和<span class="math inline">\(f_2\)</span>之间存在边<span class="math inline">\(e\)</span>当且仅当<span class="math inline">\(f_1\)</span>和<span class="math inline">\(f_2\)</span>在<span class="math inline">\(G&#39;\)</span>中有一条公共边，则称<span class="math inline">\(G^*\)</span>是<span class="math inline">\(G\)</span>的对偶图。</p>
<p><strong>定理</strong></p>
<p>设<span class="math inline">\(G=&lt;V,E&gt;\)</span>是一个连通简单平面图，且<span class="math inline">\(|V|\ge 3,|E|=m\)</span>，则<span class="math inline">\(G\)</span>中必存在结点<span class="math inline">\(u\in V\)</span>，满足<span class="math inline">\(deg(u)\leq 5\)</span>。</p>
<p><strong>希伍德五色定理</strong></p>
<p>任何一个连通简单平面图都是5可着色的。</p>
<p><strong>四色定理</strong></p>
<p>平面图的色数不超过4。</p>
<h3 id="树">树</h3>
<h4 id="无向树的定义">无向树的定义</h4>
<p><strong>平凡树</strong></p>
<p>只有一个孤立节点的树。</p>
<p><strong>定理1</strong></p>
<p>对于一个含有<span class="math inline">\(n\)</span>个结点<span class="math inline">\(m\)</span>条边的无向树，以下定义等价</p>
<ol type="1">
<li>无圈且连通</li>
<li>无圈且<span class="math inline">\(m=n-1\)</span></li>
<li>连通且<span class="math inline">\(m=n-1\)</span></li>
<li>无圈，但任意新增一条边，恰得到一个圈</li>
<li>连通，且每条边都是割边</li>
<li>每一对结点有且只有一条通路</li>
</ol>
<p><strong>定理2</strong></p>
<p>任何一颗非平凡树中至少有两片树叶</p>
<h4 id="生成树">生成树</h4>
<p><strong>定理1</strong></p>
<p>任何一个无向连通图至少有一颗生成树</p>
<p><strong>定理2</strong></p>
<p>连通图中的一个圈与其任何一棵生成树的补至少有一条公共边。</p>
<p><strong>定理3</strong></p>
<p>一个边割集和任何一棵生成树至少有一条公共边。</p>
<p><strong>最小生成树及其算法</strong></p>
<p>见竞赛模板。</p>
<h4 id="根树及其应用">根树及其应用</h4>
<p><strong>根树</strong></p>
<p>一棵有向树，恰有一个节点入度为0，其余节点入度都为1。</p>
<p><strong>m元树</strong></p>
<p>每个结点的出度均小于等于<span class="math inline">\(m\)</span>的根树。</p>
<p>每个节点的出度均等于<span class="math inline">\(0\)</span>或<span class="math inline">\(m\)</span>的根树称为正则<span class="math inline">\(m\)</span>元树。</p>
<p><strong>定理1</strong></p>
<p>正则<span class="math inline">\(m\)</span>元树<span class="math inline">\(T\)</span>，其树叶数为<span class="math inline">\(t\)</span>，分支结点数为<span class="math inline">\(i\)</span>，则有<span class="math inline">\((m-1)i=t-1\)</span></p>
<p><strong>带权树</strong></p>
<p>如果一颗二元树<span class="math inline">\(T\)</span>共有<span class="math inline">\(n\)</span>片树叶，分别带权<span class="math inline">\(\omega_1,\omega_2,\cdots,\omega_n\)</span>。定义这棵二元树<span class="math inline">\(T\)</span>的权值为，</p>
<p><span class="math display">\[
W(T)=\sum_{i=1}^{n}\omega_iL(\omega_i)
\]</span></p>
<p>其中<span class="math inline">\(L(\omega_i)\)</span>为带权<span class="math inline">\(\omega_i\)</span>的树叶的深度（根深度为0）。在所有带这些权的二元树中，具有最小权的二元树称为最优二元树。</p>
<p><strong>定理1</strong></p>
<p>最优二元树是一颗正则二元树。</p>
<p><strong>定理2</strong></p>
<p>最优二元树中，层数最大的分支节点的两个儿子所带权分别为最小的两个权。</p>
<p><strong>最优二元树的构造方法</strong></p>
<figure>
<img src="7.7.12.jpg" alt="7.7.12"/>
<figcaption aria-hidden="true">7.7.12</figcaption>
</figure>
<p><strong>前缀码</strong></p>
<p>给定一个以<span class="math inline">\(0,1\)</span>组成序列为元素的集合，若没有一个序列是另一个序列的前缀，则该集合称为前缀码。</p>
<p><strong>利用有序正则二元树解决前缀码问题</strong></p>
<figure>
<img src="7.7.13.jpg" alt="7.7.13"/>
<figcaption aria-hidden="true">7.7.13</figcaption>
</figure>



</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/">离散数学</a>
        
            <a href="/tags/%E5%A4%A7%E5%AD%A6/">大学</a>
        
            <a href="/tags/%E6%95%B0%E5%AD%A6/">数学</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/">
        
        

        <div class="article-details">
            <h2 class="article-title">复变函数整理</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E6%95%B4%E7%90%86/">
        
        
            <div class="article-image">
                <img src="/p/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E6%95%B4%E7%90%86/cover.8fa55b693c3d793670200f41ff6f26bf_hu60f44b771e1522f4fa1d5246713b9a75_57927_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-j6VbaTw9eTZwIA9B/28mvw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">概率论与数理统计整理</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%95%B4%E7%90%86/">
        
        
            <div class="article-image">
                <img src="/p/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%95%B4%E7%90%86/cover.393667604ec380a7df6254826bbb2062_hu670730d9bdf70a44294ca8d2a00a2ced_185066_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-OTZnYE7DgKffYlSCa7sgYg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">线性代数整理</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E6%88%91%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E5%86%8C%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/">
        
        
            <div class="article-image">
                <img src="/p/%E6%88%91%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8B%E5%86%8C%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/8-51.eb2fd26757434998c74bb25f2a91edc6_hu1c49316b400cd781c785bbdbc8d18c16_11689_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-6y/SZ1dDSZjHS7JfKpHtxg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">我的高等数学下册资料整理</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E6%88%91%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A%E5%86%8C%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/">
        
        
            <div class="article-image">
                <img src="/p/%E6%88%91%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8A%E5%86%8C%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/sec.1ea06f559e136e7a6f4b1502dc361e06_huc4e91e2fedcb5d4446570ef1353d17fa_50913_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-HqBvVZ4TbnpvSxUC3DYeBg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">我的高等数学上册资料整理</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="kegalas/blogComments"
        issue-term="pathname"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2023 KegalaS的个人博客
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.4.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#命题逻辑">命题逻辑</a>
      <ol>
        <li><a href="#联结词">联结词</a></li>
        <li><a href="#命题公式">命题公式</a></li>
        <li><a href="#逻辑等价与蕴含">逻辑等价与蕴含</a></li>
        <li><a href="#对偶式">对偶式</a></li>
        <li><a href="#范式">范式</a></li>
        <li><a href="#命题逻辑的推理理论">命题逻辑的推理理论</a></li>
      </ol>
    </li>
    <li><a href="#谓词逻辑">谓词逻辑</a>
      <ol>
        <li><a href="#谓词和量词">谓词和量词</a></li>
        <li><a href="#谓词公式">谓词公式</a></li>
        <li><a href="#谓词验算的永真公式">谓词验算的永真公式</a></li>
        <li><a href="#谓词逻辑的推理理论">谓词逻辑的推理理论</a></li>
      </ol>
    </li>
    <li><a href="#集合">集合</a>
      <ol>
        <li><a href="#集合的表示方法">集合的表示方法</a></li>
        <li><a href="#集合间的关系">集合间的关系</a></li>
        <li><a href="#集合的运算">集合的运算</a></li>
        <li><a href="#容斥原理">容斥原理</a></li>
        <li><a href="#归纳证明">归纳证明</a></li>
        <li><a href="#集合的笛卡尔积">集合的笛卡尔积</a></li>
        <li><a href="#二元关系">二元关系</a></li>
        <li><a href="#集合上的二元关系及其特性">集合上的二元关系及其特性</a></li>
        <li><a href="#关系的闭包运算">关系的闭包运算</a></li>
        <li><a href="#等价关系">等价关系</a></li>
        <li><a href="#序关系">序关系</a></li>
      </ol>
    </li>
    <li><a href="#函数与无限集合">函数与无限集合</a>
      <ol>
        <li><a href="#函数的定义">函数的定义</a></li>
        <li><a href="#特殊函数">特殊函数</a></li>
        <li><a href="#复合函数和逆函数">复合函数和逆函数</a></li>
        <li><a href="#可数与不可数集合">可数与不可数集合</a></li>
        <li><a href="#基数的比较">基数的比较</a></li>
      </ol>
    </li>
    <li><a href="#图论">图论</a>
      <ol>
        <li><a href="#图的基本概念">图的基本概念</a></li>
        <li><a href="#图的连通性">图的连通性</a></li>
        <li><a href="#图的矩阵表示">图的矩阵表示</a></li>
        <li><a href="#欧拉图与汉密尔顿图">欧拉图与汉密尔顿图</a></li>
        <li><a href="#平面图">平面图</a></li>
        <li><a href="#图的着色">图的着色</a></li>
        <li><a href="#树">树</a></li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>

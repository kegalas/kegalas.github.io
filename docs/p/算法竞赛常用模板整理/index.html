<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='包含ICPC竞赛常用的一些模板'><title>算法竞赛常用模板整理</title>

<link rel='canonical' href='https://kegalas.top/p/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='算法竞赛常用模板整理'>
<meta property='og:description' content='包含ICPC竞赛常用的一些模板'>
<meta property='og:url' content='https://kegalas.top/p/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/'>
<meta property='og:site_name' content='KegalaS的个人博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='算法' /><meta property='article:tag' content='模板' /><meta property='article:published_time' content='2021-12-18T15:57:37&#43;08:00'/><meta property='article:modified_time' content='2021-12-18T15:57:37&#43;08:00'/>
<meta name="twitter:title" content="算法竞赛常用模板整理">
<meta name="twitter:description" content="包含ICPC竞赛常用的一些模板">
    <link rel="shortcut icon" href="favicon-16x16.png" />

    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E7%AE%97%E6%B3%95/" >
                算法
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/">算法竞赛常用模板整理</a>
    </h2>

    
    <h3 class="article-subtitle">
        包含ICPC竞赛常用的一些模板
    </h3>
    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Dec 18, 2021</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 101 分钟
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    

<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;map&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdint&gt;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;bitset&gt;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;deque&gt;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;regex&gt;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_set&gt;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#define debug</span><span class="op">(</span>a<span class="op">)</span><span class="pp"> </span><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="pp">#</span>a<span class="op">&lt;&lt;</span><span class="st">&#34;=&#34;</span><span class="op">&lt;&lt;(</span>a<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="pp">#define rep</span><span class="op">(</span>i<span class="op">,</span>x<span class="op">,</span>y<span class="op">)</span><span class="pp"> </span><span class="cf">for</span><span class="op">(</span><span class="dt">int</span><span class="pp"> </span>i<span class="op">=(</span>x<span class="op">);</span>i<span class="op">&lt;=(</span>y<span class="op">);</span>i<span class="op">++)</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="pp">#define rrep</span><span class="op">(</span>i<span class="op">,</span>x<span class="op">,</span>y<span class="op">)</span><span class="pp"> </span><span class="cf">for</span><span class="op">(</span><span class="dt">int</span><span class="pp"> </span>i<span class="op">=(</span>x<span class="op">);</span>i<span class="op">&gt;=(</span>y<span class="op">);</span>i<span class="op">--)</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#define mms</span><span class="op">(</span>x<span class="op">)</span><span class="pp"> </span>memset<span class="op">((</span>x<span class="op">),</span><span class="pp"> </span><span class="dv">0</span><span class="op">,</span><span class="pp"> </span><span class="kw">sizeof</span><span class="op">(</span>x<span class="op">))</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="pp">#define pb </span>push_back</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="pp">#define mkp </span><span class="bu">std::</span>make_pair</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="pp">#define fi </span>first</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="pp">#define se </span>second</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> LL <span class="op">=</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> ULL <span class="op">=</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> DB <span class="op">=</span> <span class="dt">double</span><span class="op">;</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> LD <span class="op">=</span> <span class="dt">long</span> <span class="dt">double</span><span class="op">;</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> ui <span class="op">=</span> <span class="dt">unsigned</span><span class="op">;</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> i128 <span class="op">=</span> <span class="dt">__int128</span><span class="op">;</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> pii <span class="op">=</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span><span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> pll <span class="op">=</span> <span class="bu">std::</span>pair<span class="op">&lt;</span>LL<span class="op">,</span>LL<span class="op">&gt;;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">200005</span><span class="op">;</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> INF <span class="op">=</span> <span class="bn">0x7fffffff</span><span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>DB <span class="at">const</span> EPS <span class="op">=</span> <span class="fl">1e-8</span><span class="op">;</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MOD <span class="op">=</span> <span class="dv">998244353</span><span class="op">;</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>DB <span class="at">const</span> PI <span class="op">=</span> acos<span class="op">(-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> arr<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">(){</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>arr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> T<span class="op">;</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>T<span class="op">;</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">//T=1;</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>T<span class="op">--){</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        solve<span class="op">();</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="字符串">字符串</h1>
<h2 id="kmp">KMP</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度n</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">//kmp,luogu3375</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> prefixFunc<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> str<span class="op">){</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//输入一个字符串，输出该字符串的前缀函数表</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//前缀函数pi[i]是满足s[0...x-1]==s[i-x+1...i]的最大的x</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//如果输入不是字符串而是一个数组，也可以很方便的修改为vector</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> str<span class="op">.</span>length<span class="op">();</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ans<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">,</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">//ans[0]=0，因为只看真前缀和真后缀</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>j <span class="op">&amp;&amp;</span> str<span class="op">[</span>i<span class="op">]!=</span>str<span class="op">[</span>j<span class="op">])</span> j <span class="op">=</span> ans<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>str<span class="op">[</span>i<span class="op">]==</span>str<span class="op">[</span>j<span class="op">])</span> j<span class="op">++;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> KMP<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> s<span class="op">,</span> <span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> p<span class="op">){</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">//输入主串和模式串，返回所有匹配的开始下标，下标从0开始</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">;</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> pf <span class="op">=</span> prefixFunc<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ns <span class="op">=</span> s<span class="op">.</span>size<span class="op">(),</span> np <span class="op">=</span> p<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">,</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>ns<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>j <span class="op">&amp;&amp;</span> s<span class="op">[</span>i<span class="op">]!=</span>p<span class="op">[</span>j<span class="op">])</span> j <span class="op">=</span> pf<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>s<span class="op">[</span>i<span class="op">]==</span>p<span class="op">[</span>j<span class="op">])</span> j<span class="op">++;</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>j<span class="op">==</span>np<span class="op">){</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>            vec<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">-</span>j<span class="op">+</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> pf<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> vec<span class="op">;</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a><span class="co">//我们可以通过把模式串和主串拼在一起，p+#+s，然后求这个字符串的前缀函数表（#代表不在主串、模式串字符集内的一个符号），然后pi[i]如果等于模式串的长度，那么i是匹配模式串的子串的起点。</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span class="co">//关于最小循环结，设字符串下标从1开始，长度为n，则如果n%(n-pf[n])==0，则有循环节，并且长度为n-pf[n]（当然长度可以为n）</span></span></code></pre></div>
<h2 id="字典树trie">字典树(Trie)</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 插入或查找一次 模板串长度</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p8306</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Trie<span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nxt<span class="op">[</span>MAXM<span class="op">][</span><span class="dv">26</span><span class="op">];</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cnt<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> init<span class="op">(){</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;=</span>cnt<span class="op">;</span>i<span class="op">++)</span> <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span>j<span class="op">&lt;</span><span class="dv">26</span><span class="op">;</span>j<span class="op">++)</span> nxt<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        cnt <span class="op">=</span> <span class="dv">0</span><span class="op">;</span><span class="co">//起始节点编号为0</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> insert<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> s<span class="op">){</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cur <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> c<span class="op">:</span>s<span class="op">){</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(!</span>nxt<span class="op">[</span>cur<span class="op">][</span>c<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">]){</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>                nxt<span class="op">[</span>cur<span class="op">][</span>c<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">]=++</span>cnt<span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>            cur <span class="op">=</span> nxt<span class="op">[</span>cur<span class="op">][</span>c<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">];</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> find_prefix<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> s<span class="op">){</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cur<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> c<span class="op">:</span>s<span class="op">){</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span>nxt<span class="op">[</span>cur<span class="op">][</span>c<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">]){</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>               <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>            </span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>            cur <span class="op">=</span> nxt<span class="op">[</span>cur<span class="op">][</span>c<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">];</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>Trie trie<span class="op">;</span></span></code></pre></div>
<h2 id="字符串哈希">字符串哈希</h2>
<p>主要是用于判断两个字符串是否相等。通常我们的Hash函数会把字符串看成是某个进制下的自然数。把这个自然数对某个大质数取模得到Hash值。</p>
<p>求Hash的复杂度是<span class="math inline">\(O(n)\)</span>，如果我们要比较一大群字符串里有多少不同的，我们不应该两两比较，而要把它们的Hash全部记录下来，再去排序Hash、比较。</p>
<p>这种哈希函数的性质为：</p>
<ol type="1">
<li>设已知字符串<span class="math inline">\(S\)</span>的Hash值为<span class="math inline">\(H(S)\)</span>，那么添加一个字符<span class="math inline">\(c\)</span>后的新字符串的Hash值为<span class="math inline">\(H(S+c)=(H(S)*base+value[c])\%MOD\)</span>。其中<span class="math inline">\(value[c]\)</span>表示<span class="math inline">\(c\)</span>代表的数值，如果用char类型直接把<span class="math inline">\(c\)</span>转换为int或者ULL什么的就行了</li>
<li>已知<span class="math inline">\(H(S)\)</span>和<span class="math inline">\(H(S+T)\)</span>，则<span class="math inline">\(H(T)=(H(S+T)-H(S)*base^{length(T)})\%MOD\)</span>，直观理解的话，就是在<span class="math inline">\(base\)</span>进制下，在S后面补<span class="math inline">\(0\)</span>，把<span class="math inline">\(S\)</span>左端和<span class="math inline">\(S+T\)</span>左端对齐，相减得到<span class="math inline">\(H(T)\)</span>。利用这个性质可以方便地先预处理字符串所有前缀的Hash，然后查询连续子串的Hash。</li>
</ol>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">//自然溢出法，相当于对2^64取模的单哈希，是比较容易被特殊数据卡掉的</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P3370</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> ULL <span class="op">=</span> <span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>ULL H<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> str<span class="op">){</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    ULL ret <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    ULL <span class="at">const</span> base <span class="op">=</span> <span class="dv">131</span><span class="op">;</span><span class="co">//ascii也就128个字符，质数131作为底数足够</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> c<span class="op">:</span>str<span class="op">){</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        ret <span class="op">=</span> ret<span class="op">*</span>base<span class="op">+(</span>ULL<span class="op">)</span>c<span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">//双哈希法，两个字符串的两个哈希必须分别相同，才会被考虑为相同的字符串</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">//比起单哈希，更不容易被卡</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P3370</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>ULL <span class="at">const</span> MOD1 <span class="op">=</span> <span class="dv">998244353</span><span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>ULL <span class="at">const</span> MOD2 <span class="op">=</span> <span class="fl">1e9</span><span class="op">+</span><span class="dv">7</span><span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>ULL <span class="at">const</span> base <span class="op">=</span> <span class="dv">131</span><span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Data<span class="op">{</span><span class="co">//把字符串的两个哈希捆起来，便于排序比较等操作</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    ULL x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>ULL H1<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> str<span class="op">){</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    ULL ret <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> c<span class="op">:</span>str<span class="op">){</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        ret <span class="op">=</span> <span class="op">(</span>ret<span class="op">*</span>base<span class="op">+(</span>ULL<span class="op">)</span>c<span class="op">)%</span>MOD1<span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>ULL H2<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> str<span class="op">){</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    ULL ret <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> c<span class="op">:</span>str<span class="op">){</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        ret <span class="op">=</span> <span class="op">(</span>ret<span class="op">*</span>base<span class="op">+(</span>ULL<span class="op">)</span>c<span class="op">)%</span>MOD2<span class="op">;</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="ac自动机">AC自动机</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 文本串长度+模板串长度之和</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">//AC自动机，luogu P3808</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">//AC自动机会把Trie修改掉，并不是插入时候的字典树了，实际上变成了一张图+fail指针。</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">//trie数组表示从当前状态添加一个字符后到达的状态，fail数组表示，目前为止匹配，但是添加下一个字符后不匹配了，跳转至最长的后缀状态（不包括添加的下一个字符）。可以反复跳转。</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">//注意，一个状态是可行状态，当且仅当它自己可行，或者fail指针指向的状态可行，或者fail[fail]可行，以此类推</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> AC<span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> trie<span class="op">[</span>MAXN<span class="op">][</span><span class="dv">26</span><span class="op">],</span> total<span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> end<span class="op">[</span>MAXN<span class="op">],</span>fail<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> init<span class="op">(</span><span class="dt">int</span> m<span class="op">){</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>            end<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>            fail<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span>j<span class="op">&lt;</span><span class="dv">26</span><span class="op">;</span>j<span class="op">++)</span> trie<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> insert<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> str<span class="op">){</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">//插入模式串</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> c<span class="op">:</span>str<span class="op">){</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(!</span>trie<span class="op">[</span>u<span class="op">][</span>c<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">]){</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>                trie<span class="op">[</span>u<span class="op">][</span>c<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">]</span> <span class="op">=</span> <span class="op">++</span>total<span class="op">;</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> trie<span class="op">[</span>u<span class="op">][</span>c<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">];</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        end<span class="op">[</span>u<span class="op">]++;</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> buildFail<span class="op">(){</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">//构建fail指针</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> qu<span class="op">;</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span><span class="dv">26</span><span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>trie<span class="op">[</span><span class="dv">0</span><span class="op">][</span>i<span class="op">])</span> qu<span class="op">.</span>push<span class="op">(</span>trie<span class="op">[</span><span class="dv">0</span><span class="op">][</span>i<span class="op">]);</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(!</span>qu<span class="op">.</span>empty<span class="op">()){</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> u <span class="op">=</span> qu<span class="op">.</span>front<span class="op">();</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>            qu<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span><span class="dv">26</span><span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>trie<span class="op">[</span>u<span class="op">][</span>i<span class="op">]){</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>                    fail<span class="op">[</span>trie<span class="op">[</span>u<span class="op">][</span>i<span class="op">]]</span> <span class="op">=</span> trie<span class="op">[</span>fail<span class="op">[</span>u<span class="op">]][</span>i<span class="op">];</span>    </span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>                    qu<span class="op">.</span>push<span class="op">(</span>trie<span class="op">[</span>u<span class="op">][</span>i<span class="op">]);</span></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span><span class="op">{</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>                    trie<span class="op">[</span>u<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> trie<span class="op">[</span>fail<span class="op">[</span>u<span class="op">]][</span>i<span class="op">];</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> query<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> str<span class="op">){</span></span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>        <span class="co">//查询主串str中出现了几个模式串</span></span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> res <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> c<span class="op">:</span>str<span class="op">){</span></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> trie<span class="op">[</span>u<span class="op">][</span>c<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">];</span></span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> u <span class="op">;</span> j <span class="op">&amp;&amp;</span> end<span class="op">[</span>j<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span> <span class="op">;</span> j <span class="op">=</span> fail<span class="op">[</span>j<span class="op">]){</span></span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>                res <span class="op">+=</span> end<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>                end<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="最小表示法">最小表示法</h2>
<p>例如S = bcda, 则S的循环同构有cdab, dabc,
abcd，其中字典序最小的是abcd，最小表示法就是求这个字典序最小的。当然题目里面可能是算数组里面字典序最小的。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">//最小表示法</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P1368</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 O(n)</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> arr<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minStr<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span><span class="co">//数组下标从0开始，共n个；返回最小表示的开始下标</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">,</span> j<span class="op">=</span><span class="dv">1</span><span class="op">,</span> k<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>i<span class="op">&lt;</span>n <span class="op">&amp;&amp;</span> j<span class="op">&lt;</span>n <span class="op">&amp;&amp;</span> k<span class="op">&lt;</span>n<span class="op">){</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>arr<span class="op">[(</span>i<span class="op">+</span>k<span class="op">)%</span>n<span class="op">]==</span>arr<span class="op">[(</span>j<span class="op">+</span>k<span class="op">)%</span>n<span class="op">]){</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            k<span class="op">++;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>arr<span class="op">[(</span>i<span class="op">+</span>k<span class="op">)%</span>n<span class="op">]&gt;</span>arr<span class="op">[(</span>j<span class="op">+</span>k<span class="op">)%</span>n<span class="op">]){</span><span class="co">//最大表示法时就把这一段和下一段换一下</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>            j <span class="op">+=</span> k<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>            k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>i<span class="op">==</span>j<span class="op">)</span> j<span class="op">++;</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>min<span class="op">(</span>i<span class="op">,</span>j<span class="op">);</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="manacher">Manacher</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">//manacher 算法</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P3805</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度O(n)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> getD1<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> str<span class="op">){</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//返回字符串以某一位为中心的，最长的（奇数长度）回文子串的长度半径</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//例如abcba中，d1[2] = 3</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> str<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> d<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">,</span>l<span class="op">=</span><span class="dv">0</span><span class="op">,</span>r<span class="op">=-</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> j <span class="op">=</span> l<span class="op">+</span>r<span class="op">-</span>i<span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> dj <span class="op">=</span> j<span class="op">&gt;=</span><span class="dv">0</span><span class="op">?</span>d<span class="op">[</span>j<span class="op">]:</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        d<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span><span class="bu">std::</span>min<span class="op">(</span>dj<span class="op">,</span>j<span class="op">-</span>l<span class="op">+</span><span class="dv">1</span><span class="op">),</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>j<span class="op">-</span>dj<span class="op">&lt;</span>l<span class="op">){</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span><span class="op">(</span>i<span class="op">-</span>d<span class="op">[</span>i<span class="op">]&gt;=</span><span class="dv">0</span> <span class="op">&amp;&amp;</span> i<span class="op">+</span>d<span class="op">[</span>i<span class="op">]&lt;</span>n <span class="op">&amp;&amp;</span> str<span class="op">[</span>i<span class="op">-</span>d<span class="op">[</span>i<span class="op">]]==</span>str<span class="op">[</span>i<span class="op">+</span>d<span class="op">[</span>i<span class="op">]])</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>                d<span class="op">[</span>i<span class="op">]++;</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>            l <span class="op">=</span> i<span class="op">-</span>d<span class="op">[</span>i<span class="op">]+</span><span class="dv">1</span><span class="op">,</span> r <span class="op">=</span> i<span class="op">+</span>d<span class="op">[</span>i<span class="op">]-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d<span class="op">;</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> getD2<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> str<span class="op">){</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">//返回字符串以某一位的左边间隙为中心的，最长的（偶数长度）回文子串的长度半径</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">//例如abba中，d2[2] = 2</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> str<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> d<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">,</span>l<span class="op">=</span><span class="dv">0</span><span class="op">,</span>r<span class="op">=-</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> j <span class="op">=</span> l<span class="op">+</span>r<span class="op">-</span>i<span class="op">;</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> dj <span class="op">=</span> j<span class="op">&gt;=</span><span class="dv">0</span><span class="op">?</span>d<span class="op">[</span>j<span class="op">]:</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>        d<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span><span class="bu">std::</span>min<span class="op">(</span>dj<span class="op">,</span>j<span class="op">-</span>l<span class="op">),</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>j<span class="op">-</span>dj<span class="op">-</span><span class="dv">1</span><span class="op">&lt;</span>l<span class="op">){</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span><span class="op">(</span>i<span class="op">-</span>d<span class="op">[</span>i<span class="op">]-</span><span class="dv">1</span><span class="op">&gt;=</span><span class="dv">0</span> <span class="op">&amp;&amp;</span> i<span class="op">+</span>d<span class="op">[</span>i<span class="op">]&lt;</span>n <span class="op">&amp;&amp;</span> str<span class="op">[</span>i<span class="op">-</span>d<span class="op">[</span>i<span class="op">]-</span><span class="dv">1</span><span class="op">]==</span>str<span class="op">[</span>i<span class="op">+</span>d<span class="op">[</span>i<span class="op">]])</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>                d<span class="op">[</span>i<span class="op">]++;</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>            l <span class="op">=</span> i<span class="op">-</span>d<span class="op">[</span>i<span class="op">],</span> r <span class="op">=</span> i<span class="op">+</span>d<span class="op">[</span>i<span class="op">]-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d<span class="op">;</span></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="z函数">Z函数</h2>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Z函数，复杂度O(n)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P5410</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> zFunc<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> str<span class="op">){</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//求出一个字符串的z函数，即满足z[i]是s[0...x-1]==s[i...i+x-1]的最大的x，这个子串也叫做LCP</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//特别的z[0]=0，也有些题目是等于串长，需要自行调整</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//kmp里面添加字符集外字符的操作在这里也可以用</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> str<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> z<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">,</span>l<span class="op">=</span><span class="dv">0</span><span class="op">,</span>r<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>z<span class="op">[</span>i<span class="op">-</span>l<span class="op">]&lt;</span>r<span class="op">-</span>i<span class="op">+</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            z<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> z<span class="op">[</span>i<span class="op">-</span>l<span class="op">];</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            z<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>r<span class="op">-</span>i<span class="op">+</span><span class="dv">1</span><span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span><span class="op">(</span>i<span class="op">+</span>z<span class="op">[</span>i<span class="op">]&lt;</span>n <span class="op">&amp;&amp;</span> str<span class="op">[</span>z<span class="op">[</span>i<span class="op">]]==</span>str<span class="op">[</span>i<span class="op">+</span>z<span class="op">[</span>i<span class="op">]])</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>                z<span class="op">[</span>i<span class="op">]++;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            l <span class="op">=</span> i<span class="op">,</span> r <span class="op">=</span> i <span class="op">+</span> z<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> z<span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="后缀数组">后缀数组</h2>
<p>首先是<span class="math inline">\(O(n\log^2n)\)</span>的，没有用到基数排序（因为我不排除会求某种只给出偏序关系的后缀数组）</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">//求后缀数组，复杂度O(nlog^2n)</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p3809</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> rk<span class="op">[</span>MAXN<span class="op">&lt;&lt;</span><span class="dv">1</span><span class="op">],</span>sa<span class="op">[</span>MAXN<span class="op">],</span>tarr<span class="op">[</span>MAXN<span class="op">&lt;&lt;</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">//rk[i]表示后缀i（从1开始，后缀i代表字符串从i开始到结束的子串）的排名，sa[i]表示所有后缀第i小的起点序号，排名和编号都从1开始</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getSA<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> s<span class="op">){</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>n<span class="op">==</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        rk<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> sa<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        sa<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i<span class="op">,</span> rk<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> s<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> w<span class="op">=</span><span class="dv">1</span><span class="op">;</span>w<span class="op">&lt;</span>n<span class="op">;</span>w<span class="op">&lt;&lt;=</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> rp <span class="op">=</span> <span class="op">[&amp;](</span><span class="dt">int</span> x<span class="op">){</span><span class="cf">return</span> <span class="bu">std::</span>make_pair<span class="op">(</span>rk<span class="op">[</span>x<span class="op">],</span>rk<span class="op">[</span>x<span class="op">+</span>w<span class="op">]);};</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>sort<span class="op">(</span>sa<span class="op">+</span><span class="dv">1</span><span class="op">,</span>sa<span class="op">+</span>n<span class="op">+</span><span class="dv">1</span><span class="op">,[&amp;](</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">){</span><span class="cf">return</span> rp<span class="op">(</span>x<span class="op">)&lt;</span>rp<span class="op">(</span>y<span class="op">);});</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">,</span>p<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>            tarr<span class="op">[</span>sa<span class="op">[</span>i<span class="op">]]</span> <span class="op">=</span> rp<span class="op">(</span>sa<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">])==</span>rp<span class="op">(</span>sa<span class="op">[</span>i<span class="op">])</span> <span class="op">?</span> p<span class="op">:++</span>p<span class="op">;</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>copy<span class="op">(</span>tarr<span class="op">+</span><span class="dv">1</span><span class="op">,</span>tarr<span class="op">+</span>n<span class="op">+</span><span class="dv">1</span><span class="op">,</span>rk<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>再给出<span class="math inline">\(O(n\log n)\)</span>的</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">//求后缀数组，复杂度O(nlogn)</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p3809</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> rk<span class="op">[</span>MAXN<span class="op">&lt;&lt;</span><span class="dv">1</span><span class="op">],</span>sa<span class="op">[</span>MAXN<span class="op">],</span>tarr<span class="op">[</span>MAXN<span class="op">&lt;&lt;</span><span class="dv">1</span><span class="op">],</span>cnt<span class="op">[</span>MAXN<span class="op">],</span>rkt<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">//rk[i]表示后缀i（从1开始，后缀i代表字符串从i开始到结束的子串）的排名，sa[i]表示所有后缀第i小的起点序号，排名和编号都从1开始</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getSA<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> s<span class="op">){</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>n<span class="op">==</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        rk<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> sa<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> <span class="dv">128</span><span class="op">;</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>cnt<span class="op">[</span>rk<span class="op">[</span>i<span class="op">]=</span>s<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]];</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        cnt<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> cnt<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>n<span class="op">;</span>i<span class="op">&gt;=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">--)</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        sa<span class="op">[</span>cnt<span class="op">[</span>rk<span class="op">[</span>i<span class="op">]]--]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> w<span class="op">=</span><span class="dv">1</span><span class="op">;;</span>w<span class="op">&lt;&lt;=</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>n<span class="op">;</span>i<span class="op">&gt;</span>n<span class="op">-</span>w<span class="op">;</span>i<span class="op">--)</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>            tarr<span class="op">[</span>n<span class="op">-</span>i<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">,</span>p<span class="op">=</span>w<span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>sa<span class="op">[</span>i<span class="op">]&gt;</span>w<span class="op">)</span> tarr<span class="op">[++</span>p<span class="op">]=</span>sa<span class="op">[</span>i<span class="op">]-</span>w<span class="op">;</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>fill<span class="op">(</span>cnt<span class="op">+</span><span class="dv">1</span><span class="op">,</span>cnt<span class="op">+</span>m<span class="op">+</span><span class="dv">1</span><span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>            cnt<span class="op">[</span>rkt<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> rk<span class="op">[</span>tarr<span class="op">[</span>i<span class="op">]]]++;</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>            cnt<span class="op">[</span>i<span class="op">]+=</span>cnt<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>n<span class="op">;</span>i<span class="op">&gt;=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">--)</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>            sa<span class="op">[</span>cnt<span class="op">[</span>rkt<span class="op">[</span>i<span class="op">]]--]</span> <span class="op">=</span> tarr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> rp <span class="op">=</span> <span class="op">[&amp;](</span><span class="dt">int</span> x<span class="op">){</span><span class="cf">return</span> <span class="bu">std::</span>make_pair<span class="op">(</span>rk<span class="op">[</span>x<span class="op">],</span>rk<span class="op">[</span>x<span class="op">+</span>w<span class="op">]);};</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>            tarr<span class="op">[</span>sa<span class="op">[</span>i<span class="op">]]</span> <span class="op">=</span> rp<span class="op">(</span>sa<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">])==</span>rp<span class="op">(</span>sa<span class="op">[</span>i<span class="op">])</span> <span class="op">?</span> m<span class="op">:++</span>m<span class="op">;</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>copy<span class="op">(</span>tarr<span class="op">+</span><span class="dv">1</span><span class="op">,</span>tarr<span class="op">+</span>n<span class="op">+</span><span class="dv">1</span><span class="op">,</span>rk<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>n<span class="op">==</span>m<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="后缀自动机">后缀自动机</h2>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">//后缀自动机，构建SAM的复杂度为O(n)，空间复杂度为O(|S|n)，|S|为字符集的大小</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p3804</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">//SAM是动态构建的，每次插入一个字符即可</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> State<span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fa<span class="op">,</span>len<span class="op">,</span>next<span class="op">[</span><span class="dv">26</span><span class="op">];</span><span class="co">//似乎有些编译器next是保留字，需要注意</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">//endpos(p)为模式串p在s中所有出现的结束位置的集合，例如aababc中，ab出现了两次，结束位置是{3,5}。endpos等价类即，endpos相同的子串构成的集合。例如b和ab都是结束在{3,5}，则它们是等价类。这说明它们总是一起出现，可以归到一个节点，并且长度小的一定是长度大的的后缀。</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">//next[ch]表示接受ch后的状态；fa表示该状态在parent tree上的父节点；len表示该状态对应的endpos等价类中最长串的长度。</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">//假设b是a的fa，a等价类的最长字符串为s，则b的最长字符串为，s的所有后缀中，不在等价类a里的，最长的字符串。</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co">//SAM可以接受字符串的所有后缀，但是它包含了所有子串的信息。也就是从任意一个状态开始的路径，都是字符串的子串。</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="co">//可行状态是last状态，以及fa[last]、fa[fa[last]]直到根节点（空字符串）。</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="co">//除了等价类的最长字符串长度len，我们也可以计算minlen。等价类里所有字符串的长度恰好覆盖[minlen,len]之间的每一个整数。除了根节点，st[i].minlen = st[fa[i]].len+1;</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="co">//每个状态i对应的子串数量是st[i].len-st[st[i].fa].len</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="co">//算法并没有维护endpos等效类中，字符串出现的位置个数，需要自己去树形dp。</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="co">//注意，aababb中，ab的等价类为{3,5}，根据ab前面一个字符不同可以划分不同的等价类，例如aab和bab划分为{3},{5}。但是a的等价类为{1,2,4}，因为第一个的前面一个字符是空字符，只能划分出两个，即aa{2},ba{4}，树形DP需要在parent tree上注意缺少的这一部分。在建SAM时预处理dp[cur] = 1</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SAM<span class="op">{</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    State st<span class="op">[</span>MAXN<span class="op">&lt;&lt;</span><span class="dv">1</span><span class="op">];</span><span class="co">//SAM总状态数不会超过2n-1，总转移数不超过3n-4</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cnt <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> last <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">//起始节点编号为1；last表示加入新字符前整个字符串所在的等价类</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> insert<span class="op">(</span><span class="dt">int</span> ch<span class="op">){</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>        ch <span class="op">=</span> ch<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">;</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cur <span class="op">=</span> <span class="op">++</span>cnt<span class="op">;</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> p <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>cur<span class="op">].</span>len <span class="op">=</span> st<span class="op">[</span>last<span class="op">].</span>len <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span>p<span class="op">=</span>last<span class="op">;</span>p<span class="op">&amp;&amp;!</span>st<span class="op">[</span>p<span class="op">].</span>next<span class="op">[</span>ch<span class="op">];</span>p<span class="op">=</span>st<span class="op">[</span>p<span class="op">].</span>fa<span class="op">)</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>p<span class="op">].</span>next<span class="op">[</span>ch<span class="op">]</span> <span class="op">=</span> cur<span class="op">;</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">//对于每一个father状态，如果不存在ch的转移边，则连到cur</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> q <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>next<span class="op">[</span>ch<span class="op">];</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>q<span class="op">==</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>            <span class="co">//加入了从未加入的字符</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>cur<span class="op">].</span>fa <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>st<span class="op">[</span>p<span class="op">].</span>len <span class="op">+</span> <span class="dv">1</span> <span class="op">==</span> st<span class="op">[</span>q<span class="op">].</span>len<span class="op">){</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>            <span class="co">//p到q是连续的转移</span></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>cur<span class="op">].</span>fa <span class="op">=</span> q<span class="op">;</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>            <span class="co">//不连续的转移</span></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>            <span class="co">//会新增一个节点r,拥有q的所有出边，father与q相同</span></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> r <span class="op">=</span> <span class="op">++</span>cnt<span class="op">;</span></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>r<span class="op">]</span> <span class="op">=</span> st<span class="op">[</span>q<span class="op">];</span></span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>r<span class="op">].</span>len <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>len <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(;</span>p<span class="op">&amp;&amp;</span>st<span class="op">[</span>p<span class="op">].</span>next<span class="op">[</span>ch<span class="op">]==</span>q<span class="op">;</span>p<span class="op">=</span>st<span class="op">[</span>p<span class="op">].</span>fa<span class="op">){</span></span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>                st<span class="op">[</span>p<span class="op">].</span>next<span class="op">[</span>ch<span class="op">]=</span>r<span class="op">;</span></span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>cur<span class="op">].</span>fa <span class="op">=</span> st<span class="op">[</span>q<span class="op">].</span>fa <span class="op">=</span> r<span class="op">;</span></span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a>        last <span class="op">=</span> cur<span class="op">;</span></span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true" tabindex="-1"></a>SAM sam<span class="op">;</span></span></code></pre></div>
<h2 id="广义后缀自动机">广义后缀自动机</h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">//广义后缀自动机，其实就是插入多个字符串的后缀自动机，但只能离线build</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p6139</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">//后缀自动机的性质都可以用过来</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> State<span class="op">{</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fa<span class="op">,</span>len<span class="op">,</span>next<span class="op">[</span><span class="dv">26</span><span class="op">];</span><span class="co">//似乎有些编译器next是保留字，需要注意</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GSA<span class="op">{</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    State st<span class="op">[</span>MAXN<span class="op">&lt;&lt;</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cnt <span class="op">=</span> <span class="dv">1</span><span class="op">;</span><span class="co">//起始节点编号为1</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> insert<span class="op">(</span><span class="dt">int</span> last<span class="op">,</span> <span class="dt">int</span> ch<span class="op">){</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">//传入的是即将插入的字符的父节点编号，以及该字符</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">//只用在build里，不要直接把字符串插入，应该先insertTrie再build</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cur <span class="op">=</span> st<span class="op">[</span>last<span class="op">].</span>next<span class="op">[</span>ch<span class="op">];</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> p <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>cur<span class="op">].</span>len <span class="op">=</span> st<span class="op">[</span>last<span class="op">].</span>len <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span>p<span class="op">=</span>st<span class="op">[</span>last<span class="op">].</span>fa<span class="op">;</span>p <span class="op">&amp;&amp;</span> <span class="op">!</span>st<span class="op">[</span>p<span class="op">].</span>next<span class="op">[</span>ch<span class="op">];</span>p<span class="op">=</span>st<span class="op">[</span>p<span class="op">].</span>fa<span class="op">)</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>p<span class="op">].</span>next<span class="op">[</span>ch<span class="op">]</span> <span class="op">=</span> cur<span class="op">;</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> q <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>next<span class="op">[</span>ch<span class="op">];</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>q<span class="op">==</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>cur<span class="op">].</span>fa <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>st<span class="op">[</span>p<span class="op">].</span>len<span class="op">+</span><span class="dv">1</span><span class="op">==</span>st<span class="op">[</span>q<span class="op">].</span>len<span class="op">){</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>cur<span class="op">].</span>fa <span class="op">=</span> q<span class="op">;</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> r <span class="op">=</span> <span class="op">++</span>cnt<span class="op">;</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>r<span class="op">].</span>fa <span class="op">=</span> st<span class="op">[</span>q<span class="op">].</span>fa<span class="op">;</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span><span class="dv">26</span><span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>st<span class="op">[</span>st<span class="op">[</span>q<span class="op">].</span>next<span class="op">[</span>i<span class="op">]].</span>len<span class="op">)</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>                    st<span class="op">[</span>r<span class="op">].</span>next<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> st<span class="op">[</span>q<span class="op">].</span>next<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>r<span class="op">].</span>len <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>len<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(;</span>p <span class="op">&amp;&amp;</span> st<span class="op">[</span>p<span class="op">].</span>next<span class="op">[</span>ch<span class="op">]==</span>q<span class="op">;</span>p<span class="op">=</span>st<span class="op">[</span>p<span class="op">].</span>fa<span class="op">)</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>                st<span class="op">[</span>p<span class="op">].</span>next<span class="op">[</span>ch<span class="op">]</span> <span class="op">=</span> r<span class="op">;</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>cur<span class="op">].</span>fa <span class="op">=</span> st<span class="op">[</span>q<span class="op">].</span>fa <span class="op">=</span> r<span class="op">;</span></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cur<span class="op">;</span></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">//返回插入节点编号</span></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> build<span class="op">(){</span></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>queue<span class="op">&lt;</span>pii<span class="op">&gt;</span> qu<span class="op">;</span></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span><span class="dv">26</span><span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>st<span class="op">[</span><span class="dv">1</span><span class="op">].</span>next<span class="op">[</span>i<span class="op">])</span> qu<span class="op">.</span>push<span class="op">({</span><span class="dv">1</span><span class="op">,</span>i<span class="op">});</span></span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(!</span>qu<span class="op">.</span>empty<span class="op">()){</span></span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> fa <span class="op">=</span> qu<span class="op">.</span>front<span class="op">().</span>first<span class="op">;</span></span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> ch <span class="op">=</span> qu<span class="op">.</span>front<span class="op">().</span>second<span class="op">;</span></span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>            qu<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> p <span class="op">=</span> insert<span class="op">(</span>fa<span class="op">,</span>ch<span class="op">);</span></span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span><span class="dv">26</span><span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>st<span class="op">[</span>p<span class="op">].</span>next<span class="op">[</span>i<span class="op">])</span> qu<span class="op">.</span>push<span class="op">({</span>p<span class="op">,</span>i<span class="op">});</span></span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> insertTrie<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> str<span class="op">){</span></span>
<span id="cb13-62"><a href="#cb13-62" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cur <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-63"><a href="#cb13-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> c<span class="op">:</span>str<span class="op">){</span></span>
<span id="cb13-64"><a href="#cb13-64" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(!</span>st<span class="op">[</span>cur<span class="op">].</span>next<span class="op">[</span>c<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">]){</span></span>
<span id="cb13-65"><a href="#cb13-65" aria-hidden="true" tabindex="-1"></a>                st<span class="op">[</span>cur<span class="op">].</span>next<span class="op">[</span>c<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">]=++</span>cnt<span class="op">;</span></span>
<span id="cb13-66"><a href="#cb13-66" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb13-67"><a href="#cb13-67" aria-hidden="true" tabindex="-1"></a>            cur <span class="op">=</span> st<span class="op">[</span>cur<span class="op">].</span>next<span class="op">[</span>c<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">];</span></span>
<span id="cb13-68"><a href="#cb13-68" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-69"><a href="#cb13-69" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-70"><a href="#cb13-70" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb13-71"><a href="#cb13-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-72"><a href="#cb13-72" aria-hidden="true" tabindex="-1"></a>GSA gsa<span class="op">;</span></span>
<span id="cb13-73"><a href="#cb13-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-74"><a href="#cb13-74" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb13-75"><a href="#cb13-75" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb13-76"><a href="#cb13-76" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb13-77"><a href="#cb13-77" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-78"><a href="#cb13-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb13-79"><a href="#cb13-79" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string<span class="op"> </span>str<span class="op">;</span></span>
<span id="cb13-80"><a href="#cb13-80" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>str<span class="op">;</span></span>
<span id="cb13-81"><a href="#cb13-81" aria-hidden="true" tabindex="-1"></a>        gsa<span class="op">.</span>insertTrie<span class="op">(</span>str<span class="op">);</span></span>
<span id="cb13-82"><a href="#cb13-82" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-83"><a href="#cb13-83" aria-hidden="true" tabindex="-1"></a>    gsa<span class="op">.</span>build<span class="op">();</span></span>
<span id="cb13-84"><a href="#cb13-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-85"><a href="#cb13-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-86"><a href="#cb13-86" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="回文字动机">回文字动机</h2>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">//回文字动机，复杂度：线性</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p5496</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> State<span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> len<span class="op">,</span> fail<span class="op">,</span> next<span class="op">[</span><span class="dv">26</span><span class="op">];</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co">//PAM的每一个状态代表原字符串的一个回文子串，每一个转移代表从当前状态字符串的前后同时加一个相同字符后的状态。可以接受其所有回文子串。除了奇根都是可行状态（当然不能为空时偶根不可行）</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co">//fail指针指向该状态的最长回文真后缀。例如ayawaya就指向aba。总体和AC自动机的fail转移很像，都是没有ch的转移，则看fail有没有ch的转移，若fail没有则看fail[fail]的，以此类推。</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">//回文串分为奇长度和偶长度的，所以PAM有奇根和偶根，偶根的fail指向奇根，奇根不可能失配。</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co">//PAM和SAM一样是动态构建的。</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PAM<span class="op">{</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> last<span class="op">,</span>cnt<span class="op">,</span>pos<span class="op">;</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">//last代表上个前缀的最长回文后缀的状态</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    State st<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//最多有n+2个状态和n个转移</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>str<span class="op">;</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> init<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> s<span class="op">){</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>        last <span class="op">=</span> <span class="dv">1</span><span class="op">,</span>pos <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>        cnt <span class="op">=</span> <span class="dv">2</span><span class="op">;</span><span class="co">//起始两个根为1奇根，2偶根，len分别为-1和0</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span><span class="dv">1</span><span class="op">].</span>len <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> st<span class="op">[</span><span class="dv">2</span><span class="op">].</span>len <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> st<span class="op">[</span><span class="dv">2</span><span class="op">].</span>fail <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>        str <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> up<span class="op">(</span><span class="dt">int</span> p<span class="op">){</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>str<span class="op">[</span>pos<span class="op">-</span><span class="dv">1</span><span class="op">-</span>st<span class="op">[</span>p<span class="op">].</span>len<span class="op">]!=</span>str<span class="op">[</span>pos<span class="op">])</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>fail<span class="op">;</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> p<span class="op">;</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> insert<span class="op">(</span><span class="dt">int</span> ch<span class="op">){</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>        pos<span class="op">++;</span></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>        ch <span class="op">=</span> ch<span class="op">-</span><span class="ch">&#39;a&#39;</span><span class="op">;</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> p <span class="op">=</span> up<span class="op">(</span>last<span class="op">);</span></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="op">&amp;</span> q <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>next<span class="op">[</span>ch<span class="op">];</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>q<span class="op">){</span></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>            q<span class="op">=++</span>cnt<span class="op">;</span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>q<span class="op">].</span>len <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>len<span class="op">+</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>q<span class="op">].</span>fail <span class="op">=</span> p<span class="op">==</span><span class="dv">1</span> <span class="op">?</span> <span class="dv">2</span> <span class="op">:</span> st<span class="op">[</span>up<span class="op">(</span>st<span class="op">[</span>p<span class="op">].</span>fail<span class="op">)].</span>next<span class="op">[</span>ch<span class="op">];</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>        last <span class="op">=</span> q<span class="op">;</span></span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>PAM pam<span class="op">;</span></span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>str</span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>str<span class="op">;</span></span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a>    pam<span class="op">.</span>init<span class="op">(</span>str<span class="op">);</span></span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> c<span class="op">:</span>str<span class="op">){</span></span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a>        pam<span class="op">.</span>insert<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="序列自动机">序列自动机</h2>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">//序列自动机，复杂度 O(n|S|)</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p5826</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">//字符集很大时需要用可持久化线段树维护next</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> State<span class="op">{</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> next<span class="op">[</span><span class="dv">26</span><span class="op">];</span>  </span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">//SQA接受字符串的所有子序列（不需要连续，可以为空）</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SQA<span class="op">{</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    State st<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> build<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> str<span class="op">){</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> nxt<span class="op">[</span><span class="dv">26</span><span class="op">];</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>fill<span class="op">(</span>nxt<span class="op">,</span>nxt<span class="op">+</span><span class="dv">26</span><span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> str<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>n<span class="op">-</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&gt;=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">--){</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>            nxt<span class="op">[</span>str<span class="op">[</span>i<span class="op">]-</span><span class="ch">&#39;a&#39;</span><span class="op">]</span> <span class="op">=</span> i<span class="op">+</span><span class="dv">2</span><span class="op">;</span><span class="co">//1号节点是起始空节点</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> ch<span class="op">=</span><span class="dv">0</span><span class="op">;</span>ch<span class="op">&lt;</span><span class="dv">26</span><span class="op">;</span>ch<span class="op">++){</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>                st<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">].</span>next<span class="op">[</span>ch<span class="op">]</span> <span class="op">=</span> nxt<span class="op">[</span>ch<span class="op">];</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> query<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> str<span class="op">){</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">//查询str是否是子序列（可以不连续）</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> p <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> n<span class="op">=</span>str<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>next<span class="op">[</span>str<span class="op">[</span>i<span class="op">]-</span><span class="ch">&#39;a&#39;</span><span class="op">];</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>p<span class="op">==</span><span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>SQA sqa<span class="op">;</span></span></code></pre></div>
<h1 id="数论">数论</h1>
<h2 id="欧几里得算法">欧几里得算法</h2>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 logn</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu B3736</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">//gcd是可重复贡献的，gcd(x,x)=x，可以用st表维护区间gcd</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co">//x*y=gcd(x,y)*lcm(x,y)，lcm是最小公倍数</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">int</span> gcd<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span><span class="dt">int</span> b<span class="op">){</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> b<span class="op">==</span><span class="dv">0</span> <span class="op">?</span> a <span class="op">:</span> gcd<span class="op">(</span>b<span class="op">,</span> a<span class="op">%</span>b<span class="op">);</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">,</span>z<span class="op">;</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>x<span class="op">&gt;&gt;</span>y<span class="op">&gt;&gt;</span>z<span class="op">;</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>gcd<span class="op">(</span>gcd<span class="op">(</span>x<span class="op">,</span>y<span class="op">),</span>z<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="扩展欧几里得">扩展欧几里得</h2>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 logn</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">//求解ax+by=c的一组解，c不是gcd(a,b)的倍数则无解</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">//扩展欧几里得</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P5656</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> LL <span class="op">=</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>LL exgcd<span class="op">(</span>LL a<span class="op">,</span>LL b<span class="op">,</span>LL<span class="op">&amp;</span> x<span class="op">,</span>LL<span class="op">&amp;</span> y<span class="op">){</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//求出的是ax+by=gcd(a,b)的一组解，等于c的需要转换一下</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>b<span class="op">==</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span><span class="co">//此时ax+by=gcd(a,b)中b=0，任何数与0的最大公约数是他本身，所以ax+0y=a，x=1 y=0</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    LL d <span class="op">=</span> exgcd<span class="op">(</span>b<span class="op">,</span>a<span class="op">%</span>b<span class="op">,</span>y<span class="op">,</span>x<span class="op">);</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    y <span class="op">-=</span> <span class="op">(</span>a<span class="op">/</span>b<span class="op">)*</span>x<span class="op">;</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d<span class="op">;</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> T<span class="op">;</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>T<span class="op">;</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>T<span class="op">--){</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>        LL a<span class="op">,</span>b<span class="op">,</span>c<span class="op">;</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>a<span class="op">&gt;&gt;</span>b<span class="op">&gt;&gt;</span>c<span class="op">;</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>        LL x0<span class="op">=</span><span class="dv">0</span><span class="op">,</span> y0<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>        LL d <span class="op">=</span> exgcd<span class="op">(</span>a<span class="op">,</span>b<span class="op">,</span>x0<span class="op">,</span>y0<span class="op">);</span><span class="co">//d=gcd(a,b)</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>c<span class="op">%</span>d<span class="op">!=</span><span class="dv">0</span><span class="op">){</span><span class="co">//c不是gcd(a,b)的倍数则无解</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;-1</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>        LL x1 <span class="op">=</span> x0<span class="op">*</span>c<span class="op">/</span>d<span class="op">,</span> y1 <span class="op">=</span> y0<span class="op">*</span>c<span class="op">/</span>d<span class="op">;</span><span class="co">//ax+by=gcd(a,b)的一组解转化为ax+by=c的一组解</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">//通解的形式为x=x1+s*dx, y=y1-s*dy</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">//其中s为任意整数，dx=b/d, dy = a/d;</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>        LL dx <span class="op">=</span> b<span class="op">/</span>d<span class="op">,</span> dy <span class="op">=</span> a<span class="op">/</span>d<span class="op">;</span></span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>        LL l <span class="op">=</span> <span class="bu">std::</span>ceil<span class="op">((-</span>x1<span class="op">+</span><span class="fl">1.0</span><span class="op">)/</span>dx<span class="op">);</span></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>        LL r <span class="op">=</span> <span class="bu">std::</span>floor<span class="op">((</span>y1<span class="op">-</span><span class="fl">1.0</span><span class="op">)/</span>dy<span class="op">);</span></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">//x&gt;0,y&gt;0时，s的取值为[l,r]中的整数，若l&gt;r，则说明不存在正整数解</span></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>l<span class="op">&gt;</span>r<span class="op">){</span></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>x1<span class="op">+</span>l<span class="op">*</span>dx<span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span><span class="co">//所有解中x的最小正整数值</span></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>y1<span class="op">-</span>r<span class="op">*</span>dy<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span><span class="co">//所有解中y的最小正整数值</span></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>r<span class="op">-</span>l<span class="op">+</span><span class="dv">1</span><span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span><span class="co">//正整数解的个数</span></span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>x1<span class="op">+</span>l<span class="op">*</span>dx<span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span><span class="co">//正整数解中x的最小值</span></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>y1<span class="op">-</span>r<span class="op">*</span>dy<span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span><span class="co">//正整数解中y的最小值</span></span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>x1<span class="op">+</span>r<span class="op">*</span>dx<span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span><span class="co">//正整数解中x的最大值</span></span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>y1<span class="op">-</span>l<span class="op">*</span>dy<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span><span class="co">//正整数解中y的最大值</span></span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-54"><a href="#cb17-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-55"><a href="#cb17-55" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="欧拉筛">欧拉筛</h2>
<p>TODO: 用模板元编程实现编译期算素数</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 n</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="co">//欧拉筛, luogu p3383</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="fl">1e8</span><span class="op">+</span><span class="dv">5</span><span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> prime<span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isnp<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sieve<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">2</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>isnp<span class="op">[</span>i<span class="op">])</span> prime<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> p<span class="op">:</span>prime<span class="op">){</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>i<span class="op">*</span>p<span class="op">&gt;</span>n<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>            isnp<span class="op">[</span>i<span class="op">*</span>p<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>i<span class="op">%</span>p<span class="op">==</span><span class="dv">0</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="miller-rabin素数测试">Miller-Rabin素数测试</h2>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">//对数 n 进行 k 轮测试的时间复杂度是 klog^3(n)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">//miller-rabin</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">//loj 143</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">//通过测试的有可能是素数，不通过的一定不是素数</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;ctime&gt;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdint&gt;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> LL <span class="op">=</span> <span class="dt">__int128</span><span class="op">;</span><span class="co">//本题数据范围过大，防止运算中爆掉</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>LL <span class="at">const</span> test_time <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>LL qPowMod<span class="op">(</span>LL n<span class="op">,</span> LL p<span class="op">,</span> LL m<span class="op">){</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    LL res <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>p<span class="op">&gt;</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>p<span class="op">&amp;</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>            res <span class="op">=</span> <span class="op">(</span>res <span class="op">*</span> n<span class="op">)%</span>m<span class="op">;</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="op">(</span>n<span class="op">*</span>n<span class="op">)%</span>m<span class="op">;</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>        p<span class="op">&gt;&gt;=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> millerRabin<span class="op">(</span>LL n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">3</span> <span class="op">||</span> n <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> n <span class="op">==</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>    LL a <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> b <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>a <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> a <span class="op">/=</span> <span class="dv">2</span><span class="op">,</span> <span class="op">++</span>b<span class="op">;</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">// test_time 为测试次数,建议设为不小于 8</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 的整数以保证正确率,但也不宜过大,否则会影响效率</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>LL i <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> j<span class="op">;</span> i <span class="op">&lt;=</span> test_time<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>        LL x <span class="op">=</span> rand<span class="op">()</span> <span class="op">%</span> <span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">)</span> <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>        LL v <span class="op">=</span> qPowMod<span class="op">(</span>x<span class="op">,</span> a<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> b<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>v <span class="op">==</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> v <span class="op">*</span> v <span class="op">%</span> n<span class="op">;</span></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>j <span class="op">==</span> b<span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>    srand<span class="op">(</span>time<span class="op">(</span>NULL<span class="op">));</span></span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> n<span class="op">;</span></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span><span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">){</span></span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>millerRabin<span class="op">(</span>n<span class="op">)){</span></span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;Y</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;N</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="乘法逆元">乘法逆元</h2>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 扩展欧几里得法和费马小定理法都是logn</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">//乘法逆元</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">//ax≡1(mod b)，x为a在乘法意义上的逆元，记作a^(-1)，或者inv(a)</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">//用扩展欧几里得法的角度看，就是求ax+by=1的整数解</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">//快速幂法利用费马小定理，需要b为素数，并且疑似比exgcd常数大</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P3811，会TLE，需要线性求逆元</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co">//但loj 110不会TLE</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> exgcd<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span><span class="dt">int</span> b<span class="op">,</span><span class="dt">int</span><span class="op">&amp;</span> x<span class="op">,</span><span class="dt">int</span><span class="op">&amp;</span> y<span class="op">){</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>b<span class="op">==</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d <span class="op">=</span> exgcd<span class="op">(</span>b<span class="op">,</span>a<span class="op">%</span>b<span class="op">,</span>y<span class="op">,</span>x<span class="op">);</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    y <span class="op">-=</span> <span class="op">(</span>a<span class="op">/</span>b<span class="op">)*</span>x<span class="op">;</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d<span class="op">;</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> exgcd_inv<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">){</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">//a在模b意义下的逆元</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d <span class="op">=</span> exgcd<span class="op">(</span>a<span class="op">,</span>b<span class="op">,</span>x<span class="op">,</span>y<span class="op">);</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>d<span class="op">!=</span><span class="dv">1</span><span class="op">){</span><span class="co">//显然a，b要互质才会有逆元</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span><span class="op">{</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>x<span class="op">+</span>b<span class="op">)%</span>b<span class="op">;</span><span class="co">//实际上是为了防止出现x为负数的情况</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> qPowMod<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> p<span class="op">,</span> <span class="dt">int</span> mod<span class="op">){</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">//x^p % m</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>p<span class="op">){</span></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>p<span class="op">&amp;</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>            ans <span class="op">=</span> <span class="op">(</span>ans<span class="op">*</span>x<span class="op">)%</span>mod<span class="op">;</span></span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="op">(</span>x<span class="op">*</span>x<span class="op">)%</span>mod<span class="op">;</span></span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a>        p<span class="op">&gt;&gt;=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fermat_inv<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">){</span><span class="co">//a在模b意义下的逆元</span></span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> qPowMod<span class="op">(</span>a<span class="op">,</span>b<span class="op">-</span><span class="dv">2</span><span class="op">,</span>b<span class="op">);</span></span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="线性求逆元">线性求逆元</h2>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">//线性求逆元，对于1~n这些数，复杂度总共n</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p3381, loj 110</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> LL <span class="op">=</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">3000005</span><span class="op">;</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>LL inv<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getinv<span class="op">(</span>LL n<span class="op">,</span> LL m<span class="op">){</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//求1~n中，每个数在模m意义下的乘法逆元</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    inv<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>LL i<span class="op">=</span><span class="dv">2</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">//inv[i] = -(b/i)*inv[b%i]; //这样写会出现负数</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        inv<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>LL<span class="op">)(</span>m<span class="op">-</span>m<span class="op">/</span>i<span class="op">)*</span>inv<span class="op">[</span>m<span class="op">%</span>i<span class="op">]%</span>m<span class="op">;</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="线性同余方程">线性同余方程</h2>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 logn</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co">//ax≡c (mod b)求解x</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">//和ax+by=c等价</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p1082</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> exgcd<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span><span class="dt">int</span> b<span class="op">,</span><span class="dt">int</span><span class="op">&amp;</span> x<span class="op">,</span><span class="dt">int</span><span class="op">&amp;</span> y<span class="op">){</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>b<span class="op">==</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d <span class="op">=</span> exgcd<span class="op">(</span>b<span class="op">,</span>a<span class="op">%</span>b<span class="op">,</span>y<span class="op">,</span>x<span class="op">);</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    y <span class="op">-=</span> <span class="op">(</span>a<span class="op">/</span>b<span class="op">)*</span>x<span class="op">;</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d<span class="op">;</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> linearEquation<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">,</span> <span class="dt">int</span> c<span class="op">,</span> <span class="dt">int</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="dt">int</span> <span class="op">&amp;</span>y<span class="op">){</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d <span class="op">=</span> exgcd<span class="op">(</span>a<span class="op">,</span>b<span class="op">,</span>x<span class="op">,</span>y<span class="op">);</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>c<span class="op">%</span>d<span class="op">!=</span><span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> x<span class="op">*</span>c<span class="op">/</span>d<span class="op">;</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> y<span class="op">*</span>c<span class="op">/</span>d<span class="op">;</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d<span class="op">;</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">,</span>b<span class="op">,</span>c<span class="op">,</span>x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>    cin<span class="op">&gt;&gt;</span>a<span class="op">&gt;&gt;</span>b<span class="op">;</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>    c<span class="op">=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d <span class="op">=</span> linearEquation<span class="op">(</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">,</span>x<span class="op">,</span>y<span class="op">);</span></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">//d是a,b的最大公约数，如果无解d==-1</span></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">//下面输出的是最小整数解</span></span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> t <span class="op">=</span> b<span class="op">/</span>d<span class="op">;</span></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="op">(</span>x<span class="op">%</span>t<span class="op">+</span>t<span class="op">)%</span>t<span class="op">;</span></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>    cout<span class="op">&lt;&lt;</span>x<span class="op">&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="中国剩余定理">中国剩余定理</h2>
<p>求解如下方程中的<span class="math inline">\(x\)</span></p>
<p><span class="math display">\[
\left\{\begin{matrix}
x \equiv a_1(mod\quad r_1) \\
x \equiv a_2(mod\quad r_2 \\
\vdots \\
x \equiv a_k(mod\quad r_k)
\end{matrix}\right.
\]</span></p>
<p>其中<span class="math inline">\(r_i\)</span>两两互质，如果不满足则需要扩展CRT</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">//中国剩余定理 复杂度 klogk</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p1495</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll<span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">10005</span><span class="op">;</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>ll exgcd<span class="op">(</span>ll a<span class="op">,</span> ll b<span class="op">,</span> ll <span class="op">&amp;</span>x<span class="op">,</span> ll <span class="op">&amp;</span>y<span class="op">){</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(!</span>b<span class="op">){</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>        x<span class="op">=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        y<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    ll d <span class="op">=</span> exgcd<span class="op">(</span>b<span class="op">,</span>a<span class="op">%</span>b<span class="op">,</span>x<span class="op">,</span>y<span class="op">);</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    ll tmp <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> tmp <span class="op">-</span> <span class="op">(</span>a<span class="op">/</span>b<span class="op">)*</span>y<span class="op">;</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> d<span class="op">;</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>ll exgcd_inv<span class="op">(</span>ll a<span class="op">,</span> ll b<span class="op">){</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>    ll x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>    ll d <span class="op">=</span> exgcd<span class="op">(</span>a<span class="op">,</span>b<span class="op">,</span>x<span class="op">,</span>y<span class="op">);</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>x<span class="op">+</span>b<span class="op">)%</span>b<span class="op">;</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CRT<span class="op">{</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>    ll ax<span class="op">[</span>MAXN<span class="op">],</span>rx<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//每个方程的形式为x≡ai(mod ri)，要求ri互质</span></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k<span class="op">=</span><span class="dv">0</span><span class="op">;</span><span class="co">//k个方程</span></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> add<span class="op">(</span>ll a<span class="op">,</span> ll r<span class="op">){</span></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>        ax<span class="op">[++</span>k<span class="op">]</span> <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>        rx<span class="op">[</span>k<span class="op">]</span> <span class="op">=</span> r<span class="op">;</span></span>
<span id="cb23-34"><a href="#cb23-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-35"><a href="#cb23-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-36"><a href="#cb23-36" aria-hidden="true" tabindex="-1"></a>    ll solve<span class="op">(){</span></span>
<span id="cb23-37"><a href="#cb23-37" aria-hidden="true" tabindex="-1"></a>        ll n<span class="op">=</span><span class="dv">1</span><span class="op">,</span> ans<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb23-38"><a href="#cb23-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>k<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb23-39"><a href="#cb23-39" aria-hidden="true" tabindex="-1"></a>            n <span class="op">=</span> n <span class="op">*</span> rx<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb23-40"><a href="#cb23-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb23-41"><a href="#cb23-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>k<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb23-42"><a href="#cb23-42" aria-hidden="true" tabindex="-1"></a>            ll m <span class="op">=</span> n<span class="op">/</span>rx<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb23-43"><a href="#cb23-43" aria-hidden="true" tabindex="-1"></a>            ans <span class="op">=</span> <span class="op">(</span>ans<span class="op">+</span>ax<span class="op">[</span>i<span class="op">]*</span>m<span class="op">*</span>exgcd_inv<span class="op">(</span>m<span class="op">,</span>rx<span class="op">[</span>i<span class="op">]))%</span>n<span class="op">;</span></span>
<span id="cb23-44"><a href="#cb23-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb23-45"><a href="#cb23-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb23-46"><a href="#cb23-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb23-47"><a href="#cb23-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-48"><a href="#cb23-48" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb23-49"><a href="#cb23-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-50"><a href="#cb23-50" aria-hidden="true" tabindex="-1"></a>CRT crt<span class="op">;</span></span></code></pre></div>
<h2 id="积性函数">积性函数</h2>
<p>积性函数是数论函数的一种。数论函数则是定义域为正整数的函数。</p>
<p>若函数<span class="math inline">\(f(n)\)</span>满足<span class="math inline">\(f(1)=1\)</span>且<span class="math inline">\(\forall x,y\in N^*,gcd(x,y)=1\)</span>都有<span class="math inline">\(f(xy)=f(x)f(y)\)</span>，则<span class="math inline">\(f(n)\)</span>为积性函数</p>
<p>如果不要求<span class="math inline">\(gcd(x,y)=1\)</span>也有这个性质的函数叫完全积性函数。同理可知加性函数的定义。</p>
<p><strong>性质</strong></p>
<ol type="1">
<li>若<span class="math inline">\(f(x),g(x)\)</span>均为积性函数，则以下函数也是积性函数
<ol type="1">
<li><span class="math inline">\(h(x)=f(x^p)\)</span></li>
<li><span class="math inline">\(h(x)=f^p(x)\)</span></li>
<li><span class="math inline">\(h(x)=f(x)g(x)\)</span></li>
<li><span class="math inline">\(h(x)=\sum_{d|x}f(d)g(x/d)\)</span>（即狄利克雷卷积）</li>
<li>其逆元</li>
</ol></li>
<li>若<span class="math inline">\(f\)</span>是积性函数，且在算术基本定理中<span class="math inline">\(n=\prod^{m}_{i=1}p_i^{c_i}\)</span>，则<span class="math inline">\(f(n)=\prod^{m}_{i=1}f(p_i^{c_i})\)</span>。如果<span class="math inline">\(f\)</span>是完全积性函数，则<span class="math inline">\(f(n)=\prod^{m}_{i=1}f(p_i)^{c_i}\)</span></li>
</ol>
<p><strong>例子</strong></p>
<ol type="1">
<li><span class="math inline">\(\varepsilon(n)=[n=1]\)</span>，单位函数，括号是艾弗森括号，是完全积性。</li>
<li><span class="math inline">\(id_k(n)=n^k\)</span>，幂函数，是完全积性。<span class="math inline">\(k=1\)</span>是恒等函数<span class="math inline">\(id(n)=n\)</span>，<span class="math inline">\(k=0\)</span>是常数函数<span class="math inline">\(1(n)=1\)</span></li>
<li><span class="math inline">\(\sigma_k(n)=\sum_{d/n}d^k\)</span>，除数函数。当<span class="math inline">\(k=1\)</span>时，为因数和函数<span class="math inline">\(\sigma(n)\)</span>，当<span class="math inline">\(k=0\)</span>时为因数个数函数<span class="math inline">\(\sigma_0(n)\)</span></li>
<li>欧拉函数</li>
<li>莫比乌斯函数</li>
</ol>
<h2 id="欧拉函数-todo习题">欧拉函数 TODO：习题</h2>
<p><span class="math inline">\(1\sim N\)</span>中与<span class="math inline">\(N\)</span>互质的数的个数被称为欧拉函数，记为<span class="math inline">\(\varphi(N)\)</span></p>
<p>若在算数基本定理中，<span class="math inline">\(N=p_1^{c_1}p_2^{c_2}\cdots
p_m^{c_m}\)</span>，则</p>
<p><span class="math display">\[
\varphi(N)=N\times\dfrac{p_1-1}{p_1}\times\dfrac{p_2-1}{p_2}\times\cdots\times\dfrac{p_m-1}{p_m}
\]</span></p>
<p>欧拉函数也可以写成艾弗森括号的形式为</p>
<p><span class="math display">\[
\sum^n_{i=1}[\gcd(i,n)=1]
\]</span></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 根号n</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> phi<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">2</span><span class="op">;</span>i<span class="op">*</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>n<span class="op">%</span>i<span class="op">==</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>            ans <span class="op">=</span> ans<span class="op">/</span>i<span class="op">*(</span>i<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span><span class="op">(</span>n<span class="op">%</span>i<span class="op">==</span><span class="dv">0</span><span class="op">)</span> n<span class="op">/=</span>i<span class="op">;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>n<span class="op">&gt;</span><span class="dv">1</span><span class="op">)</span> ans <span class="op">=</span> ans<span class="op">/</span>n<span class="op">*(</span>n<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>欧拉函数有以下性质</p>
<ol type="1">
<li><span class="math inline">\(\forall n&gt;1\)</span>，<span class="math inline">\(1\sim n\)</span>中与<span class="math inline">\(n\)</span>互质的数的和为<span class="math inline">\(n\times\varphi(n)/2\)</span></li>
<li>若<span class="math inline">\(a,b\)</span>互质，则<span class="math inline">\(\varphi(ab)=\varphi(a)\varphi(b)\)</span>。也就是说欧拉函数是积性函数</li>
<li>设<span class="math inline">\(p\)</span>为质数，若<span class="math inline">\(p|n\)</span>且<span class="math inline">\(p^2|n\)</span>，则<span class="math inline">\(\varphi(n)=\varphi(n/p)\times p\)</span></li>
<li>设<span class="math inline">\(p\)</span>为质数，若<span class="math inline">\(p|n\)</span>但不满足<span class="math inline">\(p^2|n\)</span>，则<span class="math inline">\(\varphi(n)=\varphi(n/p)\times (p-1)\)</span></li>
<li><span class="math inline">\(\sum_{d|n}\varphi(d)=n\)</span></li>
<li>若<span class="math inline">\(p\)</span>是质数，则<span class="math inline">\(\varphi(p^n)=p^{n-1}(p-1)\)</span></li>
<li>若<span class="math inline">\(a|x\)</span>，则<span class="math inline">\(\varphi(ax)=a\varphi(x)\)</span></li>
</ol>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">//求1-N的所有欧拉函数值，使用筛法，埃氏筛复杂度NloglogN，线性筛复杂度N，这里是线性筛</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> prime<span class="op">;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isnp<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> phi<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> euler<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    phi<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">2</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>isnp<span class="op">[</span>i<span class="op">]){</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>            prime<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>            phi<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i<span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> p<span class="op">:</span>prime<span class="op">){</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>i<span class="op">*</span>p<span class="op">&gt;</span>n<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>            isnp<span class="op">[</span>i<span class="op">*</span>p<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>i<span class="op">%</span>p<span class="op">==</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>                phi<span class="op">[</span>i<span class="op">*</span>p<span class="op">]</span> <span class="op">=</span> phi<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> p<span class="op">;</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span><span class="op">{</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>                phi<span class="op">[</span>i<span class="op">*</span>p<span class="op">]</span> <span class="op">=</span> phi<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> phi<span class="op">[</span>p<span class="op">];</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="狄利克雷卷积">狄利克雷卷积</h2>
<p>两个数论函数<span class="math inline">\(f(n),g(n)\)</span>的狄利克雷卷积定义为</p>
<p><span class="math display">\[
(f\ast g)(n) = \sum_{xy=n}f(x)g(y)
\]</span></p>
<p>也可以写作</p>
<p><span class="math display">\[
(f\ast g)(n) = \sum_{d|n}f(d)g(n/d)
\]</span></p>
<p><strong>性质</strong></p>
<ol type="1">
<li>两个积性函数的卷积还是积性函数</li>
<li><span class="math inline">\((f\ast 1)(n) =
\sum_{d|n}f(d)\)</span></li>
<li><span class="math inline">\((id_k\ast
1)(n)=\sum_{d|n}d^k=\sigma_k\)</span></li>
<li><span class="math inline">\(\varphi\ast 1=id\)</span></li>
<li>满足交换率、结合律、对加法的分配律</li>
<li>等式性质，<span class="math inline">\(f=g\)</span>的充要条件是<span class="math inline">\(f\ast h = g\ast h\)</span>，其中数论函数<span class="math inline">\(h(1)\neq 0\)</span></li>
<li>幺元是<span class="math inline">\(\varepsilon\)</span>，即<span class="math inline">\(f\ast \varepsilon=f\)</span></li>
<li>逆元，即满足<span class="math inline">\(f\ast
g=\varepsilon\)</span>的函数<span class="math inline">\(g\)</span>为（显然<span class="math inline">\(f(1)\neq 0\)</span>才有逆元）</li>
</ol>
<p><span class="math display">\[
g(x)=\dfrac{\varepsilon(x)-\sum_{d|x,d\neq 1}f(d)g(x/d)}{f(1)}
\]</span> 9. 积性函数一定有逆元，且逆元也是积性函数。</p>
<h2 id="莫比乌斯反演-todo习题">莫比乌斯反演 TODO：习题</h2>
<p>莫比乌斯函数是常数函数<span class="math inline">\(1\)</span>的逆元。即</p>
<p><span class="math display">\[
\mu(n) = \left\{\begin{matrix}
1, &amp; n=1 \\
(-1)^m  &amp; n=p_1p_2\cdots p_m\\
0  &amp; \text{otherwise}
\end{matrix}\right.
\]</span></p>
<p>其中第二个条件就是<span class="math inline">\(n\)</span>质因数分解后每个因子的次数是<span class="math inline">\(1\)</span></p>
<p>莫比乌斯反演公式即为</p>
<p><span class="math display">\[
g(n)=\sum_{d|n}f(d)\Leftrightarrow f(n) = \sum_{d|n}\mu(d)g(n/d)
\]</span></p>
<p>用狄利克雷卷积来写就是</p>
<p><span class="math display">\[
f\ast 1=g\Leftrightarrow f=g\ast \mu
\]</span></p>
<p>还有一种形式（倍数形式，之前的叫因数形式）是</p>
<p><span class="math display">\[
g(n) = \sum_{n|N}f(N)\Leftrightarrow f(n) = \sum_{n|N}\mu(N/n)g(N)
\]</span></p>
<p><strong>性质</strong></p>
<ol type="1">
<li>是积性函数</li>
<li><span class="math inline">\(\sum_{d|n}\mu(d)=\varepsilon(n),\mu\ast
1=\varepsilon\)</span></li>
<li><span class="math inline">\(\sum_{d|\gcd(i,j)}\mu(d)=[\gcd(i,j)=1]\)</span></li>
</ol>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">//线性筛求莫比乌斯函数，复杂度n</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> mu<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> prime<span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isnp<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mobius<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    mu<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">2</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>isnp<span class="op">[</span>i<span class="op">]){</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>            prime<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>            mu<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> p<span class="op">:</span>prime<span class="op">){</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>i<span class="op">*</span>p<span class="op">&gt;</span>n<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>            isnp<span class="op">[</span>i<span class="op">*</span>p<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>i<span class="op">%</span>p<span class="op">==</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>                mu<span class="op">[</span>i<span class="op">*</span>p<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span><span class="op">{</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>                mu<span class="op">[</span>i<span class="op">*</span>p<span class="op">]</span> <span class="op">=</span> mu<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> mu<span class="op">[</span>p<span class="op">];</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="数论分块">数论分块</h2>
<p>在计算形如</p>
<p><span class="math display">\[
\sum^n_{i=1}f(i)g(\left \lfloor \dfrac{n}{i} \right \rfloor )
\]</span></p>
<p>的式子时，注意到<span class="math inline">\(\left \lfloor
\dfrac{n}{i} \right \rfloor\)</span>的取值个数会比<span class="math inline">\(n\)</span>小很多，我们可以将取值相同的合在一起计算。如果可以在<span class="math inline">\(O(1)\)</span>内计算<span class="math inline">\(f(l)+\cdots+f(r)\)</span>（比如等差数列求和公式）或者有<span class="math inline">\(f\)</span>的前缀和时，数论分块可以在<span class="math inline">\(O(\sqrt{n})\)</span>计算和式的值。</p>
<p><strong>定理1</strong></p>
<p><span class="math display">\[
\forall a,b,c\in Z, \left \lfloor \dfrac{a}{bc} \right \rfloor=\left
\lfloor \dfrac{\left \lfloor \dfrac{a}{b} \right \rfloor}{c} \right
\rfloor
\]</span></p>
<p><strong>定理2</strong></p>
<p>当<span class="math inline">\(i\)</span>取正整数且<span class="math inline">\(i\leq n\)</span>时，<span class="math inline">\(\left \lfloor \dfrac{n}{i} \right
\rfloor\)</span>的不同取值的数量不超过<span class="math inline">\(\left
\lfloor 2\sqrt n \right \rfloor\)</span></p>
<p><strong>定理3</strong></p>
<p>使得式子</p>
<p><span class="math display">\[
\left \lfloor \dfrac{n}{i} \right \rfloor = \left \lfloor \dfrac{n}{j}
\right \rfloor
\]</span></p>
<p>成立的最大的满足<span class="math inline">\(i\leq j\leq
n\)</span>的<span class="math inline">\(j\)</span>值是<span class="math inline">\(\left \lfloor \dfrac{n}{\left \lfloor \dfrac{n}{i}
\right \rfloor} \right \rfloor\)</span>。也就是这个分块的右端点。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">//UVA 11526</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="co">//数论分块模板 复杂度sqrt n</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co">//要求计算i=1~n, ans = ans+n/i</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">(){</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    LL n<span class="op">;</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    LL ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    LL l <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> r <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>l<span class="op">&lt;=</span>n<span class="op">){</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> n<span class="op">/(</span>n<span class="op">/</span>l<span class="op">);</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">+=</span> <span class="op">(</span>r<span class="op">-</span>l<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span>n<span class="op">/</span>l<span class="op">);</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> r<span class="op">+</span><span class="dv">1</span><span class="op">;</span>  </span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>注意如果不是<span class="math inline">\(\left \lfloor \dfrac{n}{i}
\right \rfloor\)</span>而是某个<span class="math inline">\(\left \lfloor
\dfrac{k}{i} \right \rfloor\)</span>，要注意特判判<span class="math inline">\(k/l\)</span>等于<span class="math inline">\(0\)</span>，以及<span class="math inline">\(r\)</span>要特判不能超过<span class="math inline">\(n\)</span>。</p>
<p>当有多个取整<span class="math inline">\(\left \lfloor \dfrac{a_1}{i}
\right \rfloor,\left \lfloor \dfrac{a_2}{i} \right
\rfloor,\cdots\)</span>
时，我们取的右端点就变成每一个块的右端点的最小值。</p>
<h2 id="杜教筛">杜教筛</h2>
<p>杜教筛可以在<span class="math inline">\(O(n^{2/3})\)</span>的时间复杂度下求得一类数论函数（不一定需要积性）<span class="math inline">\(f(n)\)</span>的前缀和。</p>
<p>我们需要找到一个数论函数<span class="math inline">\(g(n)\)</span>，使得<span class="math inline">\(g(n)\)</span>和<span class="math inline">\(f\ast
g(n)\)</span>的前缀和都很容易求出（最好在<span class="math inline">\(O(1)\)</span>），那我们就能以低于线性复杂度的算法求出<span class="math inline">\(f(n)\)</span>的前缀和<span class="math inline">\(S(n)\)</span>。证明略，结论为：</p>
<p><span class="math display">\[
g(1)S(n) = \sum^n_{i=1}(f\ast g)(i)-\sum^n_{i=2}g(i)S(\left \lfloor
\dfrac{n}{i} \right \rfloor)
\]</span></p>
<p><strong>筛莫比乌斯函数</strong></p>
<p>之前我们学到<span class="math inline">\(\mu\ast
1=\varepsilon\)</span>，所以我们自然的令<span class="math inline">\(g(n)=1\)</span>，得到</p>
<p><span class="math display">\[
S(n)=\sum^n_{i=1}\varepsilon(i)-\sum^n_{i=2}S(\left \lfloor \dfrac{n}{i}
\right \rfloor) = 1-\sum^n_{i=2}S(\left \lfloor \dfrac{n}{i} \right
\rfloor)
\]</span></p>
<p>此时如果我们直接用数论分块去算<span class="math inline">\(S(n)\)</span>，我们的算法复杂度是<span class="math inline">\(O(n^{3/4})\)</span>，但是如果我们用线性筛预处理前<span class="math inline">\(n^{2/3}\)</span>的<span class="math inline">\(S(n)\)</span>的值，就可以优化复杂度到<span class="math inline">\(O(n^{2/3})\)</span>，通常我们还会开一个哈希表去维护大于<span class="math inline">\(n^{2/3}\)</span>的值来优化。</p>
<p><strong>筛欧拉函数</strong></p>
<p>同样取<span class="math inline">\(g(n)=1\)</span>，有<span class="math inline">\(\varphi(n)\ast 1=id\)</span></p>
<p><span class="math display">\[
S(n) = \sum^n_{i=1}id-\sum^n_{i=2}S(\left \lfloor \dfrac{n}{i} \right
\rfloor) = \dfrac{n(1+n)}{2}-\sum^n_{i=2}S(\left \lfloor \dfrac{n}{i}
\right \rfloor)
\]</span></p>
<p>跟之前可以说没什么区别。</p>
<p>给出求欧拉函数和莫比乌斯函数前缀和的例子代码。这里筛法一次把两个函数都筛了，其他不难理解。注意要用unordered_map以及数论分块的时候<span class="math inline">\(l\)</span>从<span class="math inline">\(2\)</span>开始。以及洛谷上这题数据范围为2^31，要筛出大概前170w个数。我筛了200w也过了，分类讨论，前200w直接返回，大于200w的如果在map里就返回，否则递归计算后放入map里。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">//杜教筛 复杂度n^(2/3)</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p4213</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">2000005</span><span class="op">;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> mu<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>LL phi<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> prime<span class="op">;</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isnp<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>LL sum_mu<span class="op">[</span>MAXN<span class="op">],</span>sum_phi<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>unordered_map<span class="op">&lt;</span>LL<span class="op">,</span>LL<span class="op">&gt;</span> mp_mu<span class="op">,</span>mp_phi<span class="op">;</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sieve<span class="op">(</span><span class="dt">int</span> n<span class="op">=</span>MAXN<span class="op">-</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    mu<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>    phi<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">2</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>isnp<span class="op">[</span>i<span class="op">]){</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>            prime<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>            mu<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>            phi<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i<span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> p<span class="op">:</span>prime<span class="op">){</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>i<span class="op">*</span>p<span class="op">&gt;</span>n<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>            isnp<span class="op">[</span>i<span class="op">*</span>p<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>i<span class="op">%</span>p<span class="op">==</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>                mu<span class="op">[</span>i<span class="op">*</span>p<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>                phi<span class="op">[</span>i<span class="op">*</span>p<span class="op">]</span> <span class="op">=</span> phi<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> p<span class="op">;</span></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span><span class="op">{</span></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>                mu<span class="op">[</span>i<span class="op">*</span>p<span class="op">]</span> <span class="op">=</span> mu<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> mu<span class="op">[</span>p<span class="op">];</span></span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>                phi<span class="op">[</span>i<span class="op">*</span>p<span class="op">]</span> <span class="op">=</span> phi<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> phi<span class="op">[</span>p<span class="op">];</span></span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>        sum_mu<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> sum_mu<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]+</span>mu<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>        sum_phi<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> sum_phi<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]+</span>phi<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a>LL sum1<span class="op">(</span>LL n<span class="op">){</span></span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>n<span class="op">&lt;</span>MAXN<span class="op">){</span></span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sum_phi<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>mp_phi<span class="op">.</span>count<span class="op">(</span>n<span class="op">)){</span></span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mp_phi<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb28-48"><a href="#cb28-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-49"><a href="#cb28-49" aria-hidden="true" tabindex="-1"></a>    LL l<span class="op">=</span><span class="dv">2</span><span class="op">,</span> r<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-50"><a href="#cb28-50" aria-hidden="true" tabindex="-1"></a>    LL ret <span class="op">=</span> n<span class="op">*(</span><span class="dv">1</span><span class="op">+</span>n<span class="op">)/</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb28-51"><a href="#cb28-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>l<span class="op">&lt;=</span>n<span class="op">){</span></span>
<span id="cb28-52"><a href="#cb28-52" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> n<span class="op">/(</span>n<span class="op">/</span>l<span class="op">);</span></span>
<span id="cb28-53"><a href="#cb28-53" aria-hidden="true" tabindex="-1"></a>        ret <span class="op">-=</span> <span class="op">(</span>r<span class="op">-</span>l<span class="op">+</span><span class="dv">1</span><span class="op">)*</span>sum1<span class="op">(</span>n<span class="op">/</span>l<span class="op">);</span></span>
<span id="cb28-54"><a href="#cb28-54" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> r<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-55"><a href="#cb28-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-56"><a href="#cb28-56" aria-hidden="true" tabindex="-1"></a>    mp_phi<span class="op">[</span>n<span class="op">]</span> <span class="op">=</span> ret<span class="op">;</span></span>
<span id="cb28-57"><a href="#cb28-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb28-58"><a href="#cb28-58" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-59"><a href="#cb28-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-60"><a href="#cb28-60" aria-hidden="true" tabindex="-1"></a>LL sum2<span class="op">(</span>LL n<span class="op">){</span></span>
<span id="cb28-61"><a href="#cb28-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>n<span class="op">&lt;</span>MAXN<span class="op">){</span></span>
<span id="cb28-62"><a href="#cb28-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sum_mu<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb28-63"><a href="#cb28-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-64"><a href="#cb28-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>mp_mu<span class="op">.</span>count<span class="op">(</span>n<span class="op">)){</span></span>
<span id="cb28-65"><a href="#cb28-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mp_mu<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb28-66"><a href="#cb28-66" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-67"><a href="#cb28-67" aria-hidden="true" tabindex="-1"></a>    LL l<span class="op">=</span><span class="dv">2</span><span class="op">,</span> r<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-68"><a href="#cb28-68" aria-hidden="true" tabindex="-1"></a>    LL ret <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-69"><a href="#cb28-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>l<span class="op">&lt;=</span>n<span class="op">){</span></span>
<span id="cb28-70"><a href="#cb28-70" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> n<span class="op">/(</span>n<span class="op">/</span>l<span class="op">);</span></span>
<span id="cb28-71"><a href="#cb28-71" aria-hidden="true" tabindex="-1"></a>        ret <span class="op">-=</span> <span class="op">(</span>r<span class="op">-</span>l<span class="op">+</span><span class="dv">1</span><span class="op">)*</span>sum2<span class="op">(</span>n<span class="op">/</span>l<span class="op">);</span></span>
<span id="cb28-72"><a href="#cb28-72" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> r<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-73"><a href="#cb28-73" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-74"><a href="#cb28-74" aria-hidden="true" tabindex="-1"></a>    mp_mu<span class="op">[</span>n<span class="op">]</span> <span class="op">=</span> ret<span class="op">;</span></span>
<span id="cb28-75"><a href="#cb28-75" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb28-76"><a href="#cb28-76" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-77"><a href="#cb28-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-78"><a href="#cb28-78" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">(){</span></span>
<span id="cb28-79"><a href="#cb28-79" aria-hidden="true" tabindex="-1"></a>    LL n<span class="op">;</span></span>
<span id="cb28-80"><a href="#cb28-80" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb28-81"><a href="#cb28-81" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>sum1<span class="op">(</span>n<span class="op">)&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">&lt;&lt;</span>sum2<span class="op">(</span>n<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb28-82"><a href="#cb28-82" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-83"><a href="#cb28-83" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-84"><a href="#cb28-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-85"><a href="#cb28-85" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb28-86"><a href="#cb28-86" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb28-87"><a href="#cb28-87" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb28-88"><a href="#cb28-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-89"><a href="#cb28-89" aria-hidden="true" tabindex="-1"></a>    sieve<span class="op">();</span></span>
<span id="cb28-90"><a href="#cb28-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-91"><a href="#cb28-91" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> T<span class="op">;</span></span>
<span id="cb28-92"><a href="#cb28-92" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>T<span class="op">;</span></span>
<span id="cb28-93"><a href="#cb28-93" aria-hidden="true" tabindex="-1"></a>    <span class="co">//T=1;</span></span>
<span id="cb28-94"><a href="#cb28-94" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>T<span class="op">--){</span></span>
<span id="cb28-95"><a href="#cb28-95" aria-hidden="true" tabindex="-1"></a>        solve<span class="op">();</span></span>
<span id="cb28-96"><a href="#cb28-96" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-97"><a href="#cb28-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-98"><a href="#cb28-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-99"><a href="#cb28-99" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="图论">图论</h1>
<h2 id="存图">存图</h2>
<h3 id="邻接矩阵">邻接矩阵</h3>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> graph<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="co">//加边删边、访问很方便，a-&gt;b，权值为w，则graph[a][b]=w</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co">//空间占用大，并且不能存重边</span></span></code></pre></div>
<h3 id="邻接表vector版">邻接表（vector版）</h3>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">,</span>w<span class="op">;</span><span class="co">//下一点，权</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Edge<span class="op">&gt;</span> edges<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="co">//加边u-&gt;v,权值w</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>edges<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>w<span class="op">);</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="co">//访问只能遍历u所连的出边</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> x<span class="op">:</span>edges<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>x<span class="op">.</span>v<span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">&lt;&lt;</span>x<span class="op">.</span>w<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a><span class="co">//缺点是，删边难，以及清空边复杂度过高。快速清边见链式前向星传统数组版</span></span></code></pre></div>
<h3 id="链式前向星vector版">链式前向星（vector版）</h3>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">;</span>LL w<span class="op">;</span><span class="co">//指向的点，容量</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    Edge<span class="op">(</span><span class="dt">int</span> <span class="va">v_</span><span class="op">,</span> LL <span class="va">w_</span><span class="op">):</span>v<span class="op">(</span><span class="va">v_</span><span class="op">),</span>w<span class="op">(</span><span class="va">w_</span><span class="op">){}</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Edge<span class="op">&gt;</span> edges<span class="op">;</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&gt;</span> graph<span class="op">(</span>MAXN<span class="op">);</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="co">//常用于网络流，例如加u-&gt;v，权值为w，及其反向边v-&gt;w，权值为0</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>graph<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>v<span class="op">,</span>w<span class="op">));</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>graph<span class="op">[</span>v<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>u<span class="op">,</span><span class="dv">0</span><span class="op">));</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a><span class="co">//遍历u的边时</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> x<span class="op">:</span>graph<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> e<span class="op">=</span>edges<span class="op">[</span>x<span class="op">];</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v<span class="op">=</span>e<span class="op">.</span>v<span class="op">,</span> w<span class="op">=</span>e<span class="op">.</span>w<span class="op">;</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">//e的反向边就是edges[x^1]</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a><span class="co">//清空某个点连出的所有边时，graph[u].clear()，不需要管edges的size</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a><span class="co">//清楚整个图时edges.clear()，graph要对每个下标clear</span></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a><span class="co">//这种清楚方式复杂度比传统数组版高很多，需要反复建图时不推荐使用。</span></span></code></pre></div>
<h3 id="链式前向星传统数组版">链式前向星（传统数组版）</h3>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">,</span>w<span class="op">,</span>next<span class="op">;</span><span class="co">//指向的点，边权，下一条边</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>Edge edges<span class="op">[</span>MAXM<span class="op">];</span><span class="co">//存无向图记得开两倍</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> head<span class="op">[</span>MAXN<span class="op">],</span>cnt<span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">void</span> add<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> v<span class="op">,</span> <span class="dt">int</span> w<span class="op">){</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">[++</span>cnt<span class="op">].</span>w <span class="op">=</span> w<span class="op">;</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">[</span>cnt<span class="op">].</span>v <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">[</span>cnt<span class="op">].</span>next <span class="op">=</span> head<span class="op">[</span>u<span class="op">];</span><span class="co">//把下一条边设置为当前起点的第一条边</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    head<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> cnt<span class="op">;</span><span class="co">//该边称为当前起点的第一条边</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a><span class="co">//遍历，与vector版不同，vector版按加入先后顺序遍历，而这里是反向顺序遍历。绝大多数情况不影响</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a><span class="co">//例如遍历1号节点所连的边</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="dt">int</span> e<span class="op">=</span>head<span class="op">[</span><span class="dv">1</span><span class="op">];</span>e<span class="op">;</span>e<span class="op">=</span>edges<span class="op">[</span>e<span class="op">].</span>next<span class="op">){</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>edges<span class="op">[</span>e<span class="op">].</span>v<span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">&lt;&lt;</span>edges<span class="op">[</span>e<span class="op">].</span>w<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a><span class="co">//当需要清空某个点的所有连出边时, head[u] = 0，不需要管cnt</span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a><span class="co">//清空全图时，cnt = 0, 对于所有点head = 0， 由于还可以用memset，比vector版更是快了不少</span></span></code></pre></div>
<h2 id="最短路">最短路</h2>
<h3 id="dijkstra">Dijkstra</h3>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 优先队列实现为mlogm</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="co">//dijkstra，单源最短路</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p4779</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">500005</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXINT </span><span class="bn">0x7fffffff</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">,</span>w<span class="op">;</span><span class="co">//下一点，权</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    Edge<span class="op">(</span><span class="dt">int</span> <span class="va">v_</span><span class="op">,</span> <span class="dt">int</span> <span class="va">w_</span><span class="op">):</span>v<span class="op">(</span><span class="va">v_</span><span class="op">),</span>w<span class="op">(</span><span class="va">w_</span><span class="op">){}</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dis<span class="op">,</span> u<span class="op">;</span><span class="co">//存储起点到u点的距离</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">(</span><span class="dt">int</span> <span class="va">dis_</span><span class="op">,</span> <span class="dt">int</span> <span class="va">u_</span><span class="op">):</span>dis<span class="op">(</span><span class="va">dis_</span><span class="op">),</span>u<span class="op">(</span><span class="va">u_</span><span class="op">){};</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;(</span>Node <span class="at">const</span> <span class="op">&amp;</span> a<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> dis <span class="op">&gt;</span> a<span class="op">.</span>dis<span class="op">;</span> <span class="op">}</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Edge<span class="op">&gt;</span> graph<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dis<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> tag<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>priority_queue<span class="op">&lt;</span>Node<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>Node<span class="op">&gt;,</span> <span class="bu">std::</span>greater<span class="op">&lt;</span>Node<span class="op">&gt;</span> <span class="op">&gt;</span> pq<span class="op">;</span></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>        dis<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> MAXINT<span class="op">;</span></span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">//初始化为无限远</span></span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a>        tag<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>i<span class="op">].</span>clear<span class="op">();</span></span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(!</span>pq<span class="op">.</span>empty<span class="op">())</span> pq<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dijk<span class="op">(</span><span class="dt">int</span> s<span class="op">){</span></span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true" tabindex="-1"></a>    dis<span class="op">[</span>s<span class="op">]=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true" tabindex="-1"></a>    pq<span class="op">.</span>push<span class="op">(</span>Node<span class="op">(</span><span class="dv">0</span><span class="op">,</span>s<span class="op">));</span></span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-42"><a href="#cb33-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>pq<span class="op">.</span>empty<span class="op">())</span></span>
<span id="cb33-43"><a href="#cb33-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb33-44"><a href="#cb33-44" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> pq<span class="op">.</span>top<span class="op">().</span>u<span class="op">;</span></span>
<span id="cb33-45"><a href="#cb33-45" aria-hidden="true" tabindex="-1"></a>        pq<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb33-46"><a href="#cb33-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>tag<span class="op">[</span>u<span class="op">])</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb33-47"><a href="#cb33-47" aria-hidden="true" tabindex="-1"></a>        tag<span class="op">[</span>u<span class="op">]=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb33-48"><a href="#cb33-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> g <span class="op">:</span> graph<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb33-49"><a href="#cb33-49" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> v <span class="op">=</span> g<span class="op">.</span>v<span class="op">,</span> w <span class="op">=</span> g<span class="op">.</span>w<span class="op">;</span></span>
<span id="cb33-50"><a href="#cb33-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>dis<span class="op">[</span>v<span class="op">]&gt;</span>dis<span class="op">[</span>u<span class="op">]+</span>w<span class="op">){</span></span>
<span id="cb33-51"><a href="#cb33-51" aria-hidden="true" tabindex="-1"></a>                dis<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> dis<span class="op">[</span>u<span class="op">]+</span>w<span class="op">;</span></span>
<span id="cb33-52"><a href="#cb33-52" aria-hidden="true" tabindex="-1"></a>                pq<span class="op">.</span>push<span class="op">(</span>Node<span class="op">(</span>dis<span class="op">[</span>v<span class="op">],</span>v<span class="op">));</span></span>
<span id="cb33-53"><a href="#cb33-53" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb33-54"><a href="#cb33-54" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb33-55"><a href="#cb33-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb33-56"><a href="#cb33-56" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb33-57"><a href="#cb33-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-58"><a href="#cb33-58" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb33-59"><a href="#cb33-59" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb33-60"><a href="#cb33-60" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb33-61"><a href="#cb33-61" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">,</span>s<span class="op">;</span></span>
<span id="cb33-62"><a href="#cb33-62" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">&gt;&gt;</span>s<span class="op">;</span></span>
<span id="cb33-63"><a href="#cb33-63" aria-hidden="true" tabindex="-1"></a>    <span class="co">//点数，边数，起点</span></span>
<span id="cb33-64"><a href="#cb33-64" aria-hidden="true" tabindex="-1"></a>    init<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb33-65"><a href="#cb33-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-66"><a href="#cb33-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb33-67"><a href="#cb33-67" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span>v<span class="op">,</span>w<span class="op">;</span></span>
<span id="cb33-68"><a href="#cb33-68" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>u<span class="op">&gt;&gt;</span>v<span class="op">&gt;&gt;</span>w<span class="op">;</span><span class="co">//起点，终点，边权</span></span>
<span id="cb33-69"><a href="#cb33-69" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>Edge<span class="op">(</span>v<span class="op">,</span>w<span class="op">));</span></span>
<span id="cb33-70"><a href="#cb33-70" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb33-71"><a href="#cb33-71" aria-hidden="true" tabindex="-1"></a>    dijk<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb33-72"><a href="#cb33-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-73"><a href="#cb33-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb33-74"><a href="#cb33-74" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>dis<span class="op">[</span>i<span class="op">]&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span></span>
<span id="cb33-75"><a href="#cb33-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb33-76"><a href="#cb33-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb33-77"><a href="#cb33-77" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="bellman-ford">Bellman-Ford</h3>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 nm</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co">//bellman-ford, 单源最短路</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p4779，有一个点TLE</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">100005</span><span class="op">;</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> INF <span class="op">=</span> <span class="bn">0x6fffffff</span><span class="op">;</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">,</span>w<span class="op">;</span><span class="co">//下一点,权</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    Edge<span class="op">(</span><span class="dt">int</span> <span class="va">v_</span><span class="op">,</span> <span class="dt">int</span> <span class="va">w_</span><span class="op">):</span>v<span class="op">(</span><span class="va">v_</span><span class="op">),</span>w<span class="op">(</span><span class="va">w_</span><span class="op">){}</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dis<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Edge<span class="op">&gt;</span> graph<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>        dis<span class="op">[</span>i<span class="op">]=</span>INF<span class="op">;</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>i<span class="op">].</span>clear<span class="op">();</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> BF<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> s<span class="op">){</span></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">//如果不存在最短路就返回0，否则返回1</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>    dis<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> flag <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span><span class="co">//松弛n-1轮，若第n轮还能松弛，就说明有负环</span></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>        flag <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> u<span class="op">=</span><span class="dv">1</span><span class="op">;</span>u<span class="op">&lt;=</span>n<span class="op">;</span>u<span class="op">++){</span><span class="co">//这里看似是两层循环，实际上总数是边数，整个算法的复杂度是mn</span></span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> graph<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> w<span class="op">=</span>e<span class="op">.</span>w<span class="op">,</span>v<span class="op">=</span>e<span class="op">.</span>v<span class="op">;</span></span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>dis<span class="op">[</span>v<span class="op">]&gt;</span>dis<span class="op">[</span>u<span class="op">]+</span>w<span class="op">){</span></span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>                    dis<span class="op">[</span>v<span class="op">]=</span>dis<span class="op">[</span>u<span class="op">]+</span>w<span class="op">;</span></span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a>                    flag <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>flag<span class="op">){</span></span>
<span id="cb34-42"><a href="#cb34-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb34-43"><a href="#cb34-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb34-44"><a href="#cb34-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-45"><a href="#cb34-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb34-46"><a href="#cb34-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flag<span class="op">;</span></span>
<span id="cb34-47"><a href="#cb34-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb34-48"><a href="#cb34-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-49"><a href="#cb34-49" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb34-50"><a href="#cb34-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb34-51"><a href="#cb34-51" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb34-52"><a href="#cb34-52" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">,</span>s<span class="op">;</span><span class="co">//点数，边数，起点</span></span>
<span id="cb34-53"><a href="#cb34-53" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">&gt;&gt;</span>s<span class="op">;</span></span>
<span id="cb34-54"><a href="#cb34-54" aria-hidden="true" tabindex="-1"></a>    init<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb34-55"><a href="#cb34-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-56"><a href="#cb34-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb34-57"><a href="#cb34-57" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span>v<span class="op">,</span>w<span class="op">;</span></span>
<span id="cb34-58"><a href="#cb34-58" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>u<span class="op">&gt;&gt;</span>v<span class="op">&gt;&gt;</span>w<span class="op">;</span></span>
<span id="cb34-59"><a href="#cb34-59" aria-hidden="true" tabindex="-1"></a>        <span class="co">//起点，终点，边权</span></span>
<span id="cb34-60"><a href="#cb34-60" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>Edge<span class="op">(</span>v<span class="op">,</span>w<span class="op">));</span></span>
<span id="cb34-61"><a href="#cb34-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-62"><a href="#cb34-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb34-63"><a href="#cb34-63" aria-hidden="true" tabindex="-1"></a>    BF<span class="op">(</span>n<span class="op">,</span>s<span class="op">);</span></span>
<span id="cb34-64"><a href="#cb34-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-65"><a href="#cb34-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb34-66"><a href="#cb34-66" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>dis<span class="op">[</span>i<span class="op">]&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span></span>
<span id="cb34-67"><a href="#cb34-67" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-68"><a href="#cb34-68" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb34-69"><a href="#cb34-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb34-70"><a href="#cb34-70" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="spfa">SPFA</h3>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 nm</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co">    bellman-ford的优化</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co">    只有上一次被松弛的结点，所连接的边，</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co">    才有可能引起下一次的松弛操作</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="co">//spfa 单源最短路</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P3371</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">100005</span><span class="op">;</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> INF <span class="op">=</span> <span class="bn">0x5fffffff</span><span class="op">;</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">,</span>w<span class="op">;</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>    Edge<span class="op">(</span><span class="dt">int</span> <span class="va">v_</span><span class="op">,</span> <span class="dt">int</span> <span class="va">w_</span><span class="op">):</span>v<span class="op">(</span><span class="va">v_</span><span class="op">),</span>w<span class="op">(</span><span class="va">w_</span><span class="op">){}</span></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dis<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//距离</span></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cnt<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//算到达本节点所要经过的边数，若cnt&gt;=n，则说明有负权环</span></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> tag<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//用于判断是否为上次松弛过的节点的边所连的点</span></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> qu<span class="op">;</span></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Edge<span class="op">&gt;</span> graph<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(!</span>qu<span class="op">.</span>empty<span class="op">())</span> qu<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>        dis<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a>        cnt<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>        tag<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>i<span class="op">].</span>clear<span class="op">();</span></span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> SPFA<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> s<span class="op">){</span></span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">//如果不存在最短路就返回0，否则返回1</span></span>
<span id="cb35-40"><a href="#cb35-40" aria-hidden="true" tabindex="-1"></a>    dis<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-41"><a href="#cb35-41" aria-hidden="true" tabindex="-1"></a>    tag<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb35-42"><a href="#cb35-42" aria-hidden="true" tabindex="-1"></a>    qu<span class="op">.</span>push<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb35-43"><a href="#cb35-43" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> flag <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb35-44"><a href="#cb35-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-45"><a href="#cb35-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(!</span>qu<span class="op">.</span>empty<span class="op">()){</span></span>
<span id="cb35-46"><a href="#cb35-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>flag<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb35-47"><a href="#cb35-47" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> qu<span class="op">.</span>front<span class="op">();</span></span>
<span id="cb35-48"><a href="#cb35-48" aria-hidden="true" tabindex="-1"></a>        qu<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb35-49"><a href="#cb35-49" aria-hidden="true" tabindex="-1"></a>        tag<span class="op">[</span>u<span class="op">]=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-50"><a href="#cb35-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> graph<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb35-51"><a href="#cb35-51" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> v <span class="op">=</span> e<span class="op">.</span>v<span class="op">,</span> w <span class="op">=</span> e<span class="op">.</span>w<span class="op">;</span></span>
<span id="cb35-52"><a href="#cb35-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>dis<span class="op">[</span>v<span class="op">]&gt;</span>dis<span class="op">[</span>u<span class="op">]+</span>w<span class="op">){</span></span>
<span id="cb35-53"><a href="#cb35-53" aria-hidden="true" tabindex="-1"></a>                dis<span class="op">[</span>v<span class="op">]=</span>dis<span class="op">[</span>u<span class="op">]+</span>w<span class="op">;</span></span>
<span id="cb35-54"><a href="#cb35-54" aria-hidden="true" tabindex="-1"></a>                cnt<span class="op">[</span>v<span class="op">]=</span>cnt<span class="op">[</span>u<span class="op">]+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb35-55"><a href="#cb35-55" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>cnt<span class="op">[</span>v<span class="op">]&gt;=</span>n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-56"><a href="#cb35-56" aria-hidden="true" tabindex="-1"></a>                    flag <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-57"><a href="#cb35-57" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb35-58"><a href="#cb35-58" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb35-59"><a href="#cb35-59" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(!</span>tag<span class="op">[</span>v<span class="op">]){</span></span>
<span id="cb35-60"><a href="#cb35-60" aria-hidden="true" tabindex="-1"></a>                    qu<span class="op">.</span>push<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb35-61"><a href="#cb35-61" aria-hidden="true" tabindex="-1"></a>                    tag<span class="op">[</span>v<span class="op">]=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb35-62"><a href="#cb35-62" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb35-63"><a href="#cb35-63" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb35-64"><a href="#cb35-64" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-65"><a href="#cb35-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-66"><a href="#cb35-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flag<span class="op">;</span></span>
<span id="cb35-67"><a href="#cb35-67" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-68"><a href="#cb35-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-69"><a href="#cb35-69" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb35-70"><a href="#cb35-70" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb35-71"><a href="#cb35-71" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb35-72"><a href="#cb35-72" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">,</span>s<span class="op">;</span></span>
<span id="cb35-73"><a href="#cb35-73" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">&gt;&gt;</span>s<span class="op">;</span></span>
<span id="cb35-74"><a href="#cb35-74" aria-hidden="true" tabindex="-1"></a>    init<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb35-75"><a href="#cb35-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-76"><a href="#cb35-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb35-77"><a href="#cb35-77" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span>v<span class="op">,</span>w<span class="op">;</span></span>
<span id="cb35-78"><a href="#cb35-78" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>u<span class="op">&gt;&gt;</span>v<span class="op">&gt;&gt;</span>w<span class="op">;</span></span>
<span id="cb35-79"><a href="#cb35-79" aria-hidden="true" tabindex="-1"></a>        <span class="co">//起点，终点，边权</span></span>
<span id="cb35-80"><a href="#cb35-80" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>Edge<span class="op">(</span>v<span class="op">,</span>w<span class="op">));</span></span>
<span id="cb35-81"><a href="#cb35-81" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-82"><a href="#cb35-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-83"><a href="#cb35-83" aria-hidden="true" tabindex="-1"></a>    SPFA<span class="op">(</span>n<span class="op">,</span>s<span class="op">);</span></span>
<span id="cb35-84"><a href="#cb35-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb35-85"><a href="#cb35-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>dis<span class="op">[</span>i<span class="op">]!=</span>INF<span class="op">){</span></span>
<span id="cb35-86"><a href="#cb35-86" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>dis<span class="op">[</span>i<span class="op">]&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span></span>
<span id="cb35-87"><a href="#cb35-87" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-88"><a href="#cb35-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb35-89"><a href="#cb35-89" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;2147483647 &#34;</span><span class="op">;</span><span class="co">//根据luogu P3371要输出这个数</span></span>
<span id="cb35-90"><a href="#cb35-90" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-91"><a href="#cb35-91" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-92"><a href="#cb35-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-93"><a href="#cb35-93" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-94"><a href="#cb35-94" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="floyd">Floyd</h3>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 n^3</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="co">//floyd全源最短路</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p5905，由于不能判断负环和速度慢，会wa和tle一些</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co">//floyd虽然不能处理负环但是可以接受负边</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> LL <span class="op">=</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">3005</span><span class="op">;</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>LL <span class="at">const</span> INF <span class="op">=</span> <span class="fl">1e17</span><span class="op">;</span> <span class="co">//不能设置为int的最大值，否则后面加法可能导致溢出</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>LL graph<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span><span class="co">//点数，边数</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">;</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>n<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>            graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span>v<span class="op">;</span>LL w<span class="op">;</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>u<span class="op">&gt;&gt;</span>v<span class="op">&gt;&gt;</span>w<span class="op">;</span><span class="co">//起点，终点，边权</span></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">][</span>v<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>graph<span class="op">[</span>u<span class="op">][</span>v<span class="op">],</span> w<span class="op">);</span><span class="co">//处理重边</span></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> k<span class="op">=</span><span class="dv">1</span><span class="op">;</span>k<span class="op">&lt;=</span>n<span class="op">;</span>k<span class="op">++){</span></span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>n<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a>                graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span>graph<span class="op">[</span>i<span class="op">][</span>k<span class="op">]+</span>graph<span class="op">[</span>k<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a>        LL res<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span>LL j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>n<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]&gt;</span><span class="fl">1e9</span><span class="op">)</span> graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="fl">1e9</span><span class="op">;</span></span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a>            res <span class="op">+=</span> j<span class="op">*</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>res<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb36-46"><a href="#cb36-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-47"><a href="#cb36-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-48"><a href="#cb36-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb36-49"><a href="#cb36-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="johnson-todo">Johnson TODO</h3>
<h2 id="差分约束">差分约束</h2>
<p>给出一组不等式</p>
<p><span class="math display">\[
\left\{\begin{matrix}
x_{c_1}-x_{c_1&#39;}\leq y_1 \\
x_{c_2}-x_{c_2&#39;}\leq y_2 \\
\vdots \\
x_{c_m}-x_{c_m&#39;}\leq y_m
\end{matrix}\right.
\]</span></p>
<p>其中一共有<span class="math inline">\(n\)</span>个未知数<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>，<span class="math inline">\(m\)</span>个不等式，求一组可行解。</p>
<p>我们连边，连一条<span class="math inline">\(x_{c_i&#39;}\)</span>到<span class="math inline">\(x_{c_i}\)</span>，权值为<span class="math inline">\(y_i\)</span>的边。然后增加<span class="math inline">\(n+1\)</span>号节点，从它到所有点连一条权值为<span class="math inline">\(0\)</span>的边。然后以<span class="math inline">\(n+1\)</span>为源点求到各点的最短路，这个最短距离dis[i]就是<span class="math inline">\(x_i\)</span>的一个解。</p>
<p>当然，出现负环就无解。</p>
<p>不难理解，<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>全部加上或减去同一个数，仍然是可行解。</p>
<p>之前我们假设dis[n+1]=0，如果我们设置dis[n+1] =
w，那么我们求得的就是<span class="math inline">\(x_1,x_2,\cdots,x_n\leq
w\)</span>的一组解。实际上，可以证明这个解是满足<span class="math inline">\(x_1,x_2,\cdots,x_n\leq
w\)</span>的最大解（每个变量能取得的最大值）。</p>
<p>如果题目上的约束条件全部变为<span class="math inline">\(\geq\)</span>型，我们要求满足<span class="math inline">\(x_1,x_2,\cdots,x_n\geq
w\)</span>的最小解，则只需要求最长路即可。对于Bellman-Ford和SPFA来说，初始化dis为-INF，然后颠倒比较符号即可。</p>
<p>题目中不总是给出<span class="math inline">\(x_1-x_2\leq
y\)</span>，但我们可以转化</p>
<ul>
<li><span class="math inline">\(x_1-x_2\geq y\Rightarrow x_2-x_1\leq
-y\)</span></li>
<li><span class="math inline">\(x_1-x_2=y\Rightarrow x_1-x_2\leq y
\wedge x_2-x_1\leq -y\)</span></li>
<li><span class="math inline">\(x_1-x_2&lt;y\Rightarrow x_1-x_2\leq
y-1\)</span>（要求取值只能是整数）</li>
<li><span class="math inline">\(x_1-x_2&gt;y\Rightarrow x_2-x_1\leq
-y-1\)</span>（要求取值只能是整数）</li>
</ul>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">//差分约束，复杂度同SPFA</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p5960</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="co">//使用介绍见markdown</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">5005</span><span class="op">;</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> INF <span class="op">=</span> <span class="bn">0x5fffffff</span><span class="op">;</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">,</span>w<span class="op">;</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>    Edge<span class="op">(</span><span class="dt">int</span> <span class="va">v_</span><span class="op">,</span> <span class="dt">int</span> <span class="va">w_</span><span class="op">):</span>v<span class="op">(</span><span class="va">v_</span><span class="op">),</span>w<span class="op">(</span><span class="va">w_</span><span class="op">){}</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dis<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//距离</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cnt<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//算到达本节点所要经过的边数，若cnt&gt;=n，则说明有负权环</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> tag<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//用于判断是否为上次松弛过的节点的边所连的点</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> qu<span class="op">;</span></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Edge<span class="op">&gt;</span> graph<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(!</span>qu<span class="op">.</span>empty<span class="op">())</span> qu<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>        dis<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>        cnt<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>        tag<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>i<span class="op">].</span>clear<span class="op">();</span></span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> SPFA<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> s<span class="op">){</span></span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">//如果不存在最短路就返回0，否则返回1</span></span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a>    dis<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a>    tag<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a>    qu<span class="op">.</span>push<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> flag <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(!</span>qu<span class="op">.</span>empty<span class="op">()){</span></span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>flag<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> qu<span class="op">.</span>front<span class="op">();</span></span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a>        qu<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a>        tag<span class="op">[</span>u<span class="op">]=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> e <span class="op">:</span> graph<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> v <span class="op">=</span> e<span class="op">.</span>v<span class="op">,</span> w <span class="op">=</span> e<span class="op">.</span>w<span class="op">;</span></span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>dis<span class="op">[</span>v<span class="op">]&gt;</span>dis<span class="op">[</span>u<span class="op">]+</span>w<span class="op">){</span></span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a>                dis<span class="op">[</span>v<span class="op">]=</span>dis<span class="op">[</span>u<span class="op">]+</span>w<span class="op">;</span></span>
<span id="cb37-49"><a href="#cb37-49" aria-hidden="true" tabindex="-1"></a>                cnt<span class="op">[</span>v<span class="op">]=</span>cnt<span class="op">[</span>u<span class="op">]+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb37-50"><a href="#cb37-50" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>cnt<span class="op">[</span>v<span class="op">]&gt;=</span>n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-51"><a href="#cb37-51" aria-hidden="true" tabindex="-1"></a>                    flag <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb37-52"><a href="#cb37-52" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb37-53"><a href="#cb37-53" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb37-54"><a href="#cb37-54" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(!</span>tag<span class="op">[</span>v<span class="op">]){</span></span>
<span id="cb37-55"><a href="#cb37-55" aria-hidden="true" tabindex="-1"></a>                    qu<span class="op">.</span>push<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb37-56"><a href="#cb37-56" aria-hidden="true" tabindex="-1"></a>                    tag<span class="op">[</span>v<span class="op">]=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb37-57"><a href="#cb37-57" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb37-58"><a href="#cb37-58" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb37-59"><a href="#cb37-59" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb37-60"><a href="#cb37-60" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-61"><a href="#cb37-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flag<span class="op">;</span></span>
<span id="cb37-62"><a href="#cb37-62" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb37-63"><a href="#cb37-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-64"><a href="#cb37-64" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb37-65"><a href="#cb37-65" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb37-66"><a href="#cb37-66" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb37-67"><a href="#cb37-67" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span></span>
<span id="cb37-68"><a href="#cb37-68" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">;</span></span>
<span id="cb37-69"><a href="#cb37-69" aria-hidden="true" tabindex="-1"></a>    init<span class="op">(</span>n<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb37-70"><a href="#cb37-70" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-71"><a href="#cb37-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb37-72"><a href="#cb37-72" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v<span class="op">,</span>u<span class="op">,</span>w<span class="op">;</span></span>
<span id="cb37-73"><a href="#cb37-73" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>v<span class="op">&gt;&gt;</span>u<span class="op">&gt;&gt;</span>w<span class="op">;</span></span>
<span id="cb37-74"><a href="#cb37-74" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>Edge<span class="op">(</span>v<span class="op">,</span>w<span class="op">));</span></span>
<span id="cb37-75"><a href="#cb37-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-76"><a href="#cb37-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb37-77"><a href="#cb37-77" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>n<span class="op">+</span><span class="dv">1</span><span class="op">].</span>push_back<span class="op">(</span>Edge<span class="op">(</span>i<span class="op">,</span><span class="dv">0</span><span class="op">));</span></span>
<span id="cb37-78"><a href="#cb37-78" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-79"><a href="#cb37-79" aria-hidden="true" tabindex="-1"></a>    n<span class="op">++;</span></span>
<span id="cb37-80"><a href="#cb37-80" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-81"><a href="#cb37-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(!</span>SPFA<span class="op">(</span>n<span class="op">,</span>n<span class="op">)){</span></span>
<span id="cb37-82"><a href="#cb37-82" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;NO</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb37-83"><a href="#cb37-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb37-84"><a href="#cb37-84" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-85"><a href="#cb37-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">-</span><span class="dv">1</span><span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb37-86"><a href="#cb37-86" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>dis<span class="op">[</span>i<span class="op">]&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span></span>
<span id="cb37-87"><a href="#cb37-87" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-88"><a href="#cb37-88" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb37-89"><a href="#cb37-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-90"><a href="#cb37-90" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb37-91"><a href="#cb37-91" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="拓扑排序">拓扑排序</h2>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 n</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="co">//拓扑排序, luogu B3644</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">105</span><span class="op">;</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> graph<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> in<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span><span class="kw">true</span><span class="op">){</span></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> v<span class="op">;</span></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>v<span class="op">;</span></span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>v<span class="op">==</span><span class="dv">0</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>            graph<span class="op">[</span>i<span class="op">].</span>push_back<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>            in<span class="op">[</span>v<span class="op">]++;</span></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> qu<span class="op">;</span></span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>in<span class="op">[</span>i<span class="op">]==</span><span class="dv">0</span><span class="op">)</span> qu<span class="op">.</span>push<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(!</span>qu<span class="op">.</span>empty<span class="op">()){</span></span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> qu<span class="op">.</span>front<span class="op">();</span></span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>        qu<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>u<span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span></span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> v<span class="op">:</span>graph<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a>            in<span class="op">[</span>v<span class="op">]--;</span></span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>in<span class="op">[</span>v<span class="op">]==</span><span class="dv">0</span><span class="op">)</span> qu<span class="op">.</span>push<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<h2 id="最小生成树">最小生成树</h2>
<h3 id="kruskal">Kruskal</h3>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 mlogm</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co">//最小生成树Kruskal，luogu p3366</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXM <span class="op">=</span> <span class="dv">200005</span><span class="op">;</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">5005</span><span class="op">;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> u<span class="op">,</span>v<span class="op">,</span>w<span class="op">;</span><span class="co">//最小生成树是在无向图上跑的，由于要排序，所以记录uvw</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span>Edge <span class="at">const</span> <span class="op">&amp;</span> x<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> w<span class="op">&lt;</span>x<span class="op">.</span>w<span class="op">;</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  </span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>Edge edges<span class="op">[</span>MAXM<span class="op">];</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> find_sets<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//并查集</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> find<span class="op">(</span><span class="dt">int</span> x<span class="op">){</span><span class="cf">return</span> find_sets<span class="op">[</span>x<span class="op">]==</span>x <span class="op">?</span> x <span class="op">:</span> find_sets<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> find<span class="op">(</span>find_sets<span class="op">[</span>x<span class="op">]);}</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span><span class="co">//点数和边数</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">;</span></span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>edges<span class="op">[</span>i<span class="op">].</span>u<span class="op">&gt;&gt;</span>edges<span class="op">[</span>i<span class="op">].</span>v<span class="op">&gt;&gt;</span>edges<span class="op">[</span>i<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>edges<span class="op">+</span><span class="dv">1</span><span class="op">,</span>edges<span class="op">+</span><span class="dv">1</span><span class="op">+</span>m<span class="op">);</span></span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a>        find_sets<span class="op">[</span>i<span class="op">]=</span>i<span class="op">;</span></span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cnt<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u <span class="op">=</span> edges<span class="op">[</span>i<span class="op">].</span>u<span class="op">,</span> v <span class="op">=</span> edges<span class="op">[</span>i<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x <span class="op">=</span> find<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y <span class="op">=</span> find<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>x<span class="op">!=</span>y<span class="op">){</span></span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a>            ans <span class="op">+=</span> edges<span class="op">[</span>i<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb39-44"><a href="#cb39-44" aria-hidden="true" tabindex="-1"></a>            find_sets<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb39-45"><a href="#cb39-45" aria-hidden="true" tabindex="-1"></a>            cnt<span class="op">++;</span></span>
<span id="cb39-46"><a href="#cb39-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb39-47"><a href="#cb39-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb39-48"><a href="#cb39-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">//计数，如果小于n-1则不连通</span></span>
<span id="cb39-49"><a href="#cb39-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-50"><a href="#cb39-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>cnt<span class="op">&lt;</span>n<span class="op">-</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb39-51"><a href="#cb39-51" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;orz</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb39-52"><a href="#cb39-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb39-53"><a href="#cb39-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span><span class="op">{</span></span>
<span id="cb39-54"><a href="#cb39-54" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb39-55"><a href="#cb39-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb39-56"><a href="#cb39-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-57"><a href="#cb39-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb39-58"><a href="#cb39-58" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="prim算法">Prim算法</h3>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 (m+n)logn</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="co">//最小生成树prim，luogu p3366</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">5005</span><span class="op">;</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXM <span class="op">=</span> <span class="dv">200005</span><span class="op">;</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> INF <span class="op">=</span> <span class="bn">0x5fffffff</span><span class="op">;</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> edge<span class="op">{</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">,</span>w<span class="op">;</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>    edge<span class="op">(){};</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>    edge<span class="op">(</span><span class="dt">int</span> v<span class="op">,</span><span class="dt">int</span> w<span class="op">):</span>v<span class="op">(</span>v<span class="op">),</span>w<span class="op">(</span>w<span class="op">){}</span></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;(</span><span class="at">const</span> edge<span class="op">&amp;</span> x<span class="op">)</span> <span class="at">const</span> <span class="op">{</span><span class="cf">return</span> w<span class="op">&gt;</span>x<span class="op">.</span>w<span class="op">;}</span></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>edge<span class="op">&gt;</span> graph<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> vis<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>priority_queue<span class="op">&lt;</span>edge<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>edge<span class="op">&gt;,</span> <span class="bu">std::</span>greater<span class="op">&lt;</span>edge<span class="op">&gt;</span> <span class="op">&gt;</span> pq<span class="op">;</span></span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span><span class="co">//点数，边数</span></span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">;</span></span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cnt <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span>v<span class="op">,</span>w<span class="op">;</span><span class="co">//起点，终点，边权</span></span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>u<span class="op">&gt;&gt;</span>v<span class="op">&gt;&gt;</span>w<span class="op">;</span></span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>edge<span class="op">(</span>v<span class="op">,</span>w<span class="op">));</span></span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>v<span class="op">].</span>push_back<span class="op">(</span>edge<span class="op">(</span>u<span class="op">,</span>w<span class="op">));</span></span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">//无向图</span></span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>graph<span class="op">[</span><span class="dv">1</span><span class="op">].</span>size<span class="op">();</span>i<span class="op">++){</span></span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>        pq<span class="op">.</span>push<span class="op">(</span>graph<span class="op">[</span><span class="dv">1</span><span class="op">][</span>i<span class="op">]);</span></span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a>    vis<span class="op">[</span><span class="dv">1</span><span class="op">]=</span><span class="kw">true</span><span class="op">;</span></span>
<span id="cb40-43"><a href="#cb40-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-44"><a href="#cb40-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>cnt<span class="op">!=</span>n<span class="op">&amp;&amp;!</span>pq<span class="op">.</span>empty<span class="op">()){</span></span>
<span id="cb40-45"><a href="#cb40-45" aria-hidden="true" tabindex="-1"></a>        edge minx<span class="op">=</span>pq<span class="op">.</span>top<span class="op">();</span></span>
<span id="cb40-46"><a href="#cb40-46" aria-hidden="true" tabindex="-1"></a>        pq<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb40-47"><a href="#cb40-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>vis<span class="op">[</span>minx<span class="op">.</span>v<span class="op">]){</span></span>
<span id="cb40-48"><a href="#cb40-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>pq<span class="op">.</span>empty<span class="op">()){</span></span>
<span id="cb40-49"><a href="#cb40-49" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;orz</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span><span class="co">//不连通</span></span>
<span id="cb40-50"><a href="#cb40-50" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb40-51"><a href="#cb40-51" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb40-52"><a href="#cb40-52" aria-hidden="true" tabindex="-1"></a>            minx<span class="op">=</span>pq<span class="op">.</span>top<span class="op">();</span></span>
<span id="cb40-53"><a href="#cb40-53" aria-hidden="true" tabindex="-1"></a>            pq<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb40-54"><a href="#cb40-54" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb40-55"><a href="#cb40-55" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb40-56"><a href="#cb40-56" aria-hidden="true" tabindex="-1"></a>        vis<span class="op">[</span>minx<span class="op">.</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb40-57"><a href="#cb40-57" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">+=</span>minx<span class="op">.</span>w<span class="op">;</span></span>
<span id="cb40-58"><a href="#cb40-58" aria-hidden="true" tabindex="-1"></a>        cnt<span class="op">++;</span></span>
<span id="cb40-59"><a href="#cb40-59" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb40-60"><a href="#cb40-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>graph<span class="op">[</span>minx<span class="op">.</span>v<span class="op">].</span>size<span class="op">();</span>i<span class="op">++){</span></span>
<span id="cb40-61"><a href="#cb40-61" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(!</span>vis<span class="op">[</span>graph<span class="op">[</span>minx<span class="op">.</span>v<span class="op">][</span>i<span class="op">].</span>v<span class="op">])</span></span>
<span id="cb40-62"><a href="#cb40-62" aria-hidden="true" tabindex="-1"></a>                pq<span class="op">.</span>push<span class="op">(</span>graph<span class="op">[</span>minx<span class="op">.</span>v<span class="op">][</span>i<span class="op">]);</span></span>
<span id="cb40-63"><a href="#cb40-63" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb40-64"><a href="#cb40-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-65"><a href="#cb40-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-66"><a href="#cb40-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>cnt<span class="op">&lt;</span>n<span class="op">){</span></span>
<span id="cb40-67"><a href="#cb40-67" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;orz</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb40-68"><a href="#cb40-68" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-69"><a href="#cb40-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span><span class="op">{</span></span>
<span id="cb40-70"><a href="#cb40-70" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb40-71"><a href="#cb40-71" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-72"><a href="#cb40-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-73"><a href="#cb40-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb40-74"><a href="#cb40-74" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="最小树形图朱刘算法">最小树形图（朱刘算法）</h2>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 nm</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="co">//最小树形图，朱刘算法</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="co">//从根节点能到达其他所有点</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu4716</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">105</span><span class="op">;</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXM <span class="op">=</span> <span class="dv">10005</span><span class="op">;</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> INF <span class="op">=</span> <span class="bn">0x7fffffff</span><span class="op">;</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> u<span class="op">,</span>v<span class="op">,</span>w<span class="op">;</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>Edge edge<span class="op">[</span>MAXM<span class="op">];</span> </span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> vis<span class="op">[</span>MAXN<span class="op">],</span>id<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> in<span class="op">[</span>MAXN<span class="op">],</span>pre<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> zhuliu<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> root<span class="op">){</span></span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">//返回最小树形图的边权和，如果不存在则返回-1</span></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(;;){</span></span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++)</span> in<span class="op">[</span>i<span class="op">]=</span>INF<span class="op">;</span></span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> u <span class="op">=</span> edge<span class="op">[</span>i<span class="op">].</span>u<span class="op">;</span></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> v <span class="op">=</span> edge<span class="op">[</span>i<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>u<span class="op">!=</span>v <span class="op">&amp;&amp;</span> edge<span class="op">[</span>i<span class="op">].</span>w<span class="op">&lt;</span>in<span class="op">[</span>v<span class="op">]){</span><span class="co">//遍历所有边，找到对每个点的最短入边</span></span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a>                in<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> edge<span class="op">[</span>i<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a>                pre<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>i<span class="op">!=</span>root <span class="op">&amp;&amp;</span> in<span class="op">[</span>i<span class="op">]==</span>INF<span class="op">){</span></span>
<span id="cb41-36"><a href="#cb41-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span><span class="co">//无解</span></span>
<span id="cb41-37"><a href="#cb41-37" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb41-38"><a href="#cb41-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb41-39"><a href="#cb41-39" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-40"><a href="#cb41-40" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cnt <span class="op">=</span> <span class="dv">0</span><span class="op">;</span><span class="co">//记录环数以及下一次循环的点数</span></span>
<span id="cb41-41"><a href="#cb41-41" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-42"><a href="#cb41-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb41-43"><a href="#cb41-43" aria-hidden="true" tabindex="-1"></a>            vis<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb41-44"><a href="#cb41-44" aria-hidden="true" tabindex="-1"></a>            id<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb41-45"><a href="#cb41-45" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb41-46"><a href="#cb41-46" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-47"><a href="#cb41-47" aria-hidden="true" tabindex="-1"></a>        in<span class="op">[</span>root<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb41-48"><a href="#cb41-48" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-49"><a href="#cb41-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb41-50"><a href="#cb41-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>i<span class="op">==</span>root<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb41-51"><a href="#cb41-51" aria-hidden="true" tabindex="-1"></a>            ans <span class="op">+=</span> in<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb41-52"><a href="#cb41-52" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> v<span class="op">=</span>i<span class="op">;</span></span>
<span id="cb41-53"><a href="#cb41-53" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span><span class="op">(</span>vis<span class="op">[</span>v<span class="op">]!=</span>i<span class="op">&amp;&amp;</span>id<span class="op">[</span>v<span class="op">]==-</span><span class="dv">1</span><span class="op">&amp;&amp;</span>v<span class="op">!=</span>root<span class="op">){</span></span>
<span id="cb41-54"><a href="#cb41-54" aria-hidden="true" tabindex="-1"></a>                vis<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb41-55"><a href="#cb41-55" aria-hidden="true" tabindex="-1"></a>                v <span class="op">=</span> pre<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb41-56"><a href="#cb41-56" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb41-57"><a href="#cb41-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>v<span class="op">!=</span>root <span class="op">&amp;&amp;</span> id<span class="op">[</span>v<span class="op">]==-</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb41-58"><a href="#cb41-58" aria-hidden="true" tabindex="-1"></a>                id<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="op">++</span>cnt<span class="op">;</span></span>
<span id="cb41-59"><a href="#cb41-59" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> u<span class="op">=</span>pre<span class="op">[</span>v<span class="op">];</span>u<span class="op">!=</span>v<span class="op">;</span>u<span class="op">=</span>pre<span class="op">[</span>u<span class="op">])</span> id<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> cnt<span class="op">;</span></span>
<span id="cb41-60"><a href="#cb41-60" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb41-61"><a href="#cb41-61" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb41-62"><a href="#cb41-62" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-63"><a href="#cb41-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>cnt<span class="op">==</span><span class="dv">0</span><span class="op">){</span><span class="co">//无环，得到解</span></span>
<span id="cb41-64"><a href="#cb41-64" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb41-65"><a href="#cb41-65" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb41-66"><a href="#cb41-66" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-67"><a href="#cb41-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb41-68"><a href="#cb41-68" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>id<span class="op">[</span>i<span class="op">]==-</span><span class="dv">1</span><span class="op">)</span> id<span class="op">[</span>i<span class="op">]=++</span>cnt<span class="op">;</span></span>
<span id="cb41-69"><a href="#cb41-69" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb41-70"><a href="#cb41-70" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-71"><a href="#cb41-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb41-72"><a href="#cb41-72" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> u <span class="op">=</span> edge<span class="op">[</span>i<span class="op">].</span>u<span class="op">;</span></span>
<span id="cb41-73"><a href="#cb41-73" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> v <span class="op">=</span> edge<span class="op">[</span>i<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb41-74"><a href="#cb41-74" aria-hidden="true" tabindex="-1"></a>            edge<span class="op">[</span>i<span class="op">].</span>u <span class="op">=</span> id<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb41-75"><a href="#cb41-75" aria-hidden="true" tabindex="-1"></a>            edge<span class="op">[</span>i<span class="op">].</span>v <span class="op">=</span> id<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb41-76"><a href="#cb41-76" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>edge<span class="op">[</span>i<span class="op">].</span>u<span class="op">!=</span>edge<span class="op">[</span>i<span class="op">].</span>v<span class="op">)</span> edge<span class="op">[</span>i<span class="op">].</span>w <span class="op">-=</span> in<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb41-77"><a href="#cb41-77" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb41-78"><a href="#cb41-78" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb41-79"><a href="#cb41-79" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> cnt<span class="op">;</span></span>
<span id="cb41-80"><a href="#cb41-80" aria-hidden="true" tabindex="-1"></a>        root <span class="op">=</span> id<span class="op">[</span>root<span class="op">];</span></span>
<span id="cb41-81"><a href="#cb41-81" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb41-82"><a href="#cb41-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb41-83"><a href="#cb41-83" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb41-84"><a href="#cb41-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-85"><a href="#cb41-85" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb41-86"><a href="#cb41-86" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">,</span>root<span class="op">;</span></span>
<span id="cb41-87"><a href="#cb41-87" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">&gt;&gt;</span>root<span class="op">;</span></span>
<span id="cb41-88"><a href="#cb41-88" aria-hidden="true" tabindex="-1"></a>    <span class="co">//点数，边数，根节点序号</span></span>
<span id="cb41-89"><a href="#cb41-89" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb41-90"><a href="#cb41-90" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>edge<span class="op">[</span>i<span class="op">].</span>u<span class="op">&gt;&gt;</span>edge<span class="op">[</span>i<span class="op">].</span>v<span class="op">&gt;&gt;</span>edge<span class="op">[</span>i<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb41-91"><a href="#cb41-91" aria-hidden="true" tabindex="-1"></a>        <span class="co">//起点，终点，边权</span></span>
<span id="cb41-92"><a href="#cb41-92" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb41-93"><a href="#cb41-93" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>zhuliu<span class="op">(</span>n<span class="op">,</span>m<span class="op">,</span>root<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb41-94"><a href="#cb41-94" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb41-95"><a href="#cb41-95" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="二分图判定">二分图判定</h2>
<p>一张无向图是二分图，当且仅当图中不存在长度为奇数的环。</p>
<p>我们可以用染色法来判定。假设染成两种颜色，一个节点被染色后，所有相连节点都应该染成另一种颜色，如果有冲突，则说明不是二分图。</p>
<h2 id="二分图匹配">二分图匹配</h2>
<h3 id="最大匹配匈牙利算法">最大匹配（匈牙利算法）</h3>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 nm</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p3386</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="co">//求二分图最大匹配，根据定理，最大匹配=最小点覆盖，以及最小边覆盖=点数-最大匹配</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="co">//二分图是&#34;可以将点集分为两个不相交的部分，所有边连接的两个顶点在不同的部分中&#34;的图</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="co">//二分图的匹配：边集的任意子集的任意两条边都没有公共顶点，则这个子集是一个匹配</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="co">//二分图的最大匹配：所有匹配中边数最多的</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a><span class="co">//最小点覆盖：选最少的点，满足每条边至少有一个端点被选</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a><span class="co">//最大独立集：选最多的点，满足两两之间没有边相连</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a><span class="co">//这里的二分图是无向图</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a><span class="co">//如果最大匹配中所有点都被匹配，那么叫做完美匹配</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">505</span><span class="op">;</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> graph<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> vis<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> toLeft<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//标记右边节点i连到了哪个左边界点，即toLeft[i]</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> match<span class="op">(</span><span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> i<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> rightNum<span class="op">){</span></span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>rightNum<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]&amp;&amp;!</span>vis<span class="op">[</span>j<span class="op">]){</span></span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>            vis<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>toLeft<span class="op">[</span>j<span class="op">]==</span><span class="dv">0</span> <span class="op">||</span> match<span class="op">(</span>toLeft<span class="op">[</span>j<span class="op">],</span> rightNum<span class="op">)){</span></span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a>                toLeft<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb42-31"><a href="#cb42-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-32"><a href="#cb42-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-34"><a href="#cb42-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-35"><a href="#cb42-35" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> hungarian<span class="op">(</span><span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> leftNum<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> rightNum<span class="op">){</span></span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">//返回最大的边数</span></span>
<span id="cb42-37"><a href="#cb42-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cnt <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb42-38"><a href="#cb42-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-39"><a href="#cb42-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>leftNum<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb42-40"><a href="#cb42-40" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>memset<span class="op">(</span>vis<span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>vis<span class="op">));</span></span>
<span id="cb42-41"><a href="#cb42-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>match<span class="op">(</span>i<span class="op">,</span>rightNum<span class="op">))</span> cnt<span class="op">++;</span></span>
<span id="cb42-42"><a href="#cb42-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-43"><a href="#cb42-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-44"><a href="#cb42-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cnt<span class="op">;</span></span>
<span id="cb42-45"><a href="#cb42-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-46"><a href="#cb42-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-47"><a href="#cb42-47" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb42-48"><a href="#cb42-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">,</span>e<span class="op">;</span><span class="co">//左边点数，右边点数，边数</span></span>
<span id="cb42-49"><a href="#cb42-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">&gt;&gt;</span>e<span class="op">;</span></span>
<span id="cb42-50"><a href="#cb42-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb42-51"><a href="#cb42-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>e<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb42-52"><a href="#cb42-52" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb42-53"><a href="#cb42-53" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>x<span class="op">&gt;&gt;</span>y<span class="op">;</span></span>
<span id="cb42-54"><a href="#cb42-54" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>x<span class="op">][</span>y<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb42-55"><a href="#cb42-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-56"><a href="#cb42-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-57"><a href="#cb42-57" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>hungarian<span class="op">(</span>n<span class="op">,</span>m<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb42-58"><a href="#cb42-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-59"><a href="#cb42-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb42-60"><a href="#cb42-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="二分图的相关定理">二分图的相关定理</h3>
<p>Konig定理：一个二分图中的最大匹配数等于这个图中的最小点覆盖数。</p>
<p>最大独立集=点数-最小点覆盖。</p>
<h3 id="最大匹配转换为网络流模型">最大匹配转换为网络流模型</h3>
<p>将源点连上左边所有点，右边所有点连上汇点，容量都为1。原来的每条边从左往右连边（转成了有向有容量图），容量也为1，最大流即最大匹配。用Dinic算法求复杂度为<span class="math inline">\(O(\sqrt nm)\)</span></p>
<h3 id="二分图最大权完美匹配km算法-todo-bfs版">二分图最大权完美匹配（KM算法）
TODO: BFS版</h3>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p6577</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="co">//二分图的最大权匹配，必须是完美匹配才能正确运行，即左右各n个点，最大匹配有n条边。虽然KM算法必须是完美匹配才可以运行而转化为费用流则不需要，但是KM算法在稠密图上的效率会高于费用流</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="co">//随机数据O(n^3)，最坏O(n^4)，所以luogu p6577上会超时一些数据</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="co">//这主要是他卡dfs版的，bfs版的可以通过。但luogu p3967不卡dfs</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a><span class="co">//最大权匹配指二分图中边权和最大的匹配，最大权匹配不一定是最大匹配</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a><span class="co">//如果要跑多次KM算法记得把toLeft数组初始化</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL<span class="op">;</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">505</span><span class="op">;</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> LL INF <span class="op">=</span> <span class="fl">1e17</span><span class="op">;</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>LL graph<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>LL labelL<span class="op">[</span>MAXN<span class="op">],</span> labelR<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> visL<span class="op">[</span>MAXN<span class="op">],</span>visR<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> toLeft<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>LL upd<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> match<span class="op">(</span><span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> i<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> pointNum<span class="op">){</span></span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>    visL<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>pointNum<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>visR<span class="op">[</span>j<span class="op">]){</span></span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>labelL<span class="op">[</span>i<span class="op">]+</span>labelR<span class="op">[</span>j<span class="op">]-</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]==</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a>                visR<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(!</span>toLeft<span class="op">[</span>j<span class="op">]||</span>match<span class="op">(</span>toLeft<span class="op">[</span>j<span class="op">],</span>pointNum<span class="op">)){</span></span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a>                    toLeft<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb43-32"><a href="#cb43-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb43-33"><a href="#cb43-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span><span class="op">{</span></span>
<span id="cb43-34"><a href="#cb43-34" aria-hidden="true" tabindex="-1"></a>                upd<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>upd<span class="op">[</span>j<span class="op">],</span>labelL<span class="op">[</span>i<span class="op">]+</span>labelR<span class="op">[</span>j<span class="op">]-</span>graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb43-35"><a href="#cb43-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb43-36"><a href="#cb43-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb43-37"><a href="#cb43-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb43-38"><a href="#cb43-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb43-39"><a href="#cb43-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb43-40"><a href="#cb43-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-41"><a href="#cb43-41" aria-hidden="true" tabindex="-1"></a>LL KM<span class="op">(</span><span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> pointNum<span class="op">){</span></span>
<span id="cb43-42"><a href="#cb43-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>pointNum<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb43-43"><a href="#cb43-43" aria-hidden="true" tabindex="-1"></a>        labelL<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">-</span>INF<span class="op">;</span></span>
<span id="cb43-44"><a href="#cb43-44" aria-hidden="true" tabindex="-1"></a>        labelR<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb43-45"><a href="#cb43-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>pointNum<span class="op">;</span>j<span class="op">++)</span> labelL<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>labelL<span class="op">[</span>i<span class="op">],</span> graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb43-46"><a href="#cb43-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb43-47"><a href="#cb43-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-48"><a href="#cb43-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>pointNum<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb43-49"><a href="#cb43-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span><span class="kw">true</span><span class="op">){</span></span>
<span id="cb43-50"><a href="#cb43-50" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>memset<span class="op">(</span>visL<span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>visL<span class="op">));</span></span>
<span id="cb43-51"><a href="#cb43-51" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>memset<span class="op">(</span>visR<span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>visR<span class="op">));</span></span>
<span id="cb43-52"><a href="#cb43-52" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>pointNum<span class="op">;</span>j<span class="op">++)</span> upd<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb43-53"><a href="#cb43-53" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>match<span class="op">(</span>i<span class="op">,</span>pointNum<span class="op">))</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb43-54"><a href="#cb43-54" aria-hidden="true" tabindex="-1"></a>            LL delta <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb43-55"><a href="#cb43-55" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>pointNum<span class="op">;</span>j<span class="op">++)</span></span>
<span id="cb43-56"><a href="#cb43-56" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(!</span>visR<span class="op">[</span>j<span class="op">])</span> delta <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>delta<span class="op">,</span>upd<span class="op">[</span>j<span class="op">]);</span></span>
<span id="cb43-57"><a href="#cb43-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>pointNum<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb43-58"><a href="#cb43-58" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>visL<span class="op">[</span>j<span class="op">])</span> labelL<span class="op">[</span>j<span class="op">]</span> <span class="op">-=</span> delta<span class="op">;</span></span>
<span id="cb43-59"><a href="#cb43-59" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>visR<span class="op">[</span>j<span class="op">])</span> labelR<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> delta<span class="op">;</span></span>
<span id="cb43-60"><a href="#cb43-60" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb43-61"><a href="#cb43-61" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb43-62"><a href="#cb43-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb43-63"><a href="#cb43-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-64"><a href="#cb43-64" aria-hidden="true" tabindex="-1"></a>    LL ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb43-65"><a href="#cb43-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>pointNum<span class="op">;</span>i<span class="op">++)</span> ans <span class="op">+=</span> graph<span class="op">[</span>toLeft<span class="op">[</span>i<span class="op">]][</span>i<span class="op">];</span></span>
<span id="cb43-66"><a href="#cb43-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span><span class="co">//输出最大权匹配的权值和</span></span>
<span id="cb43-67"><a href="#cb43-67" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb43-68"><a href="#cb43-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-69"><a href="#cb43-69" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb43-70"><a href="#cb43-70" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>e<span class="op">;</span><span class="co">//一边的点数；边数</span></span>
<span id="cb43-71"><a href="#cb43-71" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>e<span class="op">;</span></span>
<span id="cb43-72"><a href="#cb43-72" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb43-73"><a href="#cb43-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb43-74"><a href="#cb43-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>n<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb43-75"><a href="#cb43-75" aria-hidden="true" tabindex="-1"></a>            graph<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="op">-</span>INF<span class="op">;</span></span>
<span id="cb43-76"><a href="#cb43-76" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb43-77"><a href="#cb43-77" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb43-78"><a href="#cb43-78" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb43-79"><a href="#cb43-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>e<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb43-80"><a href="#cb43-80" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb43-81"><a href="#cb43-81" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>x<span class="op">&gt;&gt;</span>y<span class="op">;</span></span>
<span id="cb43-82"><a href="#cb43-82" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>graph<span class="op">[</span>x<span class="op">][</span>y<span class="op">];</span><span class="co">//这里是左边有n个点，右边有n个点</span></span>
<span id="cb43-83"><a href="#cb43-83" aria-hidden="true" tabindex="-1"></a>        <span class="co">//左边第x个点到右边第y个点的边权，并不是双向边</span></span>
<span id="cb43-84"><a href="#cb43-84" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb43-85"><a href="#cb43-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-86"><a href="#cb43-86" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>KM<span class="op">(</span>n<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb43-87"><a href="#cb43-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb43-88"><a href="#cb43-88" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>toLeft<span class="op">[</span>i<span class="op">]&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span></span>
<span id="cb43-89"><a href="#cb43-89" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb43-90"><a href="#cb43-90" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb43-91"><a href="#cb43-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-92"><a href="#cb43-92" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb43-93"><a href="#cb43-93" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="最大权匹配转化为费用流">最大权匹配转化为费用流</h3>
<p>新增一个源点和一个汇点，从源点向二分图的每个左部点连一条流量为1，费用为0的边；从每个右部点向汇点连一条流量为1，费用为0的边；从左部点i向右部点j连一条流量为1，费用为c的边。然后这些边的反向边也要注意连上。然后求这个网络的最大费用最大流即可。</p>
<p>具体而言，最大费用的求法最好不要去该内部算法实现。把费用取相反数，然后最后答案再取相反数即可。</p>
<p>如果要输出方案，就遍历右边点到左边点的反向边，如果实际流量w变为1了，则说明走了这条边，也就是这两个点配对。</p>
<p>目前为止还只能处理完美匹配的情况。因为最大费用最大流是在最大流的前提下采取计算最大费用，也就是说它会去计算最大匹配再去计算其中的最大权。而最大权匹配是只要求权最大而不用一定是最大匹配。</p>
<p>解决方法是把左部点连一条边到汇点，容量为1，费用为0，再去求最大费用最大流。这样如果这条边有实际流量通过（即w变成0），他是失配的。</p>
<h2 id="动态维护二分图判定-todo-例题">动态维护二分图判定 TODO: 例题</h2>
<p>只判定一次可以用涂色法。动态加边可以用扩展域并查集（可撤销）来实现。</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>stack<span class="op">&lt;</span>pii<span class="op">&gt;</span> stk<span class="op">;</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DSU<span class="op">{</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fa<span class="op">[</span>MAXN<span class="op">*</span><span class="dv">2</span><span class="op">],</span> rk<span class="op">[</span>MAXN<span class="op">*</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> init<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++)</span> fa<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i<span class="op">,</span> rk<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> find<span class="op">(</span><span class="dt">int</span> x<span class="op">){</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fa<span class="op">[</span>x<span class="op">]==</span>x <span class="op">?</span> x <span class="op">:</span> find<span class="op">(</span>fa<span class="op">[</span>x<span class="op">]);</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> merge<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">){</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> find<span class="op">(</span>x<span class="op">),</span> y <span class="op">=</span> find<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>x<span class="op">==</span>y<span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>rk<span class="op">[</span>x<span class="op">]&gt;</span>rk<span class="op">[</span>y<span class="op">])</span> <span class="bu">std::</span>swap<span class="op">(</span>x<span class="op">,</span>y<span class="op">);</span></span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>        fa<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>        stk<span class="op">.</span>push<span class="op">({</span>x<span class="op">,</span>rk<span class="op">[</span>x<span class="op">]==</span>rk<span class="op">[</span>y<span class="op">]});</span><span class="co">//保存操作记录，也可以用stack以外的数据结构</span></span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>rk<span class="op">[</span>x<span class="op">]==</span>rk<span class="op">[</span>y<span class="op">])</span> rk<span class="op">[</span>y<span class="op">]++;</span></span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> erase<span class="op">(</span>pii p<span class="op">){</span></span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a>        rk<span class="op">[</span>find<span class="op">(</span>p<span class="op">.</span>first<span class="op">)]-=</span>p<span class="op">.</span>second<span class="op">;</span></span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>        fa<span class="op">[</span>p<span class="op">.</span>first<span class="op">]</span> <span class="op">=</span> p<span class="op">.</span>first<span class="op">;</span></span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> add<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">){</span></span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">//设总共n个点，每次添加一条边&lt;x,y&gt;，注意没有边也算二分图</span></span>
<span id="cb44-32"><a href="#cb44-32" aria-hidden="true" tabindex="-1"></a>    dsu<span class="op">.</span>merge<span class="op">(</span>x<span class="op">,</span>y<span class="op">+</span>n<span class="op">);</span></span>
<span id="cb44-33"><a href="#cb44-33" aria-hidden="true" tabindex="-1"></a>    dsu<span class="op">.</span>merge<span class="op">(</span>y<span class="op">,</span>x<span class="op">+</span>n<span class="op">);</span></span>
<span id="cb44-34"><a href="#cb44-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>dsu<span class="op">.</span>find<span class="op">(</span>x<span class="op">)==</span>dsu<span class="op">.</span>find<span class="op">(</span>x<span class="op">+</span>n<span class="op">)</span> <span class="op">||</span> dsu<span class="op">.</span>find<span class="op">(</span>y<span class="op">)==</span>dsu<span class="op">.</span>find<span class="op">(</span>y<span class="op">+</span>n<span class="op">)){</span></span>
<span id="cb44-35"><a href="#cb44-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">//说明不是二分图</span></span>
<span id="cb44-36"><a href="#cb44-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb44-37"><a href="#cb44-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb44-38"><a href="#cb44-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span><span class="op">{</span></span>
<span id="cb44-39"><a href="#cb44-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">//说明是二分图</span></span>
<span id="cb44-40"><a href="#cb44-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb44-41"><a href="#cb44-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb44-42"><a href="#cb44-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb44-43"><a href="#cb44-43" aria-hidden="true" tabindex="-1"></a><span class="co">//删边的时候，需要注意用一个pii删（调用erase函数），first保存了&lt;x,y&gt;这条边的x（y可以用find函数找出来），second保存了秩的数据，在删边时有用。至于删完是不是二分图，我没有找到办法。我做过的题目都是，添加了这条边后不再是二分图，输出某个结果，然后撤销这条边（之后显然是二分图）。要不就是只有加边的。直接删去任意一条边的题目并没有遇到过。</span></span></code></pre></div>
<h2 id="网络流">网络流</h2>
<h3 id="最大流">最大流</h3>
<h4 id="dfs实现的ford-fulkerson">DFS实现的Ford-Fulkerson</h4>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu 3376</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度O(ef)，边数乘以最大流，所以在luogu上这题超时</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL<span class="op">;</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">205</span><span class="op">;</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> LL INF <span class="op">=</span> <span class="bn">0xffffffff</span><span class="op">;</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">;</span>LL w<span class="op">;</span><span class="co">//指向的点，容量</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>    Edge<span class="op">(</span><span class="dt">int</span> <span class="va">v_</span><span class="op">,</span> LL <span class="va">w_</span><span class="op">):</span>v<span class="op">(</span><span class="va">v_</span><span class="op">),</span>w<span class="op">(</span><span class="va">w_</span><span class="op">){}</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Edge<span class="op">&gt;</span> edges<span class="op">;</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&gt;</span> graph<span class="op">(</span>MAXN<span class="op">);</span><span class="co">//vector版的链式前向星</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> vis<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>LL DFS<span class="op">(</span><span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> p<span class="op">,</span> LL <span class="at">const</span> <span class="op">&amp;</span> flow<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> s<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> t<span class="op">){</span></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>p<span class="op">==</span>t<span class="op">)</span> <span class="cf">return</span> flow<span class="op">;</span></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>    vis<span class="op">[</span>p<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> graph<span class="op">[</span>p<span class="op">].</span>size<span class="op">();</span></span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span> <span class="op">;</span> i<span class="op">&lt;</span>size <span class="op">;</span> i<span class="op">++){</span></span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> eg <span class="op">=</span> graph<span class="op">[</span>p<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> to <span class="op">=</span> edges<span class="op">[</span>eg<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a>        LL vol <span class="op">=</span> edges<span class="op">[</span>eg<span class="op">].</span>w<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>vol<span class="op">&gt;</span><span class="dv">0</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>vis<span class="op">[</span>to<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>c<span class="op">=</span>DFS<span class="op">(</span>to<span class="op">,</span><span class="bu">std::</span>min<span class="op">(</span>flow<span class="op">,</span>vol<span class="op">),</span>s<span class="op">,</span>t<span class="op">))!=-</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">[</span>eg<span class="op">].</span>w <span class="op">-=</span> c<span class="op">;</span></span>
<span id="cb45-33"><a href="#cb45-33" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">[</span>eg<span class="op">^</span><span class="dv">1</span><span class="op">].</span>w <span class="op">+=</span> c<span class="op">;</span></span>
<span id="cb45-34"><a href="#cb45-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> c<span class="op">;</span></span>
<span id="cb45-35"><a href="#cb45-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb45-36"><a href="#cb45-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb45-37"><a href="#cb45-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-38"><a href="#cb45-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb45-39"><a href="#cb45-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb45-40"><a href="#cb45-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-41"><a href="#cb45-41" aria-hidden="true" tabindex="-1"></a>LL FF<span class="op">(</span><span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> p<span class="op">,</span> LL <span class="at">const</span> <span class="op">&amp;</span> flow<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> s<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> t<span class="op">){</span></span>
<span id="cb45-42"><a href="#cb45-42" aria-hidden="true" tabindex="-1"></a>    LL ans <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> c<span class="op">;</span></span>
<span id="cb45-43"><a href="#cb45-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">((</span>c<span class="op">=</span>DFS<span class="op">(</span>p<span class="op">,</span>flow<span class="op">,</span>s<span class="op">,</span>t<span class="op">))!=-</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb45-44"><a href="#cb45-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>memset<span class="op">(</span>vis<span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>vis<span class="op">));</span></span>
<span id="cb45-45"><a href="#cb45-45" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">+=</span> c<span class="op">;</span></span>
<span id="cb45-46"><a href="#cb45-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb45-47"><a href="#cb45-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb45-48"><a href="#cb45-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb45-49"><a href="#cb45-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-50"><a href="#cb45-50" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb45-51"><a href="#cb45-51" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">,</span>s<span class="op">,</span>t<span class="op">;</span><span class="co">//点数，边数，源点，汇点</span></span>
<span id="cb45-52"><a href="#cb45-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">&gt;&gt;</span>s<span class="op">&gt;&gt;</span>t<span class="op">;</span></span>
<span id="cb45-53"><a href="#cb45-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-54"><a href="#cb45-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb45-55"><a href="#cb45-55" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span>v<span class="op">;</span>LL w<span class="op">;</span></span>
<span id="cb45-56"><a href="#cb45-56" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>u<span class="op">&gt;&gt;</span>v<span class="op">&gt;&gt;</span>w<span class="op">;</span><span class="co">//起点，终点，边容量</span></span>
<span id="cb45-57"><a href="#cb45-57" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb45-58"><a href="#cb45-58" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>v<span class="op">,</span>w<span class="op">));</span></span>
<span id="cb45-59"><a href="#cb45-59" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>v<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb45-60"><a href="#cb45-60" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>u<span class="op">,</span><span class="dv">0</span><span class="op">));</span></span>
<span id="cb45-61"><a href="#cb45-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb45-62"><a href="#cb45-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-63"><a href="#cb45-63" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>FF<span class="op">(</span>s<span class="op">,</span>INF<span class="op">,</span>s<span class="op">,</span>t<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span><span class="co">//输出最大流</span></span>
<span id="cb45-64"><a href="#cb45-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-65"><a href="#cb45-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb45-66"><a href="#cb45-66" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="edmondskarp">EdmondsKarp</h4>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P3376</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co">//EK算法的时间复杂度为O(nm^2)，这题不会超时</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL<span class="op">;</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">205</span><span class="op">;</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> LL INF <span class="op">=</span> <span class="bn">0xffffffff</span><span class="op">;</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">;</span>LL w<span class="op">;</span><span class="co">//指向的点，容量</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>    Edge<span class="op">(</span><span class="dt">int</span> <span class="va">v_</span><span class="op">,</span> LL <span class="va">w_</span><span class="op">):</span>v<span class="op">(</span><span class="va">v_</span><span class="op">),</span>w<span class="op">(</span><span class="va">w_</span><span class="op">){}</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Edge<span class="op">&gt;</span> edges<span class="op">;</span></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&gt;</span> graph<span class="op">(</span>MAXN<span class="op">);</span><span class="co">//vector版的链式前向星</span></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> last<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>LL flow<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> BFS<span class="op">(</span><span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> s<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> t<span class="op">){</span></span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>memset<span class="op">(</span>last<span class="op">,-</span><span class="dv">1</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>last<span class="op">));</span></span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> qu<span class="op">;</span></span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a>    qu<span class="op">.</span>push<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a>    flow<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb46-28"><a href="#cb46-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(!</span>qu<span class="op">.</span>empty<span class="op">()){</span></span>
<span id="cb46-29"><a href="#cb46-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> p <span class="op">=</span> qu<span class="op">.</span>front<span class="op">();</span></span>
<span id="cb46-30"><a href="#cb46-30" aria-hidden="true" tabindex="-1"></a>        qu<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb46-31"><a href="#cb46-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>p <span class="op">==</span> t<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb46-32"><a href="#cb46-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-33"><a href="#cb46-33" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> size <span class="op">=</span> graph<span class="op">[</span>p<span class="op">].</span>size<span class="op">();</span></span>
<span id="cb46-34"><a href="#cb46-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>size<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb46-35"><a href="#cb46-35" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> eg <span class="op">=</span> graph<span class="op">[</span>p<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb46-36"><a href="#cb46-36" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> to <span class="op">=</span> edges<span class="op">[</span>eg<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb46-37"><a href="#cb46-37" aria-hidden="true" tabindex="-1"></a>            LL vol <span class="op">=</span> edges<span class="op">[</span>eg<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb46-38"><a href="#cb46-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>vol<span class="op">&gt;</span><span class="dv">0</span> <span class="op">&amp;&amp;</span> last<span class="op">[</span>to<span class="op">]</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb46-39"><a href="#cb46-39" aria-hidden="true" tabindex="-1"></a>                last<span class="op">[</span>to<span class="op">]</span> <span class="op">=</span> eg<span class="op">;</span></span>
<span id="cb46-40"><a href="#cb46-40" aria-hidden="true" tabindex="-1"></a>                flow<span class="op">[</span>to<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>flow<span class="op">[</span>p<span class="op">],</span> vol<span class="op">);</span></span>
<span id="cb46-41"><a href="#cb46-41" aria-hidden="true" tabindex="-1"></a>                qu<span class="op">.</span>push<span class="op">(</span>to<span class="op">);</span></span>
<span id="cb46-42"><a href="#cb46-42" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb46-43"><a href="#cb46-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb46-44"><a href="#cb46-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb46-45"><a href="#cb46-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> last<span class="op">[</span>t<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb46-46"><a href="#cb46-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-47"><a href="#cb46-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-48"><a href="#cb46-48" aria-hidden="true" tabindex="-1"></a>LL EK<span class="op">(</span><span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> s<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> t<span class="op">){</span></span>
<span id="cb46-49"><a href="#cb46-49" aria-hidden="true" tabindex="-1"></a>    LL ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb46-50"><a href="#cb46-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-51"><a href="#cb46-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>BFS<span class="op">(</span>s<span class="op">,</span>t<span class="op">)){</span></span>
<span id="cb46-52"><a href="#cb46-52" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">+=</span> flow<span class="op">[</span>t<span class="op">];</span></span>
<span id="cb46-53"><a href="#cb46-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>t<span class="op">;</span>i<span class="op">!=</span>s<span class="op">;</span>i<span class="op">=</span>edges<span class="op">[</span>last<span class="op">[</span>i<span class="op">]^</span><span class="dv">1</span><span class="op">].</span>v<span class="op">){</span></span>
<span id="cb46-54"><a href="#cb46-54" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">[</span>last<span class="op">[</span>i<span class="op">]].</span>w <span class="op">-=</span> flow<span class="op">[</span>t<span class="op">];</span></span>
<span id="cb46-55"><a href="#cb46-55" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">[</span>last<span class="op">[</span>i<span class="op">]^</span><span class="dv">1</span><span class="op">].</span>w <span class="op">+=</span> flow<span class="op">[</span>t<span class="op">];</span></span>
<span id="cb46-56"><a href="#cb46-56" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb46-57"><a href="#cb46-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb46-58"><a href="#cb46-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-59"><a href="#cb46-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb46-60"><a href="#cb46-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-61"><a href="#cb46-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-62"><a href="#cb46-62" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb46-63"><a href="#cb46-63" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">,</span>s<span class="op">,</span>t<span class="op">;</span><span class="co">//点数，边数，源点，汇点</span></span>
<span id="cb46-64"><a href="#cb46-64" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">&gt;&gt;</span>s<span class="op">&gt;&gt;</span>t<span class="op">;</span></span>
<span id="cb46-65"><a href="#cb46-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-66"><a href="#cb46-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb46-67"><a href="#cb46-67" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span>v<span class="op">;</span>LL w<span class="op">;</span></span>
<span id="cb46-68"><a href="#cb46-68" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>u<span class="op">&gt;&gt;</span>v<span class="op">&gt;&gt;</span>w<span class="op">;</span></span>
<span id="cb46-69"><a href="#cb46-69" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb46-70"><a href="#cb46-70" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>v<span class="op">,</span>w<span class="op">));</span></span>
<span id="cb46-71"><a href="#cb46-71" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>v<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb46-72"><a href="#cb46-72" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>u<span class="op">,</span><span class="dv">0</span><span class="op">));</span></span>
<span id="cb46-73"><a href="#cb46-73" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb46-74"><a href="#cb46-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-75"><a href="#cb46-75" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>EK<span class="op">(</span>s<span class="op">,</span>t<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb46-76"><a href="#cb46-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-77"><a href="#cb46-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb46-78"><a href="#cb46-78" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="dinic-todo-如果可能换成链式前向星">Dinic TODO:
如果可能换成链式前向星</h4>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P3376</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="co">//Dinic算法的时间复杂度为O(n^2m)，这题不会超时</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL<span class="op">;</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">205</span><span class="op">;</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> LL INF <span class="op">=</span> <span class="bn">0xffffffff</span><span class="op">;</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">;</span>LL w<span class="op">;</span><span class="co">//指向的点，容量</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>    Edge<span class="op">(</span><span class="dt">int</span> <span class="va">v_</span><span class="op">,</span> LL <span class="va">w_</span><span class="op">):</span>v<span class="op">(</span><span class="va">v_</span><span class="op">),</span>w<span class="op">(</span><span class="va">w_</span><span class="op">){}</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Edge<span class="op">&gt;</span> edges<span class="op">;</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&gt;</span> graph<span class="op">(</span>MAXN<span class="op">);</span><span class="co">//vector版的链式前向星</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> cur<span class="op">(</span>MAXN<span class="op">);</span></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> level<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> BFS<span class="op">(</span><span class="dt">int</span> s<span class="op">,</span> <span class="dt">int</span> t<span class="op">){</span><span class="co">//BFS分层</span></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>memset<span class="op">(</span>level<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>level<span class="op">));</span></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>    level<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>    cur<span class="op">.</span>assign<span class="op">(</span>MAXN<span class="op">,</span><span class="dv">0</span><span class="op">);</span><span class="co">//初始化当前弧</span></span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> qu<span class="op">;</span></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a>    qu<span class="op">.</span>push<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(!</span>qu<span class="op">.</span>empty<span class="op">()){</span></span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> p <span class="op">=</span> qu<span class="op">.</span>front<span class="op">();</span></span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>        qu<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> size <span class="op">=</span> graph<span class="op">[</span>p<span class="op">].</span>size<span class="op">();</span></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>size<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> eg <span class="op">=</span> graph<span class="op">[</span>p<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> to <span class="op">=</span> edges<span class="op">[</span>eg<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a>            LL vol <span class="op">=</span> edges<span class="op">[</span>eg<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>vol<span class="op">&gt;</span><span class="dv">0</span> <span class="op">&amp;&amp;</span> level<span class="op">[</span>to<span class="op">]</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb47-39"><a href="#cb47-39" aria-hidden="true" tabindex="-1"></a>                level<span class="op">[</span>to<span class="op">]</span> <span class="op">=</span> level<span class="op">[</span>p<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb47-40"><a href="#cb47-40" aria-hidden="true" tabindex="-1"></a>                qu<span class="op">.</span>push<span class="op">(</span>to<span class="op">);</span></span>
<span id="cb47-41"><a href="#cb47-41" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb47-42"><a href="#cb47-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb47-43"><a href="#cb47-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb47-44"><a href="#cb47-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-45"><a href="#cb47-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> level<span class="op">[</span>t<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb47-46"><a href="#cb47-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-47"><a href="#cb47-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-48"><a href="#cb47-48" aria-hidden="true" tabindex="-1"></a>LL DFS<span class="op">(</span><span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> p<span class="op">,</span> LL <span class="at">const</span> <span class="op">&amp;</span> flow<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> s<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> t<span class="op">){</span></span>
<span id="cb47-49"><a href="#cb47-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>p<span class="op">==</span>t<span class="op">)</span> <span class="cf">return</span> flow<span class="op">;</span></span>
<span id="cb47-50"><a href="#cb47-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-51"><a href="#cb47-51" aria-hidden="true" tabindex="-1"></a>    LL surplus <span class="op">=</span> flow<span class="op">;</span><span class="co">//剩余流量</span></span>
<span id="cb47-52"><a href="#cb47-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-53"><a href="#cb47-53" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> graph<span class="op">[</span>p<span class="op">].</span>size<span class="op">();</span></span>
<span id="cb47-54"><a href="#cb47-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>cur<span class="op">[</span>p<span class="op">];</span>i<span class="op">&lt;</span>size <span class="op">&amp;&amp;</span> surplus<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb47-55"><a href="#cb47-55" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> eg <span class="op">=</span> graph<span class="op">[</span>p<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb47-56"><a href="#cb47-56" aria-hidden="true" tabindex="-1"></a>        cur<span class="op">[</span>p<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span><span class="co">//更新当前弧</span></span>
<span id="cb47-57"><a href="#cb47-57" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> to <span class="op">=</span> edges<span class="op">[</span>eg<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb47-58"><a href="#cb47-58" aria-hidden="true" tabindex="-1"></a>        LL vol <span class="op">=</span> edges<span class="op">[</span>eg<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb47-59"><a href="#cb47-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>vol<span class="op">&gt;</span><span class="dv">0</span> <span class="op">&amp;&amp;</span> level<span class="op">[</span>to<span class="op">]==</span>level<span class="op">[</span>p<span class="op">]+</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb47-60"><a href="#cb47-60" aria-hidden="true" tabindex="-1"></a>            LL c <span class="op">=</span> DFS<span class="op">(</span>to<span class="op">,</span> <span class="bu">std::</span>min<span class="op">(</span>vol<span class="op">,</span> surplus<span class="op">),</span> s<span class="op">,</span> t<span class="op">);</span></span>
<span id="cb47-61"><a href="#cb47-61" aria-hidden="true" tabindex="-1"></a>            surplus <span class="op">-=</span> c<span class="op">;</span></span>
<span id="cb47-62"><a href="#cb47-62" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">[</span>eg<span class="op">].</span>w <span class="op">-=</span> c<span class="op">;</span></span>
<span id="cb47-63"><a href="#cb47-63" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">[</span>eg<span class="op">^</span><span class="dv">1</span><span class="op">].</span>w <span class="op">+=</span> c<span class="op">;</span></span>
<span id="cb47-64"><a href="#cb47-64" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb47-65"><a href="#cb47-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb47-66"><a href="#cb47-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-67"><a href="#cb47-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flow <span class="op">-</span> surplus<span class="op">;</span></span>
<span id="cb47-68"><a href="#cb47-68" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-69"><a href="#cb47-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-70"><a href="#cb47-70" aria-hidden="true" tabindex="-1"></a>LL Dinic<span class="op">(</span><span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> p<span class="op">,</span> LL <span class="at">const</span> <span class="op">&amp;</span> flow<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> s<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> t<span class="op">){</span></span>
<span id="cb47-71"><a href="#cb47-71" aria-hidden="true" tabindex="-1"></a>    LL ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb47-72"><a href="#cb47-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>BFS<span class="op">(</span>s<span class="op">,</span>t<span class="op">)){</span></span>
<span id="cb47-73"><a href="#cb47-73" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">+=</span> DFS<span class="op">(</span>p<span class="op">,</span>flow<span class="op">,</span>s<span class="op">,</span>t<span class="op">);</span></span>
<span id="cb47-74"><a href="#cb47-74" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb47-75"><a href="#cb47-75" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb47-76"><a href="#cb47-76" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-77"><a href="#cb47-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-78"><a href="#cb47-78" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb47-79"><a href="#cb47-79" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">,</span>s<span class="op">,</span>t<span class="op">;</span><span class="co">//点数，边数，源点，汇点</span></span>
<span id="cb47-80"><a href="#cb47-80" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">&gt;&gt;</span>s<span class="op">&gt;&gt;</span>t<span class="op">;</span></span>
<span id="cb47-81"><a href="#cb47-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-82"><a href="#cb47-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb47-83"><a href="#cb47-83" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span>v<span class="op">;</span>LL w<span class="op">;</span></span>
<span id="cb47-84"><a href="#cb47-84" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>u<span class="op">&gt;&gt;</span>v<span class="op">&gt;&gt;</span>w<span class="op">;</span></span>
<span id="cb47-85"><a href="#cb47-85" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb47-86"><a href="#cb47-86" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>v<span class="op">,</span>w<span class="op">));</span></span>
<span id="cb47-87"><a href="#cb47-87" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>v<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb47-88"><a href="#cb47-88" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>u<span class="op">,</span><span class="dv">0</span><span class="op">));</span></span>
<span id="cb47-89"><a href="#cb47-89" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb47-90"><a href="#cb47-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-91"><a href="#cb47-91" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>Dinic<span class="op">(</span>s<span class="op">,</span>INF<span class="op">,</span>s<span class="op">,</span>t<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb47-92"><a href="#cb47-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-93"><a href="#cb47-93" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb47-94"><a href="#cb47-94" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="isap算法-todo">ISAP算法 TODO</h3>
<h3 id="最大流最小割定理">最大流最小割定理</h3>
<p>网络流的最大流等于其所有割的最小容量。</p>
<p>割：从网络中选择一些边，去掉这些边后，剩下恰好两个互相不连通的分别包含源点和汇点的点集（当然其他边不去掉）。去掉的这些边就是一个割。</p>
<p>割的大小就是去掉的这些边的容量之和。</p>
<h3 id="最小费用最大流">最小费用最大流</h3>
<p>即在使流最大的前提下，最小化费用。费用是一条边的属性，一条边的总费用等于它的单位费用<span class="math inline">\(\times\)</span>流过的流量。</p>
<p>建边的时候，反向边的容量为0，费用为相反数。</p>
<h4 id="ekspfa">EK+SPFA</h4>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P3381</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="co">//EK+SPFA的实现，复杂度为O(nmf)，即点数、边数、最大流</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL<span class="op">;</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="bu">std::</span>pair<span class="op">&lt;</span>LL<span class="op">,</span>LL<span class="op">&gt;</span> pll<span class="op">;</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">5005</span><span class="op">;</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> LL INF <span class="op">=</span> <span class="bn">0xffffffff</span><span class="op">;</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">;</span>LL w<span class="op">;</span>LL c<span class="op">;</span><span class="co">//指向的点，容量，费用</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    Edge<span class="op">(</span><span class="dt">int</span> <span class="va">v_</span><span class="op">,</span> LL <span class="va">w_</span><span class="op">,</span> LL <span class="va">c_</span><span class="op">):</span>v<span class="op">(</span><span class="va">v_</span><span class="op">),</span>w<span class="op">(</span><span class="va">w_</span><span class="op">),</span>c<span class="op">(</span><span class="va">c_</span><span class="op">){}</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Edge<span class="op">&gt;</span> edges<span class="op">;</span></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&gt;</span> graph<span class="op">(</span>MAXN<span class="op">);</span><span class="co">//vector版的链式前向星</span></span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> last<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>LL flow<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>LL dis<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> inq<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> SPFA<span class="op">(</span><span class="dt">int</span> s<span class="op">,</span> <span class="dt">int</span> t<span class="op">){</span></span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> qu<span class="op">;</span></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>    qu<span class="op">.</span>push<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>memset<span class="op">(</span>last<span class="op">,-</span><span class="dv">1</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>last<span class="op">));</span></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>memset<span class="op">(</span>dis<span class="op">,</span><span class="dv">127</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>dis<span class="op">));</span></span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>memset<span class="op">(</span>inq<span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>inq<span class="op">));</span></span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-34"><a href="#cb48-34" aria-hidden="true" tabindex="-1"></a>    flow<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> INF<span class="op">;</span></span>
<span id="cb48-35"><a href="#cb48-35" aria-hidden="true" tabindex="-1"></a>    dis<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb48-36"><a href="#cb48-36" aria-hidden="true" tabindex="-1"></a>    inq<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb48-37"><a href="#cb48-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb48-38"><a href="#cb48-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(!</span>qu<span class="op">.</span>empty<span class="op">()){</span></span>
<span id="cb48-39"><a href="#cb48-39" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> p <span class="op">=</span> qu<span class="op">.</span>front<span class="op">();</span></span>
<span id="cb48-40"><a href="#cb48-40" aria-hidden="true" tabindex="-1"></a>        qu<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb48-41"><a href="#cb48-41" aria-hidden="true" tabindex="-1"></a>        inq<span class="op">[</span>p<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb48-42"><a href="#cb48-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-43"><a href="#cb48-43" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> size <span class="op">=</span> graph<span class="op">[</span>p<span class="op">].</span>size<span class="op">();</span></span>
<span id="cb48-44"><a href="#cb48-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>size<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb48-45"><a href="#cb48-45" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> eg <span class="op">=</span> graph<span class="op">[</span>p<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb48-46"><a href="#cb48-46" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> to <span class="op">=</span> edges<span class="op">[</span>eg<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb48-47"><a href="#cb48-47" aria-hidden="true" tabindex="-1"></a>            LL vol <span class="op">=</span> edges<span class="op">[</span>eg<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb48-48"><a href="#cb48-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>vol<span class="op">&gt;</span><span class="dv">0</span> <span class="op">&amp;&amp;</span> dis<span class="op">[</span>to<span class="op">]&gt;</span>dis<span class="op">[</span>p<span class="op">]+</span>edges<span class="op">[</span>eg<span class="op">].</span>c<span class="op">){</span></span>
<span id="cb48-49"><a href="#cb48-49" aria-hidden="true" tabindex="-1"></a>                last<span class="op">[</span>to<span class="op">]</span> <span class="op">=</span> eg<span class="op">;</span></span>
<span id="cb48-50"><a href="#cb48-50" aria-hidden="true" tabindex="-1"></a>                flow<span class="op">[</span>to<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>flow<span class="op">[</span>p<span class="op">],</span> vol<span class="op">);</span></span>
<span id="cb48-51"><a href="#cb48-51" aria-hidden="true" tabindex="-1"></a>                dis<span class="op">[</span>to<span class="op">]</span> <span class="op">=</span> dis<span class="op">[</span>p<span class="op">]+</span>edges<span class="op">[</span>eg<span class="op">].</span>c<span class="op">;</span></span>
<span id="cb48-52"><a href="#cb48-52" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(!</span>inq<span class="op">[</span>to<span class="op">]){</span></span>
<span id="cb48-53"><a href="#cb48-53" aria-hidden="true" tabindex="-1"></a>                    qu<span class="op">.</span>push<span class="op">(</span>to<span class="op">);</span></span>
<span id="cb48-54"><a href="#cb48-54" aria-hidden="true" tabindex="-1"></a>                    inq<span class="op">[</span>to<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb48-55"><a href="#cb48-55" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb48-56"><a href="#cb48-56" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb48-57"><a href="#cb48-57" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb48-58"><a href="#cb48-58" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-59"><a href="#cb48-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> last<span class="op">[</span>t<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb48-60"><a href="#cb48-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb48-61"><a href="#cb48-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-62"><a href="#cb48-62" aria-hidden="true" tabindex="-1"></a>pll MCMF<span class="op">(</span><span class="dt">int</span> s<span class="op">,</span> <span class="dt">int</span> t<span class="op">){</span></span>
<span id="cb48-63"><a href="#cb48-63" aria-hidden="true" tabindex="-1"></a>    LL maxflow <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> mincost <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb48-64"><a href="#cb48-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-65"><a href="#cb48-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>SPFA<span class="op">(</span>s<span class="op">,</span>t<span class="op">)){</span></span>
<span id="cb48-66"><a href="#cb48-66" aria-hidden="true" tabindex="-1"></a>        maxflow <span class="op">+=</span> flow<span class="op">[</span>t<span class="op">];</span></span>
<span id="cb48-67"><a href="#cb48-67" aria-hidden="true" tabindex="-1"></a>        mincost <span class="op">+=</span> dis<span class="op">[</span>t<span class="op">]</span> <span class="op">*</span> flow<span class="op">[</span>t<span class="op">];</span></span>
<span id="cb48-68"><a href="#cb48-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>t<span class="op">;</span>i<span class="op">!=</span>s<span class="op">;</span>i<span class="op">=</span>edges<span class="op">[</span>last<span class="op">[</span>i<span class="op">]^</span><span class="dv">1</span><span class="op">].</span>v<span class="op">){</span></span>
<span id="cb48-69"><a href="#cb48-69" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">[</span>last<span class="op">[</span>i<span class="op">]].</span>w <span class="op">-=</span> flow<span class="op">[</span>t<span class="op">];</span></span>
<span id="cb48-70"><a href="#cb48-70" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">[</span>last<span class="op">[</span>i<span class="op">]^</span><span class="dv">1</span><span class="op">].</span>w <span class="op">+=</span> flow<span class="op">[</span>t<span class="op">];</span></span>
<span id="cb48-71"><a href="#cb48-71" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb48-72"><a href="#cb48-72" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-73"><a href="#cb48-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-74"><a href="#cb48-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>maxflow<span class="op">,</span>mincost<span class="op">};</span></span>
<span id="cb48-75"><a href="#cb48-75" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb48-76"><a href="#cb48-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-77"><a href="#cb48-77" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb48-78"><a href="#cb48-78" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">,</span>s<span class="op">,</span>t<span class="op">;</span><span class="co">//点数，边数，源点，汇点</span></span>
<span id="cb48-79"><a href="#cb48-79" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">&gt;&gt;</span>s<span class="op">&gt;&gt;</span>t<span class="op">;</span></span>
<span id="cb48-80"><a href="#cb48-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-81"><a href="#cb48-81" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb48-82"><a href="#cb48-82" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span>v<span class="op">;</span>LL w<span class="op">,</span>c<span class="op">;</span></span>
<span id="cb48-83"><a href="#cb48-83" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>u<span class="op">&gt;&gt;</span>v<span class="op">&gt;&gt;</span>w<span class="op">&gt;&gt;</span>c<span class="op">;</span></span>
<span id="cb48-84"><a href="#cb48-84" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb48-85"><a href="#cb48-85" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>v<span class="op">,</span>w<span class="op">,</span>c<span class="op">));</span></span>
<span id="cb48-86"><a href="#cb48-86" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>v<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb48-87"><a href="#cb48-87" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>u<span class="op">,</span><span class="dv">0</span><span class="op">,-</span>c<span class="op">));</span></span>
<span id="cb48-88"><a href="#cb48-88" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-89"><a href="#cb48-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-90"><a href="#cb48-90" aria-hidden="true" tabindex="-1"></a>    pll ans <span class="op">=</span> MCMF<span class="op">(</span>s<span class="op">,</span>t<span class="op">);</span></span>
<span id="cb48-91"><a href="#cb48-91" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">.</span>first<span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">&lt;&lt;</span>ans<span class="op">.</span>second<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb48-92"><a href="#cb48-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-93"><a href="#cb48-93" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb48-94"><a href="#cb48-94" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="dinicspfa">Dinic+SPFA</h4>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P3381</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="co">//Dinic+SPFA的实现，复杂度为O(nmf)，即点数、边数、最大流</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL<span class="op">;</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="bu">std::</span>pair<span class="op">&lt;</span>LL<span class="op">,</span>LL<span class="op">&gt;</span> pll<span class="op">;</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">5005</span><span class="op">;</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> LL INF <span class="op">=</span> <span class="bn">0xffffffff</span><span class="op">;</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">;</span>LL w<span class="op">,</span>c<span class="op">;</span><span class="co">//指向的点，容量，费用</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>    Edge<span class="op">(</span><span class="dt">int</span> <span class="va">v_</span><span class="op">,</span> LL <span class="va">w_</span><span class="op">,</span> LL <span class="va">c_</span><span class="op">):</span>v<span class="op">(</span><span class="va">v_</span><span class="op">),</span>w<span class="op">(</span><span class="va">w_</span><span class="op">),</span>c<span class="op">(</span><span class="va">c_</span><span class="op">){}</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Edge<span class="op">&gt;</span> edges<span class="op">;</span></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&gt;</span> graph<span class="op">(</span>MAXN<span class="op">);</span><span class="co">//vector版的链式前向星</span></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> cur<span class="op">(</span>MAXN<span class="op">);</span></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>LL dis<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> inq<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> SPFA<span class="op">(</span><span class="dt">int</span> s<span class="op">,</span> <span class="dt">int</span> t<span class="op">){</span><span class="co">//BFS分层</span></span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>fill<span class="op">(</span>dis<span class="op">,</span>dis<span class="op">+</span>MAXN<span class="op">,</span>INF<span class="op">);</span></span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>memset<span class="op">(</span>inq<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>inq<span class="op">));</span></span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a>    dis<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>    inq<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a>    cur<span class="op">.</span>assign<span class="op">(</span>MAXN<span class="op">,</span><span class="dv">0</span><span class="op">);</span><span class="co">//初始化当前弧</span></span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> qu<span class="op">;</span></span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>    qu<span class="op">.</span>push<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(!</span>qu<span class="op">.</span>empty<span class="op">()){</span></span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> p <span class="op">=</span> qu<span class="op">.</span>front<span class="op">();</span></span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>        qu<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a>        inq<span class="op">[</span>p<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb49-41"><a href="#cb49-41" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> size <span class="op">=</span> graph<span class="op">[</span>p<span class="op">].</span>size<span class="op">();</span></span>
<span id="cb49-42"><a href="#cb49-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>size<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb49-43"><a href="#cb49-43" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> eg <span class="op">=</span> graph<span class="op">[</span>p<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb49-44"><a href="#cb49-44" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> to <span class="op">=</span> edges<span class="op">[</span>eg<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb49-45"><a href="#cb49-45" aria-hidden="true" tabindex="-1"></a>            LL vol <span class="op">=</span> edges<span class="op">[</span>eg<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb49-46"><a href="#cb49-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>vol<span class="op">&gt;</span><span class="dv">0</span> <span class="op">&amp;&amp;</span> dis<span class="op">[</span>to<span class="op">]</span> <span class="op">&gt;</span> dis<span class="op">[</span>p<span class="op">]+</span>edges<span class="op">[</span>eg<span class="op">].</span>c<span class="op">){</span></span>
<span id="cb49-47"><a href="#cb49-47" aria-hidden="true" tabindex="-1"></a>                dis<span class="op">[</span>to<span class="op">]</span> <span class="op">=</span> dis<span class="op">[</span>p<span class="op">]+</span>edges<span class="op">[</span>eg<span class="op">].</span>c<span class="op">;</span></span>
<span id="cb49-48"><a href="#cb49-48" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(!</span>inq<span class="op">[</span>to<span class="op">]){</span></span>
<span id="cb49-49"><a href="#cb49-49" aria-hidden="true" tabindex="-1"></a>                    qu<span class="op">.</span>push<span class="op">(</span>to<span class="op">);</span></span>
<span id="cb49-50"><a href="#cb49-50" aria-hidden="true" tabindex="-1"></a>                    inq<span class="op">[</span>to<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb49-51"><a href="#cb49-51" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb49-52"><a href="#cb49-52" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb49-53"><a href="#cb49-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb49-54"><a href="#cb49-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb49-55"><a href="#cb49-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-56"><a href="#cb49-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dis<span class="op">[</span>t<span class="op">]</span> <span class="op">!=</span> INF<span class="op">;</span></span>
<span id="cb49-57"><a href="#cb49-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb49-58"><a href="#cb49-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-59"><a href="#cb49-59" aria-hidden="true" tabindex="-1"></a>LL DFS<span class="op">(</span><span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> p<span class="op">,</span> LL <span class="at">const</span> <span class="op">&amp;</span> flow<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> s<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> t<span class="op">){</span></span>
<span id="cb49-60"><a href="#cb49-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>p<span class="op">==</span>t<span class="op">)</span> <span class="cf">return</span> flow<span class="op">;</span></span>
<span id="cb49-61"><a href="#cb49-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-62"><a href="#cb49-62" aria-hidden="true" tabindex="-1"></a>    LL surplus <span class="op">=</span> flow<span class="op">;</span><span class="co">//剩余流量</span></span>
<span id="cb49-63"><a href="#cb49-63" aria-hidden="true" tabindex="-1"></a>    inq<span class="op">[</span>p<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span><span class="co">//由于在SPFA中都会清零，可以复用</span></span>
<span id="cb49-64"><a href="#cb49-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-65"><a href="#cb49-65" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> graph<span class="op">[</span>p<span class="op">].</span>size<span class="op">();</span></span>
<span id="cb49-66"><a href="#cb49-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>cur<span class="op">[</span>p<span class="op">];</span>i<span class="op">&lt;</span>size <span class="op">&amp;&amp;</span> surplus<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb49-67"><a href="#cb49-67" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> eg <span class="op">=</span> graph<span class="op">[</span>p<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb49-68"><a href="#cb49-68" aria-hidden="true" tabindex="-1"></a>        cur<span class="op">[</span>p<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span><span class="co">//更新当前弧</span></span>
<span id="cb49-69"><a href="#cb49-69" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> to <span class="op">=</span> edges<span class="op">[</span>eg<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb49-70"><a href="#cb49-70" aria-hidden="true" tabindex="-1"></a>        LL vol <span class="op">=</span> edges<span class="op">[</span>eg<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb49-71"><a href="#cb49-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>inq<span class="op">[</span>to<span class="op">]</span> <span class="op">&amp;&amp;</span> vol<span class="op">&gt;</span><span class="dv">0</span> <span class="op">&amp;&amp;</span> dis<span class="op">[</span>to<span class="op">]==</span>dis<span class="op">[</span>p<span class="op">]+</span>edges<span class="op">[</span>eg<span class="op">].</span>c<span class="op">){</span></span>
<span id="cb49-72"><a href="#cb49-72" aria-hidden="true" tabindex="-1"></a>            LL cx <span class="op">=</span> DFS<span class="op">(</span>to<span class="op">,</span> <span class="bu">std::</span>min<span class="op">(</span>vol<span class="op">,</span> surplus<span class="op">),</span> s<span class="op">,</span> t<span class="op">);</span></span>
<span id="cb49-73"><a href="#cb49-73" aria-hidden="true" tabindex="-1"></a>            surplus <span class="op">-=</span> cx<span class="op">;</span></span>
<span id="cb49-74"><a href="#cb49-74" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">[</span>eg<span class="op">].</span>w <span class="op">-=</span> cx<span class="op">;</span></span>
<span id="cb49-75"><a href="#cb49-75" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">[</span>eg<span class="op">^</span><span class="dv">1</span><span class="op">].</span>w <span class="op">+=</span> cx<span class="op">;</span></span>
<span id="cb49-76"><a href="#cb49-76" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb49-77"><a href="#cb49-77" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb49-78"><a href="#cb49-78" aria-hidden="true" tabindex="-1"></a>    inq<span class="op">[</span>p<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb49-79"><a href="#cb49-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-80"><a href="#cb49-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> flow <span class="op">-</span> surplus<span class="op">;</span></span>
<span id="cb49-81"><a href="#cb49-81" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb49-82"><a href="#cb49-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-83"><a href="#cb49-83" aria-hidden="true" tabindex="-1"></a>pll MCMF<span class="op">(</span><span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> p<span class="op">,</span> LL <span class="at">const</span> <span class="op">&amp;</span> flow<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> s<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> t<span class="op">){</span></span>
<span id="cb49-84"><a href="#cb49-84" aria-hidden="true" tabindex="-1"></a>    LL maxflow <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> mincost <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb49-85"><a href="#cb49-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>SPFA<span class="op">(</span>s<span class="op">,</span>t<span class="op">)){</span></span>
<span id="cb49-86"><a href="#cb49-86" aria-hidden="true" tabindex="-1"></a>        LL ret <span class="op">=</span> DFS<span class="op">(</span>p<span class="op">,</span>flow<span class="op">,</span>s<span class="op">,</span>t<span class="op">);</span></span>
<span id="cb49-87"><a href="#cb49-87" aria-hidden="true" tabindex="-1"></a>        maxflow <span class="op">+=</span> ret<span class="op">;</span></span>
<span id="cb49-88"><a href="#cb49-88" aria-hidden="true" tabindex="-1"></a>        mincost <span class="op">+=</span> ret <span class="op">*</span> dis<span class="op">[</span>t<span class="op">];</span></span>
<span id="cb49-89"><a href="#cb49-89" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb49-90"><a href="#cb49-90" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span>maxflow<span class="op">,</span>mincost<span class="op">};</span></span>
<span id="cb49-91"><a href="#cb49-91" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb49-92"><a href="#cb49-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-93"><a href="#cb49-93" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb49-94"><a href="#cb49-94" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">,</span>s<span class="op">,</span>t<span class="op">;</span><span class="co">//点数，边数，源点，汇点</span></span>
<span id="cb49-95"><a href="#cb49-95" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">&gt;&gt;</span>s<span class="op">&gt;&gt;</span>t<span class="op">;</span></span>
<span id="cb49-96"><a href="#cb49-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-97"><a href="#cb49-97" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb49-98"><a href="#cb49-98" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span>v<span class="op">;</span>LL w<span class="op">,</span>c<span class="op">;</span></span>
<span id="cb49-99"><a href="#cb49-99" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>u<span class="op">&gt;&gt;</span>v<span class="op">&gt;&gt;</span>w<span class="op">&gt;&gt;</span>c<span class="op">;</span></span>
<span id="cb49-100"><a href="#cb49-100" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb49-101"><a href="#cb49-101" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>v<span class="op">,</span>w<span class="op">,</span>c<span class="op">));</span></span>
<span id="cb49-102"><a href="#cb49-102" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>v<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb49-103"><a href="#cb49-103" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>u<span class="op">,</span><span class="dv">0</span><span class="op">,-</span>c<span class="op">));</span></span>
<span id="cb49-104"><a href="#cb49-104" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb49-105"><a href="#cb49-105" aria-hidden="true" tabindex="-1"></a>    pll ans <span class="op">=</span> MCMF<span class="op">(</span>s<span class="op">,</span>INF<span class="op">,</span>s<span class="op">,</span>t<span class="op">);</span></span>
<span id="cb49-106"><a href="#cb49-106" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">.</span>first<span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">&lt;&lt;</span>ans<span class="op">.</span>second<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb49-107"><a href="#cb49-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-108"><a href="#cb49-108" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb49-109"><a href="#cb49-109" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="上下界流">上下界流</h3>
<h4 id="无源汇上下界可行流">无源汇上下界可行流</h4>
<p>给定一个没有源点和汇点的网络，每条边的容量都有一个上界和下界，问是否有一个可行流使得流量平衡（即每个点的流入等于流出）。</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co">//loj 115</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="co">//前面的Dinic算法省略</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>LL in<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> m<span class="op">,</span> s<span class="op">,</span> t<span class="op">;</span> <span class="co">//点数，边数，源点，汇点</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op"> &gt;&gt;</span> n <span class="op">&gt;&gt;</span> m<span class="op">;</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">;</span><span class="co">//虚拟源点</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> n <span class="op">+</span> <span class="dv">2</span><span class="op">;</span><span class="co">//虚拟汇点</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>LL<span class="op">&gt;</span> ans<span class="op">;</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span> v<span class="op">;</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>        LL w1<span class="op">,</span> w2<span class="op">;</span><span class="co">//下界，上界</span></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op"> &gt;&gt;</span> u <span class="op">&gt;&gt;</span> v <span class="op">&gt;&gt;</span> w1 <span class="op">&gt;&gt;</span> w2<span class="op">;</span></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">.</span>push_back<span class="op">(</span>w1<span class="op">);</span></span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>v<span class="op">,</span> w2 <span class="op">-</span> w1<span class="op">));</span><span class="co">//只用建立差网络即可</span></span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>v<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>u<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>        in<span class="op">[</span>u<span class="op">]</span> <span class="op">-=</span> w1<span class="op">;</span></span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a>        in<span class="op">[</span>v<span class="op">]</span> <span class="op">+=</span> w1<span class="op">;</span></span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>in<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span><span class="co">//在下界网络中，有净流入的节点，要从源点连一条边，大小等于净流入</span></span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a>            graph<span class="op">[</span>s<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>i<span class="op">,</span> in<span class="op">[</span>i<span class="op">]));</span></span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a>            graph<span class="op">[</span>i<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>s<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span><span class="co">//有净流出的节点，要向汇点连一条边，大小等于净流出</span></span>
<span id="cb50-34"><a href="#cb50-34" aria-hidden="true" tabindex="-1"></a>            graph<span class="op">[</span>i<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb50-35"><a href="#cb50-35" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>t<span class="op">,</span> <span class="op">-</span>in<span class="op">[</span>i<span class="op">]));</span></span>
<span id="cb50-36"><a href="#cb50-36" aria-hidden="true" tabindex="-1"></a>            graph<span class="op">[</span>t<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb50-37"><a href="#cb50-37" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>i<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb50-38"><a href="#cb50-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb50-39"><a href="#cb50-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb50-40"><a href="#cb50-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-41"><a href="#cb50-41" aria-hidden="true" tabindex="-1"></a>    Dinic<span class="op">(</span>s<span class="op">,</span> INF<span class="op">,</span> s<span class="op">,</span> t<span class="op">);</span></span>
<span id="cb50-42"><a href="#cb50-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-43"><a href="#cb50-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> x <span class="op">:</span> graph<span class="op">[</span>s<span class="op">])</span> <span class="op">{</span></span>
<span id="cb50-44"><a href="#cb50-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>edges<span class="op">[</span>x<span class="op">].</span>w <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-45"><a href="#cb50-45" aria-hidden="true" tabindex="-1"></a>            <span class="co">//如果源点的附加边没有满流，说明不存在可行流</span></span>
<span id="cb50-46"><a href="#cb50-46" aria-hidden="true" tabindex="-1"></a>            <span class="co">//也可以换成判断汇点没有满流，二者等价</span></span>
<span id="cb50-47"><a href="#cb50-47" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&#34;NO</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb50-48"><a href="#cb50-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb50-49"><a href="#cb50-49" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb50-50"><a href="#cb50-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb50-51"><a href="#cb50-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-52"><a href="#cb50-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&#34;YES</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb50-53"><a href="#cb50-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-54"><a href="#cb50-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span> <span class="op">*</span> m<span class="op">;</span> i <span class="op">+=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-55"><a href="#cb50-55" aria-hidden="true" tabindex="-1"></a>        <span class="co">//反向边就是这条边的流量，再加之前输入的下界得到每条边的流量</span></span>
<span id="cb50-56"><a href="#cb50-56" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">[</span>i <span class="op">/</span> <span class="dv">2</span><span class="op">]</span> <span class="op">+=</span> edges<span class="op">[</span>i<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb50-57"><a href="#cb50-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb50-58"><a href="#cb50-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-59"><a href="#cb50-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> x <span class="op">:</span> ans<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-60"><a href="#cb50-60" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb50-61"><a href="#cb50-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb50-62"><a href="#cb50-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-63"><a href="#cb50-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb50-64"><a href="#cb50-64" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="有源汇上下界可行流">有源汇上下界可行流</h4>
<p>比起无源汇的情况，我们可以把图中的汇点向源点连一条下界0，上界无限大的边。然后就变成无源汇图了。处理的时候，新建附加源点汇点<span class="math inline">\(S&#39;,T&#39;\)</span>，原来的<span class="math inline">\(S,T\)</span>就变成了普通点，思路一致。</p>
<p>若有解，则<span class="math inline">\(S\)</span>到<span class="math inline">\(T\)</span>的可行流流量等于<span class="math inline">\(T\)</span>到<span class="math inline">\(S\)</span>的附加边的流量。</p>
<h4 id="有源汇上下界最大流">有源汇上下界最大流</h4>
<p>在有源汇上下界可行流有解的时候，<span class="math inline">\(S\)</span>到<span class="math inline">\(T\)</span>的可行流量就是<span class="math inline">\(T\)</span>到<span class="math inline">\(S\)</span>的附加边的流量。然后我们删去所有添加的附加边，包括<span class="math inline">\(S&#39;,T&#39;\)</span>连的以及<span class="math inline">\(T-S\)</span>附加边，再在跑完的网络上再跑一次Dinic，得到的流加上可行流就是最后的答案。</p>
<p>具体实践上，我们不需要真的把边删了，<span class="math inline">\(S&#39;,T&#39;\)</span>所连的边根本不会影响结果，可以不用管，至于<span class="math inline">\(T-S\)</span>这条边，我们获取了流量之后，直接把正向、反向边置零即可。</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">//loj 116</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="co">//前面的Dinic算法省略</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>LL in<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span> m<span class="op">,</span> s<span class="op">,</span> t<span class="op">;</span> <span class="co">//点数，边数，源点，汇点</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op"> &gt;&gt;</span> n <span class="op">&gt;&gt;</span> m <span class="op">&gt;&gt;</span> s <span class="op">&gt;&gt;</span> t<span class="op">;</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span> v<span class="op">;</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>        LL w1<span class="op">,</span> w2<span class="op">;</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op"> &gt;&gt;</span> u <span class="op">&gt;&gt;</span> v <span class="op">&gt;&gt;</span> w1 <span class="op">&gt;&gt;</span> w2<span class="op">;</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>v<span class="op">,</span> w2 <span class="op">-</span> w1<span class="op">));</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>        graph<span class="op">[</span>v<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>u<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>        in<span class="op">[</span>u<span class="op">]</span> <span class="op">-=</span> w1<span class="op">;</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>        in<span class="op">[</span>v<span class="op">]</span> <span class="op">+=</span> w1<span class="op">;</span></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a>    graph<span class="op">[</span>t<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>s<span class="op">,</span> INF <span class="op">*</span> <span class="dv">4</span><span class="bu">ll</span><span class="op">));</span></span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a>    graph<span class="op">[</span>s<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>t<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">//T-S的边</span></span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> s2 <span class="op">=</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> t2 <span class="op">=</span> n <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb51-28"><a href="#cb51-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-29"><a href="#cb51-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb51-30"><a href="#cb51-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>in<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb51-31"><a href="#cb51-31" aria-hidden="true" tabindex="-1"></a>            graph<span class="op">[</span>s2<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb51-32"><a href="#cb51-32" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>i<span class="op">,</span> in<span class="op">[</span>i<span class="op">]));</span></span>
<span id="cb51-33"><a href="#cb51-33" aria-hidden="true" tabindex="-1"></a>            graph<span class="op">[</span>i<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb51-34"><a href="#cb51-34" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>s2<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb51-35"><a href="#cb51-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb51-36"><a href="#cb51-36" aria-hidden="true" tabindex="-1"></a>            graph<span class="op">[</span>i<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb51-37"><a href="#cb51-37" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>t2<span class="op">,</span> <span class="op">-</span>in<span class="op">[</span>i<span class="op">]));</span></span>
<span id="cb51-38"><a href="#cb51-38" aria-hidden="true" tabindex="-1"></a>            graph<span class="op">[</span>t2<span class="op">].</span>push_back<span class="op">(</span>edges<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb51-39"><a href="#cb51-39" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">.</span>push_back<span class="op">(</span>Edge<span class="op">(</span>i<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb51-40"><a href="#cb51-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb51-41"><a href="#cb51-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb51-42"><a href="#cb51-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-43"><a href="#cb51-43" aria-hidden="true" tabindex="-1"></a>    Dinic<span class="op">(</span>s2<span class="op">,</span> INF<span class="op">,</span> s2<span class="op">,</span> t2<span class="op">);</span></span>
<span id="cb51-44"><a href="#cb51-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-45"><a href="#cb51-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> x <span class="op">:</span> graph<span class="op">[</span>s2<span class="op">])</span> <span class="op">{</span></span>
<span id="cb51-46"><a href="#cb51-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>edges<span class="op">[</span>x<span class="op">].</span>w <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb51-47"><a href="#cb51-47" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&#34;please go home to sleep</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb51-48"><a href="#cb51-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb51-49"><a href="#cb51-49" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb51-50"><a href="#cb51-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb51-51"><a href="#cb51-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-52"><a href="#cb51-52" aria-hidden="true" tabindex="-1"></a>    LL flow <span class="op">=</span> edges<span class="op">[</span><span class="dv">2</span> <span class="op">*</span> m <span class="op">+</span> <span class="dv">1</span><span class="op">].</span>w<span class="op">;</span></span>
<span id="cb51-53"><a href="#cb51-53" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">[</span><span class="dv">2</span> <span class="op">*</span> m<span class="op">].</span>w <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> edges<span class="op">[</span><span class="dv">2</span> <span class="op">*</span> m <span class="op">+</span> <span class="dv">1</span><span class="op">].</span>w <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb51-54"><a href="#cb51-54" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> Dinic<span class="op">(</span>s<span class="op">,</span> INF<span class="op">,</span> s<span class="op">,</span> t<span class="op">)</span> <span class="op">+</span> flow <span class="op">&lt;&lt;</span> <span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb51-55"><a href="#cb51-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-56"><a href="#cb51-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb51-57"><a href="#cb51-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="有源汇上下界最小流">有源汇上下界最小流</h4>
<p>和上面几乎一模一样，只需在拆掉附加边后，从汇点到源点跑一次Dinic，然后flow删去这个结果就得到最小流。Loj
117。</p>
<h2 id="割边tarjan算法">割边（Tarjan算法）</h2>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 n+m</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="co">//tarjan求割边，可以正确处理重边</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="co">//如果无向图中删掉某条边会使无向图的连通分量数增多，那么这条边叫割边</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p1656</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">20005</span><span class="op">;</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXM <span class="op">=</span> <span class="dv">100005</span><span class="op">;</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfn<span class="op">[</span>MAXN<span class="op">],</span> low<span class="op">[</span>MAXN<span class="op">],</span> cnt<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a><span class="co">//dfn为对一个图进行dfs时，dfs的顺序序号</span></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a><span class="co">//low[x]为以下所有符合要求的节点的dfn中的最小值</span></span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a><span class="co">//1.以x为根的子树的所有节点</span></span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a><span class="co">//2.通过非dfs生成树上的边能够到达该子树的所有节点</span></span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">,</span>next<span class="op">;</span><span class="co">//指向的点，边权，下一条边</span></span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-22"><a href="#cb52-22" aria-hidden="true" tabindex="-1"></a>Edge edges<span class="op">[</span>MAXM<span class="op">*</span><span class="dv">2</span><span class="op">];</span><span class="co">//存无向图记得开两倍</span></span>
<span id="cb52-23"><a href="#cb52-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> head<span class="op">[</span>MAXN<span class="op">],</span>ecnt<span class="op">=</span><span class="dv">1</span><span class="op">;</span><span class="co">//注意这个ecnt=1，这是用来方便in_edge判断的</span></span>
<span id="cb52-24"><a href="#cb52-24" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> bridges<span class="op">[</span>MAXM<span class="op">*</span><span class="dv">2</span><span class="op">];</span><span class="co">//判断一条边是不是割边</span></span>
<span id="cb52-25"><a href="#cb52-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-26"><a href="#cb52-26" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">void</span> add<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> v<span class="op">){</span></span>
<span id="cb52-27"><a href="#cb52-27" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">[++</span>ecnt<span class="op">].</span>v <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb52-28"><a href="#cb52-28" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">[</span>ecnt<span class="op">].</span>next <span class="op">=</span> head<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb52-29"><a href="#cb52-29" aria-hidden="true" tabindex="-1"></a>    head<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> ecnt<span class="op">;</span></span>
<span id="cb52-30"><a href="#cb52-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb52-31"><a href="#cb52-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-32"><a href="#cb52-32" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> tarjan<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> in_edge<span class="op">){</span></span>
<span id="cb52-33"><a href="#cb52-33" aria-hidden="true" tabindex="-1"></a>    low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> dfn<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="op">++</span>cnt<span class="op">;</span></span>
<span id="cb52-34"><a href="#cb52-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>head<span class="op">[</span>u<span class="op">];</span>i<span class="op">;</span>i<span class="op">=</span>edges<span class="op">[</span>i<span class="op">].</span>next<span class="op">){</span></span>
<span id="cb52-35"><a href="#cb52-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> edges<span class="op">[</span>i<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb52-36"><a href="#cb52-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>dfn<span class="op">[</span>v<span class="op">]){</span></span>
<span id="cb52-37"><a href="#cb52-37" aria-hidden="true" tabindex="-1"></a>            tarjan<span class="op">(</span>v<span class="op">,</span>i<span class="op">);</span></span>
<span id="cb52-38"><a href="#cb52-38" aria-hidden="true" tabindex="-1"></a>            low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>low<span class="op">[</span>u<span class="op">],</span>low<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb52-39"><a href="#cb52-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>low<span class="op">[</span>v<span class="op">]&gt;</span>dfn<span class="op">[</span>u<span class="op">])</span><span class="co">//边u-v是割边的充要条件</span></span>
<span id="cb52-40"><a href="#cb52-40" aria-hidden="true" tabindex="-1"></a>                bridges<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> bridges<span class="op">[</span>i<span class="op">^</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>          </span>
<span id="cb52-41"><a href="#cb52-41" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb52-42"><a href="#cb52-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb52-43"><a href="#cb52-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>i <span class="op">!=</span> <span class="op">(</span>in_edge <span class="op">^</span> <span class="dv">1</span><span class="op">)){</span></span>
<span id="cb52-44"><a href="#cb52-44" aria-hidden="true" tabindex="-1"></a>            low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>low<span class="op">[</span>u<span class="op">],</span> dfn<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb52-45"><a href="#cb52-45" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb52-46"><a href="#cb52-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb52-47"><a href="#cb52-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb52-48"><a href="#cb52-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-49"><a href="#cb52-49" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb52-50"><a href="#cb52-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span></span>
<span id="cb52-51"><a href="#cb52-51" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">;</span></span>
<span id="cb52-52"><a href="#cb52-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">//点数，边数</span></span>
<span id="cb52-53"><a href="#cb52-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb52-54"><a href="#cb52-54" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a<span class="op">,</span>b<span class="op">;</span></span>
<span id="cb52-55"><a href="#cb52-55" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>a<span class="op">&gt;&gt;</span>b<span class="op">;</span></span>
<span id="cb52-56"><a href="#cb52-56" aria-hidden="true" tabindex="-1"></a>        <span class="co">//起点，终点</span></span>
<span id="cb52-57"><a href="#cb52-57" aria-hidden="true" tabindex="-1"></a>        add<span class="op">(</span>a<span class="op">,</span>b<span class="op">);</span></span>
<span id="cb52-58"><a href="#cb52-58" aria-hidden="true" tabindex="-1"></a>        add<span class="op">(</span>b<span class="op">,</span>a<span class="op">);</span></span>
<span id="cb52-59"><a href="#cb52-59" aria-hidden="true" tabindex="-1"></a>        <span class="co">//无向图</span></span>
<span id="cb52-60"><a href="#cb52-60" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb52-61"><a href="#cb52-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb52-62"><a href="#cb52-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>dfn<span class="op">[</span>i<span class="op">])</span></span>
<span id="cb52-63"><a href="#cb52-63" aria-hidden="true" tabindex="-1"></a>            tarjan<span class="op">(</span>i<span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb52-64"><a href="#cb52-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb52-65"><a href="#cb52-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-66"><a href="#cb52-66" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&gt;</span> ans<span class="op">;</span></span>
<span id="cb52-67"><a href="#cb52-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">2</span><span class="op">;</span>i<span class="op">&lt;</span>ecnt<span class="op">;</span>i<span class="op">+=</span><span class="dv">2</span><span class="op">){</span></span>
<span id="cb52-68"><a href="#cb52-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>bridges<span class="op">[</span>i<span class="op">]){</span></span>
<span id="cb52-69"><a href="#cb52-69" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> u <span class="op">=</span> edges<span class="op">[</span>i<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb52-70"><a href="#cb52-70" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> v <span class="op">=</span> edges<span class="op">[</span>i<span class="op">^</span><span class="dv">1</span><span class="op">].</span>v<span class="op">;</span></span>
<span id="cb52-71"><a href="#cb52-71" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>u<span class="op">&gt;</span>v<span class="op">)</span> <span class="bu">std::</span>swap<span class="op">(</span>u<span class="op">,</span>v<span class="op">);</span></span>
<span id="cb52-72"><a href="#cb52-72" aria-hidden="true" tabindex="-1"></a>            ans<span class="op">.</span>push_back<span class="op">({</span>u<span class="op">,</span>v<span class="op">});</span></span>
<span id="cb52-73"><a href="#cb52-73" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb52-74"><a href="#cb52-74" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb52-75"><a href="#cb52-75" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>ans<span class="op">.</span>begin<span class="op">(),</span>ans<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb52-76"><a href="#cb52-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> x<span class="op">:</span>ans<span class="op">)</span> <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>x<span class="op">.</span>first<span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">&lt;&lt;</span>x<span class="op">.</span>second<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb52-77"><a href="#cb52-77" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb52-78"><a href="#cb52-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb52-79"><a href="#cb52-79" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="割点tarjan算法">割点（Tarjan算法）</h2>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 n+m</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="co">//tarjan求割点,luogu P3388</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="co">//如果无向图中删掉某个点和其所有相连的边边会使无向图的连通分量数增多，那么这个点叫割点</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">20005</span><span class="op">;</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXM <span class="op">=</span> <span class="dv">100005</span><span class="op">;</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfn<span class="op">[</span>MAXN<span class="op">],</span> low<span class="op">[</span>MAXN<span class="op">],</span> cnt<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a><span class="co">//含义见割边模板</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">,</span>next<span class="op">;</span><span class="co">//指向的点，边权，下一条边</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>Edge edges<span class="op">[</span>MAXM<span class="op">*</span><span class="dv">2</span><span class="op">];</span><span class="co">//存无向图记得开两倍</span></span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> head<span class="op">[</span>MAXN<span class="op">],</span>ecnt<span class="op">;</span><span class="co">//这个ecnt和割边那里不一样，但也可以等于1</span></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> cut<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//判断割点</span></span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">void</span> add<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> v<span class="op">){</span></span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">[++</span>ecnt<span class="op">].</span>v <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">[</span>ecnt<span class="op">].</span>next <span class="op">=</span> head<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>    head<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> ecnt<span class="op">;</span></span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> tarjan<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> root<span class="op">){</span></span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tot <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a>    low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> dfn<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="op">++</span>cnt<span class="op">;</span></span>
<span id="cb53-31"><a href="#cb53-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>head<span class="op">[</span>u<span class="op">];</span>i<span class="op">;</span>i<span class="op">=</span>edges<span class="op">[</span>i<span class="op">].</span>next<span class="op">){</span></span>
<span id="cb53-32"><a href="#cb53-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> edges<span class="op">[</span>i<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb53-33"><a href="#cb53-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>dfn<span class="op">[</span>v<span class="op">]){</span></span>
<span id="cb53-34"><a href="#cb53-34" aria-hidden="true" tabindex="-1"></a>            tarjan<span class="op">(</span>v<span class="op">,</span>root<span class="op">);</span></span>
<span id="cb53-35"><a href="#cb53-35" aria-hidden="true" tabindex="-1"></a>            low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>low<span class="op">[</span>u<span class="op">],</span>low<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb53-36"><a href="#cb53-36" aria-hidden="true" tabindex="-1"></a>            <span class="co">//一个点x是割点的充要条件是，它至少一个子节点y满足dfn[x]&lt;=low[y]，特别的，对于根节点，需要至少两个这样的子节点</span></span>
<span id="cb53-37"><a href="#cb53-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>low<span class="op">[</span>v<span class="op">]&gt;=</span>dfn<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb53-38"><a href="#cb53-38" aria-hidden="true" tabindex="-1"></a>                tot<span class="op">++;</span></span>
<span id="cb53-39"><a href="#cb53-39" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>u<span class="op">!=</span>root <span class="op">||</span> tot<span class="op">&gt;</span><span class="dv">1</span><span class="op">)</span> cut<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb53-40"><a href="#cb53-40" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb53-41"><a href="#cb53-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb53-42"><a href="#cb53-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb53-43"><a href="#cb53-43" aria-hidden="true" tabindex="-1"></a>            low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>low<span class="op">[</span>u<span class="op">],</span> dfn<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb53-44"><a href="#cb53-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb53-45"><a href="#cb53-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-46"><a href="#cb53-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb53-47"><a href="#cb53-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-48"><a href="#cb53-48" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb53-49"><a href="#cb53-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span></span>
<span id="cb53-50"><a href="#cb53-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">;</span></span>
<span id="cb53-51"><a href="#cb53-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">//点数，边数</span></span>
<span id="cb53-52"><a href="#cb53-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb53-53"><a href="#cb53-53" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a<span class="op">,</span>b<span class="op">;</span></span>
<span id="cb53-54"><a href="#cb53-54" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>a<span class="op">&gt;&gt;</span>b<span class="op">;</span></span>
<span id="cb53-55"><a href="#cb53-55" aria-hidden="true" tabindex="-1"></a>        <span class="co">//起点，终点</span></span>
<span id="cb53-56"><a href="#cb53-56" aria-hidden="true" tabindex="-1"></a>        add<span class="op">(</span>a<span class="op">,</span>b<span class="op">);</span></span>
<span id="cb53-57"><a href="#cb53-57" aria-hidden="true" tabindex="-1"></a>        add<span class="op">(</span>b<span class="op">,</span>a<span class="op">);</span></span>
<span id="cb53-58"><a href="#cb53-58" aria-hidden="true" tabindex="-1"></a>        <span class="co">//无向图</span></span>
<span id="cb53-59"><a href="#cb53-59" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-60"><a href="#cb53-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb53-61"><a href="#cb53-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>dfn<span class="op">[</span>i<span class="op">])</span></span>
<span id="cb53-62"><a href="#cb53-62" aria-hidden="true" tabindex="-1"></a>            tarjan<span class="op">(</span>i<span class="op">,</span>i<span class="op">);</span></span>
<span id="cb53-63"><a href="#cb53-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-64"><a href="#cb53-64" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb53-65"><a href="#cb53-65" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ans<span class="op">;</span></span>
<span id="cb53-66"><a href="#cb53-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++)</span> <span class="cf">if</span><span class="op">(</span>cut<span class="op">[</span>i<span class="op">])</span> ans<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb53-67"><a href="#cb53-67" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>ans<span class="op">.</span>begin<span class="op">(),</span>ans<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb53-68"><a href="#cb53-68" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">.</span>size<span class="op">()&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb53-69"><a href="#cb53-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> x<span class="op">:</span>ans<span class="op">)</span> <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>x<span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span></span>
<span id="cb53-70"><a href="#cb53-70" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb53-71"><a href="#cb53-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb53-72"><a href="#cb53-72" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="强连通分量tarjan算法">强连通分量（Tarjan算法）</h2>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">//强连通分量，复杂度 n+m</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P2863</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="co">//一个有向图是强连通的当且仅当其中任意两个顶点相互可达</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="co">//强连通分量是有向图中的极大的强连通子图。极大意味着把一个图分为若干个强连通分量，分量之间互相不可达。或者，不存在包含该子图的更大的子图也是强连通分量。</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">10005</span><span class="op">;</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXM <span class="op">=</span> <span class="dv">50005</span><span class="op">;</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfn<span class="op">[</span>MAXN<span class="op">],</span> low<span class="op">[</span>MAXN<span class="op">],</span> instk<span class="op">[</span>MAXN<span class="op">],</span> scci<span class="op">[</span>MAXN<span class="op">],</span> cnt<span class="op">=</span><span class="dv">0</span><span class="op">,</span> cscc<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> edges<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> stk<span class="op">;</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> scc<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a><span class="co">//dfn是dfs时的顺序的序号</span></span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a><span class="co">//stk中存入两类点，访问到节点x时</span></span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a><span class="co">//1.搜索树上x的祖先节点</span></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a><span class="co">//2.已经访问过，并且存在一条路径到达x祖先的节点</span></span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a><span class="co">//low[x]定义为满足以下两个条件的节点的最小dfn</span></span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a><span class="co">//1.该点在stk中</span></span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a><span class="co">//2.存在一条从subtree(x)出发的有向边，以该点为终点</span></span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a><span class="co">//scci[x]代表，x这个结点在第几个分量中</span></span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a><span class="co">//cscc代表有几个分量</span></span>
<span id="cb54-26"><a href="#cb54-26" aria-hidden="true" tabindex="-1"></a><span class="co">//scc[j]中表示，第j个分量的所有节点</span></span>
<span id="cb54-27"><a href="#cb54-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-28"><a href="#cb54-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> tarjan<span class="op">(</span><span class="dt">int</span> u<span class="op">){</span></span>
<span id="cb54-29"><a href="#cb54-29" aria-hidden="true" tabindex="-1"></a>    low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> dfn<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="op">++</span>cnt<span class="op">;</span></span>
<span id="cb54-30"><a href="#cb54-30" aria-hidden="true" tabindex="-1"></a>    instk<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb54-31"><a href="#cb54-31" aria-hidden="true" tabindex="-1"></a>    stk<span class="op">.</span>push<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb54-32"><a href="#cb54-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>edges<span class="op">[</span>u<span class="op">].</span>size<span class="op">();</span>i<span class="op">++){</span></span>
<span id="cb54-33"><a href="#cb54-33" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> edges<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb54-34"><a href="#cb54-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>dfn<span class="op">[</span>v<span class="op">]){</span></span>
<span id="cb54-35"><a href="#cb54-35" aria-hidden="true" tabindex="-1"></a>            tarjan<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb54-36"><a href="#cb54-36" aria-hidden="true" tabindex="-1"></a>            low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>low<span class="op">[</span>u<span class="op">],</span>low<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb54-37"><a href="#cb54-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb54-38"><a href="#cb54-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>instk<span class="op">[</span>v<span class="op">]){</span></span>
<span id="cb54-39"><a href="#cb54-39" aria-hidden="true" tabindex="-1"></a>            low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>low<span class="op">[</span>u<span class="op">],</span> dfn<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb54-40"><a href="#cb54-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb54-41"><a href="#cb54-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb54-42"><a href="#cb54-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>low<span class="op">[</span>u<span class="op">]==</span>dfn<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb54-43"><a href="#cb54-43" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> top<span class="op">;</span></span>
<span id="cb54-44"><a href="#cb54-44" aria-hidden="true" tabindex="-1"></a>        cscc<span class="op">++;</span></span>
<span id="cb54-45"><a href="#cb54-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">do</span><span class="op">{</span></span>
<span id="cb54-46"><a href="#cb54-46" aria-hidden="true" tabindex="-1"></a>            top <span class="op">=</span> stk<span class="op">.</span>top<span class="op">();</span></span>
<span id="cb54-47"><a href="#cb54-47" aria-hidden="true" tabindex="-1"></a>            stk<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb54-48"><a href="#cb54-48" aria-hidden="true" tabindex="-1"></a>            instk<span class="op">[</span>top<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb54-49"><a href="#cb54-49" aria-hidden="true" tabindex="-1"></a>            scci<span class="op">[</span>top<span class="op">]</span> <span class="op">=</span> cscc<span class="op">;</span></span>
<span id="cb54-50"><a href="#cb54-50" aria-hidden="true" tabindex="-1"></a>            scc<span class="op">[</span>cscc<span class="op">].</span>push_back<span class="op">(</span>top<span class="op">);</span></span>
<span id="cb54-51"><a href="#cb54-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span><span class="cf">while</span><span class="op">(</span>top<span class="op">!=</span>u<span class="op">);</span></span>
<span id="cb54-52"><a href="#cb54-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb54-53"><a href="#cb54-53" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb54-54"><a href="#cb54-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-55"><a href="#cb54-55" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb54-56"><a href="#cb54-56" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span></span>
<span id="cb54-57"><a href="#cb54-57" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">;</span></span>
<span id="cb54-58"><a href="#cb54-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-59"><a href="#cb54-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb54-60"><a href="#cb54-60" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a<span class="op">,</span>b<span class="op">;</span></span>
<span id="cb54-61"><a href="#cb54-61" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>a<span class="op">&gt;&gt;</span>b<span class="op">;</span></span>
<span id="cb54-62"><a href="#cb54-62" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">[</span>a<span class="op">].</span>push_back<span class="op">(</span>b<span class="op">);</span><span class="co">//有向边</span></span>
<span id="cb54-63"><a href="#cb54-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb54-64"><a href="#cb54-64" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-65"><a href="#cb54-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb54-66"><a href="#cb54-66" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>dfn<span class="op">[</span>i<span class="op">])</span> tarjan<span class="op">(</span>i<span class="op">);</span><span class="co">//注意遍历所有dfn为零的点</span></span>
<span id="cb54-67"><a href="#cb54-67" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb54-68"><a href="#cb54-68" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb54-69"><a href="#cb54-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>cscc<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb54-70"><a href="#cb54-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>scc<span class="op">[</span>i<span class="op">].</span>size<span class="op">()&gt;</span><span class="dv">1</span><span class="op">)</span> ans<span class="op">++;</span></span>
<span id="cb54-71"><a href="#cb54-71" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb54-72"><a href="#cb54-72" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb54-73"><a href="#cb54-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb54-74"><a href="#cb54-74" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="sat问题">2-SAT问题</h2>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">//2-SAT算法，复杂度n+m</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P4782</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="co">//2-SAT是用来解决一些条件是否能够满足的算法。</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="co">//每个条件都能转化为形如&#34;若x赋值为a，则y必须赋值为b&#34;的形式。其中a,b的取值只能有两个，通常是true和false。</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="co">//例如总共有m个这样的条件，我们要判断是否存在一种赋值情况满足所有的条件。如果有还要输出一种可行方案</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="fl">2e6</span><span class="op">+</span><span class="dv">5</span><span class="op">;</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfn<span class="op">[</span>MAXN<span class="op">],</span> low<span class="op">[</span>MAXN<span class="op">],</span> instk<span class="op">[</span>MAXN<span class="op">],</span> scci<span class="op">[</span>MAXN<span class="op">],</span> cnt<span class="op">=</span><span class="dv">0</span><span class="op">,</span> cscc<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> edges<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> stk<span class="op">;</span></span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> scc<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a><span class="co">//含义见强连通分量tarjan算法</span></span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> ans<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> tarjan<span class="op">(</span><span class="dt">int</span> u<span class="op">){</span></span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a>    low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> dfn<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="op">++</span>cnt<span class="op">;</span></span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a>    instk<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb55-24"><a href="#cb55-24" aria-hidden="true" tabindex="-1"></a>    stk<span class="op">.</span>push<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb55-25"><a href="#cb55-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>edges<span class="op">[</span>u<span class="op">].</span>size<span class="op">();</span>i<span class="op">++){</span></span>
<span id="cb55-26"><a href="#cb55-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> edges<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb55-27"><a href="#cb55-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>dfn<span class="op">[</span>v<span class="op">]){</span></span>
<span id="cb55-28"><a href="#cb55-28" aria-hidden="true" tabindex="-1"></a>            tarjan<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb55-29"><a href="#cb55-29" aria-hidden="true" tabindex="-1"></a>            low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>low<span class="op">[</span>u<span class="op">],</span>low<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb55-30"><a href="#cb55-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb55-31"><a href="#cb55-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>instk<span class="op">[</span>v<span class="op">]){</span></span>
<span id="cb55-32"><a href="#cb55-32" aria-hidden="true" tabindex="-1"></a>            low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>low<span class="op">[</span>u<span class="op">],</span> dfn<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb55-33"><a href="#cb55-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb55-34"><a href="#cb55-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-35"><a href="#cb55-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>low<span class="op">[</span>u<span class="op">]==</span>dfn<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb55-36"><a href="#cb55-36" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> top<span class="op">;</span></span>
<span id="cb55-37"><a href="#cb55-37" aria-hidden="true" tabindex="-1"></a>        cscc<span class="op">++;</span></span>
<span id="cb55-38"><a href="#cb55-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">do</span><span class="op">{</span></span>
<span id="cb55-39"><a href="#cb55-39" aria-hidden="true" tabindex="-1"></a>            top <span class="op">=</span> stk<span class="op">.</span>top<span class="op">();</span></span>
<span id="cb55-40"><a href="#cb55-40" aria-hidden="true" tabindex="-1"></a>            stk<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb55-41"><a href="#cb55-41" aria-hidden="true" tabindex="-1"></a>            instk<span class="op">[</span>top<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb55-42"><a href="#cb55-42" aria-hidden="true" tabindex="-1"></a>            scci<span class="op">[</span>top<span class="op">]</span> <span class="op">=</span> cscc<span class="op">;</span></span>
<span id="cb55-43"><a href="#cb55-43" aria-hidden="true" tabindex="-1"></a>            scc<span class="op">[</span>cscc<span class="op">].</span>push_back<span class="op">(</span>top<span class="op">);</span></span>
<span id="cb55-44"><a href="#cb55-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span><span class="cf">while</span><span class="op">(</span>top<span class="op">!=</span>u<span class="op">);</span></span>
<span id="cb55-45"><a href="#cb55-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-46"><a href="#cb55-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb55-47"><a href="#cb55-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-48"><a href="#cb55-48" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb55-49"><a href="#cb55-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span></span>
<span id="cb55-50"><a href="#cb55-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">;</span></span>
<span id="cb55-51"><a href="#cb55-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">//n个点，m个条件</span></span>
<span id="cb55-52"><a href="#cb55-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb55-53"><a href="#cb55-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>m<span class="op">--){</span></span>
<span id="cb55-54"><a href="#cb55-54" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i<span class="op">,</span>j<span class="op">;</span></span>
<span id="cb55-55"><a href="#cb55-55" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> a<span class="op">,</span>b<span class="op">;</span></span>
<span id="cb55-56"><a href="#cb55-56" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>i<span class="op">&gt;&gt;</span>a<span class="op">&gt;&gt;</span>j<span class="op">&gt;&gt;</span>b<span class="op">;</span></span>
<span id="cb55-57"><a href="#cb55-57" aria-hidden="true" tabindex="-1"></a>        <span class="co">//本题的条件为，i为a或（不是异或）j为b，其他题按情况处理</span></span>
<span id="cb55-58"><a href="#cb55-58" aria-hidden="true" tabindex="-1"></a>        <span class="co">//每个点x拆为两个点y和y+n,y代表x为0，y+n代表x为1</span></span>
<span id="cb55-59"><a href="#cb55-59" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb55-60"><a href="#cb55-60" aria-hidden="true" tabindex="-1"></a>        <span class="co">//每条边x-&gt;y代表着，如果x，那么一定有y</span></span>
<span id="cb55-61"><a href="#cb55-61" aria-hidden="true" tabindex="-1"></a>        <span class="co">//本题如“i为假或j为真”可以拆为两个条件，这个条件满足（为真）时</span></span>
<span id="cb55-62"><a href="#cb55-62" aria-hidden="true" tabindex="-1"></a>        <span class="co">//i为真则j一定为真</span></span>
<span id="cb55-63"><a href="#cb55-63" aria-hidden="true" tabindex="-1"></a>        <span class="co">//j为假则i一定为假</span></span>
<span id="cb55-64"><a href="#cb55-64" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">[</span>i<span class="op">+(!</span>a<span class="op">)*</span>n<span class="op">].</span>push_back<span class="op">(</span>j<span class="op">+</span>b<span class="op">*</span>n<span class="op">);</span></span>
<span id="cb55-65"><a href="#cb55-65" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">[</span>j<span class="op">+(!</span>b<span class="op">)*</span>n<span class="op">].</span>push_back<span class="op">(</span>i<span class="op">+</span>a<span class="op">*</span>n<span class="op">);</span><span class="co">//逆否命题</span></span>
<span id="cb55-66"><a href="#cb55-66" aria-hidden="true" tabindex="-1"></a>        <span class="co">//逆否命题是一定要插入的，不能只插入原命题，但是本题拆出来的两个条件正好互为逆否命题，所以只插入了两条边。其他题并不一定总会给出逆否命题</span></span>
<span id="cb55-67"><a href="#cb55-67" aria-hidden="true" tabindex="-1"></a>        <span class="co">//这里的逻辑运算可能有些不容易理解，怕错可以写成很长的if else判断a和b的具体取值</span></span>
<span id="cb55-68"><a href="#cb55-68" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-69"><a href="#cb55-69" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb55-70"><a href="#cb55-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span><span class="dv">2</span><span class="op">*</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb55-71"><a href="#cb55-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>dfn<span class="op">[</span>i<span class="op">])</span> tarjan<span class="op">(</span>i<span class="op">);</span><span class="co">//注意遍历所有dfn为零的点</span></span>
<span id="cb55-72"><a href="#cb55-72" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-73"><a href="#cb55-73" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb55-74"><a href="#cb55-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb55-75"><a href="#cb55-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>scci<span class="op">[</span>i<span class="op">]==</span>scci<span class="op">[</span>i<span class="op">+</span>n<span class="op">]){</span><span class="co">//如果i和i+n在一个强连通分量，则不可满足</span></span>
<span id="cb55-76"><a href="#cb55-76" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;IMPOSSIBLE</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb55-77"><a href="#cb55-77" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb55-78"><a href="#cb55-78" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb55-79"><a href="#cb55-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>scci<span class="op">[</span>i<span class="op">]&gt;</span>scci<span class="op">[</span>i<span class="op">+</span>n<span class="op">])</span></span>
<span id="cb55-80"><a href="#cb55-80" aria-hidden="true" tabindex="-1"></a>            ans<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb55-81"><a href="#cb55-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb55-82"><a href="#cb55-82" aria-hidden="true" tabindex="-1"></a>            ans<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb55-83"><a href="#cb55-83" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-84"><a href="#cb55-84" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;POSSIBLE</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb55-85"><a href="#cb55-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb55-86"><a href="#cb55-86" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">[</span>i<span class="op">]&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span></span>
<span id="cb55-87"><a href="#cb55-87" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-88"><a href="#cb55-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-89"><a href="#cb55-89" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb55-90"><a href="#cb55-90" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="边双联通分量">边双联通分量</h2>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 n+m</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="co">//tarjan求边双联通分量</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p8436</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="co">//如果一张无向连通图不存在割边，则称之为边双联通图</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a><span class="co">//双连通分量是图的极大双联通子图</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a><span class="co">//若u-v边双联通，v-w边双联通，则u-w边双联通</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a><span class="co">//一张图是边双联通，当且仅当每条边都在至少一个简单环中</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a><span class="co">//无向连通图中，对于任意两个点，如果无论删去哪条边（只能一条），都不能使它们不连通，则为边双联通</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a><span class="co">//同时这也意味着，把割边删去后的图，就是若干个双联通分量</span></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a><span class="co">/*这一段是求割边的核心代码，省略*/</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dcci<span class="op">[</span>MAXN<span class="op">],</span> cdcc<span class="op">;</span><span class="co">//记录点i属于双联通分量dcci[i]，以及总的dcc个数</span></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&gt;</span> dcc<span class="op">(</span>MAXN<span class="op">);</span><span class="co">//存储双联通分量dcc[i]中有哪些点</span></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> getDCC<span class="op">(</span><span class="dt">int</span> u<span class="op">){</span></span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a>    dcci<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> cdcc<span class="op">;</span></span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a>    dcc<span class="op">[</span>cdcc<span class="op">].</span>push_back<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>head<span class="op">[</span>u<span class="op">];</span>i<span class="op">;</span>i<span class="op">=</span>edges<span class="op">[</span>i<span class="op">].</span>next<span class="op">){</span></span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> edges<span class="op">[</span>i<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>dcci<span class="op">[</span>v<span class="op">]</span> <span class="op">||</span> bridges<span class="op">[</span>i<span class="op">])</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb56-24"><a href="#cb56-24" aria-hidden="true" tabindex="-1"></a>        getDCC<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb56-25"><a href="#cb56-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb56-26"><a href="#cb56-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb56-27"><a href="#cb56-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-28"><a href="#cb56-28" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb56-29"><a href="#cb56-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb56-30"><a href="#cb56-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb56-31"><a href="#cb56-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb56-32"><a href="#cb56-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span></span>
<span id="cb56-33"><a href="#cb56-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">;</span></span>
<span id="cb56-34"><a href="#cb56-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">//点数，边数</span></span>
<span id="cb56-35"><a href="#cb56-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb56-36"><a href="#cb56-36" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a<span class="op">,</span>b<span class="op">;</span></span>
<span id="cb56-37"><a href="#cb56-37" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>a<span class="op">&gt;&gt;</span>b<span class="op">;</span></span>
<span id="cb56-38"><a href="#cb56-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">//起点，终点</span></span>
<span id="cb56-39"><a href="#cb56-39" aria-hidden="true" tabindex="-1"></a>        add<span class="op">(</span>a<span class="op">,</span>b<span class="op">);</span></span>
<span id="cb56-40"><a href="#cb56-40" aria-hidden="true" tabindex="-1"></a>        add<span class="op">(</span>b<span class="op">,</span>a<span class="op">);</span></span>
<span id="cb56-41"><a href="#cb56-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">//无向图</span></span>
<span id="cb56-42"><a href="#cb56-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb56-43"><a href="#cb56-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb56-44"><a href="#cb56-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>dfn<span class="op">[</span>i<span class="op">])</span></span>
<span id="cb56-45"><a href="#cb56-45" aria-hidden="true" tabindex="-1"></a>            tarjan<span class="op">(</span>i<span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb56-46"><a href="#cb56-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb56-47"><a href="#cb56-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb56-48"><a href="#cb56-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">//以上求完了割边</span></span>
<span id="cb56-49"><a href="#cb56-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb56-50"><a href="#cb56-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb56-51"><a href="#cb56-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>dcci<span class="op">[</span>i<span class="op">]){</span></span>
<span id="cb56-52"><a href="#cb56-52" aria-hidden="true" tabindex="-1"></a>            cdcc<span class="op">++;</span></span>
<span id="cb56-53"><a href="#cb56-53" aria-hidden="true" tabindex="-1"></a>            getDCC<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb56-54"><a href="#cb56-54" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb56-55"><a href="#cb56-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb56-56"><a href="#cb56-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb56-57"><a href="#cb56-57" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>cdcc<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb56-58"><a href="#cb56-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>cdcc<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb56-59"><a href="#cb56-59" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>dcc<span class="op">[</span>i<span class="op">].</span>size<span class="op">()&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span></span>
<span id="cb56-60"><a href="#cb56-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> x<span class="op">:</span>dcc<span class="op">[</span>i<span class="op">]){</span></span>
<span id="cb56-61"><a href="#cb56-61" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>x<span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span></span>
<span id="cb56-62"><a href="#cb56-62" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb56-63"><a href="#cb56-63" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb56-64"><a href="#cb56-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb56-65"><a href="#cb56-65" aria-hidden="true" tabindex="-1"></a>     </span>
<span id="cb56-66"><a href="#cb56-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb56-67"><a href="#cb56-67" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="边双联通缩点todo">边双联通缩点TODO</h2>
<h2 id="点双联通分量">点双联通分量</h2>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 n+m</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="co">//tarjan求点双联通分量</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p8435</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="co">//如果一张无向连通图不存在割点，则称之为点双联通图</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="co">//双连通分量是图的极大双联通子图</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="co">//极大指的是，不存在包含这个子图的更大的子图也是边双联通图</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="co">//若u-v点双联通，v-w点双联通，则u-w[并不一定]点双联通</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a><span class="co">//一张图是点双联通，当且仅当以下两个条件之一成立</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a><span class="co">//1. 图的顶点数不超过2</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a><span class="co">//2. 图中任意两点都同时包含在至少一个简单环中</span></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a><span class="co">//无向连通图中，对于任意两个点，如果无论删去哪个点（只能一个，且不能删除这两个点自己），都不能使它们不连通，则为点双联通</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a><span class="co">//但是，虽然边双联通中的割边不属于任何连通分量，但割点却可以属于多个点双联通分量</span></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">500005</span><span class="op">;</span></span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXM <span class="op">=</span> <span class="dv">2000005</span><span class="op">;</span></span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfn<span class="op">[</span>MAXN<span class="op">],</span> low<span class="op">[</span>MAXN<span class="op">],</span> cnt<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true" tabindex="-1"></a><span class="co">//含义见割边模板</span></span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">,</span>next<span class="op">;</span><span class="co">//指向的点，边权，下一条边</span></span>
<span id="cb57-28"><a href="#cb57-28" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb57-29"><a href="#cb57-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-30"><a href="#cb57-30" aria-hidden="true" tabindex="-1"></a>Edge edges<span class="op">[</span>MAXM<span class="op">*</span><span class="dv">2</span><span class="op">];</span><span class="co">//存无向图记得开两倍</span></span>
<span id="cb57-31"><a href="#cb57-31" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> head<span class="op">[</span>MAXN<span class="op">],</span>ecnt<span class="op">;</span><span class="co">//这个ecnt和割边那里不一样，但也可以等于1</span></span>
<span id="cb57-32"><a href="#cb57-32" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> cut<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//判断割点</span></span>
<span id="cb57-33"><a href="#cb57-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-34"><a href="#cb57-34" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">void</span> add<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> v<span class="op">){</span></span>
<span id="cb57-35"><a href="#cb57-35" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">[++</span>ecnt<span class="op">].</span>v <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb57-36"><a href="#cb57-36" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">[</span>ecnt<span class="op">].</span>next <span class="op">=</span> head<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb57-37"><a href="#cb57-37" aria-hidden="true" tabindex="-1"></a>    head<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> ecnt<span class="op">;</span></span>
<span id="cb57-38"><a href="#cb57-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-39"><a href="#cb57-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-40"><a href="#cb57-40" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> stk<span class="op">;</span></span>
<span id="cb57-41"><a href="#cb57-41" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cdcc<span class="op">;</span></span>
<span id="cb57-42"><a href="#cb57-42" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&gt;</span> dcc<span class="op">(</span>MAXN<span class="op">);</span></span>
<span id="cb57-43"><a href="#cb57-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-44"><a href="#cb57-44" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> tarjan<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> root<span class="op">){</span></span>
<span id="cb57-45"><a href="#cb57-45" aria-hidden="true" tabindex="-1"></a>    low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> dfn<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="op">++</span>cnt<span class="op">;</span></span>
<span id="cb57-46"><a href="#cb57-46" aria-hidden="true" tabindex="-1"></a>    stk<span class="op">.</span>push<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb57-47"><a href="#cb57-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>u<span class="op">==</span>root <span class="op">&amp;&amp;</span> head<span class="op">[</span>u<span class="op">]==</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb57-48"><a href="#cb57-48" aria-hidden="true" tabindex="-1"></a>        dcc<span class="op">[++</span>cdcc<span class="op">].</span>push_back<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb57-49"><a href="#cb57-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb57-50"><a href="#cb57-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-51"><a href="#cb57-51" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tot<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb57-52"><a href="#cb57-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>head<span class="op">[</span>u<span class="op">];</span>i<span class="op">;</span>i<span class="op">=</span>edges<span class="op">[</span>i<span class="op">].</span>next<span class="op">){</span></span>
<span id="cb57-53"><a href="#cb57-53" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> edges<span class="op">[</span>i<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb57-54"><a href="#cb57-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>dfn<span class="op">[</span>v<span class="op">]){</span></span>
<span id="cb57-55"><a href="#cb57-55" aria-hidden="true" tabindex="-1"></a>            tarjan<span class="op">(</span>v<span class="op">,</span>root<span class="op">);</span></span>
<span id="cb57-56"><a href="#cb57-56" aria-hidden="true" tabindex="-1"></a>            low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>low<span class="op">[</span>u<span class="op">],</span>low<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb57-57"><a href="#cb57-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>low<span class="op">[</span>v<span class="op">]&gt;=</span>dfn<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb57-58"><a href="#cb57-58" aria-hidden="true" tabindex="-1"></a>                tot<span class="op">++;</span></span>
<span id="cb57-59"><a href="#cb57-59" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>u<span class="op">!=</span>root <span class="op">||</span> tot<span class="op">&gt;</span><span class="dv">1</span><span class="op">)</span> cut<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb57-60"><a href="#cb57-60" aria-hidden="true" tabindex="-1"></a>                cdcc<span class="op">++;</span></span>
<span id="cb57-61"><a href="#cb57-61" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> z<span class="op">;</span></span>
<span id="cb57-62"><a href="#cb57-62" aria-hidden="true" tabindex="-1"></a>                <span class="cf">do</span><span class="op">{</span></span>
<span id="cb57-63"><a href="#cb57-63" aria-hidden="true" tabindex="-1"></a>                    z <span class="op">=</span> stk<span class="op">.</span>top<span class="op">();</span></span>
<span id="cb57-64"><a href="#cb57-64" aria-hidden="true" tabindex="-1"></a>                    stk<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb57-65"><a href="#cb57-65" aria-hidden="true" tabindex="-1"></a>                    dcc<span class="op">[</span>cdcc<span class="op">].</span>push_back<span class="op">(</span>z<span class="op">);</span></span>
<span id="cb57-66"><a href="#cb57-66" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span><span class="cf">while</span><span class="op">(</span>z<span class="op">!=</span>v<span class="op">);</span></span>
<span id="cb57-67"><a href="#cb57-67" aria-hidden="true" tabindex="-1"></a>                dcc<span class="op">[</span>cdcc<span class="op">].</span>push_back<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb57-68"><a href="#cb57-68" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb57-69"><a href="#cb57-69" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb57-70"><a href="#cb57-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb57-71"><a href="#cb57-71" aria-hidden="true" tabindex="-1"></a>            low<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>low<span class="op">[</span>u<span class="op">],</span> dfn<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb57-72"><a href="#cb57-72" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb57-73"><a href="#cb57-73" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-74"><a href="#cb57-74" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb57-75"><a href="#cb57-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-76"><a href="#cb57-76" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb57-77"><a href="#cb57-77" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span></span>
<span id="cb57-78"><a href="#cb57-78" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">;</span></span>
<span id="cb57-79"><a href="#cb57-79" aria-hidden="true" tabindex="-1"></a>    <span class="co">//点数，边数</span></span>
<span id="cb57-80"><a href="#cb57-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb57-81"><a href="#cb57-81" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a<span class="op">,</span>b<span class="op">;</span></span>
<span id="cb57-82"><a href="#cb57-82" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>a<span class="op">&gt;&gt;</span>b<span class="op">;</span></span>
<span id="cb57-83"><a href="#cb57-83" aria-hidden="true" tabindex="-1"></a>        <span class="co">//起点，终点</span></span>
<span id="cb57-84"><a href="#cb57-84" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>a<span class="op">==</span>b<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span><span class="co">//点双联通需要注意排除自环才能处理孤立点</span></span>
<span id="cb57-85"><a href="#cb57-85" aria-hidden="true" tabindex="-1"></a>        add<span class="op">(</span>a<span class="op">,</span>b<span class="op">);</span></span>
<span id="cb57-86"><a href="#cb57-86" aria-hidden="true" tabindex="-1"></a>        add<span class="op">(</span>b<span class="op">,</span>a<span class="op">);</span></span>
<span id="cb57-87"><a href="#cb57-87" aria-hidden="true" tabindex="-1"></a>        <span class="co">//无向图</span></span>
<span id="cb57-88"><a href="#cb57-88" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-89"><a href="#cb57-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-90"><a href="#cb57-90" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb57-91"><a href="#cb57-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>dfn<span class="op">[</span>i<span class="op">])</span></span>
<span id="cb57-92"><a href="#cb57-92" aria-hidden="true" tabindex="-1"></a>            tarjan<span class="op">(</span>i<span class="op">,</span>i<span class="op">);</span></span>
<span id="cb57-93"><a href="#cb57-93" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-94"><a href="#cb57-94" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb57-95"><a href="#cb57-95" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>cdcc<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb57-96"><a href="#cb57-96" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>cdcc<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb57-97"><a href="#cb57-97" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>dcc<span class="op">[</span>i<span class="op">].</span>size<span class="op">()&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span></span>
<span id="cb57-98"><a href="#cb57-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> x<span class="op">:</span>dcc<span class="op">[</span>i<span class="op">])</span> <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>x<span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span></span>
<span id="cb57-99"><a href="#cb57-99" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb57-100"><a href="#cb57-100" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-101"><a href="#cb57-101" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb57-102"><a href="#cb57-102" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb57-103"><a href="#cb57-103" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="点双联通缩点todo">点双联通缩点TODO</h2>
<h2 id="树的直径">树的直径</h2>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co">//树的直径，复杂度n</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="co">//poj1985，输出树上最长路径的长度，即树的直径</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="co">//两遍dfs版可以求出路径上的点，但树形dp的可以处理负边权问题</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>pii<span class="op">&gt;</span> edges<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//first是v，second是w</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dis<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> far<span class="op">;</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> fa<span class="op">){</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> edges<span class="op">[</span>u<span class="op">].</span>size<span class="op">();</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>size<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>        pii e <span class="op">=</span> edges<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> e<span class="op">.</span>first<span class="op">,</span> w <span class="op">=</span> e<span class="op">.</span>second<span class="op">;</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>v<span class="op">==</span>fa<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>        dis<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> dis<span class="op">[</span>u<span class="op">]+</span>w<span class="op">;</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>dis<span class="op">[</span>v<span class="op">]&gt;</span>dis<span class="op">[</span>far<span class="op">])</span> far<span class="op">=</span>v<span class="op">;</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>        dfs<span class="op">(</span>v<span class="op">,</span>u<span class="op">);</span></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">(){</span></span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span></span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">;</span></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span>v<span class="op">,</span>w<span class="op">;</span></span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> trash<span class="op">;</span><span class="co">//poj 1985的输入数据问题</span></span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>u<span class="op">&gt;&gt;</span>v<span class="op">&gt;&gt;</span>w<span class="op">&gt;&gt;</span>trash<span class="op">;</span></span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span><span class="bu">std::</span>make_pair<span class="op">(</span>v<span class="op">,</span>w<span class="op">));</span></span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">[</span>v<span class="op">].</span>push_back<span class="op">(</span><span class="bu">std::</span>make_pair<span class="op">(</span>u<span class="op">,</span>w<span class="op">));</span></span>
<span id="cb58-29"><a href="#cb58-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb58-30"><a href="#cb58-30" aria-hidden="true" tabindex="-1"></a>    dfs<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb58-31"><a href="#cb58-31" aria-hidden="true" tabindex="-1"></a>    dis<span class="op">[</span>far<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb58-32"><a href="#cb58-32" aria-hidden="true" tabindex="-1"></a>    dfs<span class="op">(</span>far<span class="op">,</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb58-33"><a href="#cb58-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>dis<span class="op">[</span>far<span class="op">]&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb58-34"><a href="#cb58-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co">//树的直径，复杂度n</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="co">//poj1985，输出树上最长路径的长度，即树的直径</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="co">//两遍dfs版可以求出路径上的点，但树形dp的可以处理负边权问题</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>pii<span class="op">&gt;</span> edges<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//first是v，second是w</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dis<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> vis<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ans<span class="op">;</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dp<span class="op">(</span><span class="dt">int</span> u<span class="op">){</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>    vis<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> edges<span class="op">[</span>u<span class="op">].</span>size<span class="op">();</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>size<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>        pii e <span class="op">=</span> edges<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> e<span class="op">.</span>first<span class="op">,</span> w <span class="op">=</span> e<span class="op">.</span>second<span class="op">;</span></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>vis<span class="op">[</span>v<span class="op">])</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span>dis<span class="op">[</span>u<span class="op">]+</span>dis<span class="op">[</span>v<span class="op">]+</span>w<span class="op">);</span></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>        dis<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>dis<span class="op">[</span>u<span class="op">],</span>dis<span class="op">[</span>v<span class="op">]+</span>w<span class="op">);</span></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">(){</span></span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span></span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">;</span></span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb59-26"><a href="#cb59-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span>v<span class="op">,</span>w<span class="op">;</span></span>
<span id="cb59-27"><a href="#cb59-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> trash<span class="op">;</span><span class="co">//poj 1985的输入数据问题</span></span>
<span id="cb59-28"><a href="#cb59-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>u<span class="op">&gt;&gt;</span>v<span class="op">&gt;&gt;</span>w<span class="op">&gt;&gt;</span>trash<span class="op">;</span></span>
<span id="cb59-29"><a href="#cb59-29" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span><span class="bu">std::</span>make_pair<span class="op">(</span>v<span class="op">,</span>w<span class="op">));</span></span>
<span id="cb59-30"><a href="#cb59-30" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">[</span>v<span class="op">].</span>push_back<span class="op">(</span><span class="bu">std::</span>make_pair<span class="op">(</span>u<span class="op">,</span>w<span class="op">));</span></span>
<span id="cb59-31"><a href="#cb59-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb59-32"><a href="#cb59-32" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb59-33"><a href="#cb59-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb59-34"><a href="#cb59-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>若树上所有边边权均为正，则树的所有直径中点重合。</p>
<h2 id="树的重心">树的重心</h2>
<p>计算无根树的每一个节点作为根时，其最大子树的大小。最大子树的大小最小的节点叫做树的重心。</p>
<p><strong>性质如下</strong></p>
<ol type="1">
<li>重心如果不唯一，则最多只有两个，且它们相邻。并且此时树有偶数个节点，可以被划分为两个大小相等的连通块，每个块各自包含一个重心。</li>
<li>以树的重心为根时，所有子树的大小都不超过整棵树的一半</li>
<li>树中所有点到某个点的距离之和中，到重心的距离之和是最小的。如果有两个重心，它们是并列最小的。反过来距离之和最小的点一定是重心。</li>
<li>两棵树通过一条边连成一棵树，则新树的重心在连接原来两颗树的重心的路径上。如果两棵树大小一样，那么重心就是两个连接点。</li>
<li>在一棵树上添加或删除一个叶节点，它的重心最多只移动一条边的距离。如果原树有奇数个节点，那么重心可能会增加一个，原重心仍然是重心。如果有偶数个节点，那么重心可能减少一个，另一个重心仍然是重心。</li>
</ol>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 n</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="co">//poj 1655</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> edges<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sz<span class="op">[</span>MAXN<span class="op">],</span> mss<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//树的大小（含自己），最大子树大小（不含自己）</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ctr<span class="op">;</span><span class="co">//存重心</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> fa<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> n<span class="op">){</span><span class="co">//需要传入点的个数</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>    sz<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> mss<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> edges<span class="op">[</span>u<span class="op">].</span>size<span class="op">();</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> e<span class="op">=</span><span class="dv">0</span><span class="op">;</span>e<span class="op">&lt;</span>size<span class="op">;</span>e<span class="op">++){</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> edges<span class="op">[</span>u<span class="op">][</span>e<span class="op">];</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>v<span class="op">==</span>fa<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>        dfs<span class="op">(</span>v<span class="op">,</span>u<span class="op">,</span>n<span class="op">);</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>        mss<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>mss<span class="op">[</span>u<span class="op">],</span>sz<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>        sz<span class="op">[</span>u<span class="op">]</span> <span class="op">+=</span> sz<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>    mss<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>mss<span class="op">[</span>u<span class="op">],</span>n<span class="op">-</span>sz<span class="op">[</span>u<span class="op">]);</span></span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>mss<span class="op">[</span>u<span class="op">]&lt;=</span>n<span class="op">/</span><span class="dv">2</span><span class="op">)</span> ctr<span class="op">.</span>push_back<span class="op">(</span>u<span class="op">);</span></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="倍增求最近公共祖先">倍增求最近公共祖先</h2>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 单次查询 logn 预处理 nlogn，常数小点的可以用重链剖分</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P3379</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="co">//倍增求最近公共祖先</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">500005</span><span class="op">;</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> LOGN <span class="op">=</span> <span class="dv">31</span><span class="op">;</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> edge<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//邻接表</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> logn<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fa<span class="op">[</span>MAXN<span class="op">][</span>LOGN<span class="op">],</span>deep<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a><span class="co">//fa[a][b]代表a的第2^b个祖先，deep是深度，根节点深度为1</span></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> build<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span><span class="dt">int</span> father<span class="op">){</span></span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>    fa<span class="op">[</span>u<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> father<span class="op">;</span></span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>    deep<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> deep<span class="op">[</span>father<span class="op">]+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>logn<span class="op">[</span>deep<span class="op">[</span>u<span class="op">]];</span>i<span class="op">++){</span></span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>        fa<span class="op">[</span>u<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> fa<span class="op">[</span>fa<span class="op">[</span>u<span class="op">][</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]][</span>i<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> v<span class="op">:</span>edge<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>v<span class="op">==</span>father<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a>        build<span class="op">(</span>v<span class="op">,</span>u<span class="op">);</span></span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb61-29"><a href="#cb61-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-30"><a href="#cb61-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> lca<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span><span class="dt">int</span> y<span class="op">){</span></span>
<span id="cb61-31"><a href="#cb61-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>deep<span class="op">[</span>x<span class="op">]&gt;</span>deep<span class="op">[</span>y<span class="op">])</span> <span class="bu">std::</span>swap<span class="op">(</span>x<span class="op">,</span>y<span class="op">);</span></span>
<span id="cb61-32"><a href="#cb61-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">//保证y比x深</span></span>
<span id="cb61-33"><a href="#cb61-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-34"><a href="#cb61-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>deep<span class="op">[</span>x<span class="op">]!=</span>deep<span class="op">[</span>y<span class="op">]){</span></span>
<span id="cb61-35"><a href="#cb61-35" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> fa<span class="op">[</span>y<span class="op">][</span>logn<span class="op">[</span>deep<span class="op">[</span>y<span class="op">]-</span>deep<span class="op">[</span>x<span class="op">]]];</span></span>
<span id="cb61-36"><a href="#cb61-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-37"><a href="#cb61-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb61-38"><a href="#cb61-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>x<span class="op">==</span>y<span class="op">)</span> <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb61-39"><a href="#cb61-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb61-40"><a href="#cb61-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> k<span class="op">=</span>logn<span class="op">[</span>deep<span class="op">[</span>x<span class="op">]];</span>k<span class="op">&gt;=</span><span class="dv">0</span><span class="op">;</span>k<span class="op">--){</span></span>
<span id="cb61-41"><a href="#cb61-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>fa<span class="op">[</span>x<span class="op">][</span>k<span class="op">]!=</span>fa<span class="op">[</span>y<span class="op">][</span>k<span class="op">]){</span></span>
<span id="cb61-42"><a href="#cb61-42" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> fa<span class="op">[</span>x<span class="op">][</span>k<span class="op">],</span> y <span class="op">=</span> fa<span class="op">[</span>y<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb61-43"><a href="#cb61-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb61-44"><a href="#cb61-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-45"><a href="#cb61-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fa<span class="op">[</span>x<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb61-46"><a href="#cb61-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb61-47"><a href="#cb61-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-48"><a href="#cb61-48" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb61-49"><a href="#cb61-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb61-50"><a href="#cb61-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb61-51"><a href="#cb61-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb61-52"><a href="#cb61-52" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">,</span>s<span class="op">;</span></span>
<span id="cb61-53"><a href="#cb61-53" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">&gt;&gt;</span>s<span class="op">;</span></span>
<span id="cb61-54"><a href="#cb61-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">//点数，询问数，根节点序号</span></span>
<span id="cb61-55"><a href="#cb61-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb61-56"><a href="#cb61-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">2</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb61-57"><a href="#cb61-57" aria-hidden="true" tabindex="-1"></a>        logn<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> logn<span class="op">[</span>i<span class="op">/</span><span class="dv">2</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb61-58"><a href="#cb61-58" aria-hidden="true" tabindex="-1"></a>        <span class="co">//必须的初始化</span></span>
<span id="cb61-59"><a href="#cb61-59" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-60"><a href="#cb61-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-61"><a href="#cb61-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">-</span><span class="dv">1</span><span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb61-62"><a href="#cb61-62" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a<span class="op">,</span>b<span class="op">;</span></span>
<span id="cb61-63"><a href="#cb61-63" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>a<span class="op">&gt;&gt;</span>b<span class="op">;</span></span>
<span id="cb61-64"><a href="#cb61-64" aria-hidden="true" tabindex="-1"></a>        <span class="co">//读入树</span></span>
<span id="cb61-65"><a href="#cb61-65" aria-hidden="true" tabindex="-1"></a>        edge<span class="op">[</span>a<span class="op">].</span>push_back<span class="op">(</span>b<span class="op">);</span></span>
<span id="cb61-66"><a href="#cb61-66" aria-hidden="true" tabindex="-1"></a>        edge<span class="op">[</span>b<span class="op">].</span>push_back<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb61-67"><a href="#cb61-67" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-68"><a href="#cb61-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-69"><a href="#cb61-69" aria-hidden="true" tabindex="-1"></a>    build<span class="op">(</span>s<span class="op">,</span><span class="dv">0</span><span class="op">);</span><span class="co">//必须build才能用</span></span>
<span id="cb61-70"><a href="#cb61-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-71"><a href="#cb61-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb61-72"><a href="#cb61-72" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb61-73"><a href="#cb61-73" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>x<span class="op">&gt;&gt;</span>y<span class="op">;</span></span>
<span id="cb61-74"><a href="#cb61-74" aria-hidden="true" tabindex="-1"></a>        <span class="co">//查询x,y的最近公共祖先</span></span>
<span id="cb61-75"><a href="#cb61-75" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>lca<span class="op">(</span>x<span class="op">,</span>y<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb61-76"><a href="#cb61-76" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-77"><a href="#cb61-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-78"><a href="#cb61-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb61-79"><a href="#cb61-79" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="虚树-todo">虚树 TODO</h2>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"></code></pre></div>
<h2 id="点分治">点分治</h2>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co">//点分治 复杂度nlog^2n</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="co">//poj 1741</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="co">//查询树上长度小于等于k的路径的数量</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;map&gt;</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">10007</span><span class="op">;</span></span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Edge<span class="op">{</span></span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v<span class="op">,</span>w<span class="op">,</span>next<span class="op">;</span><span class="co">//指向的点，边权，下一条边</span></span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a>Edge edges<span class="op">[</span>MAXN<span class="op">*</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> head<span class="op">[</span>MAXN<span class="op">],</span>cnt<span class="op">;</span></span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">void</span> add<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> v<span class="op">,</span> <span class="dt">int</span> w<span class="op">){</span></span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">[++</span>cnt<span class="op">].</span>w <span class="op">=</span> w<span class="op">;</span></span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">[</span>cnt<span class="op">].</span>v <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a>    edges<span class="op">[</span>cnt<span class="op">].</span>next <span class="op">=</span> head<span class="op">[</span>u<span class="op">];</span></span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a>    head<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> cnt<span class="op">;</span></span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-32"><a href="#cb63-32" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sz<span class="op">[</span>MAXN<span class="op">],</span> mss<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//树的大小（含自己），最大子树大小（不含自己）</span></span>
<span id="cb63-33"><a href="#cb63-33" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ctr<span class="op">=-</span><span class="dv">1</span><span class="op">;</span><span class="co">//重心</span></span>
<span id="cb63-34"><a href="#cb63-34" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> del<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//这个点是否在分治的时候被删除</span></span>
<span id="cb63-35"><a href="#cb63-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-36"><a href="#cb63-36" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfsCtr<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> fa<span class="op">,</span> <span class="dt">int</span> <span class="at">const</span> n<span class="op">){</span><span class="co">//需要传入树的点的个数</span></span>
<span id="cb63-37"><a href="#cb63-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">//执行完后ctr为本子树的重心</span></span>
<span id="cb63-38"><a href="#cb63-38" aria-hidden="true" tabindex="-1"></a>    sz<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> mss<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb63-39"><a href="#cb63-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> e<span class="op">=</span>head<span class="op">[</span>u<span class="op">];</span>e<span class="op">;</span>e<span class="op">=</span>edges<span class="op">[</span>e<span class="op">].</span>next<span class="op">){</span></span>
<span id="cb63-40"><a href="#cb63-40" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> edges<span class="op">[</span>e<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb63-41"><a href="#cb63-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>v<span class="op">==</span>fa <span class="op">||</span> del<span class="op">[</span>v<span class="op">])</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb63-42"><a href="#cb63-42" aria-hidden="true" tabindex="-1"></a>        dfsCtr<span class="op">(</span>v<span class="op">,</span>u<span class="op">,</span>n<span class="op">);</span></span>
<span id="cb63-43"><a href="#cb63-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>ctr<span class="op">!=-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb63-44"><a href="#cb63-44" aria-hidden="true" tabindex="-1"></a>        mss<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>mss<span class="op">[</span>u<span class="op">],</span>sz<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb63-45"><a href="#cb63-45" aria-hidden="true" tabindex="-1"></a>        sz<span class="op">[</span>u<span class="op">]</span> <span class="op">+=</span> sz<span class="op">[</span>v<span class="op">];</span></span>
<span id="cb63-46"><a href="#cb63-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-47"><a href="#cb63-47" aria-hidden="true" tabindex="-1"></a>    mss<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>mss<span class="op">[</span>u<span class="op">],</span>n<span class="op">-</span>sz<span class="op">[</span>u<span class="op">]);</span></span>
<span id="cb63-48"><a href="#cb63-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>mss<span class="op">[</span>u<span class="op">]&lt;=</span>n<span class="op">/</span><span class="dv">2</span><span class="op">)</span> ctr <span class="op">=</span> u<span class="op">,</span> sz<span class="op">[</span>fa<span class="op">]</span> <span class="op">=</span> n<span class="op">-</span>sz<span class="op">[</span>u<span class="op">];</span><span class="co">//注意要改编sz以保证复杂度正确</span></span>
<span id="cb63-49"><a href="#cb63-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb63-50"><a href="#cb63-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-51"><a href="#cb63-51" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dis<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//dis[x]存储点x到根root的距离</span></span>
<span id="cb63-52"><a href="#cb63-52" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> indexx<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//要对节点编号按照dis进行排序，indexx[0]代表元素个数</span></span>
<span id="cb63-53"><a href="#cb63-53" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> belong<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//判断子树节点属于哪一个子子树</span></span>
<span id="cb63-54"><a href="#cb63-54" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cntsame<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//查询[l,r]时，维护[l+1,r]中belong与l的belong相同的个数，见calc函数</span></span>
<span id="cb63-55"><a href="#cb63-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-56"><a href="#cb63-56" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> cmp<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span><span class="dt">int</span> y<span class="op">){</span><span class="cf">return</span> dis<span class="op">[</span>x<span class="op">]&lt;</span>dis<span class="op">[</span>y<span class="op">];}</span></span>
<span id="cb63-57"><a href="#cb63-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-58"><a href="#cb63-58" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfsDis<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> fa<span class="op">,</span> <span class="dt">int</span> from<span class="op">){</span></span>
<span id="cb63-59"><a href="#cb63-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">//获得子树到根节点的距离，from用于计算belong</span></span>
<span id="cb63-60"><a href="#cb63-60" aria-hidden="true" tabindex="-1"></a>    indexx<span class="op">[++</span>indexx<span class="op">[</span><span class="dv">0</span><span class="op">]]</span> <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb63-61"><a href="#cb63-61" aria-hidden="true" tabindex="-1"></a>    belong<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> from<span class="op">;</span></span>
<span id="cb63-62"><a href="#cb63-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> e<span class="op">=</span>head<span class="op">[</span>u<span class="op">];</span>e<span class="op">;</span>e<span class="op">=</span>edges<span class="op">[</span>e<span class="op">].</span>next<span class="op">){</span></span>
<span id="cb63-63"><a href="#cb63-63" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> edges<span class="op">[</span>e<span class="op">].</span>v<span class="op">,</span> w <span class="op">=</span> edges<span class="op">[</span>e<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb63-64"><a href="#cb63-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>v<span class="op">==</span>fa <span class="op">||</span> del<span class="op">[</span>v<span class="op">])</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb63-65"><a href="#cb63-65" aria-hidden="true" tabindex="-1"></a>        dis<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> dis<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> w<span class="op">;</span></span>
<span id="cb63-66"><a href="#cb63-66" aria-hidden="true" tabindex="-1"></a>        cntsame<span class="op">[</span>from<span class="op">]++;</span></span>
<span id="cb63-67"><a href="#cb63-67" aria-hidden="true" tabindex="-1"></a>        dfsDis<span class="op">(</span>v<span class="op">,</span>u<span class="op">,</span>from<span class="op">);</span></span>
<span id="cb63-68"><a href="#cb63-68" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-69"><a href="#cb63-69" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb63-70"><a href="#cb63-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-71"><a href="#cb63-71" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> calc<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span><span class="dt">int</span> k<span class="op">){</span></span>
<span id="cb63-72"><a href="#cb63-72" aria-hidden="true" tabindex="-1"></a>    indexx<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb63-73"><a href="#cb63-73" aria-hidden="true" tabindex="-1"></a>    indexx<span class="op">[++</span>indexx<span class="op">[</span><span class="dv">0</span><span class="op">]]</span> <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb63-74"><a href="#cb63-74" aria-hidden="true" tabindex="-1"></a>    belong<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb63-75"><a href="#cb63-75" aria-hidden="true" tabindex="-1"></a>    dis<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb63-76"><a href="#cb63-76" aria-hidden="true" tabindex="-1"></a>    cntsame<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb63-77"><a href="#cb63-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> e<span class="op">=</span>head<span class="op">[</span>u<span class="op">];</span>e<span class="op">;</span>e<span class="op">=</span>edges<span class="op">[</span>e<span class="op">].</span>next<span class="op">){</span></span>
<span id="cb63-78"><a href="#cb63-78" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> edges<span class="op">[</span>e<span class="op">].</span>v<span class="op">,</span> w <span class="op">=</span>edges<span class="op">[</span>e<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb63-79"><a href="#cb63-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>del<span class="op">[</span>v<span class="op">])</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb63-80"><a href="#cb63-80" aria-hidden="true" tabindex="-1"></a>        dis<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> dis<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> w<span class="op">;</span></span>
<span id="cb63-81"><a href="#cb63-81" aria-hidden="true" tabindex="-1"></a>        cntsame<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb63-82"><a href="#cb63-82" aria-hidden="true" tabindex="-1"></a>        dfsDis<span class="op">(</span>v<span class="op">,</span>u<span class="op">,</span>v<span class="op">);</span></span>
<span id="cb63-83"><a href="#cb63-83" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-84"><a href="#cb63-84" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>indexx<span class="op">+</span><span class="dv">1</span><span class="op">,</span>indexx<span class="op">+</span><span class="dv">1</span><span class="op">+</span>indexx<span class="op">[</span><span class="dv">0</span><span class="op">],</span>cmp<span class="op">);</span></span>
<span id="cb63-85"><a href="#cb63-85" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb63-86"><a href="#cb63-86" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l<span class="op">=</span><span class="dv">1</span><span class="op">,</span> r<span class="op">=</span>indexx<span class="op">[</span><span class="dv">0</span><span class="op">],</span>ans<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb63-87"><a href="#cb63-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>l<span class="op">&lt;</span>r<span class="op">){</span></span>
<span id="cb63-88"><a href="#cb63-88" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x <span class="op">=</span> indexx<span class="op">[</span>l<span class="op">],</span> y <span class="op">=</span> indexx<span class="op">[</span>r<span class="op">];</span></span>
<span id="cb63-89"><a href="#cb63-89" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>dis<span class="op">[</span>x<span class="op">]+</span>dis<span class="op">[</span>y<span class="op">]&gt;</span>k<span class="op">){</span></span>
<span id="cb63-90"><a href="#cb63-90" aria-hidden="true" tabindex="-1"></a>            cntsame<span class="op">[</span>belong<span class="op">[</span>y<span class="op">]]--;</span><span class="co">//把cntsame由[l,r]转移,r-1]</span></span>
<span id="cb63-91"><a href="#cb63-91" aria-hidden="true" tabindex="-1"></a>            r<span class="op">--;</span></span>
<span id="cb63-92"><a href="#cb63-92" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb63-93"><a href="#cb63-93" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb63-94"><a href="#cb63-94" aria-hidden="true" tabindex="-1"></a>            <span class="co">//显然，如果不考虑两个点在同一个子子树内，则l和l+1~r的每个点都满足dis[x]+dis[y]&lt;=k</span></span>
<span id="cb63-95"><a href="#cb63-95" aria-hidden="true" tabindex="-1"></a>            <span class="co">//减去同子子树的情况，即减去[l+1,r]中和l拥有相同belong的点</span></span>
<span id="cb63-96"><a href="#cb63-96" aria-hidden="true" tabindex="-1"></a>            cntsame<span class="op">[</span>belong<span class="op">[</span>x<span class="op">]]--;</span><span class="co">//把cntsame由[l,r]转移到[l+1,r]，一定要注意顺序</span></span>
<span id="cb63-97"><a href="#cb63-97" aria-hidden="true" tabindex="-1"></a>            ans <span class="op">+=</span> r<span class="op">-</span>l<span class="op">-</span>cntsame<span class="op">[</span>belong<span class="op">[</span>x<span class="op">]];</span></span>
<span id="cb63-98"><a href="#cb63-98" aria-hidden="true" tabindex="-1"></a>            l<span class="op">++;</span></span>
<span id="cb63-99"><a href="#cb63-99" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> </span>
<span id="cb63-100"><a href="#cb63-100" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-101"><a href="#cb63-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb63-102"><a href="#cb63-102" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb63-103"><a href="#cb63-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-104"><a href="#cb63-104" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> res <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb63-105"><a href="#cb63-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-106"><a href="#cb63-106" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> divide<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> k<span class="op">){</span></span>
<span id="cb63-107"><a href="#cb63-107" aria-hidden="true" tabindex="-1"></a>    del<span class="op">[</span>u<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb63-108"><a href="#cb63-108" aria-hidden="true" tabindex="-1"></a>    res <span class="op">+=</span> calc<span class="op">(</span>u<span class="op">,</span>k<span class="op">);</span></span>
<span id="cb63-109"><a href="#cb63-109" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> e<span class="op">=</span>head<span class="op">[</span>u<span class="op">];</span>e<span class="op">;</span>e<span class="op">=</span>edges<span class="op">[</span>e<span class="op">].</span>next<span class="op">){</span></span>
<span id="cb63-110"><a href="#cb63-110" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> edges<span class="op">[</span>e<span class="op">].</span>v<span class="op">,</span> w <span class="op">=</span> edges<span class="op">[</span>e<span class="op">].</span>w<span class="op">;</span></span>
<span id="cb63-111"><a href="#cb63-111" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>del<span class="op">[</span>v<span class="op">])</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb63-112"><a href="#cb63-112" aria-hidden="true" tabindex="-1"></a>        ctr <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb63-113"><a href="#cb63-113" aria-hidden="true" tabindex="-1"></a>        dfsCtr<span class="op">(</span>v<span class="op">,</span><span class="dv">0</span><span class="op">,</span>sz<span class="op">[</span>v<span class="op">]);</span></span>
<span id="cb63-114"><a href="#cb63-114" aria-hidden="true" tabindex="-1"></a>        divide<span class="op">(</span>ctr<span class="op">,</span>k<span class="op">);</span></span>
<span id="cb63-115"><a href="#cb63-115" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-116"><a href="#cb63-116" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb63-117"><a href="#cb63-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-118"><a href="#cb63-118" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">){</span></span>
<span id="cb63-119"><a href="#cb63-119" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb63-120"><a href="#cb63-120" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> u<span class="op">,</span>v<span class="op">,</span>w<span class="op">;</span></span>
<span id="cb63-121"><a href="#cb63-121" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>u<span class="op">&gt;&gt;</span>v<span class="op">&gt;&gt;</span>w<span class="op">;</span></span>
<span id="cb63-122"><a href="#cb63-122" aria-hidden="true" tabindex="-1"></a>        add<span class="op">(</span>u<span class="op">,</span>v<span class="op">,</span>w<span class="op">);</span></span>
<span id="cb63-123"><a href="#cb63-123" aria-hidden="true" tabindex="-1"></a>        add<span class="op">(</span>v<span class="op">,</span>u<span class="op">,</span>w<span class="op">);</span></span>
<span id="cb63-124"><a href="#cb63-124" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-125"><a href="#cb63-125" aria-hidden="true" tabindex="-1"></a>    dfsCtr<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span>n<span class="op">);</span></span>
<span id="cb63-126"><a href="#cb63-126" aria-hidden="true" tabindex="-1"></a>    divide<span class="op">(</span>ctr<span class="op">,</span>k<span class="op">);</span></span>
<span id="cb63-127"><a href="#cb63-127" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>res<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb63-128"><a href="#cb63-128" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb63-129"><a href="#cb63-129" aria-hidden="true" tabindex="-1"></a>    ctr <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb63-130"><a href="#cb63-130" aria-hidden="true" tabindex="-1"></a>    cnt <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb63-131"><a href="#cb63-131" aria-hidden="true" tabindex="-1"></a>    res <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb63-132"><a href="#cb63-132" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++)</span> head<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">,</span>del<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb63-133"><a href="#cb63-133" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb63-134"><a href="#cb63-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-135"><a href="#cb63-135" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb63-136"><a href="#cb63-136" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb63-137"><a href="#cb63-137" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb63-138"><a href="#cb63-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-139"><a href="#cb63-139" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>k<span class="op">;</span></span>
<span id="cb63-140"><a href="#cb63-140" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb63-141"><a href="#cb63-141" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span><span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>k<span class="op">){</span></span>
<span id="cb63-142"><a href="#cb63-142" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>n<span class="op">==</span><span class="dv">0</span><span class="op">&amp;&amp;</span>k<span class="op">==</span><span class="dv">0</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb63-143"><a href="#cb63-143" aria-hidden="true" tabindex="-1"></a>        solve<span class="op">(</span>n<span class="op">,</span>k<span class="op">);</span></span>
<span id="cb63-144"><a href="#cb63-144" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-145"><a href="#cb63-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-146"><a href="#cb63-146" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb63-147"><a href="#cb63-147" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="重链剖分">重链剖分</h2>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co">//树根节点的子节点中子树最大的为它的重子节点，其他的为轻子节点（整棵树的根节点是轻点，其他子树的根节点可轻可重）</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="co">//节点连向其轻子节点的边叫轻边，否则叫重边</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="co">//节点数为n，则从任意节点向上到根节点，经过的轻边数不超过logn</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node<span class="op">{</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fa<span class="op">,</span> sz<span class="op">,</span> dep<span class="op">,</span> hson<span class="op">;</span><span class="co">//父节点、子树大小（包含自己）、深度、重子节点</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top<span class="op">;</span><span class="co">//链头，即所在的重链中深度最小的那个节点 </span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>node<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> edges<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs1<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> d<span class="op">=</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">//在dfs2之前先用dfs1</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> ma <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>    node<span class="op">[</span>u<span class="op">].</span>dep <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> v<span class="op">:</span>edges<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>node<span class="op">[</span>v<span class="op">].</span>dep<span class="op">){</span></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>            dfs1<span class="op">(</span>v<span class="op">,</span>d<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>            node<span class="op">[</span>v<span class="op">].</span>fa <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a>            size <span class="op">+=</span> node<span class="op">[</span>v<span class="op">].</span>sz<span class="op">;</span></span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>node<span class="op">[</span>v<span class="op">].</span>sz <span class="op">&gt;</span> ma<span class="op">){</span></span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a>                node<span class="op">[</span>u<span class="op">].</span>hson <span class="op">=</span> v<span class="op">,</span> ma <span class="op">=</span> node<span class="op">[</span>v<span class="op">].</span>sz<span class="op">;</span></span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb64-26"><a href="#cb64-26" aria-hidden="true" tabindex="-1"></a>    node<span class="op">[</span>u<span class="op">].</span>sz <span class="op">=</span> size<span class="op">;</span></span>
<span id="cb64-27"><a href="#cb64-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb64-28"><a href="#cb64-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-29"><a href="#cb64-29" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs2<span class="op">(</span><span class="dt">int</span> u<span class="op">){</span></span>
<span id="cb64-30"><a href="#cb64-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">//需要先把根节点的top设置为自己</span></span>
<span id="cb64-31"><a href="#cb64-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> v<span class="op">:</span>edges<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb64-32"><a href="#cb64-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>node<span class="op">[</span>v<span class="op">].</span>top<span class="op">){</span></span>
<span id="cb64-33"><a href="#cb64-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>v<span class="op">==</span>node<span class="op">[</span>u<span class="op">].</span>hson<span class="op">)</span> node<span class="op">[</span>v<span class="op">].</span>top <span class="op">=</span> node<span class="op">[</span>u<span class="op">].</span>top<span class="op">;</span></span>
<span id="cb64-34"><a href="#cb64-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> node<span class="op">[</span>v<span class="op">].</span>top <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb64-35"><a href="#cb64-35" aria-hidden="true" tabindex="-1"></a>            dfs2<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb64-36"><a href="#cb64-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb64-37"><a href="#cb64-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb64-38"><a href="#cb64-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb64-39"><a href="#cb64-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-40"><a href="#cb64-40" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> cut<span class="op">(</span><span class="dt">int</span> r<span class="op">=</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb64-41"><a href="#cb64-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">//进行树剖预处理</span></span>
<span id="cb64-42"><a href="#cb64-42" aria-hidden="true" tabindex="-1"></a>    dfs1<span class="op">(</span>r<span class="op">);</span></span>
<span id="cb64-43"><a href="#cb64-43" aria-hidden="true" tabindex="-1"></a>    node<span class="op">[</span>r<span class="op">].</span>top <span class="op">=</span> r<span class="op">;</span></span>
<span id="cb64-44"><a href="#cb64-44" aria-hidden="true" tabindex="-1"></a>    dfs2<span class="op">(</span>r<span class="op">);</span></span>
<span id="cb64-45"><a href="#cb64-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="重链剖分求lca">重链剖分求LCA</h3>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co">//树剖求LCA，每次查询复杂度 logn，常数很小</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p3379</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> lca<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">){</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>node<span class="op">[</span>a<span class="op">].</span>top<span class="op">!=</span>node<span class="op">[</span>b<span class="op">].</span>top<span class="op">){</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>node<span class="op">[</span>node<span class="op">[</span>a<span class="op">].</span>top<span class="op">].</span>dep<span class="op">&gt;</span>node<span class="op">[</span>node<span class="op">[</span>b<span class="op">].</span>top<span class="op">].</span>dep<span class="op">)</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>            a <span class="op">=</span> node<span class="op">[</span>node<span class="op">[</span>a<span class="op">].</span>top<span class="op">].</span>fa<span class="op">;</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>            b <span class="op">=</span> node<span class="op">[</span>node<span class="op">[</span>b<span class="op">].</span>top<span class="op">].</span>fa<span class="op">;</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>node<span class="op">[</span>a<span class="op">].</span>dep <span class="op">&gt;</span> node<span class="op">[</span>b<span class="op">].</span>dep<span class="op">)</span> <span class="cf">return</span> b<span class="op">;</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a<span class="op">;</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="重链剖分线段树维护树上路径点权和">重链剖分+线段树维护树上路径点权和</h3>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">//树剖维护树上路径的点权和，维护和查询一次复杂度 logn</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p3384</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="co">//树根节点的子节点中子树最大的为它的重子节点，其他的为轻子节点（整棵树的根节点是轻点，其他子树的根节点可轻可重）</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="co">//节点连向其轻子节点的边叫轻边，否则叫重边</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="co">//节点数为n，则从任意节点向上到根节点，经过的轻边数不超过logn</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#define pb </span>push_back</span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#define mkp </span><span class="bu">std::</span>make_pair</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#define fi </span>first</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a><span class="pp">#define se </span>second</span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> LL <span class="op">=</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">100005</span><span class="op">;</span></span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> INF <span class="op">=</span> <span class="bn">0x7fffffff</span><span class="op">;</span></span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a>LL MOD <span class="op">=</span> <span class="dv">998244353</span><span class="op">;</span></span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node<span class="op">{</span></span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fa<span class="op">,</span> sz<span class="op">,</span> dep<span class="op">,</span> hson<span class="op">;</span><span class="co">//父节点、子树大小（包含自己）、深度、重子节点</span></span>
<span id="cb66-26"><a href="#cb66-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top<span class="op">;</span><span class="co">//链头，即所在的重链中深度最小的那个节点 </span></span>
<span id="cb66-27"><a href="#cb66-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dfn<span class="op">,</span> mdfn<span class="op">;</span><span class="co">//该节点的dfs序，该节点子树的最大dfs序</span></span>
<span id="cb66-28"><a href="#cb66-28" aria-hidden="true" tabindex="-1"></a>    LL v<span class="op">;</span><span class="co">//点上的权</span></span>
<span id="cb66-29"><a href="#cb66-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>node<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb66-30"><a href="#cb66-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfnmap<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//映射dfn对应的点编号</span></span>
<span id="cb66-31"><a href="#cb66-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-32"><a href="#cb66-32" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> edges<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb66-33"><a href="#cb66-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-34"><a href="#cb66-34" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs1<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> d<span class="op">=</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb66-35"><a href="#cb66-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">//在dfs2之前先用dfs1</span></span>
<span id="cb66-36"><a href="#cb66-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> ma <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb66-37"><a href="#cb66-37" aria-hidden="true" tabindex="-1"></a>    node<span class="op">[</span>u<span class="op">].</span>dep <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb66-38"><a href="#cb66-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> v<span class="op">:</span>edges<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb66-39"><a href="#cb66-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>node<span class="op">[</span>v<span class="op">].</span>dep<span class="op">){</span></span>
<span id="cb66-40"><a href="#cb66-40" aria-hidden="true" tabindex="-1"></a>            dfs1<span class="op">(</span>v<span class="op">,</span>d<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb66-41"><a href="#cb66-41" aria-hidden="true" tabindex="-1"></a>            node<span class="op">[</span>v<span class="op">].</span>fa <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb66-42"><a href="#cb66-42" aria-hidden="true" tabindex="-1"></a>            size <span class="op">+=</span> node<span class="op">[</span>v<span class="op">].</span>sz<span class="op">;</span></span>
<span id="cb66-43"><a href="#cb66-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>node<span class="op">[</span>v<span class="op">].</span>sz <span class="op">&gt;</span> ma<span class="op">){</span></span>
<span id="cb66-44"><a href="#cb66-44" aria-hidden="true" tabindex="-1"></a>                node<span class="op">[</span>u<span class="op">].</span>hson <span class="op">=</span> v<span class="op">,</span> ma <span class="op">=</span> node<span class="op">[</span>v<span class="op">].</span>sz<span class="op">;</span></span>
<span id="cb66-45"><a href="#cb66-45" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb66-46"><a href="#cb66-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb66-47"><a href="#cb66-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-48"><a href="#cb66-48" aria-hidden="true" tabindex="-1"></a>    node<span class="op">[</span>u<span class="op">].</span>sz <span class="op">=</span> size<span class="op">;</span></span>
<span id="cb66-49"><a href="#cb66-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-50"><a href="#cb66-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-51"><a href="#cb66-51" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cnt<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb66-52"><a href="#cb66-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-53"><a href="#cb66-53" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs2<span class="op">(</span><span class="dt">int</span> u<span class="op">){</span></span>
<span id="cb66-54"><a href="#cb66-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">//需要先把根节点的top设置为自己</span></span>
<span id="cb66-55"><a href="#cb66-55" aria-hidden="true" tabindex="-1"></a>    node<span class="op">[</span>u<span class="op">].</span>dfn <span class="op">=</span> <span class="op">++</span>cnt<span class="op">;</span></span>
<span id="cb66-56"><a href="#cb66-56" aria-hidden="true" tabindex="-1"></a>    dfnmap<span class="op">[</span>cnt<span class="op">]</span> <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb66-57"><a href="#cb66-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>node<span class="op">[</span>u<span class="op">].</span>hson<span class="op">!=</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb66-58"><a href="#cb66-58" aria-hidden="true" tabindex="-1"></a>        node<span class="op">[</span>node<span class="op">[</span>u<span class="op">].</span>hson<span class="op">].</span>top <span class="op">=</span> node<span class="op">[</span>u<span class="op">].</span>top<span class="op">;</span></span>
<span id="cb66-59"><a href="#cb66-59" aria-hidden="true" tabindex="-1"></a>        dfs2<span class="op">(</span>node<span class="op">[</span>u<span class="op">].</span>hson<span class="op">);</span></span>
<span id="cb66-60"><a href="#cb66-60" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-61"><a href="#cb66-61" aria-hidden="true" tabindex="-1"></a>    <span class="co">//采取这个改变的原因是，每棵子树的dfs序是连续的，根节点dfs序最小</span></span>
<span id="cb66-62"><a href="#cb66-62" aria-hidden="true" tabindex="-1"></a>    <span class="co">//而如果我们强制先遍历重子节点，那么重链上的dfs序是连续的，并且链头dfs序最小。这样就能用线段树维护链上的信息了</span></span>
<span id="cb66-63"><a href="#cb66-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb66-64"><a href="#cb66-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> v<span class="op">:</span>edges<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb66-65"><a href="#cb66-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>node<span class="op">[</span>v<span class="op">].</span>top<span class="op">){</span></span>
<span id="cb66-66"><a href="#cb66-66" aria-hidden="true" tabindex="-1"></a>            node<span class="op">[</span>v<span class="op">].</span>top <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb66-67"><a href="#cb66-67" aria-hidden="true" tabindex="-1"></a>            dfs2<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb66-68"><a href="#cb66-68" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb66-69"><a href="#cb66-69" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-70"><a href="#cb66-70" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb66-71"><a href="#cb66-71" aria-hidden="true" tabindex="-1"></a>    node<span class="op">[</span>u<span class="op">].</span>mdfn <span class="op">=</span> cnt<span class="op">;</span></span>
<span id="cb66-72"><a href="#cb66-72" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-73"><a href="#cb66-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-74"><a href="#cb66-74" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> cut<span class="op">(</span><span class="dt">int</span> r<span class="op">){</span></span>
<span id="cb66-75"><a href="#cb66-75" aria-hidden="true" tabindex="-1"></a>    dfs1<span class="op">(</span>r<span class="op">);</span></span>
<span id="cb66-76"><a href="#cb66-76" aria-hidden="true" tabindex="-1"></a>    node<span class="op">[</span>r<span class="op">].</span>top <span class="op">=</span> r<span class="op">;</span></span>
<span id="cb66-77"><a href="#cb66-77" aria-hidden="true" tabindex="-1"></a>    dfs2<span class="op">(</span>r<span class="op">);</span></span>
<span id="cb66-78"><a href="#cb66-78" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-79"><a href="#cb66-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-80"><a href="#cb66-80" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Nodest</span>
<span id="cb66-81"><a href="#cb66-81" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb66-82"><a href="#cb66-82" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> s<span class="op">,</span>t<span class="op">;</span><span class="co">//该端点的起点和终点下标</span></span>
<span id="cb66-83"><a href="#cb66-83" aria-hidden="true" tabindex="-1"></a>    LL tag<span class="op">,</span> v<span class="op">;</span></span>
<span id="cb66-84"><a href="#cb66-84" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb66-85"><a href="#cb66-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-86"><a href="#cb66-86" aria-hidden="true" tabindex="-1"></a>Nodest st<span class="op">[</span>MAXN<span class="op">*</span><span class="dv">4</span><span class="op">+</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb66-87"><a href="#cb66-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-88"><a href="#cb66-88" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> build<span class="op">(</span><span class="dt">int</span> s<span class="op">,</span> <span class="dt">int</span> t<span class="op">,</span> <span class="dt">int</span> p<span class="op">){</span></span>
<span id="cb66-89"><a href="#cb66-89" aria-hidden="true" tabindex="-1"></a>    st<span class="op">[</span>p<span class="op">].</span>s <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb66-90"><a href="#cb66-90" aria-hidden="true" tabindex="-1"></a>    st<span class="op">[</span>p<span class="op">].</span>t <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb66-91"><a href="#cb66-91" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>s<span class="op">==</span>t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb66-92"><a href="#cb66-92" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">].</span>v <span class="op">=</span> node<span class="op">[</span>dfnmap<span class="op">[</span>s<span class="op">]].</span>v<span class="op">%</span>MOD<span class="op">;</span></span>
<span id="cb66-93"><a href="#cb66-93" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">].</span>tag <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb66-94"><a href="#cb66-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb66-95"><a href="#cb66-95" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-96"><a href="#cb66-96" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> s<span class="op">+((</span>t<span class="op">-</span>s<span class="op">)&gt;&gt;</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb66-97"><a href="#cb66-97" aria-hidden="true" tabindex="-1"></a>    build<span class="op">(</span>s<span class="op">,</span>m<span class="op">,</span>p<span class="op">*</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb66-98"><a href="#cb66-98" aria-hidden="true" tabindex="-1"></a>    build<span class="op">(</span>m<span class="op">+</span><span class="dv">1</span><span class="op">,</span>t<span class="op">,</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb66-99"><a href="#cb66-99" aria-hidden="true" tabindex="-1"></a>    st<span class="op">[</span>p<span class="op">].</span>v <span class="op">=</span> <span class="op">(</span>st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">].</span>v <span class="op">+</span> st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">].</span>v<span class="op">)%</span>MOD<span class="op">;</span></span>
<span id="cb66-100"><a href="#cb66-100" aria-hidden="true" tabindex="-1"></a>    st<span class="op">[</span>p<span class="op">].</span>tag <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb66-101"><a href="#cb66-101" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-102"><a href="#cb66-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-103"><a href="#cb66-103" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> spreadTag<span class="op">(</span><span class="dt">int</span> p<span class="op">){</span></span>
<span id="cb66-104"><a href="#cb66-104" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>st<span class="op">[</span>p<span class="op">].</span>tag<span class="op">){</span></span>
<span id="cb66-105"><a href="#cb66-105" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> s <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>s<span class="op">,</span> t <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>t<span class="op">;</span></span>
<span id="cb66-106"><a href="#cb66-106" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> s<span class="op">+((</span>t<span class="op">-</span>s<span class="op">)&gt;&gt;</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb66-107"><a href="#cb66-107" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">].</span>v     <span class="op">=</span> <span class="op">(</span>st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">].</span>v <span class="op">+</span> <span class="op">(</span>m<span class="op">-</span>s<span class="op">+</span><span class="dv">1</span><span class="op">)*</span>st<span class="op">[</span>p<span class="op">].</span>tag<span class="op">)%</span>MOD<span class="op">;</span></span>
<span id="cb66-108"><a href="#cb66-108" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">].</span>v   <span class="op">=</span> <span class="op">(</span>st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">].</span>v <span class="op">+</span> <span class="op">(</span>t<span class="op">-</span>m<span class="op">)*</span>st<span class="op">[</span>p<span class="op">].</span>tag<span class="op">)%</span>MOD<span class="op">;</span></span>
<span id="cb66-109"><a href="#cb66-109" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">].</span>tag   <span class="op">=</span> <span class="op">(</span>st<span class="op">[</span>p<span class="op">].</span>tag <span class="op">+</span> st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">].</span>tag<span class="op">)%</span>MOD<span class="op">;</span></span>
<span id="cb66-110"><a href="#cb66-110" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">].</span>tag <span class="op">=</span> <span class="op">(</span>st<span class="op">[</span>p<span class="op">].</span>tag <span class="op">+</span> st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">].</span>tag<span class="op">)%</span>MOD<span class="op">;</span></span>
<span id="cb66-111"><a href="#cb66-111" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">].</span>tag<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb66-112"><a href="#cb66-112" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-113"><a href="#cb66-113" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-114"><a href="#cb66-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-115"><a href="#cb66-115" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> update<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> p<span class="op">,</span> LL k<span class="op">){</span></span>
<span id="cb66-116"><a href="#cb66-116" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> s <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>s<span class="op">,</span> t <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>t<span class="op">;</span></span>
<span id="cb66-117"><a href="#cb66-117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">&lt;=</span>s <span class="op">&amp;&amp;</span> t<span class="op">&lt;=</span>r<span class="op">){</span></span>
<span id="cb66-118"><a href="#cb66-118" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">].</span>v   <span class="op">=</span> <span class="op">(</span>st<span class="op">[</span>p<span class="op">].</span>v <span class="op">+</span> <span class="op">(</span>t<span class="op">-</span>s<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="op">*</span> k<span class="op">)%</span>MOD<span class="op">;</span></span>
<span id="cb66-119"><a href="#cb66-119" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">].</span>tag <span class="op">=</span> <span class="op">(</span>st<span class="op">[</span>p<span class="op">].</span>tag <span class="op">+</span> k<span class="op">)%</span>MOD<span class="op">;</span></span>
<span id="cb66-120"><a href="#cb66-120" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb66-121"><a href="#cb66-121" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-122"><a href="#cb66-122" aria-hidden="true" tabindex="-1"></a>    spreadTag<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb66-123"><a href="#cb66-123" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb66-124"><a href="#cb66-124" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> s<span class="op">+((</span>t<span class="op">-</span>s<span class="op">)&gt;&gt;</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb66-125"><a href="#cb66-125" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">&lt;=</span>m<span class="op">)</span> update<span class="op">(</span>l<span class="op">,</span> r<span class="op">,</span> p<span class="op">*</span><span class="dv">2</span><span class="op">,</span> k<span class="op">);</span></span>
<span id="cb66-126"><a href="#cb66-126" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>r<span class="op">&gt;</span>m<span class="op">)</span>  update<span class="op">(</span>l<span class="op">,</span> r<span class="op">,</span> p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">,</span> k<span class="op">);</span></span>
<span id="cb66-127"><a href="#cb66-127" aria-hidden="true" tabindex="-1"></a>    st<span class="op">[</span>p<span class="op">].</span>v <span class="op">=</span> <span class="op">(</span>st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">].</span>v <span class="op">+</span> st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">].</span>v<span class="op">)%</span>MOD<span class="op">;</span></span>
<span id="cb66-128"><a href="#cb66-128" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-129"><a href="#cb66-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-130"><a href="#cb66-130" aria-hidden="true" tabindex="-1"></a>LL query<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> p<span class="op">){</span></span>
<span id="cb66-131"><a href="#cb66-131" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> s <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>s<span class="op">,</span> t <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>t<span class="op">;</span></span>
<span id="cb66-132"><a href="#cb66-132" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">&lt;=</span>s <span class="op">&amp;&amp;</span> t<span class="op">&lt;=</span>r<span class="op">)</span> <span class="cf">return</span> st<span class="op">[</span>p<span class="op">].</span>v<span class="op">%</span>MOD<span class="op">;</span></span>
<span id="cb66-133"><a href="#cb66-133" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb66-134"><a href="#cb66-134" aria-hidden="true" tabindex="-1"></a>    spreadTag<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb66-135"><a href="#cb66-135" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> s<span class="op">+((</span>t<span class="op">-</span>s<span class="op">)&gt;&gt;</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb66-136"><a href="#cb66-136" aria-hidden="true" tabindex="-1"></a>    LL ret <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb66-137"><a href="#cb66-137" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">&lt;=</span>m<span class="op">)</span> ret <span class="op">=</span> <span class="op">(</span>ret <span class="op">+</span> query<span class="op">(</span>l<span class="op">,</span>r<span class="op">,</span>p<span class="op">*</span><span class="dv">2</span><span class="op">))%</span>MOD<span class="op">;</span></span>
<span id="cb66-138"><a href="#cb66-138" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>r<span class="op">&gt;</span>m<span class="op">)</span>  ret <span class="op">=</span> <span class="op">(</span>ret <span class="op">+</span> query<span class="op">(</span>l<span class="op">,</span>r<span class="op">,</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">))%</span>MOD<span class="op">;</span></span>
<span id="cb66-139"><a href="#cb66-139" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb66-140"><a href="#cb66-140" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb66-141"><a href="#cb66-141" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-142"><a href="#cb66-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-143"><a href="#cb66-143" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> update_path<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">,</span> LL k<span class="op">){</span></span>
<span id="cb66-144"><a href="#cb66-144" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>node<span class="op">[</span>x<span class="op">].</span>top <span class="op">!=</span> node<span class="op">[</span>y<span class="op">].</span>top<span class="op">){</span></span>
<span id="cb66-145"><a href="#cb66-145" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>node<span class="op">[</span>node<span class="op">[</span>x<span class="op">].</span>top<span class="op">].</span>dep <span class="op">&gt;</span> node<span class="op">[</span>node<span class="op">[</span>y<span class="op">].</span>top<span class="op">].</span>dep<span class="op">){</span></span>
<span id="cb66-146"><a href="#cb66-146" aria-hidden="true" tabindex="-1"></a>            update<span class="op">(</span>node<span class="op">[</span>node<span class="op">[</span>x<span class="op">].</span>top<span class="op">].</span>dfn<span class="op">,</span> node<span class="op">[</span>x<span class="op">].</span>dfn<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> k<span class="op">);</span></span>
<span id="cb66-147"><a href="#cb66-147" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> node<span class="op">[</span>node<span class="op">[</span>x<span class="op">].</span>top<span class="op">].</span>fa<span class="op">;</span></span>
<span id="cb66-148"><a href="#cb66-148" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb66-149"><a href="#cb66-149" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb66-150"><a href="#cb66-150" aria-hidden="true" tabindex="-1"></a>            update<span class="op">(</span>node<span class="op">[</span>node<span class="op">[</span>y<span class="op">].</span>top<span class="op">].</span>dfn<span class="op">,</span> node<span class="op">[</span>y<span class="op">].</span>dfn<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> k<span class="op">);</span></span>
<span id="cb66-151"><a href="#cb66-151" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> node<span class="op">[</span>node<span class="op">[</span>y<span class="op">].</span>top<span class="op">].</span>fa<span class="op">;</span></span>
<span id="cb66-152"><a href="#cb66-152" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb66-153"><a href="#cb66-153" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-154"><a href="#cb66-154" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>node<span class="op">[</span>x<span class="op">].</span>dep<span class="op">&gt;</span>node<span class="op">[</span>y<span class="op">].</span>dep<span class="op">){</span></span>
<span id="cb66-155"><a href="#cb66-155" aria-hidden="true" tabindex="-1"></a>        update<span class="op">(</span>node<span class="op">[</span>y<span class="op">].</span>dfn<span class="op">,</span> node<span class="op">[</span>x<span class="op">].</span>dfn<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> k<span class="op">);</span></span>
<span id="cb66-156"><a href="#cb66-156" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-157"><a href="#cb66-157" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span><span class="op">{</span></span>
<span id="cb66-158"><a href="#cb66-158" aria-hidden="true" tabindex="-1"></a>        update<span class="op">(</span>node<span class="op">[</span>x<span class="op">].</span>dfn<span class="op">,</span> node<span class="op">[</span>y<span class="op">].</span>dfn<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> k<span class="op">);</span></span>
<span id="cb66-159"><a href="#cb66-159" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-160"><a href="#cb66-160" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-161"><a href="#cb66-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-162"><a href="#cb66-162" aria-hidden="true" tabindex="-1"></a>LL query_path<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">){</span></span>
<span id="cb66-163"><a href="#cb66-163" aria-hidden="true" tabindex="-1"></a>    LL ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb66-164"><a href="#cb66-164" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>node<span class="op">[</span>x<span class="op">].</span>top <span class="op">!=</span> node<span class="op">[</span>y<span class="op">].</span>top<span class="op">){</span></span>
<span id="cb66-165"><a href="#cb66-165" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>node<span class="op">[</span>node<span class="op">[</span>x<span class="op">].</span>top<span class="op">].</span>dep <span class="op">&gt;</span> node<span class="op">[</span>node<span class="op">[</span>y<span class="op">].</span>top<span class="op">].</span>dep<span class="op">){</span></span>
<span id="cb66-166"><a href="#cb66-166" aria-hidden="true" tabindex="-1"></a>            ans <span class="op">+=</span> query<span class="op">(</span>node<span class="op">[</span>node<span class="op">[</span>x<span class="op">].</span>top<span class="op">].</span>dfn<span class="op">,</span> node<span class="op">[</span>x<span class="op">].</span>dfn<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb66-167"><a href="#cb66-167" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> node<span class="op">[</span>node<span class="op">[</span>x<span class="op">].</span>top<span class="op">].</span>fa<span class="op">;</span></span>
<span id="cb66-168"><a href="#cb66-168" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb66-169"><a href="#cb66-169" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb66-170"><a href="#cb66-170" aria-hidden="true" tabindex="-1"></a>            ans <span class="op">+=</span> query<span class="op">(</span>node<span class="op">[</span>node<span class="op">[</span>y<span class="op">].</span>top<span class="op">].</span>dfn<span class="op">,</span> node<span class="op">[</span>y<span class="op">].</span>dfn<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb66-171"><a href="#cb66-171" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> node<span class="op">[</span>node<span class="op">[</span>y<span class="op">].</span>top<span class="op">].</span>fa<span class="op">;</span></span>
<span id="cb66-172"><a href="#cb66-172" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb66-173"><a href="#cb66-173" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-174"><a href="#cb66-174" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>node<span class="op">[</span>x<span class="op">].</span>dep<span class="op">&gt;</span>node<span class="op">[</span>y<span class="op">].</span>dep<span class="op">){</span></span>
<span id="cb66-175"><a href="#cb66-175" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">+=</span> query<span class="op">(</span>node<span class="op">[</span>y<span class="op">].</span>dfn<span class="op">,</span> node<span class="op">[</span>x<span class="op">].</span>dfn<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb66-176"><a href="#cb66-176" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-177"><a href="#cb66-177" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span><span class="op">{</span></span>
<span id="cb66-178"><a href="#cb66-178" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">+=</span> query<span class="op">(</span>node<span class="op">[</span>x<span class="op">].</span>dfn<span class="op">,</span> node<span class="op">[</span>y<span class="op">].</span>dfn<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb66-179"><a href="#cb66-179" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-180"><a href="#cb66-180" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb66-181"><a href="#cb66-181" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">%</span>MOD<span class="op">;</span></span>
<span id="cb66-182"><a href="#cb66-182" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-183"><a href="#cb66-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-184"><a href="#cb66-184" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> update_subtree<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> LL k<span class="op">){</span></span>
<span id="cb66-185"><a href="#cb66-185" aria-hidden="true" tabindex="-1"></a>    update<span class="op">(</span>node<span class="op">[</span>x<span class="op">].</span>dfn<span class="op">,</span> node<span class="op">[</span>x<span class="op">].</span>mdfn<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> k<span class="op">);</span></span>
<span id="cb66-186"><a href="#cb66-186" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-187"><a href="#cb66-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-188"><a href="#cb66-188" aria-hidden="true" tabindex="-1"></a>LL query_subtree<span class="op">(</span><span class="dt">int</span> x<span class="op">){</span></span>
<span id="cb66-189"><a href="#cb66-189" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> query<span class="op">(</span>node<span class="op">[</span>x<span class="op">].</span>dfn<span class="op">,</span> node<span class="op">[</span>x<span class="op">].</span>mdfn<span class="op">,</span> <span class="dv">1</span><span class="op">)%</span>MOD<span class="op">;</span></span>
<span id="cb66-190"><a href="#cb66-190" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-191"><a href="#cb66-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-192"><a href="#cb66-192" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">(){</span></span>
<span id="cb66-193"><a href="#cb66-193" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">,</span>r<span class="op">;</span></span>
<span id="cb66-194"><a href="#cb66-194" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">&gt;&gt;</span>r<span class="op">&gt;&gt;</span>MOD<span class="op">;</span><span class="co">//节点个数，操作个数，根节点序号，取模数</span></span>
<span id="cb66-195"><a href="#cb66-195" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb66-196"><a href="#cb66-196" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>node<span class="op">[</span>i<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb66-197"><a href="#cb66-197" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-198"><a href="#cb66-198" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb66-199"><a href="#cb66-199" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb66-200"><a href="#cb66-200" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>x<span class="op">&gt;&gt;</span>y<span class="op">;</span></span>
<span id="cb66-201"><a href="#cb66-201" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">[</span>x<span class="op">].</span>pb<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb66-202"><a href="#cb66-202" aria-hidden="true" tabindex="-1"></a>        edges<span class="op">[</span>y<span class="op">].</span>pb<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb66-203"><a href="#cb66-203" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-204"><a href="#cb66-204" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb66-205"><a href="#cb66-205" aria-hidden="true" tabindex="-1"></a>    cut<span class="op">(</span>r<span class="op">);</span></span>
<span id="cb66-206"><a href="#cb66-206" aria-hidden="true" tabindex="-1"></a>    build<span class="op">(</span><span class="dv">1</span><span class="op">,</span>n<span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb66-207"><a href="#cb66-207" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb66-208"><a href="#cb66-208" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>m<span class="op">--){</span></span>
<span id="cb66-209"><a href="#cb66-209" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> ope<span class="op">,</span>x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb66-210"><a href="#cb66-210" aria-hidden="true" tabindex="-1"></a>        LL z<span class="op">;</span></span>
<span id="cb66-211"><a href="#cb66-211" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>ope<span class="op">;</span></span>
<span id="cb66-212"><a href="#cb66-212" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb66-213"><a href="#cb66-213" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>ope<span class="op">==</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb66-214"><a href="#cb66-214" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>x<span class="op">&gt;&gt;</span>y<span class="op">&gt;&gt;</span>z<span class="op">;</span></span>
<span id="cb66-215"><a href="#cb66-215" aria-hidden="true" tabindex="-1"></a>            update_path<span class="op">(</span>x<span class="op">,</span>y<span class="op">,</span>z<span class="op">);</span></span>
<span id="cb66-216"><a href="#cb66-216" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb66-217"><a href="#cb66-217" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>ope<span class="op">==</span><span class="dv">2</span><span class="op">){</span></span>
<span id="cb66-218"><a href="#cb66-218" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>x<span class="op">&gt;&gt;</span>y<span class="op">;</span></span>
<span id="cb66-219"><a href="#cb66-219" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>query_path<span class="op">(</span>x<span class="op">,</span>y<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb66-220"><a href="#cb66-220" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb66-221"><a href="#cb66-221" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>ope<span class="op">==</span><span class="dv">3</span><span class="op">){</span></span>
<span id="cb66-222"><a href="#cb66-222" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>x<span class="op">&gt;&gt;</span>z<span class="op">;</span></span>
<span id="cb66-223"><a href="#cb66-223" aria-hidden="true" tabindex="-1"></a>            update_subtree<span class="op">(</span>x<span class="op">,</span>z<span class="op">);</span></span>
<span id="cb66-224"><a href="#cb66-224" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb66-225"><a href="#cb66-225" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>ope<span class="op">==</span><span class="dv">4</span><span class="op">){</span></span>
<span id="cb66-226"><a href="#cb66-226" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>x<span class="op">;</span></span>
<span id="cb66-227"><a href="#cb66-227" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>query_subtree<span class="op">(</span>x<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb66-228"><a href="#cb66-228" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb66-229"><a href="#cb66-229" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-230"><a href="#cb66-230" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb66-231"><a href="#cb66-231" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-232"><a href="#cb66-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-233"><a href="#cb66-233" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb66-234"><a href="#cb66-234" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb66-235"><a href="#cb66-235" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb66-236"><a href="#cb66-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-237"><a href="#cb66-237" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> T<span class="op">;</span></span>
<span id="cb66-238"><a href="#cb66-238" aria-hidden="true" tabindex="-1"></a>    T<span class="op">=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb66-239"><a href="#cb66-239" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>T<span class="op">--){</span></span>
<span id="cb66-240"><a href="#cb66-240" aria-hidden="true" tabindex="-1"></a>        solve<span class="op">();</span></span>
<span id="cb66-241"><a href="#cb66-241" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-242"><a href="#cb66-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-243"><a href="#cb66-243" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb66-244"><a href="#cb66-244" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="长链剖分">长链剖分</h2>
<h3 id="求k级祖先">求K级祖先</h3>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co">//长链剖分定义子树最深深度最深的节点为重子节点</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="co">//任意节点p的k级祖先q所在的链长度一定大于k</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="co">//任意节点p到根节点最多经过sqrt n级别的轻边</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p5903</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="co">//求任意节点的第k级祖先，预处理nlogn，查询常数</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define pb </span>push_back</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> LL <span class="op">=</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">500005</span><span class="op">;</span></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node<span class="op">{</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fa<span class="op">,</span> dep<span class="op">,</span> hson<span class="op">;</span><span class="co">//父节点、深度、重子节点</span></span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top<span class="op">;</span><span class="co">//链头，即所在的长链中深度最小的那个节点 </span></span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> len<span class="op">,</span>dfn<span class="op">,</span>mdfn<span class="op">;</span><span class="co">//部分链长，dfs序，子树最大dfs序</span></span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>node<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfnmap<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//dfs序对应节点</span></span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> edges<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs1<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> d<span class="op">=</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a>    node<span class="op">[</span>u<span class="op">].</span>len <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> node<span class="op">[</span>u<span class="op">].</span>dep <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> v<span class="op">:</span>edges<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb67-27"><a href="#cb67-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>node<span class="op">[</span>v<span class="op">].</span>dep<span class="op">){</span></span>
<span id="cb67-28"><a href="#cb67-28" aria-hidden="true" tabindex="-1"></a>            dfs1<span class="op">(</span>v<span class="op">,</span>d<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb67-29"><a href="#cb67-29" aria-hidden="true" tabindex="-1"></a>            node<span class="op">[</span>v<span class="op">].</span>fa <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb67-30"><a href="#cb67-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>node<span class="op">[</span>v<span class="op">].</span>len<span class="op">+</span><span class="dv">1</span><span class="op">&gt;</span>node<span class="op">[</span>u<span class="op">].</span>len<span class="op">)</span></span>
<span id="cb67-31"><a href="#cb67-31" aria-hidden="true" tabindex="-1"></a>                node<span class="op">[</span>u<span class="op">].</span>hson <span class="op">=</span> v<span class="op">,</span> node<span class="op">[</span>u<span class="op">].</span>len <span class="op">=</span> node<span class="op">[</span>v<span class="op">].</span>len<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb67-32"><a href="#cb67-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb67-33"><a href="#cb67-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb67-34"><a href="#cb67-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb67-35"><a href="#cb67-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-36"><a href="#cb67-36" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cnt <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb67-37"><a href="#cb67-37" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dfs2<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> tp<span class="op">){</span></span>
<span id="cb67-38"><a href="#cb67-38" aria-hidden="true" tabindex="-1"></a>    node<span class="op">[</span>u<span class="op">].</span>dfn <span class="op">=</span> <span class="op">++</span>cnt<span class="op">;</span></span>
<span id="cb67-39"><a href="#cb67-39" aria-hidden="true" tabindex="-1"></a>    node<span class="op">[</span>u<span class="op">].</span>top <span class="op">=</span> tp<span class="op">;</span></span>
<span id="cb67-40"><a href="#cb67-40" aria-hidden="true" tabindex="-1"></a>    dfnmap<span class="op">[</span>cnt<span class="op">]</span> <span class="op">=</span> u<span class="op">;</span></span>
<span id="cb67-41"><a href="#cb67-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>node<span class="op">[</span>u<span class="op">].</span>hson<span class="op">)</span> dfs2<span class="op">(</span>node<span class="op">[</span>u<span class="op">].</span>hson<span class="op">,</span> tp<span class="op">);</span></span>
<span id="cb67-42"><a href="#cb67-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> v<span class="op">:</span>edges<span class="op">[</span>u<span class="op">]){</span></span>
<span id="cb67-43"><a href="#cb67-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>node<span class="op">[</span>v<span class="op">].</span>top<span class="op">)</span> dfs2<span class="op">(</span>v<span class="op">,</span>v<span class="op">);</span></span>
<span id="cb67-44"><a href="#cb67-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb67-45"><a href="#cb67-45" aria-hidden="true" tabindex="-1"></a>    node<span class="op">[</span>u<span class="op">].</span>mdfn <span class="op">=</span> cnt<span class="op">;</span></span>
<span id="cb67-46"><a href="#cb67-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb67-47"><a href="#cb67-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-48"><a href="#cb67-48" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> cut<span class="op">(</span><span class="dt">int</span> r<span class="op">=</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb67-49"><a href="#cb67-49" aria-hidden="true" tabindex="-1"></a>    dfs1<span class="op">(</span>r<span class="op">);</span></span>
<span id="cb67-50"><a href="#cb67-50" aria-hidden="true" tabindex="-1"></a>    dfs2<span class="op">(</span>r<span class="op">,</span>r<span class="op">);</span></span>
<span id="cb67-51"><a href="#cb67-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb67-52"><a href="#cb67-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-53"><a href="#cb67-53" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> anc<span class="op">[</span>MAXN<span class="op">],</span> des<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb67-54"><a href="#cb67-54" aria-hidden="true" tabindex="-1"></a><span class="co">//分别存储（链头）节点p的1,2,...,node[p].len-1级祖先节点和子孙节点</span></span>
<span id="cb67-55"><a href="#cb67-55" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> LOGN <span class="op">=</span> <span class="dv">21</span><span class="op">;</span></span>
<span id="cb67-56"><a href="#cb67-56" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fa<span class="op">[</span>MAXN<span class="op">][</span>LOGN<span class="op">];</span></span>
<span id="cb67-57"><a href="#cb67-57" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> logn<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb67-58"><a href="#cb67-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-59"><a href="#cb67-59" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init<span class="op">(</span><span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb67-60"><a href="#cb67-60" aria-hidden="true" tabindex="-1"></a>    cut<span class="op">(</span>r<span class="op">);</span></span>
<span id="cb67-61"><a href="#cb67-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb67-62"><a href="#cb67-62" aria-hidden="true" tabindex="-1"></a>    logn<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb67-63"><a href="#cb67-63" aria-hidden="true" tabindex="-1"></a>    logn<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb67-64"><a href="#cb67-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">3</span><span class="op">;</span>i<span class="op">&lt;</span>MAXN<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb67-65"><a href="#cb67-65" aria-hidden="true" tabindex="-1"></a>        logn<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> logn<span class="op">[</span>i<span class="op">/</span><span class="dv">2</span><span class="op">]+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb67-66"><a href="#cb67-66" aria-hidden="true" tabindex="-1"></a>        <span class="co">//预先计算logn</span></span>
<span id="cb67-67"><a href="#cb67-67" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb67-68"><a href="#cb67-68" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb67-69"><a href="#cb67-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++)</span> fa<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> node<span class="op">[</span>i<span class="op">].</span>fa<span class="op">;</span></span>
<span id="cb67-70"><a href="#cb67-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;</span>LOGN<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb67-71"><a href="#cb67-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb67-72"><a href="#cb67-72" aria-hidden="true" tabindex="-1"></a>            fa<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> fa<span class="op">[</span>fa<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb67-73"><a href="#cb67-73" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb67-74"><a href="#cb67-74" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb67-75"><a href="#cb67-75" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb67-76"><a href="#cb67-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb67-77"><a href="#cb67-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>node<span class="op">[</span>i<span class="op">].</span>top<span class="op">==</span>i<span class="op">){</span></span>
<span id="cb67-78"><a href="#cb67-78" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">,</span>p<span class="op">=</span>i<span class="op">;</span>j<span class="op">&lt;</span>node<span class="op">[</span>i<span class="op">].</span>len<span class="op">;</span>j<span class="op">++,</span>p<span class="op">=</span>fa<span class="op">[</span>p<span class="op">][</span><span class="dv">0</span><span class="op">])</span></span>
<span id="cb67-79"><a href="#cb67-79" aria-hidden="true" tabindex="-1"></a>                anc<span class="op">[</span>i<span class="op">].</span>pb<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb67-80"><a href="#cb67-80" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span>j<span class="op">&lt;</span>node<span class="op">[</span>i<span class="op">].</span>len<span class="op">;</span>j<span class="op">++)</span></span>
<span id="cb67-81"><a href="#cb67-81" aria-hidden="true" tabindex="-1"></a>                des<span class="op">[</span>i<span class="op">].</span>pb<span class="op">(</span>dfnmap<span class="op">[</span>node<span class="op">[</span>i<span class="op">].</span>dfn<span class="op">+</span>j<span class="op">]);</span></span>
<span id="cb67-82"><a href="#cb67-82" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb67-83"><a href="#cb67-83" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb67-84"><a href="#cb67-84" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb67-85"><a href="#cb67-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-86"><a href="#cb67-86" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> query<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> k<span class="op">){</span></span>
<span id="cb67-87"><a href="#cb67-87" aria-hidden="true" tabindex="-1"></a>    <span class="co">//查询节点u的k级祖先</span></span>
<span id="cb67-88"><a href="#cb67-88" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>k<span class="op">==</span><span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> u<span class="op">;</span></span>
<span id="cb67-89"><a href="#cb67-89" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> logn<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb67-90"><a href="#cb67-90" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> v <span class="op">=</span> fa<span class="op">[</span>u<span class="op">][</span>i<span class="op">];</span></span>
<span id="cb67-91"><a href="#cb67-91" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tp <span class="op">=</span> node<span class="op">[</span>v<span class="op">].</span>top<span class="op">;</span></span>
<span id="cb67-92"><a href="#cb67-92" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d <span class="op">=</span> k <span class="op">-</span> <span class="op">(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>i<span class="op">)</span> <span class="op">+</span> node<span class="op">[</span>tp<span class="op">].</span>dep <span class="op">-</span> node<span class="op">[</span>v<span class="op">].</span>dep<span class="op">;</span></span>
<span id="cb67-93"><a href="#cb67-93" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>d<span class="op">&gt;</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb67-94"><a href="#cb67-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> anc<span class="op">[</span>tp<span class="op">][</span>d<span class="op">];</span></span>
<span id="cb67-95"><a href="#cb67-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb67-96"><a href="#cb67-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> des<span class="op">[</span>tp<span class="op">][-</span>d<span class="op">];</span></span>
<span id="cb67-97"><a href="#cb67-97" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="计算几何-todo">计算几何 TODO</h1>
<h2 id="基础板子">基础板子</h2>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co">/////////////////////////////////////////////////</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="co">//数据类型定义</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">double</span> db<span class="op">;</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">double</span> LD<span class="op">;</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point<span class="op">{</span>db x<span class="op">,</span>y<span class="op">;};</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> Point Vec<span class="op">;</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Line<span class="op">{</span>Point p<span class="op">;</span> Vec v<span class="op">;};</span><span class="co">//点向式直线，不保证方向向量为单位向量</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Seg<span class="op">{</span>Point a<span class="op">,</span>b<span class="op">;};</span><span class="co">//线段</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Circle<span class="op">{</span>Point o<span class="op">;</span>db r<span class="op">;};</span><span class="co">//圆心和半径</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a><span class="co">/////////////////////////////////////////////////</span></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a><span class="co">//常数定义</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>Point <span class="at">const</span> o<span class="op">{</span><span class="fl">0.0</span><span class="op">,</span><span class="fl">0.0</span><span class="op">};</span><span class="co">//原点</span></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>Line <span class="at">const</span> ox<span class="op">{</span>o<span class="op">,{</span><span class="fl">1.0</span><span class="op">,</span><span class="fl">0.0</span><span class="op">}},</span> oy<span class="op">{</span>o<span class="op">,{</span><span class="fl">0.0</span><span class="op">,</span><span class="fl">1.0</span><span class="op">}};</span><span class="co">//横轴纵轴</span></span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>db <span class="at">const</span> PI <span class="op">=</span> acos<span class="op">(-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>db <span class="at">const</span> EPS <span class="op">=</span> <span class="fl">1e-9</span><span class="op">;</span></span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a><span class="co">/////////////////////////////////////////////////</span></span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a><span class="co">//可调整精度的比较</span></span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> eq<span class="op">(</span>db a<span class="op">,</span> db b<span class="op">)</span>  <span class="op">{</span><span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">(</span>a <span class="op">-</span> b<span class="op">)&lt;</span> EPS<span class="op">;}</span><span class="co">//等于</span></span>
<span id="cb68-24"><a href="#cb68-24" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> ge<span class="op">(</span>db a<span class="op">,</span> db b<span class="op">)</span>  <span class="op">{</span><span class="cf">return</span> a <span class="op">-</span> b          <span class="op">&gt;</span> EPS<span class="op">;}</span><span class="co">//大于</span></span>
<span id="cb68-25"><a href="#cb68-25" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> le<span class="op">(</span>db a<span class="op">,</span> db b<span class="op">)</span>  <span class="op">{</span><span class="cf">return</span> a <span class="op">-</span> b          <span class="op">&lt;</span> <span class="op">-</span>EPS<span class="op">;}</span><span class="co">//小于</span></span>
<span id="cb68-26"><a href="#cb68-26" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> geq<span class="op">(</span>db a<span class="op">,</span> db b<span class="op">)</span> <span class="op">{</span><span class="cf">return</span> a <span class="op">-</span> b          <span class="op">&gt;</span> <span class="op">-</span>EPS<span class="op">;}</span><span class="co">//大于等于</span></span>
<span id="cb68-27"><a href="#cb68-27" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> leq<span class="op">(</span>db a<span class="op">,</span> db b<span class="op">)</span> <span class="op">{</span><span class="cf">return</span> a <span class="op">-</span> b          <span class="op">&lt;</span> EPS<span class="op">;}</span><span class="co">//小于等于</span></span>
<span id="cb68-28"><a href="#cb68-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-29"><a href="#cb68-29" aria-hidden="true" tabindex="-1"></a><span class="co">/////////////////////////////////////////////////</span></span>
<span id="cb68-30"><a href="#cb68-30" aria-hidden="true" tabindex="-1"></a><span class="co">//基础运算</span></span>
<span id="cb68-31"><a href="#cb68-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-32"><a href="#cb68-32" aria-hidden="true" tabindex="-1"></a>Vec r90a<span class="op">(</span>Vec v<span class="op">){</span><span class="cf">return</span> <span class="op">{-</span>v<span class="op">.</span>y<span class="op">,</span> v<span class="op">.</span>x<span class="op">};}</span><span class="co">//向量逆时针90度</span></span>
<span id="cb68-33"><a href="#cb68-33" aria-hidden="true" tabindex="-1"></a>Vec r90c<span class="op">(</span>Vec v<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>v<span class="op">.</span>y<span class="op">,</span> <span class="op">-</span>v<span class="op">.</span>x<span class="op">};}</span><span class="co">//向量顺时针90度</span></span>
<span id="cb68-34"><a href="#cb68-34" aria-hidden="true" tabindex="-1"></a>Vec <span class="kw">operator</span><span class="op">+(</span>Vec a<span class="op">,</span> Vec b<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>a<span class="op">.</span>x<span class="op">+</span>b<span class="op">.</span>x<span class="op">,</span> a<span class="op">.</span>y<span class="op">+</span>b<span class="op">.</span>y<span class="op">};}</span></span>
<span id="cb68-35"><a href="#cb68-35" aria-hidden="true" tabindex="-1"></a>Vec <span class="kw">operator</span><span class="op">-(</span>Vec a<span class="op">,</span> Vec b<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>a<span class="op">.</span>x<span class="op">-</span>b<span class="op">.</span>x<span class="op">,</span> a<span class="op">.</span>y<span class="op">-</span>b<span class="op">.</span>y<span class="op">};}</span></span>
<span id="cb68-36"><a href="#cb68-36" aria-hidden="true" tabindex="-1"></a>Vec <span class="kw">operator</span><span class="op">*(</span>db k<span class="op">,</span> Vec v<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>k<span class="op">*</span>v<span class="op">.</span>x<span class="op">,</span> k<span class="op">*</span>v<span class="op">.</span>y<span class="op">};}</span></span>
<span id="cb68-37"><a href="#cb68-37" aria-hidden="true" tabindex="-1"></a>Vec <span class="kw">operator</span><span class="op">*(</span>Vec v<span class="op">,</span> db k<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>v<span class="op">.</span>x<span class="op">*</span>k<span class="op">,</span> v<span class="op">.</span>y<span class="op">*</span>k<span class="op">};}</span></span>
<span id="cb68-38"><a href="#cb68-38" aria-hidden="true" tabindex="-1"></a>db <span class="kw">operator</span><span class="op">*(</span>Vec a<span class="op">,</span> Vec b<span class="op">){</span><span class="cf">return</span> a<span class="op">.</span>x<span class="op">*</span>b<span class="op">.</span>x<span class="op">+</span>a<span class="op">.</span>y<span class="op">*</span>b<span class="op">.</span>y<span class="op">;}</span></span>
<span id="cb68-39"><a href="#cb68-39" aria-hidden="true" tabindex="-1"></a>db <span class="kw">operator</span><span class="op">^(</span>Vec a<span class="op">,</span> Vec b<span class="op">){</span><span class="cf">return</span> a<span class="op">.</span>x<span class="op">*</span>b<span class="op">.</span>y<span class="op">-</span>a<span class="op">.</span>y<span class="op">*</span>b<span class="op">.</span>x<span class="op">;}</span><span class="co">//叉积</span></span>
<span id="cb68-40"><a href="#cb68-40" aria-hidden="true" tabindex="-1"></a>db len2<span class="op">(</span>Vec v<span class="op">){</span><span class="cf">return</span> v<span class="op">.</span>x<span class="op">*</span>v<span class="op">.</span>x<span class="op">+</span>v<span class="op">.</span>y<span class="op">*</span>v<span class="op">.</span>y<span class="op">;}</span><span class="co">//长度平方</span></span>
<span id="cb68-41"><a href="#cb68-41" aria-hidden="true" tabindex="-1"></a>db len<span class="op">(</span>Vec v<span class="op">){</span><span class="cf">return</span> <span class="bu">std::</span>sqrt<span class="op">(</span>len2<span class="op">(</span>v<span class="op">));}</span><span class="co">//向量长度</span></span>
<span id="cb68-42"><a href="#cb68-42" aria-hidden="true" tabindex="-1"></a>db slope<span class="op">(</span>Vec v<span class="op">){</span><span class="cf">return</span> v<span class="op">.</span>y<span class="op">/</span>v<span class="op">.</span>x<span class="op">;}</span><span class="co">//斜率，不存在时，用后面的paral_y函数，不要判断是否是无穷</span></span>
<span id="cb68-43"><a href="#cb68-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-44"><a href="#cb68-44" aria-hidden="true" tabindex="-1"></a><span class="co">/////////////////////////////////////////////////</span></span>
<span id="cb68-45"><a href="#cb68-45" aria-hidden="true" tabindex="-1"></a><span class="co">//向量操作</span></span>
<span id="cb68-46"><a href="#cb68-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-47"><a href="#cb68-47" aria-hidden="true" tabindex="-1"></a>db cos_v<span class="op">(</span>Vec a<span class="op">,</span> Vec b<span class="op">){</span><span class="cf">return</span> a<span class="op">*</span>b<span class="op">/</span>len<span class="op">(</span>a<span class="op">)/</span>len<span class="op">(</span>b<span class="op">);}</span><span class="co">//向量夹角余弦</span></span>
<span id="cb68-48"><a href="#cb68-48" aria-hidden="true" tabindex="-1"></a>Vec norm<span class="op">(</span>Vec v<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>v<span class="op">.</span>x<span class="op">/</span>len<span class="op">(</span>v<span class="op">),</span> v<span class="op">.</span>y<span class="op">/</span>len<span class="op">(</span>v<span class="op">)};}</span><span class="co">//求其单位向量</span></span>
<span id="cb68-49"><a href="#cb68-49" aria-hidden="true" tabindex="-1"></a>Vec pnorm<span class="op">(</span>Vec v<span class="op">){</span><span class="cf">return</span> <span class="op">(</span>v<span class="op">.</span>x<span class="op">&lt;</span><span class="dv">0</span><span class="op">?-</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">)/</span>len<span class="op">(</span>v<span class="op">)*</span>v<span class="op">;}</span><span class="co">//与原向量平行且横坐标大于零的单位向量</span></span>
<span id="cb68-50"><a href="#cb68-50" aria-hidden="true" tabindex="-1"></a>Vec dvec<span class="op">(</span>Seg l<span class="op">){</span><span class="cf">return</span> l<span class="op">.</span>b<span class="op">-</span>l<span class="op">.</span>a<span class="op">;}</span><span class="co">//线段转化为向量（没有归一化）</span></span>
<span id="cb68-51"><a href="#cb68-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-52"><a href="#cb68-52" aria-hidden="true" tabindex="-1"></a><span class="co">/////////////////////////////////////////////////</span></span>
<span id="cb68-53"><a href="#cb68-53" aria-hidden="true" tabindex="-1"></a><span class="co">//直线操作</span></span>
<span id="cb68-54"><a href="#cb68-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-55"><a href="#cb68-55" aria-hidden="true" tabindex="-1"></a>Line line<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>a<span class="op">,</span>b<span class="op">-</span>a<span class="op">};}</span><span class="co">//两点式直线</span></span>
<span id="cb68-56"><a href="#cb68-56" aria-hidden="true" tabindex="-1"></a>Line line<span class="op">(</span>db k<span class="op">,</span> db b<span class="op">){</span><span class="cf">return</span> <span class="op">{{</span><span class="dv">0</span><span class="op">,</span>b<span class="op">},{</span><span class="dv">1</span><span class="op">,</span>k<span class="op">}};}</span><span class="co">//斜截式直线y=kx+b</span></span>
<span id="cb68-57"><a href="#cb68-57" aria-hidden="true" tabindex="-1"></a>Line line<span class="op">(</span>Point p<span class="op">,</span> db k<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>p<span class="op">,{</span><span class="dv">1</span><span class="op">,</span>k<span class="op">}};}</span><span class="co">//点斜式直线</span></span>
<span id="cb68-58"><a href="#cb68-58" aria-hidden="true" tabindex="-1"></a>Line line<span class="op">(</span>Seg l<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>l<span class="op">.</span>a<span class="op">,</span> l<span class="op">.</span>b<span class="op">-</span>l<span class="op">.</span>a<span class="op">};}</span><span class="co">//线段所在直线</span></span>
<span id="cb68-59"><a href="#cb68-59" aria-hidden="true" tabindex="-1"></a>db at_x<span class="op">(</span>Line l<span class="op">,</span> db x<span class="op">){</span><span class="cf">return</span> l<span class="op">.</span>p<span class="op">.</span>y<span class="op">+(</span>x<span class="op">-</span>l<span class="op">.</span>p<span class="op">.</span>x<span class="op">)*</span>l<span class="op">.</span>v<span class="op">.</span>y<span class="op">/</span>l<span class="op">.</span>v<span class="op">.</span>x<span class="op">;}</span><span class="co">//给定直线上的横坐标求纵坐标，要确保直线不与y轴平行</span></span>
<span id="cb68-60"><a href="#cb68-60" aria-hidden="true" tabindex="-1"></a>db at_y<span class="op">(</span>Line l<span class="op">,</span> db y<span class="op">){</span><span class="cf">return</span> l<span class="op">.</span>p<span class="op">.</span>x<span class="op">+(</span>y<span class="op">+</span>l<span class="op">.</span>p<span class="op">.</span>y<span class="op">)*</span>l<span class="op">.</span>v<span class="op">.</span>x<span class="op">/</span>l<span class="op">.</span>v<span class="op">.</span>y<span class="op">;}</span><span class="co">//与上相反</span></span>
<span id="cb68-61"><a href="#cb68-61" aria-hidden="true" tabindex="-1"></a>Point pedal<span class="op">(</span>Point p<span class="op">,</span> Line l<span class="op">){</span><span class="cf">return</span> l<span class="op">.</span>p<span class="op">-(</span>l<span class="op">.</span>p<span class="op">-</span>p<span class="op">)*</span>l<span class="op">.</span>v<span class="op">/(</span>l<span class="op">.</span>v<span class="op">*</span>l<span class="op">.</span>v<span class="op">)*</span>l<span class="op">.</span>v<span class="op">;}</span><span class="co">//求点到直线的垂足</span></span>
<span id="cb68-62"><a href="#cb68-62" aria-hidden="true" tabindex="-1"></a>Line perp<span class="op">(</span>Line l<span class="op">,</span> Point p<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>p<span class="op">,</span>r90c<span class="op">(</span>l<span class="op">.</span>v<span class="op">)};}</span><span class="co">//过某点作直线的垂线</span></span>
<span id="cb68-63"><a href="#cb68-63" aria-hidden="true" tabindex="-1"></a>Line bisec<span class="op">(</span>Point p<span class="op">,</span> Vec a<span class="op">,</span> Vec b<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>p<span class="op">,</span>norm<span class="op">(</span>a<span class="op">)+</span>norm<span class="op">(</span>b<span class="op">)};}</span><span class="co">//角平分线</span></span>
<span id="cb68-64"><a href="#cb68-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-65"><a href="#cb68-65" aria-hidden="true" tabindex="-1"></a><span class="co">/////////////////////////////////////////////////</span></span>
<span id="cb68-66"><a href="#cb68-66" aria-hidden="true" tabindex="-1"></a><span class="co">//线段操作</span></span>
<span id="cb68-67"><a href="#cb68-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-68"><a href="#cb68-68" aria-hidden="true" tabindex="-1"></a>Point midp<span class="op">(</span>Seg l<span class="op">){</span><span class="cf">return</span> <span class="op">{(</span>l<span class="op">.</span>a<span class="op">.</span>x<span class="op">+</span>l<span class="op">.</span>b<span class="op">.</span>x<span class="op">)/</span><span class="fl">2.0</span><span class="op">,(</span>l<span class="op">.</span>a<span class="op">.</span>y<span class="op">+</span>l<span class="op">.</span>b<span class="op">.</span>y<span class="op">)/</span><span class="fl">2.0</span><span class="op">};}</span><span class="co">//线段中点</span></span>
<span id="cb68-69"><a href="#cb68-69" aria-hidden="true" tabindex="-1"></a>Line perp<span class="op">(</span>Seg l<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>midp<span class="op">(</span>l<span class="op">),</span> r90c<span class="op">(</span>l<span class="op">.</span>b<span class="op">-</span>l<span class="op">.</span>a<span class="op">)};}</span><span class="co">//线段中垂线</span></span>
<span id="cb68-70"><a href="#cb68-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-71"><a href="#cb68-71" aria-hidden="true" tabindex="-1"></a><span class="co">/////////////////////////////////////////////////</span></span>
<span id="cb68-72"><a href="#cb68-72" aria-hidden="true" tabindex="-1"></a><span class="co">//几何关系</span></span>
<span id="cb68-73"><a href="#cb68-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-74"><a href="#cb68-74" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> verti<span class="op">(</span>Vec a<span class="op">,</span> Vec b<span class="op">){</span><span class="cf">return</span> eq<span class="op">(</span>a<span class="op">*</span>b<span class="op">,</span><span class="fl">0.0</span><span class="op">);}</span><span class="co">//向量是否垂直</span></span>
<span id="cb68-75"><a href="#cb68-75" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> paral<span class="op">(</span>Vec a<span class="op">,</span> Vec b<span class="op">){</span><span class="cf">return</span> eq<span class="op">(</span>a<span class="op">^</span>b<span class="op">,</span><span class="fl">0.0</span><span class="op">);}</span><span class="co">//向量是否平行</span></span>
<span id="cb68-76"><a href="#cb68-76" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> paral_x<span class="op">(</span>Vec v<span class="op">){</span><span class="cf">return</span> eq<span class="op">(</span>v<span class="op">.</span>y<span class="op">,</span><span class="fl">0.0</span><span class="op">);}</span><span class="co">//是否平行x轴</span></span>
<span id="cb68-77"><a href="#cb68-77" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> paral_y<span class="op">(</span>Vec v<span class="op">){</span><span class="cf">return</span> eq<span class="op">(</span>v<span class="op">.</span>x<span class="op">,</span><span class="fl">0.0</span><span class="op">);}</span><span class="co">//是否平行y轴</span></span>
<span id="cb68-78"><a href="#cb68-78" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> on<span class="op">(</span>Point p<span class="op">,</span> Line l<span class="op">){</span><span class="cf">return</span> eq<span class="op">((</span>p<span class="op">.</span>x<span class="op">-</span>l<span class="op">.</span>p<span class="op">.</span>x<span class="op">)*</span>l<span class="op">.</span>v<span class="op">.</span>y<span class="op">,</span> <span class="op">(</span>p<span class="op">.</span>y<span class="op">-</span>l<span class="op">.</span>p<span class="op">.</span>y<span class="op">)*</span>l<span class="op">.</span>v<span class="op">.</span>x<span class="op">);}</span><span class="co">//点是否在直线上</span></span>
<span id="cb68-79"><a href="#cb68-79" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> on<span class="op">(</span>Point p<span class="op">,</span> Seg l<span class="op">){</span><span class="cf">return</span> eq<span class="op">(</span>len<span class="op">(</span>p<span class="op">-</span>l<span class="op">.</span>a<span class="op">)+</span>len<span class="op">(</span>p<span class="op">-</span>l<span class="op">.</span>b<span class="op">),</span>len<span class="op">(</span>l<span class="op">.</span>a<span class="op">-</span>l<span class="op">.</span>b<span class="op">));}</span><span class="co">//点是否在线段上</span></span>
<span id="cb68-80"><a href="#cb68-80" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Point a<span class="op">,</span> Point b<span class="op">){</span><span class="cf">return</span> eq<span class="op">(</span>a<span class="op">.</span>x<span class="op">,</span>b<span class="op">.</span>x<span class="op">)&amp;&amp;</span>eq<span class="op">(</span>a<span class="op">.</span>y<span class="op">,</span>b<span class="op">.</span>y<span class="op">);}</span><span class="co">//点重合</span></span>
<span id="cb68-81"><a href="#cb68-81" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Line a<span class="op">,</span> Line b<span class="op">){</span><span class="cf">return</span> on<span class="op">(</span>a<span class="op">.</span>p<span class="op">,</span>b<span class="op">)&amp;&amp;</span>on<span class="op">(</span>a<span class="op">.</span>p<span class="op">+</span>a<span class="op">.</span>v<span class="op">,</span>b<span class="op">);}</span><span class="co">//直线重合</span></span>
<span id="cb68-82"><a href="#cb68-82" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Seg a<span class="op">,</span> Seg b<span class="op">){</span><span class="cf">return</span> <span class="op">((</span>a<span class="op">.</span>a<span class="op">==</span>b<span class="op">.</span>a<span class="op">&amp;&amp;</span>a<span class="op">.</span>b<span class="op">==</span>b<span class="op">.</span>b<span class="op">)||(</span>a<span class="op">.</span>a<span class="op">==</span>b<span class="op">.</span>b<span class="op">&amp;&amp;</span>a<span class="op">.</span>b<span class="op">==</span>b<span class="op">.</span>a<span class="op">));}</span><span class="co">//线段（完全）重合</span></span>
<span id="cb68-83"><a href="#cb68-83" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span>Point a<span class="op">,</span> Point b<span class="op">){</span><span class="cf">return</span> le<span class="op">(</span>a<span class="op">.</span>x<span class="op">,</span>b<span class="op">.</span>x<span class="op">)||(</span>eq<span class="op">(</span>a<span class="op">.</span>x<span class="op">,</span>b<span class="op">.</span>x<span class="op">)&amp;&amp;</span>le<span class="op">(</span>a<span class="op">.</span>y<span class="op">,</span>b<span class="op">.</span>y<span class="op">));}</span><span class="co">//横坐标第一关键字，纵坐标第二关键字</span></span>
<span id="cb68-84"><a href="#cb68-84" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> tangency<span class="op">(</span>Line l<span class="op">,</span> Circle c<span class="op">){</span><span class="cf">return</span> eq<span class="op">(</span><span class="bu">std::</span>abs<span class="op">((</span>c<span class="op">.</span>o<span class="op">^</span>l<span class="op">.</span>v<span class="op">)-(</span>l<span class="op">.</span>p<span class="op">^</span>l<span class="op">.</span>v<span class="op">)),</span>c<span class="op">.</span>r<span class="op">*</span>len<span class="op">(</span>l<span class="op">.</span>v<span class="op">));}</span><span class="co">//直线和圆是否相切</span></span>
<span id="cb68-85"><a href="#cb68-85" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> tangency<span class="op">(</span>Circle c1<span class="op">,</span> Circle c2<span class="op">){</span><span class="cf">return</span> eq<span class="op">(</span>len<span class="op">(</span>c1<span class="op">.</span>o<span class="op">-</span>c2<span class="op">.</span>o<span class="op">),</span>c1<span class="op">.</span>r<span class="op">+</span>c2<span class="op">.</span>r<span class="op">);}</span><span class="co">//两个圆是否相切</span></span>
<span id="cb68-86"><a href="#cb68-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-87"><a href="#cb68-87" aria-hidden="true" tabindex="-1"></a><span class="co">/////////////////////////////////////////////////</span></span>
<span id="cb68-88"><a href="#cb68-88" aria-hidden="true" tabindex="-1"></a><span class="co">//距离</span></span>
<span id="cb68-89"><a href="#cb68-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-90"><a href="#cb68-90" aria-hidden="true" tabindex="-1"></a>db dis<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">){</span><span class="cf">return</span> len<span class="op">(</span>a<span class="op">-</span>b<span class="op">);}</span><span class="co">//两点距离</span></span>
<span id="cb68-91"><a href="#cb68-91" aria-hidden="true" tabindex="-1"></a>db dis<span class="op">(</span>Point p<span class="op">,</span> Line l<span class="op">){</span><span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">((</span>p<span class="op">^</span>l<span class="op">.</span>v<span class="op">)-(</span>l<span class="op">.</span>p<span class="op">^</span>l<span class="op">.</span>v<span class="op">))/</span>len<span class="op">(</span>l<span class="op">.</span>v<span class="op">);}</span><span class="co">//点到直线的距离</span></span>
<span id="cb68-92"><a href="#cb68-92" aria-hidden="true" tabindex="-1"></a>db dis<span class="op">(</span>Line a<span class="op">,</span> Line b<span class="op">){</span><span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">((</span>a<span class="op">.</span>p<span class="op">^</span>pnorm<span class="op">(</span>a<span class="op">.</span>v<span class="op">))-(</span>b<span class="op">.</span>p<span class="op">^</span>pnorm<span class="op">(</span>b<span class="op">.</span>v<span class="op">)));}</span><span class="co">//两直线距离，需要确保平行</span></span>
<span id="cb68-93"><a href="#cb68-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-94"><a href="#cb68-94" aria-hidden="true" tabindex="-1"></a><span class="co">/////////////////////////////////////////////////</span></span>
<span id="cb68-95"><a href="#cb68-95" aria-hidden="true" tabindex="-1"></a><span class="co">//平移</span></span>
<span id="cb68-96"><a href="#cb68-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-97"><a href="#cb68-97" aria-hidden="true" tabindex="-1"></a>Line <span class="kw">operator</span><span class="op">+(</span>Line l<span class="op">,</span> Vec v<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>l<span class="op">.</span>p<span class="op">+</span>v<span class="op">,</span> l<span class="op">.</span>v<span class="op">};}</span><span class="co">//直线平移</span></span>
<span id="cb68-98"><a href="#cb68-98" aria-hidden="true" tabindex="-1"></a>Seg <span class="kw">operator</span><span class="op">+(</span>Seg l<span class="op">,</span> Vec v<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>l<span class="op">.</span>a<span class="op">+</span>v<span class="op">,</span>l<span class="op">.</span>b<span class="op">+</span>v<span class="op">};}</span><span class="co">//线段平移</span></span>
<span id="cb68-99"><a href="#cb68-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-100"><a href="#cb68-100" aria-hidden="true" tabindex="-1"></a><span class="co">/////////////////////////////////////////////////</span></span>
<span id="cb68-101"><a href="#cb68-101" aria-hidden="true" tabindex="-1"></a><span class="co">//旋转</span></span>
<span id="cb68-102"><a href="#cb68-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-103"><a href="#cb68-103" aria-hidden="true" tabindex="-1"></a>Point rotate<span class="op">(</span>Point p<span class="op">,</span> db rad<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>cos<span class="op">(</span>rad<span class="op">)*</span>p<span class="op">.</span>x<span class="op">-</span>sin<span class="op">(</span>rad<span class="op">)*</span>p<span class="op">.</span>y<span class="op">,</span>sin<span class="op">(</span>rad<span class="op">)*</span>p<span class="op">.</span>x<span class="op">+</span>cos<span class="op">(</span>rad<span class="op">)*</span>p<span class="op">.</span>y<span class="op">};}</span><span class="co">//绕原点旋转rad弧度</span></span>
<span id="cb68-104"><a href="#cb68-104" aria-hidden="true" tabindex="-1"></a>Point rotate<span class="op">(</span>Point p<span class="op">,</span> db rad<span class="op">,</span> Point c<span class="op">){</span><span class="cf">return</span> c<span class="op">+</span>rotate<span class="op">(</span>p<span class="op">-</span>c<span class="op">,</span>rad<span class="op">);}</span><span class="co">//绕c旋转rad弧度</span></span>
<span id="cb68-105"><a href="#cb68-105" aria-hidden="true" tabindex="-1"></a>Line rotate<span class="op">(</span>Line l<span class="op">,</span> db rad<span class="op">,</span> Point c<span class="op">=</span>o<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>rotate<span class="op">(</span>l<span class="op">.</span>p<span class="op">,</span>rad<span class="op">,</span>c<span class="op">),</span>rotate<span class="op">(</span>l<span class="op">.</span>v<span class="op">,</span>rad<span class="op">)};}</span><span class="co">//直线绕c点旋转rad弧度</span></span>
<span id="cb68-106"><a href="#cb68-106" aria-hidden="true" tabindex="-1"></a>Seg rotate<span class="op">(</span>Seg l<span class="op">,</span> db rad<span class="op">,</span> Point c<span class="op">=</span>o<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>rotate<span class="op">(</span>l<span class="op">.</span>a<span class="op">,</span>rad<span class="op">,</span>c<span class="op">),</span> rotate<span class="op">(</span>l<span class="op">.</span>b<span class="op">,</span>rad<span class="op">,</span>c<span class="op">)};};</span></span>
<span id="cb68-107"><a href="#cb68-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-108"><a href="#cb68-108" aria-hidden="true" tabindex="-1"></a><span class="co">/////////////////////////////////////////////////</span></span>
<span id="cb68-109"><a href="#cb68-109" aria-hidden="true" tabindex="-1"></a><span class="co">//对称</span></span>
<span id="cb68-110"><a href="#cb68-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-111"><a href="#cb68-111" aria-hidden="true" tabindex="-1"></a>Point reflect<span class="op">(</span>Point a<span class="op">,</span> Point p<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>p<span class="op">.</span>x<span class="op">*</span><span class="fl">2.0</span><span class="op">-</span>a<span class="op">.</span>x<span class="op">,</span> p<span class="op">.</span>y<span class="op">*</span><span class="fl">2.0</span><span class="op">-</span>a<span class="op">.</span>y<span class="op">};}</span><span class="co">//a关于p的对称点</span></span>
<span id="cb68-112"><a href="#cb68-112" aria-hidden="true" tabindex="-1"></a>Line reflect<span class="op">(</span>Line l<span class="op">,</span> Point p<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>reflect<span class="op">(</span>l<span class="op">.</span>p<span class="op">,</span>p<span class="op">),</span>l<span class="op">.</span>v<span class="op">};}</span><span class="co">//直线l关于p的对称直线</span></span>
<span id="cb68-113"><a href="#cb68-113" aria-hidden="true" tabindex="-1"></a>Seg reflect<span class="op">(</span>Seg l<span class="op">,</span> Point p<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>reflect<span class="op">(</span>l<span class="op">.</span>a<span class="op">,</span>p<span class="op">),</span>reflect<span class="op">(</span>l<span class="op">.</span>b<span class="op">,</span>p<span class="op">)};}</span><span class="co">//线段l关于p的对称线段</span></span>
<span id="cb68-114"><a href="#cb68-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-115"><a href="#cb68-115" aria-hidden="true" tabindex="-1"></a>Point reflect<span class="op">(</span>Point a<span class="op">,</span> Line ax<span class="op">){</span><span class="cf">return</span> reflect<span class="op">(</span>a<span class="op">,</span> pedal<span class="op">(</span>a<span class="op">,</span>ax<span class="op">));}</span><span class="co">//点a关于直线ax的对称点</span></span>
<span id="cb68-116"><a href="#cb68-116" aria-hidden="true" tabindex="-1"></a>Point reflect_v<span class="op">(</span>Vec v<span class="op">,</span> Line ax<span class="op">){</span><span class="cf">return</span> reflect<span class="op">(</span>v<span class="op">,</span>ax<span class="op">)-</span>reflect<span class="op">(</span>o<span class="op">,</span>ax<span class="op">);}</span><span class="co">//向量v关于直线ax的对称向量</span></span>
<span id="cb68-117"><a href="#cb68-117" aria-hidden="true" tabindex="-1"></a>Line reflect<span class="op">(</span>Line l<span class="op">,</span> Line ax<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>reflect<span class="op">(</span>l<span class="op">.</span>p<span class="op">,</span> ax<span class="op">),</span>reflect_v<span class="op">(</span>l<span class="op">.</span>v<span class="op">,</span> ax<span class="op">)};}</span><span class="co">//直线l关于直线ax的对称直线</span></span>
<span id="cb68-118"><a href="#cb68-118" aria-hidden="true" tabindex="-1"></a>Seg reflect<span class="op">(</span>Seg l<span class="op">,</span> Line ax<span class="op">){</span><span class="cf">return</span> <span class="op">{</span>reflect<span class="op">(</span>l<span class="op">.</span>a<span class="op">,</span> ax<span class="op">),</span> reflect<span class="op">(</span>l<span class="op">.</span>b<span class="op">,</span> ax<span class="op">)};}</span></span>
<span id="cb68-119"><a href="#cb68-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-120"><a href="#cb68-120" aria-hidden="true" tabindex="-1"></a><span class="co">/////////////////////////////////////////////////</span></span>
<span id="cb68-121"><a href="#cb68-121" aria-hidden="true" tabindex="-1"></a><span class="co">//交点</span></span>
<span id="cb68-122"><a href="#cb68-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-123"><a href="#cb68-123" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> inter<span class="op">(</span>Line a<span class="op">,</span> Line b<span class="op">){</span></span>
<span id="cb68-124"><a href="#cb68-124" aria-hidden="true" tabindex="-1"></a>    <span class="co">//两直线的交点，没有交点返回空vector，否则返回一个大小为1的vector</span></span>
<span id="cb68-125"><a href="#cb68-125" aria-hidden="true" tabindex="-1"></a>    db c <span class="op">=</span> a<span class="op">.</span>v<span class="op">^</span>b<span class="op">.</span>v<span class="op">;</span></span>
<span id="cb68-126"><a href="#cb68-126" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> ret<span class="op">;</span></span>
<span id="cb68-127"><a href="#cb68-127" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>eq<span class="op">(</span>c<span class="op">,</span><span class="fl">0.0</span><span class="op">))</span> <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb68-128"><a href="#cb68-128" aria-hidden="true" tabindex="-1"></a>    Vec v <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>c<span class="op">*</span>Vec<span class="op">{</span>a<span class="op">.</span>p<span class="op">^(</span>a<span class="op">.</span>p<span class="op">+</span>a<span class="op">.</span>v<span class="op">),</span> b<span class="op">.</span>p<span class="op">^(</span>b<span class="op">.</span>p<span class="op">+</span>b<span class="op">.</span>v<span class="op">)};</span></span>
<span id="cb68-129"><a href="#cb68-129" aria-hidden="true" tabindex="-1"></a>    ret<span class="op">.</span>push_back<span class="op">({</span>v<span class="op">*</span>Vec<span class="op">{-</span>b<span class="op">.</span>v<span class="op">.</span>x<span class="op">,</span> a<span class="op">.</span>v<span class="op">.</span>x<span class="op">},</span>v<span class="op">*</span>Vec<span class="op">{-</span>b<span class="op">.</span>v<span class="op">.</span>y<span class="op">,</span> a<span class="op">.</span>v<span class="op">.</span>y<span class="op">}});</span></span>
<span id="cb68-130"><a href="#cb68-130" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb68-131"><a href="#cb68-131" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb68-132"><a href="#cb68-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-133"><a href="#cb68-133" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> inter<span class="op">(</span>Line l<span class="op">,</span> Circle c<span class="op">){</span></span>
<span id="cb68-134"><a href="#cb68-134" aria-hidden="true" tabindex="-1"></a>    <span class="co">//直线与圆的交点</span></span>
<span id="cb68-135"><a href="#cb68-135" aria-hidden="true" tabindex="-1"></a>    Point p <span class="op">=</span> pedal<span class="op">(</span>c<span class="op">.</span>o<span class="op">,</span> l<span class="op">);</span></span>
<span id="cb68-136"><a href="#cb68-136" aria-hidden="true" tabindex="-1"></a>    db h <span class="op">=</span> len<span class="op">(</span>p<span class="op">-</span>c<span class="op">.</span>o<span class="op">);</span></span>
<span id="cb68-137"><a href="#cb68-137" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> ret<span class="op">;</span></span>
<span id="cb68-138"><a href="#cb68-138" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>ge<span class="op">(</span>h<span class="op">,</span>c<span class="op">.</span>r<span class="op">))</span> <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb68-139"><a href="#cb68-139" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>eq<span class="op">(</span>h<span class="op">,</span>c<span class="op">.</span>r<span class="op">))</span> <span class="op">{</span>ret<span class="op">.</span>push_back<span class="op">(</span>p<span class="op">);</span><span class="cf">return</span> ret<span class="op">;};</span></span>
<span id="cb68-140"><a href="#cb68-140" aria-hidden="true" tabindex="-1"></a>    db d <span class="op">=</span> <span class="bu">std::</span>sqrt<span class="op">(</span>c<span class="op">.</span>r<span class="op">*</span>c<span class="op">.</span>r <span class="op">-</span> h<span class="op">*</span>h<span class="op">);</span></span>
<span id="cb68-141"><a href="#cb68-141" aria-hidden="true" tabindex="-1"></a>    Vec v <span class="op">=</span> d<span class="op">/</span>len<span class="op">(</span>l<span class="op">.</span>v<span class="op">)*</span>l<span class="op">.</span>v<span class="op">;</span></span>
<span id="cb68-142"><a href="#cb68-142" aria-hidden="true" tabindex="-1"></a>    ret<span class="op">.</span>push_back<span class="op">(</span>p<span class="op">+</span>v<span class="op">);</span>ret<span class="op">.</span>push_back<span class="op">(</span>p<span class="op">+</span>v<span class="op">);</span></span>
<span id="cb68-143"><a href="#cb68-143" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb68-144"><a href="#cb68-144" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb68-145"><a href="#cb68-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-146"><a href="#cb68-146" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> inter<span class="op">(</span>Circle c1<span class="op">,</span> Circle c2<span class="op">){</span></span>
<span id="cb68-147"><a href="#cb68-147" aria-hidden="true" tabindex="-1"></a>    <span class="co">//两个圆的交点</span></span>
<span id="cb68-148"><a href="#cb68-148" aria-hidden="true" tabindex="-1"></a>    Vec v1 <span class="op">=</span> c2<span class="op">.</span>o <span class="op">-</span> c1<span class="op">.</span>o<span class="op">,</span> v2 <span class="op">=</span> r90c<span class="op">(</span>v1<span class="op">);</span></span>
<span id="cb68-149"><a href="#cb68-149" aria-hidden="true" tabindex="-1"></a>    db d <span class="op">=</span> len<span class="op">(</span>v1<span class="op">);</span></span>
<span id="cb68-150"><a href="#cb68-150" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> ret<span class="op">;</span></span>
<span id="cb68-151"><a href="#cb68-151" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>ge<span class="op">(</span>d<span class="op">,</span> c1<span class="op">.</span>r<span class="op">+</span>c2<span class="op">.</span>r<span class="op">)||</span>ge<span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>c1<span class="op">.</span>r<span class="op">-</span>c2<span class="op">.</span>r<span class="op">),</span>d<span class="op">))</span> <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb68-152"><a href="#cb68-152" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>eq<span class="op">(</span>d<span class="op">,</span> c1<span class="op">.</span>r<span class="op">+</span>c2<span class="op">.</span>r<span class="op">)||</span>eq<span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>c1<span class="op">.</span>r<span class="op">-</span>c2<span class="op">.</span>r<span class="op">),</span>d<span class="op">)){</span>ret<span class="op">.</span>push_back<span class="op">(</span>c1<span class="op">.</span>o<span class="op">+</span>c1<span class="op">.</span>r<span class="op">/</span>d<span class="op">*</span>v1<span class="op">);</span><span class="cf">return</span> ret<span class="op">;}</span></span>
<span id="cb68-153"><a href="#cb68-153" aria-hidden="true" tabindex="-1"></a>    db a <span class="op">=</span> <span class="op">((</span>c1<span class="op">.</span>r<span class="op">*</span>c1<span class="op">.</span>r<span class="op">-</span>c2<span class="op">.</span>r<span class="op">*</span>c2<span class="op">.</span>r<span class="op">)/</span>d<span class="op">+</span>d<span class="op">)/</span><span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb68-154"><a href="#cb68-154" aria-hidden="true" tabindex="-1"></a>    db h <span class="op">=</span> <span class="bu">std::</span>sqrt<span class="op">(</span>c1<span class="op">.</span>r<span class="op">*</span>c1<span class="op">.</span>r<span class="op">-</span>a<span class="op">*</span>a<span class="op">);</span></span>
<span id="cb68-155"><a href="#cb68-155" aria-hidden="true" tabindex="-1"></a>    Vec av <span class="op">=</span> a<span class="op">/</span>len<span class="op">(</span>v1<span class="op">)*</span>v1<span class="op">,</span> hv <span class="op">=</span> h<span class="op">/</span>len<span class="op">(</span>v2<span class="op">)*</span>v2<span class="op">;</span></span>
<span id="cb68-156"><a href="#cb68-156" aria-hidden="true" tabindex="-1"></a>    ret<span class="op">.</span>push_back<span class="op">(</span>c1<span class="op">.</span>o<span class="op">+</span>av<span class="op">+</span>hv<span class="op">);</span>ret<span class="op">.</span>push_back<span class="op">(</span>c1<span class="op">.</span>o<span class="op">+</span>av<span class="op">-</span>hv<span class="op">);</span></span>
<span id="cb68-157"><a href="#cb68-157" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb68-158"><a href="#cb68-158" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb68-159"><a href="#cb68-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-160"><a href="#cb68-160" aria-hidden="true" tabindex="-1"></a><span class="co">/////////////////////////////////////////////////</span></span>
<span id="cb68-161"><a href="#cb68-161" aria-hidden="true" tabindex="-1"></a><span class="co">//三角形四心</span></span>
<span id="cb68-162"><a href="#cb68-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-163"><a href="#cb68-163" aria-hidden="true" tabindex="-1"></a>Point barycenter<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">,</span> Point c<span class="op">){</span></span>
<span id="cb68-164"><a href="#cb68-164" aria-hidden="true" tabindex="-1"></a>    <span class="co">//重心</span></span>
<span id="cb68-165"><a href="#cb68-165" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{(</span>a<span class="op">.</span>x<span class="op">+</span>b<span class="op">.</span>x<span class="op">+</span>c<span class="op">.</span>x<span class="op">)/</span><span class="fl">3.0</span><span class="op">,</span> <span class="op">(</span>a<span class="op">.</span>y<span class="op">+</span>b<span class="op">.</span>y<span class="op">+</span>c<span class="op">.</span>y<span class="op">)/</span><span class="fl">3.0</span><span class="op">};</span></span>
<span id="cb68-166"><a href="#cb68-166" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb68-167"><a href="#cb68-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-168"><a href="#cb68-168" aria-hidden="true" tabindex="-1"></a>Point circumcenter<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">,</span> Point c<span class="op">){</span></span>
<span id="cb68-169"><a href="#cb68-169" aria-hidden="true" tabindex="-1"></a>    <span class="co">//外心</span></span>
<span id="cb68-170"><a href="#cb68-170" aria-hidden="true" tabindex="-1"></a>    db a2 <span class="op">=</span> a<span class="op">*</span>a<span class="op">,</span> b2 <span class="op">=</span> b<span class="op">*</span>b<span class="op">,</span> c2 <span class="op">=</span> c<span class="op">*</span>c<span class="op">;</span></span>
<span id="cb68-171"><a href="#cb68-171" aria-hidden="true" tabindex="-1"></a>    db d <span class="op">=</span> <span class="fl">2.0</span><span class="op">*(</span>a<span class="op">.</span>x<span class="op">*(</span>b<span class="op">.</span>y<span class="op">-</span>c<span class="op">.</span>y<span class="op">))+</span>b<span class="op">.</span>x<span class="op">*(</span>c<span class="op">.</span>y<span class="op">-</span>a<span class="op">.</span>y<span class="op">)+</span>c<span class="op">.</span>x<span class="op">*(</span>a<span class="op">.</span>y<span class="op">-</span>b<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb68-172"><a href="#cb68-172" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">/</span>d <span class="op">*</span> r90c<span class="op">(</span>a2<span class="op">*(</span>b<span class="op">-</span>c<span class="op">)+</span>b2<span class="op">*(</span>c<span class="op">-</span>a<span class="op">)+</span>c2<span class="op">*(</span>a<span class="op">-</span>b<span class="op">));</span></span>
<span id="cb68-173"><a href="#cb68-173" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb68-174"><a href="#cb68-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-175"><a href="#cb68-175" aria-hidden="true" tabindex="-1"></a>Point incenter<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">,</span> Point c<span class="op">){</span></span>
<span id="cb68-176"><a href="#cb68-176" aria-hidden="true" tabindex="-1"></a>    <span class="co">//内心</span></span>
<span id="cb68-177"><a href="#cb68-177" aria-hidden="true" tabindex="-1"></a>    db a1 <span class="op">=</span> len<span class="op">(</span>b<span class="op">-</span>c<span class="op">),</span> b1 <span class="op">=</span> len<span class="op">(</span>a<span class="op">-</span>c<span class="op">),</span> c1 <span class="op">=</span> len<span class="op">(</span>a<span class="op">-</span>b<span class="op">);</span></span>
<span id="cb68-178"><a href="#cb68-178" aria-hidden="true" tabindex="-1"></a>    db d <span class="op">=</span> a1<span class="op">+</span>b1<span class="op">+</span>c1<span class="op">;</span></span>
<span id="cb68-179"><a href="#cb68-179" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">/</span>d <span class="op">*</span> <span class="op">(</span>a1<span class="op">*</span>a<span class="op">+</span>b1<span class="op">*</span>b<span class="op">+</span>c1<span class="op">*</span>c<span class="op">);</span></span>
<span id="cb68-180"><a href="#cb68-180" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb68-181"><a href="#cb68-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-182"><a href="#cb68-182" aria-hidden="true" tabindex="-1"></a>Point orthocenter<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">,</span> Point c<span class="op">){</span></span>
<span id="cb68-183"><a href="#cb68-183" aria-hidden="true" tabindex="-1"></a>    <span class="co">//垂心</span></span>
<span id="cb68-184"><a href="#cb68-184" aria-hidden="true" tabindex="-1"></a>    db n <span class="op">=</span> b<span class="op">*(</span>a<span class="op">-</span>c<span class="op">),</span> m <span class="op">=</span> a<span class="op">*(</span>b<span class="op">-</span>c<span class="op">);</span></span>
<span id="cb68-185"><a href="#cb68-185" aria-hidden="true" tabindex="-1"></a>    db d <span class="op">=</span> <span class="op">(</span>b<span class="op">-</span>c<span class="op">)^(</span>a<span class="op">-</span>c<span class="op">);</span></span>
<span id="cb68-186"><a href="#cb68-186" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">/</span>d <span class="op">*</span> r90c<span class="op">(</span>n<span class="op">*(</span>c<span class="op">-</span>b<span class="op">)-</span>m<span class="op">*(</span>c<span class="op">-</span>a<span class="op">));</span></span>
<span id="cb68-187"><a href="#cb68-187" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="二维凸包">二维凸包</h2>
<h3 id="andrew扫描法">Andrew扫描法</h3>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 nlogn</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">50005</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point<span class="op">{</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>    Point<span class="op">()=</span><span class="cf">default</span><span class="op">;</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>    Point<span class="op">(</span><span class="dt">double</span> x<span class="op">,</span> <span class="dt">double</span> y<span class="op">):</span>x<span class="op">(</span>x<span class="op">),</span>y<span class="op">(</span>y<span class="op">){}</span></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>    Point <span class="kw">operator</span> <span class="op">+</span> <span class="op">(</span>Point p<span class="op">){</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Point<span class="op">(</span>x<span class="op">+</span>p<span class="op">.</span>x<span class="op">,</span> y<span class="op">+</span>p<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>    Point <span class="kw">operator</span> <span class="op">-</span> <span class="op">(</span>Point p<span class="op">){</span></span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Point<span class="op">(</span>x<span class="op">-</span>p<span class="op">.</span>x<span class="op">,</span> y<span class="op">-</span>p<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>    Point <span class="kw">operator</span> <span class="op">*</span> <span class="op">(</span><span class="dt">double</span> d<span class="op">){</span></span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Point<span class="op">(</span>x<span class="op">*</span>d<span class="op">,</span> y<span class="op">*</span>d<span class="op">);</span></span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-25"><a href="#cb69-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dot<span class="op">(</span>Point p<span class="op">){</span><span class="co">//点积</span></span>
<span id="cb69-26"><a href="#cb69-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x<span class="op">*</span>p<span class="op">.</span>x<span class="op">+</span>y<span class="op">*</span>p<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb69-27"><a href="#cb69-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-28"><a href="#cb69-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> det<span class="op">(</span>Point p<span class="op">){</span><span class="co">//叉积</span></span>
<span id="cb69-29"><a href="#cb69-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x<span class="op">*(</span>p<span class="op">.</span>y<span class="op">)-(</span>p<span class="op">.</span>x<span class="op">)*</span>y<span class="op">;</span></span>
<span id="cb69-30"><a href="#cb69-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-31"><a href="#cb69-31" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb69-32"><a href="#cb69-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-33"><a href="#cb69-33" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb69-34"><a href="#cb69-34" aria-hidden="true" tabindex="-1"></a>Point po<span class="op">[</span>MAXN<span class="op">*</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb69-35"><a href="#cb69-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-36"><a href="#cb69-36" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> cmp<span class="op">(</span>Point<span class="op">&amp;</span> a<span class="op">,</span> Point<span class="op">&amp;</span> b<span class="op">){</span></span>
<span id="cb69-37"><a href="#cb69-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>a<span class="op">.</span>x<span class="op">!=</span>b<span class="op">.</span>x<span class="op">)</span> <span class="cf">return</span> a<span class="op">.</span>x<span class="op">&lt;</span>b<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb69-38"><a href="#cb69-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a<span class="op">.</span>y<span class="op">&lt;</span>b<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb69-39"><a href="#cb69-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb69-40"><a href="#cb69-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-41"><a href="#cb69-41" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> convexHull<span class="op">(){</span></span>
<span id="cb69-42"><a href="#cb69-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">//返回凸包上的点</span></span>
<span id="cb69-43"><a href="#cb69-43" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb69-44"><a href="#cb69-44" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> qs<span class="op">;</span></span>
<span id="cb69-45"><a href="#cb69-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb69-46"><a href="#cb69-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>k<span class="op">&gt;</span><span class="dv">1</span><span class="op">&amp;&amp;(</span>qs<span class="op">[</span>k<span class="op">-</span><span class="dv">1</span><span class="op">]-</span>qs<span class="op">[</span>k<span class="op">-</span><span class="dv">2</span><span class="op">]).</span>det<span class="op">(</span>po<span class="op">[</span>i<span class="op">]-</span>qs<span class="op">[</span>k<span class="op">-</span><span class="dv">1</span><span class="op">])&lt;=</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb69-47"><a href="#cb69-47" aria-hidden="true" tabindex="-1"></a>            qs<span class="op">.</span>erase<span class="op">(</span>qs<span class="op">.</span>end<span class="op">()-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb69-48"><a href="#cb69-48" aria-hidden="true" tabindex="-1"></a>            k<span class="op">--;</span></span>
<span id="cb69-49"><a href="#cb69-49" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb69-50"><a href="#cb69-50" aria-hidden="true" tabindex="-1"></a>        qs<span class="op">.</span>push_back<span class="op">(</span>po<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb69-51"><a href="#cb69-51" aria-hidden="true" tabindex="-1"></a>        k<span class="op">++;</span></span>
<span id="cb69-52"><a href="#cb69-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-53"><a href="#cb69-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>n<span class="op">-</span><span class="dv">2</span><span class="op">,</span>t<span class="op">=</span>k<span class="op">;</span>i<span class="op">&gt;=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">--){</span></span>
<span id="cb69-54"><a href="#cb69-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>k<span class="op">&gt;</span>t<span class="op">&amp;&amp;(</span>qs<span class="op">[</span>k<span class="op">-</span><span class="dv">1</span><span class="op">]-</span>qs<span class="op">[</span>k<span class="op">-</span><span class="dv">2</span><span class="op">]).</span>det<span class="op">(</span>po<span class="op">[</span>i<span class="op">]-</span>qs<span class="op">[</span>k<span class="op">-</span><span class="dv">1</span><span class="op">])&lt;=</span><span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb69-55"><a href="#cb69-55" aria-hidden="true" tabindex="-1"></a>            qs<span class="op">.</span>erase<span class="op">(</span>qs<span class="op">.</span>end<span class="op">()-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb69-56"><a href="#cb69-56" aria-hidden="true" tabindex="-1"></a>            k<span class="op">--;</span></span>
<span id="cb69-57"><a href="#cb69-57" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb69-58"><a href="#cb69-58" aria-hidden="true" tabindex="-1"></a>        qs<span class="op">.</span>push_back<span class="op">(</span>po<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb69-59"><a href="#cb69-59" aria-hidden="true" tabindex="-1"></a>        k<span class="op">++;</span></span>
<span id="cb69-60"><a href="#cb69-60" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-61"><a href="#cb69-61" aria-hidden="true" tabindex="-1"></a>    qs<span class="op">.</span>erase<span class="op">(</span>qs<span class="op">.</span>end<span class="op">()-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb69-62"><a href="#cb69-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> qs<span class="op">;</span></span>
<span id="cb69-63"><a href="#cb69-63" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb69-64"><a href="#cb69-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-65"><a href="#cb69-65" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb69-66"><a href="#cb69-66" aria-hidden="true" tabindex="-1"></a>    cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb69-67"><a href="#cb69-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb69-68"><a href="#cb69-68" aria-hidden="true" tabindex="-1"></a>        cin<span class="op">&gt;&gt;</span>po<span class="op">[</span>i<span class="op">].</span>x<span class="op">&gt;&gt;</span>po<span class="op">[</span>i<span class="op">].</span>y<span class="op">;</span></span>
<span id="cb69-69"><a href="#cb69-69" aria-hidden="true" tabindex="-1"></a>        <span class="co">//输入点的横纵坐标</span></span>
<span id="cb69-70"><a href="#cb69-70" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-71"><a href="#cb69-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-72"><a href="#cb69-72" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>po<span class="op">,</span>po<span class="op">+</span>n<span class="op">,</span>cmp<span class="op">);</span></span>
<span id="cb69-73"><a href="#cb69-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-74"><a href="#cb69-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> p<span class="op">:</span>convexHull<span class="op">()){</span></span>
<span id="cb69-75"><a href="#cb69-75" aria-hidden="true" tabindex="-1"></a>        cout<span class="op">&lt;&lt;</span>p<span class="op">.</span>x<span class="op">&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">&lt;&lt;</span>p<span class="op">.</span>y<span class="op">&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb69-76"><a href="#cb69-76" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-77"><a href="#cb69-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-78"><a href="#cb69-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb69-79"><a href="#cb69-79" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="旋转卡壳求最远点对">旋转卡壳求最远点对</h2>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 nlogn，其中求凸包nlogn，旋转卡壳本身为n</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="co">//Luogu P1452</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="co">//旋转卡壳和凸包</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">50005</span></span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point<span class="op">{</span></span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>    Point<span class="op">()=</span><span class="cf">default</span><span class="op">;</span></span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>    Point<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">):</span>x<span class="op">(</span>x<span class="op">),</span>y<span class="op">(</span>y<span class="op">){}</span></span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>    Point <span class="kw">operator</span> <span class="op">-</span> <span class="op">(</span>Point p<span class="op">){</span></span>
<span id="cb70-18"><a href="#cb70-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Point<span class="op">(</span>x<span class="op">-</span>p<span class="op">.</span>x<span class="op">,</span> y<span class="op">-</span>p<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb70-19"><a href="#cb70-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-20"><a href="#cb70-20" aria-hidden="true" tabindex="-1"></a>    Point <span class="kw">operator</span> <span class="op">+</span> <span class="op">(</span>Point p<span class="op">){</span></span>
<span id="cb70-21"><a href="#cb70-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Point<span class="op">(</span>x<span class="op">+</span>p<span class="op">.</span>x<span class="op">,</span> y<span class="op">+</span>p<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb70-22"><a href="#cb70-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-23"><a href="#cb70-23" aria-hidden="true" tabindex="-1"></a>    Point <span class="kw">operator</span> <span class="op">*</span> <span class="op">(</span><span class="dt">int</span> d<span class="op">){</span></span>
<span id="cb70-24"><a href="#cb70-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Point<span class="op">(</span>x<span class="op">*</span>d<span class="op">,</span> y<span class="op">*</span>d<span class="op">);</span></span>
<span id="cb70-25"><a href="#cb70-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-26"><a href="#cb70-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dot<span class="op">(</span>Point p<span class="op">){</span></span>
<span id="cb70-27"><a href="#cb70-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x<span class="op">*</span>p<span class="op">.</span>x<span class="op">+</span>y<span class="op">*</span>p<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb70-28"><a href="#cb70-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-29"><a href="#cb70-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> det<span class="op">(</span>Point p<span class="op">){</span></span>
<span id="cb70-30"><a href="#cb70-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x<span class="op">*(</span>p<span class="op">.</span>y<span class="op">)-</span>y<span class="op">*(</span>p<span class="op">.</span>x<span class="op">);</span></span>
<span id="cb70-31"><a href="#cb70-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-32"><a href="#cb70-32" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb70-33"><a href="#cb70-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-34"><a href="#cb70-34" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> cmp<span class="op">(</span>Point<span class="op">&amp;</span> a<span class="op">,</span> Point<span class="op">&amp;</span> b<span class="op">){</span></span>
<span id="cb70-35"><a href="#cb70-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>a<span class="op">.</span>x<span class="op">!=</span>b<span class="op">.</span>x<span class="op">)</span> <span class="cf">return</span> a<span class="op">.</span>x<span class="op">&lt;</span>b<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb70-36"><a href="#cb70-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a<span class="op">.</span>y<span class="op">&lt;</span>b<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb70-37"><a href="#cb70-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb70-38"><a href="#cb70-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-39"><a href="#cb70-39" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb70-40"><a href="#cb70-40" aria-hidden="true" tabindex="-1"></a>Point po<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb70-41"><a href="#cb70-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-42"><a href="#cb70-42" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> convexHull<span class="op">(){</span></span>
<span id="cb70-43"><a href="#cb70-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">//返回凸包上的点</span></span>
<span id="cb70-44"><a href="#cb70-44" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> ans<span class="op">;</span></span>
<span id="cb70-45"><a href="#cb70-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb70-46"><a href="#cb70-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb70-47"><a href="#cb70-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>k<span class="op">&gt;</span><span class="dv">1</span><span class="op">&amp;&amp;(</span>ans<span class="op">[</span>k<span class="op">-</span><span class="dv">1</span><span class="op">]-</span>ans<span class="op">[</span>k<span class="op">-</span><span class="dv">2</span><span class="op">]).</span>det<span class="op">(</span>po<span class="op">[</span>i<span class="op">]-</span>ans<span class="op">[</span>k<span class="op">-</span><span class="dv">1</span><span class="op">])&lt;=</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb70-48"><a href="#cb70-48" aria-hidden="true" tabindex="-1"></a>            ans<span class="op">.</span>erase<span class="op">(</span>ans<span class="op">.</span>end<span class="op">()-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb70-49"><a href="#cb70-49" aria-hidden="true" tabindex="-1"></a>            k<span class="op">--;</span></span>
<span id="cb70-50"><a href="#cb70-50" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb70-51"><a href="#cb70-51" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">.</span>push_back<span class="op">(</span>po<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb70-52"><a href="#cb70-52" aria-hidden="true" tabindex="-1"></a>        k<span class="op">++;</span></span>
<span id="cb70-53"><a href="#cb70-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-54"><a href="#cb70-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>n<span class="op">-</span><span class="dv">2</span><span class="op">,</span>t<span class="op">=</span>k<span class="op">;</span>i<span class="op">&gt;=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">--){</span></span>
<span id="cb70-55"><a href="#cb70-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>k<span class="op">&gt;</span>t<span class="op">&amp;&amp;(</span>ans<span class="op">[</span>k<span class="op">-</span><span class="dv">1</span><span class="op">]-</span>ans<span class="op">[</span>k<span class="op">-</span><span class="dv">2</span><span class="op">]).</span>det<span class="op">(</span>po<span class="op">[</span>i<span class="op">]-</span>ans<span class="op">[</span>k<span class="op">-</span><span class="dv">1</span><span class="op">])&lt;=</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb70-56"><a href="#cb70-56" aria-hidden="true" tabindex="-1"></a>            ans<span class="op">.</span>erase<span class="op">(</span>ans<span class="op">.</span>end<span class="op">()-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb70-57"><a href="#cb70-57" aria-hidden="true" tabindex="-1"></a>            k<span class="op">--;</span></span>
<span id="cb70-58"><a href="#cb70-58" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb70-59"><a href="#cb70-59" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">.</span>push_back<span class="op">(</span>po<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb70-60"><a href="#cb70-60" aria-hidden="true" tabindex="-1"></a>        k<span class="op">++;</span></span>
<span id="cb70-61"><a href="#cb70-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-62"><a href="#cb70-62" aria-hidden="true" tabindex="-1"></a>    ans<span class="op">.</span>erase<span class="op">(</span>ans<span class="op">.</span>end<span class="op">()-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb70-63"><a href="#cb70-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb70-64"><a href="#cb70-64" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb70-65"><a href="#cb70-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-66"><a href="#cb70-66" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">long</span> <span class="dt">long</span> dist<span class="op">(</span>Point a<span class="op">,</span> Point b<span class="op">){</span><span class="co">//计算距离的平方</span></span>
<span id="cb70-67"><a href="#cb70-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>a<span class="op">-</span>b<span class="op">).</span>dot<span class="op">(</span>a<span class="op">-</span>b<span class="op">);</span></span>
<span id="cb70-68"><a href="#cb70-68" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb70-69"><a href="#cb70-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-70"><a href="#cb70-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-71"><a href="#cb70-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-72"><a href="#cb70-72" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> rc<span class="op">(</span>vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> ans<span class="op">){</span></span>
<span id="cb70-73"><a href="#cb70-73" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tn <span class="op">=</span> ans<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb70-74"><a href="#cb70-74" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cnt<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb70-75"><a href="#cb70-75" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>tn<span class="op">==</span><span class="dv">2</span><span class="op">){</span></span>
<span id="cb70-76"><a href="#cb70-76" aria-hidden="true" tabindex="-1"></a>        cout<span class="op">&lt;&lt;</span>dist<span class="op">(</span>ans<span class="op">[</span><span class="dv">0</span><span class="op">],</span>ans<span class="op">[</span><span class="dv">1</span><span class="op">])&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb70-77"><a href="#cb70-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb70-78"><a href="#cb70-78" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-79"><a href="#cb70-79" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">,</span>j<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb70-80"><a href="#cb70-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> k<span class="op">=</span><span class="dv">0</span><span class="op">;</span>k<span class="op">&lt;</span>tn<span class="op">;</span>k<span class="op">++){</span></span>
<span id="cb70-81"><a href="#cb70-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>cmp<span class="op">(</span>ans<span class="op">[</span>i<span class="op">],</span>ans<span class="op">[</span>k<span class="op">]))</span> i<span class="op">=</span>k<span class="op">;</span></span>
<span id="cb70-82"><a href="#cb70-82" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>cmp<span class="op">(</span>ans<span class="op">[</span>j<span class="op">],</span>ans<span class="op">[</span>k<span class="op">]))</span> j<span class="op">=</span>k<span class="op">;</span></span>
<span id="cb70-83"><a href="#cb70-83" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-84"><a href="#cb70-84" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> res <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb70-85"><a href="#cb70-85" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> si<span class="op">=</span>i<span class="op">,</span>sj<span class="op">=</span>j<span class="op">;</span></span>
<span id="cb70-86"><a href="#cb70-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>i<span class="op">!=</span>sj<span class="op">||</span>j<span class="op">!=</span>si<span class="op">){</span></span>
<span id="cb70-87"><a href="#cb70-87" aria-hidden="true" tabindex="-1"></a>        res <span class="op">=</span> max<span class="op">(</span>res<span class="op">,</span>dist<span class="op">(</span>ans<span class="op">[</span>i<span class="op">],</span>ans<span class="op">[</span>j<span class="op">]));</span></span>
<span id="cb70-88"><a href="#cb70-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">((</span>ans<span class="op">[(</span>i<span class="op">+</span><span class="dv">1</span><span class="op">)%</span>tn<span class="op">]-</span>ans<span class="op">[</span>i<span class="op">]).</span>det<span class="op">(</span>ans<span class="op">[(</span>j<span class="op">+</span><span class="dv">1</span><span class="op">)%</span>tn<span class="op">]-</span>ans<span class="op">[</span>j<span class="op">])&lt;</span><span class="dv">0</span><span class="op">){</span></span>
<span id="cb70-89"><a href="#cb70-89" aria-hidden="true" tabindex="-1"></a>            i <span class="op">=</span> <span class="op">(</span>i<span class="op">+</span><span class="dv">1</span><span class="op">)%</span>tn<span class="op">;</span></span>
<span id="cb70-90"><a href="#cb70-90" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span><span class="cf">else</span><span class="op">{</span></span>
<span id="cb70-91"><a href="#cb70-91" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> <span class="op">(</span>j<span class="op">+</span><span class="dv">1</span><span class="op">)%</span>tn<span class="op">;</span></span>
<span id="cb70-92"><a href="#cb70-92" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb70-93"><a href="#cb70-93" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb70-94"><a href="#cb70-94" aria-hidden="true" tabindex="-1"></a>        cnt<span class="op">++;</span></span>
<span id="cb70-95"><a href="#cb70-95" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-96"><a href="#cb70-96" aria-hidden="true" tabindex="-1"></a>    <span class="co">//返回凸包最远点对的距离的平方</span></span>
<span id="cb70-97"><a href="#cb70-97" aria-hidden="true" tabindex="-1"></a>    cout<span class="op">&lt;&lt;</span>res<span class="op">&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb70-98"><a href="#cb70-98" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb70-99"><a href="#cb70-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-100"><a href="#cb70-100" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb70-101"><a href="#cb70-101" aria-hidden="true" tabindex="-1"></a>    cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb70-102"><a href="#cb70-102" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>Point<span class="op">&gt;</span> qs<span class="op">;</span></span>
<span id="cb70-103"><a href="#cb70-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb70-104"><a href="#cb70-104" aria-hidden="true" tabindex="-1"></a>        cin<span class="op">&gt;&gt;</span>po<span class="op">[</span>i<span class="op">].</span>x<span class="op">&gt;&gt;</span>po<span class="op">[</span>i<span class="op">].</span>y<span class="op">;</span></span>
<span id="cb70-105"><a href="#cb70-105" aria-hidden="true" tabindex="-1"></a>        <span class="co">//按横纵坐标输入点对</span></span>
<span id="cb70-106"><a href="#cb70-106" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-107"><a href="#cb70-107" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>po<span class="op">,</span>po<span class="op">+</span>n<span class="op">,</span>cmp<span class="op">);</span></span>
<span id="cb70-108"><a href="#cb70-108" aria-hidden="true" tabindex="-1"></a>    qs <span class="op">=</span> convexHull<span class="op">();</span></span>
<span id="cb70-109"><a href="#cb70-109" aria-hidden="true" tabindex="-1"></a>    rc<span class="op">(</span>qs<span class="op">);</span></span>
<span id="cb70-110"><a href="#cb70-110" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb70-111"><a href="#cb70-111" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="平面最近点对">平面最近点对</h2>
<p>输入<span class="math inline">\(n\)</span>个点的平面坐标，使用分治法计算最近点对，复杂度<span class="math inline">\(O(nlogn)\)</span></p>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度nlogn</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="co">//Luogu P1257</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">200005</span><span class="op">;</span></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node<span class="op">{</span></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> id<span class="op">;</span></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="at">const</span> Node<span class="op">&amp;</span> a<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>x<span class="op">!=</span>a<span class="op">.</span>x<span class="op">)</span> <span class="cf">return</span> x<span class="op">&lt;</span>a<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb71-15"><a href="#cb71-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y<span class="op">&lt;</span>a<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb71-16"><a href="#cb71-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb71-17"><a href="#cb71-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>nodes<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb71-18"><a href="#cb71-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-19"><a href="#cb71-19" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> cmp<span class="op">(</span><span class="at">const</span> Node<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> Node<span class="op">&amp;</span> b<span class="op">){</span></span>
<span id="cb71-20"><a href="#cb71-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a<span class="op">.</span>y<span class="op">&lt;</span>b<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb71-21"><a href="#cb71-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb71-22"><a href="#cb71-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-23"><a href="#cb71-23" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> minDist<span class="op">;</span></span>
<span id="cb71-24"><a href="#cb71-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ansA<span class="op">,</span> ansB<span class="op">;</span></span>
<span id="cb71-25"><a href="#cb71-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-26"><a href="#cb71-26" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">void</span> updAns<span class="op">(</span><span class="at">const</span> Node<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> Node<span class="op">&amp;</span> b<span class="op">){</span></span>
<span id="cb71-27"><a href="#cb71-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> dist <span class="op">=</span> sqrt<span class="op">((</span>a<span class="op">.</span>x<span class="op">-</span>b<span class="op">.</span>x<span class="op">)*(</span>a<span class="op">.</span>x<span class="op">-</span>b<span class="op">.</span>x<span class="op">)+(</span>a<span class="op">.</span>y<span class="op">-</span>b<span class="op">.</span>y<span class="op">)*(</span>a<span class="op">.</span>y<span class="op">-</span>b<span class="op">.</span>y<span class="op">)+</span><span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb71-28"><a href="#cb71-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>dist<span class="op">&lt;</span>minDist<span class="op">){</span></span>
<span id="cb71-29"><a href="#cb71-29" aria-hidden="true" tabindex="-1"></a>        minDist <span class="op">=</span> dist<span class="op">;</span></span>
<span id="cb71-30"><a href="#cb71-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">//如果要记录节点</span></span>
<span id="cb71-31"><a href="#cb71-31" aria-hidden="true" tabindex="-1"></a>        ansA <span class="op">=</span> a<span class="op">.</span>id<span class="op">;</span></span>
<span id="cb71-32"><a href="#cb71-32" aria-hidden="true" tabindex="-1"></a>        ansB <span class="op">=</span> b<span class="op">.</span>id<span class="op">;</span></span>
<span id="cb71-33"><a href="#cb71-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb71-34"><a href="#cb71-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb71-35"><a href="#cb71-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-36"><a href="#cb71-36" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> calcMin<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">){</span></span>
<span id="cb71-37"><a href="#cb71-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>r<span class="op">-</span>l<span class="op">&lt;=</span><span class="dv">3</span><span class="op">){</span></span>
<span id="cb71-38"><a href="#cb71-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>l<span class="op">;</span>i<span class="op">&lt;=</span>r<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb71-39"><a href="#cb71-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span>i<span class="op">+</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>r<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb71-40"><a href="#cb71-40" aria-hidden="true" tabindex="-1"></a>                updAns<span class="op">(</span>nodes<span class="op">[</span>i<span class="op">],</span>nodes<span class="op">[</span>j<span class="op">]);</span></span>
<span id="cb71-41"><a href="#cb71-41" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb71-42"><a href="#cb71-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb71-43"><a href="#cb71-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>sort<span class="op">(</span>nodes<span class="op">+</span>l<span class="op">,</span> nodes<span class="op">+</span>r<span class="op">+</span><span class="dv">1</span><span class="op">,</span> cmp<span class="op">);</span></span>
<span id="cb71-44"><a href="#cb71-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb71-45"><a href="#cb71-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb71-46"><a href="#cb71-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-47"><a href="#cb71-47" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> <span class="op">(</span>l<span class="op">+</span>r<span class="op">)&gt;&gt;</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb71-48"><a href="#cb71-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> midx <span class="op">=</span> nodes<span class="op">[</span>m<span class="op">].</span>x<span class="op">;</span></span>
<span id="cb71-49"><a href="#cb71-49" aria-hidden="true" tabindex="-1"></a>    calcMin<span class="op">(</span>l<span class="op">,</span>m<span class="op">);</span></span>
<span id="cb71-50"><a href="#cb71-50" aria-hidden="true" tabindex="-1"></a>    calcMin<span class="op">(</span>m<span class="op">+</span><span class="dv">1</span><span class="op">,</span>r<span class="op">);</span></span>
<span id="cb71-51"><a href="#cb71-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb71-52"><a href="#cb71-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">//归并排序的合并，两个有序数组合并，合并之后仍然有序</span></span>
<span id="cb71-53"><a href="#cb71-53" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>inplace_merge<span class="op">(</span>nodes<span class="op">+</span>l<span class="op">,</span> nodes<span class="op">+</span>m<span class="op">+</span><span class="dv">1</span><span class="op">,</span> nodes<span class="op">+</span>r<span class="op">+</span><span class="dv">1</span><span class="op">,</span> cmp<span class="op">);</span></span>
<span id="cb71-54"><a href="#cb71-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-55"><a href="#cb71-55" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> Node t<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb71-56"><a href="#cb71-56" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tsz <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb71-57"><a href="#cb71-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-58"><a href="#cb71-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> l<span class="op">;</span> i <span class="op">&lt;=</span> r<span class="op">;</span> <span class="op">++</span>i<span class="op">){</span></span>
<span id="cb71-59"><a href="#cb71-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>abs<span class="op">(</span>nodes<span class="op">[</span>i<span class="op">].</span>x <span class="op">-</span> midx<span class="op">)</span> <span class="op">&lt;</span> minDist<span class="op">)</span> <span class="op">{</span></span>
<span id="cb71-60"><a href="#cb71-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> tsz <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> nodes<span class="op">[</span>i<span class="op">].</span>y <span class="op">-</span> t<span class="op">[</span>j<span class="op">].</span>y <span class="op">&lt;</span> minDist<span class="op">;</span> <span class="op">--</span>j<span class="op">)</span></span>
<span id="cb71-61"><a href="#cb71-61" aria-hidden="true" tabindex="-1"></a>                updAns<span class="op">(</span>nodes<span class="op">[</span>i<span class="op">],</span> t<span class="op">[</span>j<span class="op">]);</span></span>
<span id="cb71-62"><a href="#cb71-62" aria-hidden="true" tabindex="-1"></a>            t<span class="op">[</span>tsz<span class="op">++]</span> <span class="op">=</span> nodes<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb71-63"><a href="#cb71-63" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb71-64"><a href="#cb71-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb71-65"><a href="#cb71-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-66"><a href="#cb71-66" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb71-67"><a href="#cb71-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-68"><a href="#cb71-68" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb71-69"><a href="#cb71-69" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb71-70"><a href="#cb71-70" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb71-71"><a href="#cb71-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb71-72"><a href="#cb71-72" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>nodes<span class="op">[</span>i<span class="op">].</span>x<span class="op">&gt;&gt;</span>nodes<span class="op">[</span>i<span class="op">].</span>y<span class="op">;</span></span>
<span id="cb71-73"><a href="#cb71-73" aria-hidden="true" tabindex="-1"></a>        nodes<span class="op">[</span>i<span class="op">].</span>id <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb71-74"><a href="#cb71-74" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb71-75"><a href="#cb71-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-76"><a href="#cb71-76" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>nodes<span class="op">+</span><span class="dv">1</span><span class="op">,</span>nodes<span class="op">+</span><span class="dv">1</span><span class="op">+</span>n<span class="op">);</span></span>
<span id="cb71-77"><a href="#cb71-77" aria-hidden="true" tabindex="-1"></a>    minDist <span class="op">=</span> <span class="fl">1e20</span><span class="op">;</span></span>
<span id="cb71-78"><a href="#cb71-78" aria-hidden="true" tabindex="-1"></a>    calcMin<span class="op">(</span><span class="dv">1</span><span class="op">,</span>n<span class="op">);</span></span>
<span id="cb71-79"><a href="#cb71-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-80"><a href="#cb71-80" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&#34;</span><span class="sc">%.4f\n</span><span class="st">&#34;</span><span class="op">,</span>minDist<span class="op">);</span></span>
<span id="cb71-81"><a href="#cb71-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-82"><a href="#cb71-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb71-83"><a href="#cb71-83" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="扫描线算法">扫描线算法</h2>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Luogu P5490</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 nlogn</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> ll <span class="op">=</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">2000005</span><span class="op">;</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Line<span class="op">{</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>    ll l<span class="op">,</span>r<span class="op">,</span>h<span class="op">;</span></span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tag<span class="op">;</span></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>    Line<span class="op">(){}</span></span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>    Line<span class="op">(</span>ll l<span class="op">,</span> ll r<span class="op">,</span> ll h<span class="op">,</span> <span class="dt">int</span> tag<span class="op">):</span>l<span class="op">(</span>l<span class="op">),</span>r<span class="op">(</span>r<span class="op">),</span>h<span class="op">(</span>h<span class="op">),</span>tag<span class="op">(</span>tag<span class="op">){}</span></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span>Line <span class="at">const</span> <span class="op">&amp;</span> rhs<span class="op">)</span> <span class="at">const</span><span class="op">{</span></span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> h<span class="op">&lt;</span>rhs<span class="op">.</span>h<span class="op">;</span></span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  </span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>line<span class="op">[</span>MAXN<span class="op">*</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a>ll st<span class="op">[</span>MAXN<span class="op">*</span><span class="dv">4</span><span class="op">+</span><span class="dv">2</span><span class="op">];</span><span class="co">//对于一颗线段树，n个数所组成的树最多有4n-5个节点，开大了一点</span></span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a>ll posX<span class="op">[</span>MAXN<span class="op">*</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a>ll len<span class="op">[</span>MAXN<span class="op">*</span><span class="dv">4</span><span class="op">+</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> update<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> s<span class="op">,</span> <span class="dt">int</span> t<span class="op">,</span> <span class="dt">int</span> p<span class="op">,</span> ll c<span class="op">){</span><span class="co">//c表示加减的数值</span></span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>posX<span class="op">[</span>t<span class="op">+</span><span class="dv">1</span><span class="op">]&lt;=</span>l <span class="op">||</span> r<span class="op">&lt;=</span>posX<span class="op">[</span>s<span class="op">])</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">&lt;=</span>posX<span class="op">[</span>s<span class="op">]</span> <span class="op">&amp;&amp;</span> posX<span class="op">[</span>t<span class="op">+</span><span class="dv">1</span><span class="op">]&lt;=</span>r<span class="op">){</span></span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">]</span> <span class="op">+=</span> c<span class="op">;</span></span>
<span id="cb72-29"><a href="#cb72-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>st<span class="op">[</span>p<span class="op">]){</span></span>
<span id="cb72-30"><a href="#cb72-30" aria-hidden="true" tabindex="-1"></a>            len<span class="op">[</span>p<span class="op">]</span> <span class="op">=</span> posX<span class="op">[</span>t<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">-</span> posX<span class="op">[</span>s<span class="op">];</span></span>
<span id="cb72-31"><a href="#cb72-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb72-32"><a href="#cb72-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb72-33"><a href="#cb72-33" aria-hidden="true" tabindex="-1"></a>            len<span class="op">[</span>p<span class="op">]</span> <span class="op">=</span> len<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">]</span> <span class="op">+</span> len<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb72-34"><a href="#cb72-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb72-35"><a href="#cb72-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb72-36"><a href="#cb72-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb72-37"><a href="#cb72-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb72-38"><a href="#cb72-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb72-39"><a href="#cb72-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> s <span class="op">+</span> <span class="op">((</span>t<span class="op">-</span>s<span class="op">)&gt;&gt;</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb72-40"><a href="#cb72-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">&lt;=</span>posX<span class="op">[</span>m<span class="op">])</span> update<span class="op">(</span>l<span class="op">,</span> r<span class="op">,</span> s<span class="op">,</span> m<span class="op">,</span> p<span class="op">*</span><span class="dv">2</span><span class="op">,</span> c<span class="op">);</span></span>
<span id="cb72-41"><a href="#cb72-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>r<span class="op">&gt;</span>posX<span class="op">[</span>m<span class="op">])</span>  update<span class="op">(</span>l<span class="op">,</span> r<span class="op">,</span> m<span class="op">+</span><span class="dv">1</span><span class="op">,</span> t<span class="op">,</span> p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">,</span> c<span class="op">);</span></span>
<span id="cb72-42"><a href="#cb72-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>st<span class="op">[</span>p<span class="op">]){</span></span>
<span id="cb72-43"><a href="#cb72-43" aria-hidden="true" tabindex="-1"></a>        len<span class="op">[</span>p<span class="op">]</span> <span class="op">=</span> posX<span class="op">[</span>t<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">-</span> posX<span class="op">[</span>s<span class="op">];</span></span>
<span id="cb72-44"><a href="#cb72-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb72-45"><a href="#cb72-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span><span class="op">{</span></span>
<span id="cb72-46"><a href="#cb72-46" aria-hidden="true" tabindex="-1"></a>        len<span class="op">[</span>p<span class="op">]</span> <span class="op">=</span> len<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">]</span> <span class="op">+</span> len<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb72-47"><a href="#cb72-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb72-48"><a href="#cb72-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb72-49"><a href="#cb72-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-50"><a href="#cb72-50" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb72-51"><a href="#cb72-51" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb72-52"><a href="#cb72-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb72-53"><a href="#cb72-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-54"><a href="#cb72-54" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb72-55"><a href="#cb72-55" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">;</span><span class="co">//矩形个数</span></span>
<span id="cb72-56"><a href="#cb72-56" aria-hidden="true" tabindex="-1"></a>    ll x1<span class="op">,</span>x2<span class="op">,</span>y1<span class="op">,</span>y2<span class="op">;</span></span>
<span id="cb72-57"><a href="#cb72-57" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb72-58"><a href="#cb72-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb72-59"><a href="#cb72-59" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>x1<span class="op">&gt;&gt;</span>y1<span class="op">&gt;&gt;</span>x2<span class="op">&gt;&gt;</span>y2<span class="op">;</span><span class="co">//输入每个矩形的左下角和右上角</span></span>
<span id="cb72-60"><a href="#cb72-60" aria-hidden="true" tabindex="-1"></a>        posX<span class="op">[</span><span class="dv">2</span><span class="op">*</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> x1<span class="op">,</span> posX<span class="op">[</span><span class="dv">2</span><span class="op">*</span>i<span class="op">]</span> <span class="op">=</span> x2<span class="op">;</span></span>
<span id="cb72-61"><a href="#cb72-61" aria-hidden="true" tabindex="-1"></a>        line<span class="op">[</span><span class="dv">2</span><span class="op">*</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> Line<span class="op">(</span>x1<span class="op">,</span>x2<span class="op">,</span>y1<span class="op">,</span><span class="dv">1</span><span class="op">),</span> line<span class="op">[</span><span class="dv">2</span><span class="op">*</span>i<span class="op">]</span> <span class="op">=</span> Line<span class="op">(</span>x1<span class="op">,</span>x2<span class="op">,</span>y2<span class="op">,-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb72-62"><a href="#cb72-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb72-63"><a href="#cb72-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb72-64"><a href="#cb72-64" aria-hidden="true" tabindex="-1"></a>    n<span class="op">*=</span><span class="dv">2</span><span class="op">;</span><span class="co">//方便起见</span></span>
<span id="cb72-65"><a href="#cb72-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb72-66"><a href="#cb72-66" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>line<span class="op">+</span><span class="dv">1</span><span class="op">,</span>line<span class="op">+</span>n<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb72-67"><a href="#cb72-67" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>posX<span class="op">+</span><span class="dv">1</span><span class="op">,</span>posX<span class="op">+</span>n<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb72-68"><a href="#cb72-68" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb72-69"><a href="#cb72-69" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sumSeg <span class="op">=</span> <span class="bu">std::</span>unique<span class="op">(</span>posX<span class="op">+</span><span class="dv">1</span><span class="op">,</span> posX<span class="op">+</span><span class="dv">1</span><span class="op">+</span>n<span class="op">)</span> <span class="op">-</span> posX <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span><span class="co">//去重求出线段总数</span></span>
<span id="cb72-70"><a href="#cb72-70" aria-hidden="true" tabindex="-1"></a>    ll ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb72-71"><a href="#cb72-71" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb72-72"><a href="#cb72-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span><span class="co">//最后一条边不用管</span></span>
<span id="cb72-73"><a href="#cb72-73" aria-hidden="true" tabindex="-1"></a>        update<span class="op">(</span>line<span class="op">[</span>i<span class="op">].</span>l<span class="op">,</span> line<span class="op">[</span>i<span class="op">].</span>r<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> sumSeg<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> line<span class="op">[</span>i<span class="op">].</span>tag<span class="op">);</span></span>
<span id="cb72-74"><a href="#cb72-74" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">+=</span> len<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span>line<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">].</span>h <span class="op">-</span> line<span class="op">[</span>i<span class="op">].</span>h<span class="op">);</span></span>
<span id="cb72-75"><a href="#cb72-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb72-76"><a href="#cb72-76" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb72-77"><a href="#cb72-77" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span><span class="co">//输出矩形的并集的总面积</span></span>
<span id="cb72-78"><a href="#cb72-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-79"><a href="#cb72-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb72-80"><a href="#cb72-80" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="二维数点">二维数点</h2>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Luogu P2163</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="co">//时间复杂度 nlogn</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">500005</span><span class="op">;</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point<span class="op">{</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tag<span class="op">;</span><span class="co">//用于区分实际的点和查询时的虚点  </span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span>Point <span class="at">const</span> <span class="op">&amp;</span> p<span class="op">){</span></span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>x<span class="op">!=</span>p<span class="op">.</span>x<span class="op">)</span> <span class="cf">return</span> x<span class="op">&lt;</span>p<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>y<span class="op">!=</span>p<span class="op">.</span>y<span class="op">)</span> <span class="cf">return</span> y<span class="op">&lt;</span>p<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> tag<span class="op">&lt;</span>p<span class="op">.</span>tag<span class="op">;</span></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>pts<span class="op">[</span>MAXN<span class="op">*</span><span class="dv">5</span><span class="op">];</span><span class="co">//实点和查询矩阵的点都放在这里面</span></span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> b<span class="op">[</span>MAXN<span class="op">*</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> bit<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ans<span class="op">[</span>MAXN<span class="op">][</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> tot<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb73-23"><a href="#cb73-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-24"><a href="#cb73-24" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">int</span> lowbit<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb73-25"><a href="#cb73-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n<span class="op">&amp;(-</span>n<span class="op">);</span></span>
<span id="cb73-26"><a href="#cb73-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb73-27"><a href="#cb73-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-28"><a href="#cb73-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> update<span class="op">(</span><span class="dt">int</span> p<span class="op">,</span> <span class="dt">int</span> k<span class="op">,</span> <span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb73-29"><a href="#cb73-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(;</span>p<span class="op">&lt;=</span>n<span class="op">;</span>p<span class="op">+=</span>lowbit<span class="op">(</span>p<span class="op">)){</span></span>
<span id="cb73-30"><a href="#cb73-30" aria-hidden="true" tabindex="-1"></a>        bit<span class="op">[</span>p<span class="op">]+=</span>k<span class="op">;</span></span>
<span id="cb73-31"><a href="#cb73-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb73-32"><a href="#cb73-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb73-33"><a href="#cb73-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-34"><a href="#cb73-34" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> query<span class="op">(</span><span class="dt">int</span> p<span class="op">){</span></span>
<span id="cb73-35"><a href="#cb73-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ret<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb73-36"><a href="#cb73-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(;</span>p<span class="op">;</span>p<span class="op">-=</span>lowbit<span class="op">(</span>p<span class="op">)){</span></span>
<span id="cb73-37"><a href="#cb73-37" aria-hidden="true" tabindex="-1"></a>        ret<span class="op">+=</span>bit<span class="op">[</span>p<span class="op">];</span></span>
<span id="cb73-38"><a href="#cb73-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb73-39"><a href="#cb73-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb73-40"><a href="#cb73-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb73-41"><a href="#cb73-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-42"><a href="#cb73-42" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">int</span> lsh<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> cnt<span class="op">){</span><span class="co">//离散化函数</span></span>
<span id="cb73-43"><a href="#cb73-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>lower_bound<span class="op">(</span>b<span class="op">+</span><span class="dv">1</span><span class="op">,</span>b<span class="op">+</span>cnt<span class="op">+</span><span class="dv">1</span><span class="op">,</span>x<span class="op">)-</span>b<span class="op">;</span></span>
<span id="cb73-44"><a href="#cb73-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb73-45"><a href="#cb73-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-46"><a href="#cb73-46" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb73-47"><a href="#cb73-47" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb73-48"><a href="#cb73-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb73-49"><a href="#cb73-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-50"><a href="#cb73-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span></span>
<span id="cb73-51"><a href="#cb73-51" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">;</span><span class="co">//点数，查询数</span></span>
<span id="cb73-52"><a href="#cb73-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-53"><a href="#cb73-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb73-54"><a href="#cb73-54" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>pts<span class="op">[</span>i<span class="op">].</span>x<span class="op">&gt;&gt;</span>pts<span class="op">[</span>i<span class="op">].</span>y<span class="op">;</span><span class="co">//所有实点的坐标</span></span>
<span id="cb73-55"><a href="#cb73-55" aria-hidden="true" tabindex="-1"></a>        pts<span class="op">[</span>i<span class="op">].</span>tag <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb73-56"><a href="#cb73-56" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb73-57"><a href="#cb73-57" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb73-58"><a href="#cb73-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb73-59"><a href="#cb73-59" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x1<span class="op">,</span>x2<span class="op">,</span>y1<span class="op">,</span>y2<span class="op">;</span></span>
<span id="cb73-60"><a href="#cb73-60" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>x1<span class="op">&gt;&gt;</span>y1<span class="op">&gt;&gt;</span>x2<span class="op">&gt;&gt;</span>y2<span class="op">;</span><span class="co">//查询的长方形的左下角和右上角</span></span>
<span id="cb73-61"><a href="#cb73-61" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb73-62"><a href="#cb73-62" aria-hidden="true" tabindex="-1"></a>        pts<span class="op">[++</span>n<span class="op">].</span>x <span class="op">=</span> x1<span class="op">-</span><span class="dv">1</span><span class="op">,</span> pts<span class="op">[</span>n<span class="op">].</span>y <span class="op">=</span> y1<span class="op">-</span><span class="dv">1</span><span class="op">,</span> pts<span class="op">[</span>n<span class="op">].</span>tag <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb73-63"><a href="#cb73-63" aria-hidden="true" tabindex="-1"></a>        pts<span class="op">[++</span>n<span class="op">].</span>x <span class="op">=</span> x2<span class="op">,</span> pts<span class="op">[</span>n<span class="op">].</span>y <span class="op">=</span> y2<span class="op">,</span> pts<span class="op">[</span>n<span class="op">].</span>tag <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb73-64"><a href="#cb73-64" aria-hidden="true" tabindex="-1"></a>        pts<span class="op">[++</span>n<span class="op">].</span>x <span class="op">=</span> x2<span class="op">,</span> pts<span class="op">[</span>n<span class="op">].</span>y <span class="op">=</span> y1<span class="op">-</span><span class="dv">1</span><span class="op">,</span> pts<span class="op">[</span>n<span class="op">].</span>tag <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb73-65"><a href="#cb73-65" aria-hidden="true" tabindex="-1"></a>        pts<span class="op">[++</span>n<span class="op">].</span>x <span class="op">=</span> x1<span class="op">-</span><span class="dv">1</span><span class="op">,</span> pts<span class="op">[</span>n<span class="op">].</span>y <span class="op">=</span> y2<span class="op">,</span> pts<span class="op">[</span>n<span class="op">].</span>tag <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb73-66"><a href="#cb73-66" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb73-67"><a href="#cb73-67" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb73-68"><a href="#cb73-68" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>pts<span class="op">+</span><span class="dv">1</span><span class="op">,</span>pts<span class="op">+</span><span class="dv">1</span><span class="op">+</span>n<span class="op">);</span></span>
<span id="cb73-69"><a href="#cb73-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++)</span> b<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> pts<span class="op">[</span>i<span class="op">].</span>y<span class="op">;</span></span>
<span id="cb73-70"><a href="#cb73-70" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>b<span class="op">+</span><span class="dv">1</span><span class="op">,</span>b<span class="op">+</span><span class="dv">1</span><span class="op">+</span>n<span class="op">);</span></span>
<span id="cb73-71"><a href="#cb73-71" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cnt <span class="op">=</span> <span class="bu">std::</span>unique<span class="op">(</span>b<span class="op">+</span><span class="dv">1</span><span class="op">,</span>b<span class="op">+</span><span class="dv">1</span><span class="op">+</span>n<span class="op">)</span> <span class="op">-</span> b <span class="op">-</span> <span class="dv">1</span><span class="op">;</span><span class="co">//把所有y离散化</span></span>
<span id="cb73-72"><a href="#cb73-72" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb73-73"><a href="#cb73-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb73-74"><a href="#cb73-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>pts<span class="op">[</span>i<span class="op">].</span>tag<span class="op">){</span></span>
<span id="cb73-75"><a href="#cb73-75" aria-hidden="true" tabindex="-1"></a>            ans<span class="op">[</span>pts<span class="op">[</span>i<span class="op">].</span>tag<span class="op">][++</span>tot<span class="op">[</span>pts<span class="op">[</span>i<span class="op">].</span>tag<span class="op">]]</span> <span class="op">=</span> query<span class="op">(</span>lsh<span class="op">(</span>pts<span class="op">[</span>i<span class="op">].</span>y<span class="op">,</span> cnt<span class="op">));</span></span>
<span id="cb73-76"><a href="#cb73-76" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb73-77"><a href="#cb73-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb73-78"><a href="#cb73-78" aria-hidden="true" tabindex="-1"></a>            update<span class="op">(</span>lsh<span class="op">(</span>pts<span class="op">[</span>i<span class="op">].</span>y<span class="op">,</span> cnt<span class="op">),</span> <span class="dv">1</span><span class="op">,</span> cnt<span class="op">);</span></span>
<span id="cb73-79"><a href="#cb73-79" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb73-80"><a href="#cb73-80" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb73-81"><a href="#cb73-81" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb73-82"><a href="#cb73-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb73-83"><a href="#cb73-83" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">[</span>i<span class="op">][</span><span class="dv">4</span><span class="op">]-</span>ans<span class="op">[</span>i<span class="op">][</span><span class="dv">3</span><span class="op">]-</span>ans<span class="op">[</span>i<span class="op">][</span><span class="dv">2</span><span class="op">]+</span>ans<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">]&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb73-84"><a href="#cb73-84" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb73-85"><a href="#cb73-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-86"><a href="#cb73-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb73-87"><a href="#cb73-87" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="pick定理">Pick定理</h2>
<p>给定顶点均为整点的简单多边形，其面积<span class="math inline">\(A\)</span>和内部格点数目<span class="math inline">\(i\)</span>，边上格点数目<span class="math inline">\(b\)</span>的关系为</p>
<p><span class="math display">\[
A = i+\dfrac{b}{2}-1
\]</span></p>
<h1 id="组合数学">组合数学</h1>
<h2 id="用乘法逆元计算组合数">用乘法逆元计算组合数</h2>
<p>TODO: 用模板元编程实现编译期算阶乘</p>
<p>根据</p>
<p><span class="math display">\[
(a/b)\%p=(a\times b^{-1})\%p=[(a\%p)\times(b^{-1}\%p)]\%p
\]</span></p>
<p>（如果加载不全，见<a href="https://kegalas.top/p/%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97%E7%9A%84%E5%88%86%E9%85%8D%E5%BE%8B/">取余运算的分配律</a>）</p>
<p>可以不用除法求出组合数。其中<span class="math inline">\(b^{-1}\)</span>是<span class="math inline">\(b\)</span>在模<span class="math inline">\(p\)</span>意义下的逆元。</p>
<p>注意阶乘和其逆元的预处理。</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 初始化为nlogn 后续查询为O(1)</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P3414，只能过50%（因为这道题考的不是这个）</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> LL <span class="op">=</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">200005</span><span class="op">;</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> LL MOD <span class="op">=</span> <span class="dv">6662333</span><span class="op">;</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>LL fac<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>LL invFac<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>LL qPowMod<span class="op">(</span>LL x<span class="op">,</span> LL p<span class="op">,</span> LL m<span class="op">){</span></span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">//x^p % m</span></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>    LL ans <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>p<span class="op">){</span></span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>p<span class="op">&amp;</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>            ans <span class="op">=</span> <span class="op">(</span>ans<span class="op">*</span>x<span class="op">)%</span>m<span class="op">;</span></span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="op">(</span>x<span class="op">*</span>x<span class="op">)%</span>m<span class="op">;</span></span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a>        p<span class="op">&gt;&gt;=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb74-20"><a href="#cb74-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb74-21"><a href="#cb74-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb74-22"><a href="#cb74-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-23"><a href="#cb74-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-24"><a href="#cb74-24" aria-hidden="true" tabindex="-1"></a>LL fermat_inv<span class="op">(</span>LL a<span class="op">,</span> LL b<span class="op">){</span></span>
<span id="cb74-25"><a href="#cb74-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> qPowMod<span class="op">(</span>a<span class="op">,</span>b<span class="op">-</span><span class="dv">2</span><span class="op">,</span>b<span class="op">);</span></span>
<span id="cb74-26"><a href="#cb74-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-27"><a href="#cb74-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-28"><a href="#cb74-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb74-29"><a href="#cb74-29" aria-hidden="true" tabindex="-1"></a>    fac<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb74-30"><a href="#cb74-30" aria-hidden="true" tabindex="-1"></a>    invFac<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb74-31"><a href="#cb74-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-32"><a href="#cb74-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb74-33"><a href="#cb74-33" aria-hidden="true" tabindex="-1"></a>        fac<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>fac<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]*</span>i<span class="op">)%</span>MOD<span class="op">;</span></span>
<span id="cb74-34"><a href="#cb74-34" aria-hidden="true" tabindex="-1"></a>        invFac<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> fermat_inv<span class="op">(</span>fac<span class="op">[</span>i<span class="op">],</span>MOD<span class="op">);</span></span>
<span id="cb74-35"><a href="#cb74-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb74-36"><a href="#cb74-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-37"><a href="#cb74-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-38"><a href="#cb74-38" aria-hidden="true" tabindex="-1"></a>LL comb<span class="op">(</span>LL n<span class="op">,</span> LL m<span class="op">){</span></span>
<span id="cb74-39"><a href="#cb74-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">//n里面选m个</span></span>
<span id="cb74-40"><a href="#cb74-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>n<span class="op">&lt;</span><span class="dv">0</span><span class="op">||</span>m<span class="op">&lt;</span><span class="dv">0</span><span class="op">||</span>m<span class="op">&gt;</span>n<span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb74-41"><a href="#cb74-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(((</span>fac<span class="op">[</span>n<span class="op">]*</span>invFac<span class="op">[</span>m<span class="op">])%</span>MOD<span class="op">)*</span>invFac<span class="op">[</span>n<span class="op">-</span>m<span class="op">])%</span>MOD<span class="op">;</span></span>
<span id="cb74-42"><a href="#cb74-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="组合数的性质">组合数的性质</h2>
<p><strong>二项式定理</strong></p>
<p><span class="math display">\[
(a+b)^n = \sum^n_{i=0}\binom{n}{i}a^{n-i}b^i
\]</span></p>
<p><strong>对称性</strong></p>
<p><span class="math display">\[
\binom{n}{m} = \binom{n}{n-m}
\]</span></p>
<p><strong>递推式1</strong></p>
<p><span class="math display">\[
\binom{n}{k}=\dfrac{n}{k}\binom{n-1}{k-1}
\]</span></p>
<p><strong>递推式2</strong></p>
<p><span class="math display">\[
\binom{n}{m} = \binom{n-1}{m}+\binom{n-1}{m-1}
\]</span></p>
<p><strong>二项式定理的特例1</strong></p>
<p><span class="math display">\[
\binom{n}{0}+\binom{n}{1}+\cdots+\binom{n}{n} = 2^n
\]</span></p>
<p><strong>二项式定理的特例2</strong></p>
<p><span class="math display">\[
\sum^n_{i=0}(-1)^i\binom{n}{i} = [n=0]
\]</span></p>
<p><strong>组合数拆分</strong></p>
<p><span class="math display">\[
\sum^m_{i=0}\binom{n}{i}\binom{m}{m-i} = \binom{m+n}{m} (n\geq m)
\]</span></p>
<p><strong>组合数拆分的特例</strong></p>
<p><span class="math display">\[
\sum^m_{i=0}\binom{n}{i}^2= \binom{2n}{n}
\]</span></p>
<p><strong>带权和1</strong></p>
<p><span class="math display">\[
\sum^n_{i=0}i\binom{n}{i} = n2^{n-1}
\]</span></p>
<p><strong>带权和2</strong></p>
<p><span class="math display">\[
\sum^n_{i=0}i^2\binom{n}{i} = n(n+1)2^{n-2}
\]</span></p>
<p><strong>性质1</strong></p>
<p><span class="math display">\[
\sum^n_{l=0}\binom{l}{k} = \binom{n+1}{k+1}
\]</span></p>
<p><strong>性质2</strong></p>
<p><span class="math display">\[
\binom{n}{r}\binom{r}{k} = \binom{n}{k}\binom{n-k}{r-k}
\]</span></p>
<p><strong>斐波那契数列性质</strong></p>
<p><span class="math display">\[
\sum^n_{i=0}\binom{n-i}{i} = F_{n+1}
\]</span></p>
<h2 id="圆排列">圆排列</h2>
<p><span class="math inline">\(n\)</span>个人全部来围成一圈，所有的排列数记为<span class="math inline">\(Q^n_n\)</span>。考虑其中已经拍好的一圈，从不同位置断开可以变成不同的队列，则有</p>
<p><span class="math display">\[
Q^n_n\times n = A^n_n
\]</span></p>
<p>由此可知</p>
<p><span class="math display">\[
Q^r_n = \dfrac{A^r_n}{r}
\]</span></p>
<h2 id="二项式反演">二项式反演</h2>
<p>记<span class="math inline">\(f_n\)</span>表示恰好使用<span class="math inline">\(n\)</span>个不同元素形成特定结构的方案数，<span class="math inline">\(g_n\)</span>表示从<span class="math inline">\(n\)</span>个不同元素中选出<span class="math inline">\(i\geq
0\)</span>个元素形成特定结构的总方案数。有</p>
<p><span class="math display">\[
g_n = \sum^n_{i=0}\binom{n}{i}f_i
\]</span></p>
<p>二项式反演就是已知<span class="math inline">\(g_n\)</span>求<span class="math inline">\(f_n\)</span></p>
<p><span class="math display">\[
f_n = \sum^n_{i=0}\binom{n}{i}(-1)^{n-i}g_i
\]</span></p>
<h2 id="斐波那契数列的性质">斐波那契数列的性质</h2>
<p><strong>通项公式</strong></p>
<p><span class="math display">\[
F_n =
\dfrac{\left(\dfrac{1+\sqrt{5}}{2}\right)^n-\left(\dfrac{1-\sqrt{5}}{2}\right)^n}{\sqrt{5}}
\]</span></p>
<p><span class="math display">\[
F_n =
\left[\dfrac{\left(\dfrac{1+\sqrt{5}}{2}\right)^n}{\sqrt{5}}\right]
\]</span></p>
<p>中括号表示取离他最近的整数。</p>
<p><strong>性质1</strong></p>
<p><span class="math display">\[
F_{n-1}F_{n+1}-F_n^2=(-1)^n
\]</span></p>
<p><strong>性质2</strong></p>
<p><span class="math display">\[
F_{n+k}=F_kF_{n+1}+F_{k-1}F_n
\]</span></p>
<p><strong>性质3</strong></p>
<p><span class="math display">\[
F_{2n}=F_{n}(F_{n+1}+F_{n-1}),\quad F_{2n+1}=F^2_{k+1}+F^2_k
\]</span></p>
<p><strong>性质4</strong></p>
<p><span class="math display">\[
\forall k\in N,F_n|F_{nk}
\]</span></p>
<p><strong>性质5</strong></p>
<p><span class="math display">\[
\forall F_a|F_b,a|b
\]</span></p>
<p><strong>性质6</strong></p>
<p><span class="math display">\[
\gcd(F_m,F_n)=F_{\gcd(m,n)}
\]</span></p>
<p><strong>性质7</strong></p>
<p><span class="math display">\[
F_{n+1}=\sum_{0\leq i\leq n}\binom{n-i}{i}
\]</span></p>
<h2 id="和式性质">和式性质</h2>
<h3 id="基本性质">基本性质</h3>
<p><span class="math display">\[
\sum_{k\in K}ca_k=c\sum_{k\in K}a_k
\]</span></p>
<p><span class="math display">\[
\sum_{k\in K}(a_k+b_k)=\sum_{k\in K}a_k+\sum_{k\in K}b_k
\]</span></p>
<p><span class="math display">\[
\sum_{k\in K}a_k = \sum_{p(k)\in K}a_{p(k)}
\]</span></p>
<p>此处<span class="math inline">\(p(k)\)</span>是<span class="math inline">\(k\)</span>的任意排列。</p>
<h3 id="多重和式分配律">多重和式分配律</h3>
<p><span class="math display">\[
\sum_{j\in J,k\in K}a_jb_k = (\sum_{j\in J}a_j)(\sum_{k\in K}b_k)
\]</span></p>
<h3 id="多重和式次序交换">多重和式次序交换</h3>
<p><span class="math display">\[
\sum_{j\in J}\sum_{k\in K}a_{j,k} = \sum_{j\in J,k\in K}a_{j,k} =
\sum_{k\in K}\sum_{j\in J}a_{j,k}
\]</span></p>
<p>当<span class="math inline">\(J,K\)</span>相互独立时成立。</p>
<p><span class="math display">\[
\sum_{j\in J}\sum_{k\in K(j)}a_{j,k} = \sum_{k\in K&#39;}\sum_{j\in
J&#39;(k)}a_{j,k}
\]</span></p>
<p>这里<span class="math inline">\(J,K\)</span>不独立，并且要满足</p>
<p><span class="math display">\[
[j\in J][k\in K(j)]=[k\in K&#39;][j\in J&#39;(k)]
\]</span> 例如</p>
<p><span class="math display">\[
\sum_{j=1}^n\sum_{k=j}^na_{j,k}=\sum_{i\leq j\leq k\leq
n}a_{j,k}=\sum_{k=1}^n\sum_{j=1}^ka_{j,k}
\]</span></p>
<h2 id="卡特兰数">卡特兰数</h2>
<p>TODO: 用模板元编程实现编译期算卡特兰数</p>
<p>第<span class="math inline">\(n\)</span>个记作<span class="math inline">\(C_n\)</span></p>
<p><span class="math inline">\(n\)</span>对括号形成的字符串，合法的情况数是<span class="math inline">\(C_n\)</span></p>
<p><span class="math inline">\(n\)</span>个节点的二叉树，总共有<span class="math inline">\(C_n\)</span>种</p>
<p><span class="math inline">\(2n+1\)</span>个节点组成的满二叉树，有<span class="math inline">\(C_n\)</span>种</p>
<p><span class="math inline">\(n\times
n\)</span>的格点网中，从左下角格点出发，到达右上角格点，不穿过对角线（但可以碰到）的单调路径个数有<span class="math inline">\(C_n\)</span>个。</p>
<p>在圆上有<span class="math inline">\(2n\)</span>个点，将这些点成对连接起来使得所得到的<span class="math inline">\(n\)</span>条线段不相交的方法数为<span class="math inline">\(C_n\)</span>种</p>
<p>一个栈（无穷大）的进栈序列为<span class="math inline">\(1,2,3,\cdots,n\)</span>，合法的出栈序列有<span class="math inline">\(C_n\)</span>个</p>
<p>其计算公式为</p>
<p><span class="math display">\[
C_n = \frac{1}{n+1}\binom{2n}{n}
\]</span></p>
<p><span class="math display">\[
C_n=\binom{2n}{n} - \binom{2n}{n-1}
\]</span></p>
<p><span class="math display">\[
C_0=1,C_{n+1}=\sum^n_{i=0}C_iC_{n-i}
\]</span></p>
<p><span class="math display">\[
C_0=1,C_{n+1}=\frac{2(2n+1)}{n+2}C_n
\]</span></p>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 n</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="co">//前几项：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p1044</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll<span class="op">;</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">3005</span><span class="op">;</span></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>ll h<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>ll comb<span class="op">(</span>ll a<span class="op">,</span>ll b<span class="op">){</span></span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a>    ll ans<span class="op">=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>ll i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>b<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">*=</span>a<span class="op">;</span><span class="co">//数字太大会爆</span></span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a>        a<span class="op">--;</span></span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb75-18"><a href="#cb75-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>ll i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>b<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb75-19"><a href="#cb75-19" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">/=</span>i<span class="op">;</span></span>
<span id="cb75-20"><a href="#cb75-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb75-21"><a href="#cb75-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb75-22"><a href="#cb75-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb75-23"><a href="#cb75-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-24"><a href="#cb75-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb75-25"><a href="#cb75-25" aria-hidden="true" tabindex="-1"></a>    ll n<span class="op">;</span></span>
<span id="cb75-26"><a href="#cb75-26" aria-hidden="true" tabindex="-1"></a>    cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb75-27"><a href="#cb75-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>ll i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb75-28"><a href="#cb75-28" aria-hidden="true" tabindex="-1"></a>        cout<span class="op">&lt;&lt;</span>comb<span class="op">(</span><span class="dv">2</span><span class="op">*</span>i<span class="op">,</span>i<span class="op">)/(</span>i<span class="op">+</span><span class="dv">1</span><span class="op">)&lt;&lt;</span>endl<span class="op">;</span><span class="co">//n&gt;=15的时候ll都能爆</span></span>
<span id="cb75-29"><a href="#cb75-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb75-30"><a href="#cb75-30" aria-hidden="true" tabindex="-1"></a>    cout<span class="op">&lt;&lt;</span><span class="st">&#34;###&#34;</span><span class="op">&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb75-31"><a href="#cb75-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">//下面是递推求法，不容易爆</span></span>
<span id="cb75-32"><a href="#cb75-32" aria-hidden="true" tabindex="-1"></a>    h<span class="op">[</span><span class="dv">1</span><span class="op">]=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb75-33"><a href="#cb75-33" aria-hidden="true" tabindex="-1"></a>    cout<span class="op">&lt;&lt;</span>h<span class="op">[</span><span class="dv">1</span><span class="op">]&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb75-34"><a href="#cb75-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>ll i<span class="op">=</span><span class="dv">2</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb75-35"><a href="#cb75-35" aria-hidden="true" tabindex="-1"></a>        h<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> h<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]*(</span><span class="dv">4</span><span class="op">*</span>i<span class="op">-</span><span class="dv">2</span><span class="op">)/(</span>i<span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb75-36"><a href="#cb75-36" aria-hidden="true" tabindex="-1"></a>        cout<span class="op">&lt;&lt;</span>h<span class="op">[</span>i<span class="op">]&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb75-37"><a href="#cb75-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb75-38"><a href="#cb75-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-39"><a href="#cb75-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb75-40"><a href="#cb75-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="生成函数">生成函数</h2>
<p>生成函数是一种形式幂级数</p>
<p><span class="math display">\[
F(x) = \sum_na_nx^n
\]</span></p>
<p><span class="math inline">\(\{a_i\}\)</span>序列可以是有限的，也可以是无限的。<span class="math inline">\(a_i\)</span>下标以<span class="math inline">\(0\)</span>为起点。生成函数例如</p>
<ol type="1">
<li><span class="math inline">\(a=&lt;1,2,3&gt;\)</span>的普通生成函数为<span class="math inline">\(1+2x+3x^2\)</span></li>
<li><span class="math inline">\(a=&lt;1,1,1,\cdots&gt;\)</span>的普通生成函数为<span class="math inline">\(\sum_{n\geq 0}x^n\)</span></li>
<li><span class="math inline">\(a=&lt;2,4,6,8,\cdots&gt;\)</span>的普通生成函数为<span class="math inline">\(\sum_{n\geq 0}(2n+2)x^n\)</span></li>
</ol>
<p><strong>加减运算</strong></p>
<p>设序列<span class="math inline">\(a,b\)</span>的普通生成函数分别为<span class="math inline">\(F(x),G(x)\)</span>，则</p>
<p><span class="math display">\[
F(x)\pm G(x) = \sum_n(a_n\pm b_n)x^n
\]</span></p>
<p><strong>乘/卷积运算</strong></p>
<p><span class="math display">\[
F(x)G(x) = \sum_n x^n\sum^n_{i=0}a_i b_{n-i}
\]</span></p>
<p>给出一些常见封闭形式，这其实和幂级数收敛时的求和公式差不多（目前只会普通生成函数来应对组合问题，之后更新指数生成函数应对排列问题TODO）：</p>
<p><span class="math display">\[
\sum_{n\geq 0}x^n = \dfrac{1}{1-x}
\]</span></p>
<p><span class="math display">\[
\sum_{n\geq 0}p^nx^n=\dfrac{1}{1-px}
\]</span></p>
<p><span class="math display">\[
\sum_{n\geq 1}x^n = \dfrac{x}{1-x}
\]</span></p>
<p><span class="math display">\[
\sum_{n\geq 0}x^{cn} = \dfrac{1}{1-x^c}
\]</span></p>
<p><span class="math display">\[
1+2x+3x^2+\cdots = \sum_{n\geq 0}(n-1)x^n = \dfrac{1}{(1-x)^2}
\]</span></p>
<p><span class="math display">\[
\sum_{n\geq 0}\binom{m}{n}x^n = (1+x)^m
\]</span></p>
<p><span class="math display">\[
\sum_{n\geq 0}\binom{m+n-1}{n}x^n = \dfrac{1}{(1-x)^{m}}
\]</span></p>
<p>其他有限项生成函数应该用等比数列求和公式，转化成分式形式。之后再来进行生成函数的计算。</p>
<p><strong>例题</strong></p>
<p>在许多不同种类的食物中选出<span class="math inline">\(n\)</span>个，每种食物的限制如下（每种食物选出来的个数必须满足该限制）</p>
<ol type="1">
<li>汉堡：偶数个</li>
<li>可乐：0或1个</li>
<li>鸡腿：0或1或2个</li>
<li>蜜桃多：奇数个（注：0个不满足条件）</li>
<li>鸡块：4的倍数个</li>
<li>包子，0、1、2、3个</li>
<li>土豆炒肉：不超过1个</li>
<li>面包：3的倍数个</li>
</ol>
<p>所有食物选出来的总数加起来等于<span class="math inline">\(n\)</span>就可以算作一种方案。计算方案总数模<span class="math inline">\(10007\)</span></p>
<p>我们设<span class="math inline">\(a_n\)</span>表示这种食物选<span class="math inline">\(n\)</span>个的方案数，并求出其生成函数。显然，假设只选两个食品，如果食品1选了<span class="math inline">\(i\)</span>个，那么食品2就只能选<span class="math inline">\(n-i\)</span>个。这和我们之前的卷积形式是一样的。所以我们应该把各种食品的生成函数的封闭形式乘起来得到答案。生成函数构造如下</p>
<ol type="1">
<li><span class="math inline">\(\sum_{n\geq
0}x^{2n}=\dfrac{1}{1-x^2}\)</span></li>
<li><span class="math inline">\(1+x\)</span></li>
<li><span class="math inline">\(1+x+x^2=\dfrac{1-x^3}{1-x}\)</span>（这里食品都是相同的，所以选1个只有1种方案。求法是等比数列求和。有些题的物品是不同的，这里就要变成其他序列）</li>
<li><span class="math inline">\(\dfrac{x}{1-x^2}\)</span></li>
<li><span class="math inline">\(\dfrac{1}{1-x^4}\)</span></li>
<li><span class="math inline">\(\dfrac{1-x^4}{1-x}\)</span></li>
<li><span class="math inline">\(1+x\)</span></li>
<li><span class="math inline">\(\dfrac{1}{1-x^3}\)</span></li>
</ol>
<p>全部乘起来得到的生成函数为</p>
<p><span class="math display">\[
F(x) =
\dfrac{(1+x)(1-x^3)x(1-x^4)(1+x)}{(1-x^2)(1-x)(1-x^2)(1-x^4)(1-x)(1-x^3)}
= \dfrac{x}{(1-x)^4}
\]</span></p>
<p>再转化为展开形式</p>
<p><span class="math display">\[
F(x) = \sum_{n\geq 0}\binom{n+3}{n}x^{n+1}=\sum_{n\geq
1}\binom{n+2}{n-1}x^n
\]</span></p>
<p>可得答案就是<span class="math inline">\(\binom{n+2}{n-1}=\binom{n+2}{3}\)</span></p>
<h2 id="稳定婚姻问题gale-shapley算法-todo">稳定婚姻问题(Gale-Shapley算法)
TODO</h2>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="co">//POJ 3487</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> N   <span class="op">=</span> <span class="dv">30</span><span class="op">;</span></span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> inf <span class="op">=</span> <span class="dv">1</span><span class="op">&lt;&lt;</span><span class="dv">29</span><span class="op">;</span></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MOD <span class="op">=</span> <span class="dv">2007</span><span class="op">;</span></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> ll<span class="op">;</span></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> couple<span class="op">;</span></span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maleLike<span class="op">[</span>N<span class="op">][</span>N<span class="op">],</span> femaleLike<span class="op">[</span>N<span class="op">][</span>N<span class="op">];</span></span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maleChoice<span class="op">[</span>N<span class="op">],</span>  femaleChoice<span class="op">[</span>N<span class="op">];</span></span>
<span id="cb76-17"><a href="#cb76-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maleName<span class="op">[</span>N<span class="op">],</span>    femaleName<span class="op">[</span>N<span class="op">];</span></span>
<span id="cb76-18"><a href="#cb76-18" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> str<span class="op">[</span>N<span class="op">];</span></span>
<span id="cb76-19"><a href="#cb76-19" aria-hidden="true" tabindex="-1"></a>queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span>freemale<span class="op">;</span><span class="co">//目前单身的男人</span></span>
<span id="cb76-20"><a href="#cb76-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-21"><a href="#cb76-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb76-22"><a href="#cb76-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> t<span class="op">;</span></span>
<span id="cb76-23"><a href="#cb76-23" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&#34;</span><span class="sc">%d</span><span class="st">&#34;</span><span class="op">,&amp;</span>t<span class="op">);</span><span class="co">//数据组数</span></span>
<span id="cb76-24"><a href="#cb76-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>t<span class="op">--){</span></span>
<span id="cb76-25"><a href="#cb76-25" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">&#34;</span><span class="sc">%d</span><span class="st">&#34;</span><span class="op">,&amp;</span>couple<span class="op">);</span><span class="co">//男女对数</span></span>
<span id="cb76-26"><a href="#cb76-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(!</span>freemale<span class="op">.</span>empty<span class="op">()){</span></span>
<span id="cb76-27"><a href="#cb76-27" aria-hidden="true" tabindex="-1"></a>            freemale<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb76-28"><a href="#cb76-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb76-29"><a href="#cb76-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>couple<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb76-30"><a href="#cb76-30" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">&#34;</span><span class="sc">%s</span><span class="st">&#34;</span><span class="op">,</span>str<span class="op">);</span></span>
<span id="cb76-31"><a href="#cb76-31" aria-hidden="true" tabindex="-1"></a>            maleName<span class="op">[</span>i<span class="op">]=</span>str<span class="op">[</span><span class="dv">0</span><span class="op">]-</span><span class="ch">&#39;a&#39;</span><span class="op">;</span><span class="co">//题目中是以小写字母给男人名字，转化为数字</span></span>
<span id="cb76-32"><a href="#cb76-32" aria-hidden="true" tabindex="-1"></a>            freemale<span class="op">.</span>push<span class="op">(</span>maleName<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb76-33"><a href="#cb76-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb76-34"><a href="#cb76-34" aria-hidden="true" tabindex="-1"></a>        sort<span class="op">(</span>maleName<span class="op">,</span> maleName<span class="op">+</span>couple<span class="op">);</span><span class="co">//名字排序，便于字典序</span></span>
<span id="cb76-35"><a href="#cb76-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-36"><a href="#cb76-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>couple<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb76-37"><a href="#cb76-37" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">&#34;</span><span class="sc">%s</span><span class="st">&#34;</span><span class="op">,</span>str<span class="op">);</span></span>
<span id="cb76-38"><a href="#cb76-38" aria-hidden="true" tabindex="-1"></a>            femaleName<span class="op">[</span>i<span class="op">]=</span>str<span class="op">[</span><span class="dv">0</span><span class="op">]-</span><span class="ch">&#39;A&#39;</span><span class="op">;</span><span class="co">//女人名字是大写字母</span></span>
<span id="cb76-39"><a href="#cb76-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb76-40"><a href="#cb76-40" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb76-41"><a href="#cb76-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>couple<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb76-42"><a href="#cb76-42" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">&#34;</span><span class="sc">%s</span><span class="st">&#34;</span><span class="op">,</span>str<span class="op">);</span></span>
<span id="cb76-43"><a href="#cb76-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span>j<span class="op">&lt;</span>couple<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb76-44"><a href="#cb76-44" aria-hidden="true" tabindex="-1"></a>                maleLike<span class="op">[</span>i<span class="op">][</span>j<span class="op">]=</span>str<span class="op">[</span>j<span class="op">+</span><span class="dv">2</span><span class="op">]-</span><span class="ch">&#39;A&#39;</span><span class="op">;</span><span class="co">//男人喜好顺序由男人名字:女人名字列表给出;降序排列</span></span>
<span id="cb76-45"><a href="#cb76-45" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb76-46"><a href="#cb76-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb76-47"><a href="#cb76-47" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb76-48"><a href="#cb76-48" aria-hidden="true" tabindex="-1"></a>        <span class="co">//女士对男士的打分，添加虚拟人物，编号couple，为女士的初始对象</span></span>
<span id="cb76-49"><a href="#cb76-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>couple<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb76-50"><a href="#cb76-50" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">&#34;</span><span class="sc">%s</span><span class="st">&#34;</span><span class="op">,</span>str<span class="op">);</span></span>
<span id="cb76-51"><a href="#cb76-51" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span>j<span class="op">&lt;</span>couple<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb76-52"><a href="#cb76-52" aria-hidden="true" tabindex="-1"></a>                femaleLike<span class="op">[</span>i<span class="op">][</span>str<span class="op">[</span>j<span class="op">+</span><span class="dv">2</span><span class="op">]-</span><span class="ch">&#39;a&#39;</span><span class="op">]=</span>couple<span class="op">-</span>j<span class="op">;</span><span class="co">//排名越前打分越高</span></span>
<span id="cb76-53"><a href="#cb76-53" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb76-54"><a href="#cb76-54" aria-hidden="true" tabindex="-1"></a>            femaleLike<span class="op">[</span>i<span class="op">][</span>couple<span class="op">]=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb76-55"><a href="#cb76-55" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb76-56"><a href="#cb76-56" aria-hidden="true" tabindex="-1"></a>        memset<span class="op">(</span>maleChoice<span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>maleChoice<span class="op">));</span></span>
<span id="cb76-57"><a href="#cb76-57" aria-hidden="true" tabindex="-1"></a>        <span class="co">//一开始男士的期望都是最喜欢的女士</span></span>
<span id="cb76-58"><a href="#cb76-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-59"><a href="#cb76-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>couple<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb76-60"><a href="#cb76-60" aria-hidden="true" tabindex="-1"></a>            femaleChoice<span class="op">[</span>i<span class="op">]=</span>couple<span class="op">;</span></span>
<span id="cb76-61"><a href="#cb76-61" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb76-62"><a href="#cb76-62" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb76-63"><a href="#cb76-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(!</span>freemale<span class="op">.</span>empty<span class="op">()){</span></span>
<span id="cb76-64"><a href="#cb76-64" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> male<span class="op">=</span>freemale<span class="op">.</span>front<span class="op">();</span></span>
<span id="cb76-65"><a href="#cb76-65" aria-hidden="true" tabindex="-1"></a>            <span class="co">//找出未配对的男士</span></span>
<span id="cb76-66"><a href="#cb76-66" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> female<span class="op">=</span>maleLike<span class="op">[</span>male<span class="op">][</span>maleChoice<span class="op">[</span>male<span class="op">]];</span></span>
<span id="cb76-67"><a href="#cb76-67" aria-hidden="true" tabindex="-1"></a>            <span class="co">//找出心意的女士</span></span>
<span id="cb76-68"><a href="#cb76-68" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>femaleLike<span class="op">[</span>female<span class="op">][</span>male<span class="op">]&gt;</span>femaleLike<span class="op">[</span>female<span class="op">][</span>femaleChoice<span class="op">[</span>female<span class="op">]]){</span></span>
<span id="cb76-69"><a href="#cb76-69" aria-hidden="true" tabindex="-1"></a>            <span class="co">//比现男友好</span></span>
<span id="cb76-70"><a href="#cb76-70" aria-hidden="true" tabindex="-1"></a>                freemale<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb76-71"><a href="#cb76-71" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>femaleChoice<span class="op">[</span>female<span class="op">]!=</span>couple<span class="op">){</span></span>
<span id="cb76-72"><a href="#cb76-72" aria-hidden="true" tabindex="-1"></a>                <span class="co">//前男友再次单身，并且不能将虚拟人物加入队列</span></span>
<span id="cb76-73"><a href="#cb76-73" aria-hidden="true" tabindex="-1"></a>                    freemale<span class="op">.</span>push<span class="op">(</span>femaleChoice<span class="op">[</span>female<span class="op">]);</span></span>
<span id="cb76-74"><a href="#cb76-74" aria-hidden="true" tabindex="-1"></a>                    maleChoice<span class="op">[</span>femaleChoice<span class="op">[</span>female<span class="op">]]++;</span></span>
<span id="cb76-75"><a href="#cb76-75" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb76-76"><a href="#cb76-76" aria-hidden="true" tabindex="-1"></a>                femaleChoice<span class="op">[</span>female<span class="op">]=</span>male<span class="op">;</span></span>
<span id="cb76-77"><a href="#cb76-77" aria-hidden="true" tabindex="-1"></a>                <span class="co">//更换男友</span></span>
<span id="cb76-78"><a href="#cb76-78" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb76-79"><a href="#cb76-79" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb76-80"><a href="#cb76-80" aria-hidden="true" tabindex="-1"></a>                maleChoice<span class="op">[</span>male<span class="op">]++;</span></span>
<span id="cb76-81"><a href="#cb76-81" aria-hidden="true" tabindex="-1"></a>                <span class="co">//如果被拒绝，则选择下一位</span></span>
<span id="cb76-82"><a href="#cb76-82" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb76-83"><a href="#cb76-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>couple<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb76-84"><a href="#cb76-84" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&#34;</span><span class="sc">%c</span><span class="st"> </span><span class="sc">%c\n</span><span class="st">&#34;</span><span class="op">,</span>maleName<span class="op">[</span>i<span class="op">]+</span><span class="ch">&#39;a&#39;</span><span class="op">,</span> maleLike<span class="op">[</span>maleName<span class="op">[</span>i<span class="op">]][</span>maleChoice<span class="op">[</span>maleName<span class="op">[</span>i<span class="op">]]]+</span><span class="ch">&#39;A&#39;</span><span class="op">);</span></span>
<span id="cb76-85"><a href="#cb76-85" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb76-86"><a href="#cb76-86" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>t<span class="op">)</span> puts<span class="op">(</span><span class="st">&#34;&#34;</span><span class="op">);</span></span>
<span id="cb76-87"><a href="#cb76-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-88"><a href="#cb76-88" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb76-89"><a href="#cb76-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-90"><a href="#cb76-90" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb76-91"><a href="#cb76-91" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="数据结构">数据结构</h1>
<h2 id="树状数组">树状数组</h2>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 单次查询 logn 单次修改 logn</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="co">//树状数组，维护的是数组的前缀和，有大量的应用</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P3374</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a><span class="co">//普通的树状数组要维护的信息，其运算要满足结合律和可差分</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a><span class="co">//结合律不难理解，可差分指的是若已知x op y和x，则可以求出y</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a><span class="co">//这样的运算例如加，乘，异或。乘如果在模意义下可差分，需要保证每个数都有逆元，如果模数为质数则肯定有</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a><span class="co">//gcd,max这种是不可差分的</span></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">1000005</span><span class="op">;</span></span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> LL <span class="op">=</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Fenwick<span class="op">{</span></span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb77-17"><a href="#cb77-17" aria-hidden="true" tabindex="-1"></a>    LL data<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb77-18"><a href="#cb77-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb77-19"><a href="#cb77-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb77-20"><a href="#cb77-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> init<span class="op">(</span><span class="dt">int</span> <span class="va">size_</span><span class="op">){</span>size<span class="op">=</span><span class="va">size_</span><span class="op">;}</span></span>
<span id="cb77-21"><a href="#cb77-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb77-22"><a href="#cb77-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="dt">int</span> lowbit<span class="op">(</span><span class="dt">int</span> x<span class="op">){</span></span>
<span id="cb77-23"><a href="#cb77-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x<span class="op">&amp;(-</span>x<span class="op">);</span></span>
<span id="cb77-24"><a href="#cb77-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb77-25"><a href="#cb77-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb77-26"><a href="#cb77-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> update<span class="op">(</span><span class="dt">int</span> p<span class="op">,</span> LL k<span class="op">){</span><span class="co">//位置p的元素加k</span></span>
<span id="cb77-27"><a href="#cb77-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(;</span>p<span class="op">&lt;=</span>size<span class="op">;</span>p<span class="op">+=</span>lowbit<span class="op">(</span>p<span class="op">)){</span></span>
<span id="cb77-28"><a href="#cb77-28" aria-hidden="true" tabindex="-1"></a>            data<span class="op">[</span>p<span class="op">]+=</span>k<span class="op">;</span></span>
<span id="cb77-29"><a href="#cb77-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb77-30"><a href="#cb77-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb77-31"><a href="#cb77-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb77-32"><a href="#cb77-32" aria-hidden="true" tabindex="-1"></a>    LL query<span class="op">(</span><span class="dt">int</span> p<span class="op">){</span><span class="co">//查询[1,p]的和</span></span>
<span id="cb77-33"><a href="#cb77-33" aria-hidden="true" tabindex="-1"></a>        LL ret<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb77-34"><a href="#cb77-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(;</span>p<span class="op">;</span>p<span class="op">-=</span>lowbit<span class="op">(</span>p<span class="op">)){</span></span>
<span id="cb77-35"><a href="#cb77-35" aria-hidden="true" tabindex="-1"></a>            ret <span class="op">+=</span> data<span class="op">[</span>p<span class="op">];</span></span>
<span id="cb77-36"><a href="#cb77-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb77-37"><a href="#cb77-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb77-38"><a href="#cb77-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb77-39"><a href="#cb77-39" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb77-40"><a href="#cb77-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-41"><a href="#cb77-41" aria-hidden="true" tabindex="-1"></a>Fenwick fenwick<span class="op">;</span></span>
<span id="cb77-42"><a href="#cb77-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-43"><a href="#cb77-43" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb77-44"><a href="#cb77-44" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb77-45"><a href="#cb77-45" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb77-46"><a href="#cb77-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb77-47"><a href="#cb77-47" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span></span>
<span id="cb77-48"><a href="#cb77-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">;</span></span>
<span id="cb77-49"><a href="#cb77-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">//数组长度，查询数</span></span>
<span id="cb77-50"><a href="#cb77-50" aria-hidden="true" tabindex="-1"></a>    fenwick<span class="op">.</span>init<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb77-51"><a href="#cb77-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb77-52"><a href="#cb77-52" aria-hidden="true" tabindex="-1"></a>        LL tmp<span class="op">;</span></span>
<span id="cb77-53"><a href="#cb77-53" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>tmp<span class="op">;</span></span>
<span id="cb77-54"><a href="#cb77-54" aria-hidden="true" tabindex="-1"></a>        fenwick<span class="op">.</span>update<span class="op">(</span>i<span class="op">,</span>tmp<span class="op">);</span></span>
<span id="cb77-55"><a href="#cb77-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb77-56"><a href="#cb77-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-57"><a href="#cb77-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb77-58"><a href="#cb77-58" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> op<span class="op">;</span></span>
<span id="cb77-59"><a href="#cb77-59" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">,</span>y<span class="op">;</span></span>
<span id="cb77-60"><a href="#cb77-60" aria-hidden="true" tabindex="-1"></a>        LL k<span class="op">;</span></span>
<span id="cb77-61"><a href="#cb77-61" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>op<span class="op">&gt;&gt;</span>x<span class="op">;</span></span>
<span id="cb77-62"><a href="#cb77-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>op<span class="op">==</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb77-63"><a href="#cb77-63" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>k<span class="op">;</span></span>
<span id="cb77-64"><a href="#cb77-64" aria-hidden="true" tabindex="-1"></a>            <span class="co">//将单点增加k，如果想要改成修改，则可以update(x,k-查询x位置上的数)</span></span>
<span id="cb77-65"><a href="#cb77-65" aria-hidden="true" tabindex="-1"></a>            fenwick<span class="op">.</span>update<span class="op">(</span>x<span class="op">,</span>k<span class="op">);</span></span>
<span id="cb77-66"><a href="#cb77-66" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb77-67"><a href="#cb77-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb77-68"><a href="#cb77-68" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>y<span class="op">;</span></span>
<span id="cb77-69"><a href="#cb77-69" aria-hidden="true" tabindex="-1"></a>            <span class="co">//输出[x,y]的数组和</span></span>
<span id="cb77-70"><a href="#cb77-70" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>fenwick<span class="op">.</span>query<span class="op">(</span>y<span class="op">)-</span>fenwick<span class="op">.</span>query<span class="op">(</span>x<span class="op">-</span><span class="dv">1</span><span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb77-71"><a href="#cb77-71" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb77-72"><a href="#cb77-72" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb77-73"><a href="#cb77-73" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb77-74"><a href="#cb77-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb77-75"><a href="#cb77-75" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="树状数组求逆序对">树状数组求逆序对</h3>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 nlogn</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="co">//Luogu P1908</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a><span class="co">//逆序对&lt;i,j&gt;即，符合i&lt;j且ai&gt;aj的&lt;i,j&gt;的个数</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#define LL </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">500005</span><span class="op">;</span></span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>LL arr<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Par<span class="op">{</span></span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a>    LL value<span class="op">,</span>id<span class="op">;</span></span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>par<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> cmp<span class="op">(</span><span class="at">const</span> Par<span class="op">&amp;</span> a<span class="op">,</span><span class="at">const</span> Par<span class="op">&amp;</span> b<span class="op">){</span></span>
<span id="cb78-18"><a href="#cb78-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>a<span class="op">.</span>value<span class="op">!=</span>b<span class="op">.</span>value<span class="op">)</span> <span class="cf">return</span> a<span class="op">.</span>value<span class="op">&lt;</span>b<span class="op">.</span>value<span class="op">;</span></span>
<span id="cb78-19"><a href="#cb78-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a<span class="op">.</span>id<span class="op">&lt;</span>b<span class="op">.</span>id<span class="op">;</span></span>
<span id="cb78-20"><a href="#cb78-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb78-21"><a href="#cb78-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-22"><a href="#cb78-22" aria-hidden="true" tabindex="-1"></a>LL bit<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb78-23"><a href="#cb78-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-24"><a href="#cb78-24" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> LL lowbit<span class="op">(</span>LL n<span class="op">){</span></span>
<span id="cb78-25"><a href="#cb78-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n<span class="op">&amp;(-</span>n<span class="op">);</span></span>
<span id="cb78-26"><a href="#cb78-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb78-27"><a href="#cb78-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-28"><a href="#cb78-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> update<span class="op">(</span>LL p<span class="op">,</span> LL k<span class="op">,</span> LL n<span class="op">){</span></span>
<span id="cb78-29"><a href="#cb78-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(;</span>p<span class="op">&lt;=</span>n<span class="op">;</span>p<span class="op">+=</span>lowbit<span class="op">(</span>p<span class="op">)){</span></span>
<span id="cb78-30"><a href="#cb78-30" aria-hidden="true" tabindex="-1"></a>        bit<span class="op">[</span>p<span class="op">]+=</span>k<span class="op">;</span></span>
<span id="cb78-31"><a href="#cb78-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb78-32"><a href="#cb78-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb78-33"><a href="#cb78-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-34"><a href="#cb78-34" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> query<span class="op">(</span>LL p<span class="op">){</span></span>
<span id="cb78-35"><a href="#cb78-35" aria-hidden="true" tabindex="-1"></a>    LL ans<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb78-36"><a href="#cb78-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(;</span>p<span class="op">;</span>p<span class="op">-=</span>lowbit<span class="op">(</span>p<span class="op">)){</span></span>
<span id="cb78-37"><a href="#cb78-37" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">+=</span>bit<span class="op">[</span>p<span class="op">];</span></span>
<span id="cb78-38"><a href="#cb78-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb78-39"><a href="#cb78-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb78-40"><a href="#cb78-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb78-41"><a href="#cb78-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-42"><a href="#cb78-42" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb78-43"><a href="#cb78-43" aria-hidden="true" tabindex="-1"></a>    LL n<span class="op">;</span></span>
<span id="cb78-44"><a href="#cb78-44" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb78-45"><a href="#cb78-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-46"><a href="#cb78-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb78-47"><a href="#cb78-47" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>par<span class="op">[</span>i<span class="op">].</span>value<span class="op">;</span></span>
<span id="cb78-48"><a href="#cb78-48" aria-hidden="true" tabindex="-1"></a>        par<span class="op">[</span>i<span class="op">].</span>id <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb78-49"><a href="#cb78-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb78-50"><a href="#cb78-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-51"><a href="#cb78-51" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>par<span class="op">+</span><span class="dv">1</span><span class="op">,</span>par<span class="op">+</span><span class="dv">1</span><span class="op">+</span>n<span class="op">,</span>cmp<span class="op">);</span></span>
<span id="cb78-52"><a href="#cb78-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-53"><a href="#cb78-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb78-54"><a href="#cb78-54" aria-hidden="true" tabindex="-1"></a>        arr<span class="op">[</span>par<span class="op">[</span>i<span class="op">].</span>id<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb78-55"><a href="#cb78-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span><span class="co">//这一步其实是离散化</span></span>
<span id="cb78-56"><a href="#cb78-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-57"><a href="#cb78-57" aria-hidden="true" tabindex="-1"></a>    LL ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb78-58"><a href="#cb78-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-59"><a href="#cb78-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb78-60"><a href="#cb78-60" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">+=</span> query<span class="op">(</span>arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb78-61"><a href="#cb78-61" aria-hidden="true" tabindex="-1"></a>        update<span class="op">(</span>arr<span class="op">[</span>i<span class="op">],</span><span class="dv">1</span><span class="op">,</span>n<span class="op">);</span></span>
<span id="cb78-62"><a href="#cb78-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb78-63"><a href="#cb78-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-64"><a href="#cb78-64" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> n<span class="op">*(</span>n<span class="op">-</span><span class="dv">1</span><span class="op">)/</span><span class="dv">2</span><span class="op">-</span>ans<span class="op">;</span><span class="co">//本来统计的是等于或顺序对，现在反过来计算逆序对</span></span>
<span id="cb78-65"><a href="#cb78-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-66"><a href="#cb78-66" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb78-67"><a href="#cb78-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-68"><a href="#cb78-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb78-69"><a href="#cb78-69" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="二维树状数组">二维树状数组</h3>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="co">//二维树状数组 支持单点修改和区间查询</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="co">//loj 133</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">5005</span><span class="op">;</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> LL <span class="op">=</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BIT2D<span class="op">{</span></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N<span class="op">,</span>M<span class="op">;</span></span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>    LL data<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> init<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span><span class="dt">int</span> m<span class="op">){</span></span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a>        N <span class="op">=</span> n<span class="op">,</span> M <span class="op">=</span> m<span class="op">;</span></span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="dt">int</span> lowbit<span class="op">(</span><span class="dt">int</span> x<span class="op">){</span></span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x<span class="op">&amp;(-</span>x<span class="op">);</span></span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb79-21"><a href="#cb79-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> add<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">,</span> LL v<span class="op">){</span><span class="co">//把(x,y)这个点加上v</span></span>
<span id="cb79-22"><a href="#cb79-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>x<span class="op">;</span>i<span class="op">&lt;=</span>N<span class="op">;</span>i<span class="op">+=</span>lowbit<span class="op">(</span>i<span class="op">)){</span></span>
<span id="cb79-23"><a href="#cb79-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span>y<span class="op">;</span>j<span class="op">&lt;=</span>M<span class="op">;</span>j<span class="op">+=</span>lowbit<span class="op">(</span>j<span class="op">)){</span></span>
<span id="cb79-24"><a href="#cb79-24" aria-hidden="true" tabindex="-1"></a>                data<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> v<span class="op">;</span></span>
<span id="cb79-25"><a href="#cb79-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb79-26"><a href="#cb79-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb79-27"><a href="#cb79-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb79-28"><a href="#cb79-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb79-29"><a href="#cb79-29" aria-hidden="true" tabindex="-1"></a>    LL sum<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">){</span></span>
<span id="cb79-30"><a href="#cb79-30" aria-hidden="true" tabindex="-1"></a>        LL ret <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb79-31"><a href="#cb79-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>x<span class="op">;</span>i<span class="op">&gt;</span><span class="dv">0</span><span class="op">;</span>i<span class="op">-=</span>lowbit<span class="op">(</span>i<span class="op">)){</span></span>
<span id="cb79-32"><a href="#cb79-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span>y<span class="op">;</span>j<span class="op">&gt;</span><span class="dv">0</span><span class="op">;</span>j<span class="op">-=</span>lowbit<span class="op">(</span>j<span class="op">)){</span></span>
<span id="cb79-33"><a href="#cb79-33" aria-hidden="true" tabindex="-1"></a>                ret <span class="op">+=</span> data<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb79-34"><a href="#cb79-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb79-35"><a href="#cb79-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb79-36"><a href="#cb79-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb79-37"><a href="#cb79-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb79-38"><a href="#cb79-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb79-39"><a href="#cb79-39" aria-hidden="true" tabindex="-1"></a>    LL query<span class="op">(</span><span class="dt">int</span> x1<span class="op">,</span> <span class="dt">int</span> y1<span class="op">,</span> <span class="dt">int</span> x2<span class="op">,</span> <span class="dt">int</span> y2<span class="op">){</span><span class="co">//查询(x1,y1)-(x2,y2)这个矩形的区间和</span></span>
<span id="cb79-40"><a href="#cb79-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sum<span class="op">(</span>x2<span class="op">,</span>y2<span class="op">)</span> <span class="op">-</span> sum<span class="op">(</span>x2<span class="op">,</span>y1<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">-</span> sum<span class="op">(</span>x1<span class="op">-</span><span class="dv">1</span><span class="op">,</span> y2<span class="op">)</span> <span class="op">+</span> sum<span class="op">(</span>x1<span class="op">-</span><span class="dv">1</span><span class="op">,</span> y1<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb79-41"><a href="#cb79-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb79-42"><a href="#cb79-42" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb79-43"><a href="#cb79-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-44"><a href="#cb79-44" aria-hidden="true" tabindex="-1"></a>BIT2D bit2d<span class="op">;</span></span></code></pre></div>
<h2 id="并查集">并查集</h2>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 很小</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="co">//并查集 Luogu3367</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">10005</span><span class="op">;</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DSU<span class="op">{</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fa<span class="op">[</span>MAXN<span class="op">],</span> rk<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> init<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++)</span> fa<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i<span class="op">,</span> rk<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> find<span class="op">(</span><span class="dt">int</span> x<span class="op">){</span></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">//没有路径压缩的find，在需要删除操作时，不能使用路径压缩，只能按秩合并保证复杂度</span></span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fa<span class="op">[</span>x<span class="op">]==</span>x <span class="op">?</span> x <span class="op">:</span> find<span class="op">(</span>fa<span class="op">[</span>x<span class="op">]);</span></span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> findc<span class="op">(</span><span class="dt">int</span> x<span class="op">){</span></span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">//带路径压缩的find</span></span>
<span id="cb80-20"><a href="#cb80-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fa<span class="op">[</span>x<span class="op">]==</span>x <span class="op">?</span> x <span class="op">:</span> <span class="op">(</span>fa<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> findc<span class="op">(</span>fa<span class="op">[</span>x<span class="op">]));</span></span>
<span id="cb80-21"><a href="#cb80-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb80-22"><a href="#cb80-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb80-23"><a href="#cb80-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> merge<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">){</span></span>
<span id="cb80-24"><a href="#cb80-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">//按秩合并，如果不需要则直接 fa[find(x)] = find(y);</span></span>
<span id="cb80-25"><a href="#cb80-25" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> find<span class="op">(</span>x<span class="op">),</span> y <span class="op">=</span> find<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb80-26"><a href="#cb80-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>x<span class="op">==</span>y<span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb80-27"><a href="#cb80-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>rk<span class="op">[</span>x<span class="op">]&gt;</span>rk<span class="op">[</span>y<span class="op">])</span> <span class="bu">std::</span>swap<span class="op">(</span>x<span class="op">,</span>y<span class="op">);</span></span>
<span id="cb80-28"><a href="#cb80-28" aria-hidden="true" tabindex="-1"></a>        fa<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb80-29"><a href="#cb80-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>rk<span class="op">[</span>x<span class="op">]==</span>rk<span class="op">[</span>y<span class="op">])</span> rk<span class="op">[</span>y<span class="op">]++;</span></span>
<span id="cb80-30"><a href="#cb80-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb80-31"><a href="#cb80-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb80-32"><a href="#cb80-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> mergec<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">){</span></span>
<span id="cb80-33"><a href="#cb80-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">//按秩合并+路径压缩，如果不需要则直接 fa[findc(x)] = findc(y);</span></span>
<span id="cb80-34"><a href="#cb80-34" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> findc<span class="op">(</span>x<span class="op">),</span> y <span class="op">=</span> findc<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb80-35"><a href="#cb80-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>x<span class="op">==</span>y<span class="op">)</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb80-36"><a href="#cb80-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>rk<span class="op">[</span>x<span class="op">]&gt;</span>rk<span class="op">[</span>y<span class="op">])</span> <span class="bu">std::</span>swap<span class="op">(</span>x<span class="op">,</span>y<span class="op">);</span></span>
<span id="cb80-37"><a href="#cb80-37" aria-hidden="true" tabindex="-1"></a>        fa<span class="op">[</span>y<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb80-38"><a href="#cb80-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>rk<span class="op">[</span>x<span class="op">]==</span>rk<span class="op">[</span>y<span class="op">])</span> rk<span class="op">[</span>y<span class="op">]++;</span></span>
<span id="cb80-39"><a href="#cb80-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb80-40"><a href="#cb80-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb80-41"><a href="#cb80-41" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> erase<span class="op">(</span><span class="dt">int</span> x<span class="op">){</span></span>
<span id="cb80-42"><a href="#cb80-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">--</span>rk<span class="op">[</span>find<span class="op">(</span>x<span class="op">)];</span></span>
<span id="cb80-43"><a href="#cb80-43" aria-hidden="true" tabindex="-1"></a>        fa<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb80-44"><a href="#cb80-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb80-45"><a href="#cb80-45" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="线段树">线段树</h2>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 单次查询 logn 单次修改 logn</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p3372</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="co">//线段树维护的数据要求满足结合律，比如区间和，区间最大区间最小，区间gcd</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="co">//区间修改一般支持加、乘、赋值</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">100005</span><span class="op">;</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> LL <span class="op">=</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node</span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> s<span class="op">,</span>t<span class="op">;</span><span class="co">//该端点的起点和终点下标</span></span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>    LL tag<span class="op">,</span> v<span class="op">;</span></span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true" tabindex="-1"></a>Node st<span class="op">[</span>MAXN<span class="op">*</span><span class="dv">4</span><span class="op">+</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true" tabindex="-1"></a>LL arr<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb81-19"><a href="#cb81-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-20"><a href="#cb81-20" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> build<span class="op">(</span><span class="dt">int</span> s<span class="op">,</span> <span class="dt">int</span> t<span class="op">,</span> <span class="dt">int</span> p<span class="op">=</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb81-21"><a href="#cb81-21" aria-hidden="true" tabindex="-1"></a>    st<span class="op">[</span>p<span class="op">].</span>s <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb81-22"><a href="#cb81-22" aria-hidden="true" tabindex="-1"></a>    st<span class="op">[</span>p<span class="op">].</span>t <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb81-23"><a href="#cb81-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>s<span class="op">==</span>t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb81-24"><a href="#cb81-24" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">].</span>v <span class="op">=</span> arr<span class="op">[</span>s<span class="op">];</span></span>
<span id="cb81-25"><a href="#cb81-25" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">].</span>tag <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb81-26"><a href="#cb81-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb81-27"><a href="#cb81-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb81-28"><a href="#cb81-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> s<span class="op">+((</span>t<span class="op">-</span>s<span class="op">)&gt;&gt;</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb81-29"><a href="#cb81-29" aria-hidden="true" tabindex="-1"></a>    build<span class="op">(</span>s<span class="op">,</span>m<span class="op">,</span>p<span class="op">*</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb81-30"><a href="#cb81-30" aria-hidden="true" tabindex="-1"></a>    build<span class="op">(</span>m<span class="op">+</span><span class="dv">1</span><span class="op">,</span>t<span class="op">,</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb81-31"><a href="#cb81-31" aria-hidden="true" tabindex="-1"></a>    st<span class="op">[</span>p<span class="op">].</span>v <span class="op">=</span> st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">].</span>v <span class="op">+</span> st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">].</span>v<span class="op">;</span></span>
<span id="cb81-32"><a href="#cb81-32" aria-hidden="true" tabindex="-1"></a>    st<span class="op">[</span>p<span class="op">].</span>tag <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb81-33"><a href="#cb81-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb81-34"><a href="#cb81-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-35"><a href="#cb81-35" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> spreadTag<span class="op">(</span><span class="dt">int</span> p<span class="op">){</span></span>
<span id="cb81-36"><a href="#cb81-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>st<span class="op">[</span>p<span class="op">].</span>tag<span class="op">){</span></span>
<span id="cb81-37"><a href="#cb81-37" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> s <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>s<span class="op">,</span> t <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>t<span class="op">;</span></span>
<span id="cb81-38"><a href="#cb81-38" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> s<span class="op">+((</span>t<span class="op">-</span>s<span class="op">)&gt;&gt;</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb81-39"><a href="#cb81-39" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">].</span>v     <span class="op">+=</span> <span class="op">(</span>m<span class="op">-</span>s<span class="op">+</span><span class="dv">1</span><span class="op">)*</span>st<span class="op">[</span>p<span class="op">].</span>tag<span class="op">;</span></span>
<span id="cb81-40"><a href="#cb81-40" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">].</span>v   <span class="op">+=</span> <span class="op">(</span>t<span class="op">-</span>m<span class="op">)*</span>st<span class="op">[</span>p<span class="op">].</span>tag<span class="op">;</span></span>
<span id="cb81-41"><a href="#cb81-41" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">].</span>tag   <span class="op">+=</span> st<span class="op">[</span>p<span class="op">].</span>tag<span class="op">;</span></span>
<span id="cb81-42"><a href="#cb81-42" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">].</span>tag <span class="op">+=</span> st<span class="op">[</span>p<span class="op">].</span>tag<span class="op">;</span></span>
<span id="cb81-43"><a href="#cb81-43" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">].</span>tag<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb81-44"><a href="#cb81-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb81-45"><a href="#cb81-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb81-46"><a href="#cb81-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-47"><a href="#cb81-47" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> update<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> LL k<span class="op">,</span> <span class="dt">int</span> p<span class="op">=</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb81-48"><a href="#cb81-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> s <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>s<span class="op">,</span> t <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>t<span class="op">;</span></span>
<span id="cb81-49"><a href="#cb81-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">&lt;=</span>s <span class="op">&amp;&amp;</span> t<span class="op">&lt;=</span>r<span class="op">){</span></span>
<span id="cb81-50"><a href="#cb81-50" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">].</span>v   <span class="op">+=</span> <span class="op">(</span>t<span class="op">-</span>s<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="op">*</span> k<span class="op">;</span></span>
<span id="cb81-51"><a href="#cb81-51" aria-hidden="true" tabindex="-1"></a>        st<span class="op">[</span>p<span class="op">].</span>tag <span class="op">+=</span> k<span class="op">;</span></span>
<span id="cb81-52"><a href="#cb81-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb81-53"><a href="#cb81-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb81-54"><a href="#cb81-54" aria-hidden="true" tabindex="-1"></a>    spreadTag<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb81-55"><a href="#cb81-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb81-56"><a href="#cb81-56" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> s<span class="op">+((</span>t<span class="op">-</span>s<span class="op">)&gt;&gt;</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb81-57"><a href="#cb81-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">&lt;=</span>m<span class="op">)</span> update<span class="op">(</span>l<span class="op">,</span> r<span class="op">,</span> k<span class="op">,</span> p<span class="op">*</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb81-58"><a href="#cb81-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>r<span class="op">&gt;</span>m<span class="op">)</span>  update<span class="op">(</span>l<span class="op">,</span> r<span class="op">,</span> k<span class="op">,</span> p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb81-59"><a href="#cb81-59" aria-hidden="true" tabindex="-1"></a>    st<span class="op">[</span>p<span class="op">].</span>v <span class="op">=</span> st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">].</span>v <span class="op">+</span> st<span class="op">[</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">].</span>v<span class="op">;</span></span>
<span id="cb81-60"><a href="#cb81-60" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb81-61"><a href="#cb81-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-62"><a href="#cb81-62" aria-hidden="true" tabindex="-1"></a>LL query<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> p<span class="op">=</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb81-63"><a href="#cb81-63" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> s <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>s<span class="op">,</span> t <span class="op">=</span> st<span class="op">[</span>p<span class="op">].</span>t<span class="op">;</span></span>
<span id="cb81-64"><a href="#cb81-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">&lt;=</span>s <span class="op">&amp;&amp;</span> t<span class="op">&lt;=</span>r<span class="op">)</span> <span class="cf">return</span> st<span class="op">[</span>p<span class="op">].</span>v<span class="op">;</span></span>
<span id="cb81-65"><a href="#cb81-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb81-66"><a href="#cb81-66" aria-hidden="true" tabindex="-1"></a>    spreadTag<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb81-67"><a href="#cb81-67" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> s<span class="op">+((</span>t<span class="op">-</span>s<span class="op">)&gt;&gt;</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb81-68"><a href="#cb81-68" aria-hidden="true" tabindex="-1"></a>    LL ret <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb81-69"><a href="#cb81-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>l<span class="op">&lt;=</span>m<span class="op">)</span> ret<span class="op">+=</span>query<span class="op">(</span>l<span class="op">,</span>r<span class="op">,</span>p<span class="op">*</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb81-70"><a href="#cb81-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>r<span class="op">&gt;</span>m<span class="op">)</span>  ret<span class="op">+=</span>query<span class="op">(</span>l<span class="op">,</span>r<span class="op">,</span>p<span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb81-71"><a href="#cb81-71" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb81-72"><a href="#cb81-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb81-73"><a href="#cb81-73" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="珂朵莉树">珂朵莉树</h2>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="co">//珂朵莉树，区间推平问题</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="co">//方便给某个区间赋值，区间加数，维护区间第k大值，区间和等等</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="co">//数据随机的情况下，复杂度为nloglogn</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="co">//珂朵莉树的每一个节点都是一个区间，这个区间内的值相同。</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="co">//cf896c</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node<span class="op">{</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l<span class="op">,</span>r<span class="op">;</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">mutable</span> LL v<span class="op">;</span><span class="co">//这里修改成自己需要的数据类型，在[l,r]内都等于这个值</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> LL v<span class="op">):</span>l<span class="op">(</span>l<span class="op">),</span>r<span class="op">(</span>r<span class="op">),</span>v<span class="op">(</span>v<span class="op">){}</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span>Node <span class="at">const</span> <span class="op">&amp;</span> x<span class="op">)</span> <span class="at">const</span> <span class="op">{</span><span class="cf">return</span> l<span class="op">&lt;</span>x<span class="op">.</span>l<span class="op">;}</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ODT<span class="op">{</span></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>set<span class="op">&lt;</span>Node<span class="op">&gt;</span> tree<span class="op">;</span></span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> split<span class="op">(</span><span class="dt">int</span> pos<span class="op">){</span></span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> it <span class="op">=</span> tree<span class="op">.</span>lower_bound<span class="op">(</span>Node<span class="op">(</span>pos<span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">));</span></span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>it<span class="op">!=</span>tree<span class="op">.</span>end<span class="op">()</span> <span class="op">&amp;&amp;</span> it<span class="op">-&gt;</span>l<span class="op">==</span>pos<span class="op">)</span></span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> it<span class="op">;</span></span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a>        it<span class="op">--;</span></span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> l <span class="op">=</span> it<span class="op">-&gt;</span>l<span class="op">,</span> r <span class="op">=</span> it<span class="op">-&gt;</span>r<span class="op">;</span></span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true" tabindex="-1"></a>        LL v <span class="op">=</span> it<span class="op">-&gt;</span>v<span class="op">;</span></span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true" tabindex="-1"></a>        tree<span class="op">.</span>erase<span class="op">(</span>it<span class="op">);</span></span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true" tabindex="-1"></a>        tree<span class="op">.</span>insert<span class="op">(</span>Node<span class="op">(</span>l<span class="op">,</span>pos<span class="op">-</span><span class="dv">1</span><span class="op">,</span>v<span class="op">));</span></span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> tree<span class="op">.</span>insert<span class="op">(</span>Node<span class="op">(</span>pos<span class="op">,</span>r<span class="op">,</span>v<span class="op">)).</span>first<span class="op">;</span></span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb82-29"><a href="#cb82-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-30"><a href="#cb82-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> assign<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> v<span class="op">){</span></span>
<span id="cb82-31"><a href="#cb82-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">//给区间赋值</span></span>
<span id="cb82-32"><a href="#cb82-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> end <span class="op">=</span> split<span class="op">(</span>r<span class="op">+</span><span class="dv">1</span><span class="op">),</span> begin <span class="op">=</span> split<span class="op">(</span>l<span class="op">);</span><span class="co">//必须要注意顺序</span></span>
<span id="cb82-33"><a href="#cb82-33" aria-hidden="true" tabindex="-1"></a>        tree<span class="op">.</span>erase<span class="op">(</span>begin<span class="op">,</span>end<span class="op">);</span></span>
<span id="cb82-34"><a href="#cb82-34" aria-hidden="true" tabindex="-1"></a>        tree<span class="op">.</span>insert<span class="op">(</span>Node<span class="op">(</span>l<span class="op">,</span>r<span class="op">,</span>v<span class="op">));</span></span>
<span id="cb82-35"><a href="#cb82-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb82-36"><a href="#cb82-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-37"><a href="#cb82-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> perf<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">){</span><span class="co">//其他操作的模板函数</span></span>
<span id="cb82-38"><a href="#cb82-38" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> end <span class="op">=</span> split<span class="op">(</span>r<span class="op">+</span><span class="dv">1</span><span class="op">),</span> begin <span class="op">=</span> split<span class="op">(</span>l<span class="op">);</span></span>
<span id="cb82-39"><a href="#cb82-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> it<span class="op">=</span>begin<span class="op">;</span>it<span class="op">!=</span>end<span class="op">;</span>it<span class="op">++){</span></span>
<span id="cb82-40"><a href="#cb82-40" aria-hidden="true" tabindex="-1"></a>            <span class="co">//这里是操作</span></span>
<span id="cb82-41"><a href="#cb82-41" aria-hidden="true" tabindex="-1"></a>            <span class="co">//这些操作都很暴力，例如k大值，就把区间全部枚举排序一遍去找</span></span>
<span id="cb82-42"><a href="#cb82-42" aria-hidden="true" tabindex="-1"></a>            <span class="co">//例如区间和，就枚举区间加起来，注意是加it-&gt;v * (it-&gt;r-it-&gt;l+1)</span></span>
<span id="cb82-43"><a href="#cb82-43" aria-hidden="true" tabindex="-1"></a>            <span class="co">//例如区间加数，就枚举区间给所有的it-&gt;v都加一个数</span></span>
<span id="cb82-44"><a href="#cb82-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb82-45"><a href="#cb82-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb82-46"><a href="#cb82-46" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb82-47"><a href="#cb82-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-48"><a href="#cb82-48" aria-hidden="true" tabindex="-1"></a><span class="co">//珂朵莉树的初始化不能用assign，设范围为[1,w]，初值全部为0，则</span></span>
<span id="cb82-49"><a href="#cb82-49" aria-hidden="true" tabindex="-1"></a>ODT odt<span class="op">;</span></span>
<span id="cb82-50"><a href="#cb82-50" aria-hidden="true" tabindex="-1"></a>odt<span class="op">.</span>tree<span class="op">.</span>insert<span class="op">(</span>Node<span class="op">(</span><span class="dv">1</span><span class="op">,</span>w<span class="op">,</span><span class="dv">0</span><span class="op">));</span></span></code></pre></div>
<h2 id="分块">分块</h2>
<p>分块是根号算法，比线段树略差，但是不需要满足结合律，也不需要传递tag。</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p3372 和线段树区间加，维护区间和一样</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度n sqrt(n)</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="co">//在块内时对块操作，跨块时中间对块操作，两边多余部分暴力处理</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>LL arr<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BA<span class="op">{</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> st<span class="op">[</span>MAXN<span class="op">],</span>ed<span class="op">[</span>MAXN<span class="op">],</span>size<span class="op">[</span>MAXN<span class="op">],</span>bel<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//每一段的开始下标、结束下标、段大小；每个元素属于哪个段</span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sq<span class="op">;</span></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>    LL sum<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//保存第i个块的和</span></span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a>    LL tag<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> init<span class="op">(</span><span class="dt">int</span> n<span class="op">){</span></span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a>        sq <span class="op">=</span> <span class="bu">std::</span>sqrt<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>sq<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb83-16"><a href="#cb83-16" aria-hidden="true" tabindex="-1"></a>            st<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> n <span class="op">/</span> sq <span class="op">*</span> <span class="op">(</span>i<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb83-17"><a href="#cb83-17" aria-hidden="true" tabindex="-1"></a>            ed<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> n <span class="op">/</span> sq <span class="op">*</span> i<span class="op">;</span></span>
<span id="cb83-18"><a href="#cb83-18" aria-hidden="true" tabindex="-1"></a>            size<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> ed<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> st<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb83-19"><a href="#cb83-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb83-20"><a href="#cb83-20" aria-hidden="true" tabindex="-1"></a>        ed<span class="op">[</span>sq<span class="op">]</span> <span class="op">=</span> n<span class="op">;</span><span class="co">//最后一段可能长度不够n/sq</span></span>
<span id="cb83-21"><a href="#cb83-21" aria-hidden="true" tabindex="-1"></a>        size<span class="op">[</span>sq<span class="op">]</span> <span class="op">=</span> ed<span class="op">[</span>sq<span class="op">]</span> <span class="op">-</span> st<span class="op">[</span>sq<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb83-22"><a href="#cb83-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb83-23"><a href="#cb83-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>sq<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb83-24"><a href="#cb83-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span>st<span class="op">[</span>i<span class="op">];</span>j<span class="op">&lt;=</span>ed<span class="op">[</span>i<span class="op">];</span>j<span class="op">++)</span></span>
<span id="cb83-25"><a href="#cb83-25" aria-hidden="true" tabindex="-1"></a>                bel<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> i<span class="op">,</span> sum<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> arr<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb83-26"><a href="#cb83-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb83-27"><a href="#cb83-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-28"><a href="#cb83-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> update<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> LL k<span class="op">){</span></span>
<span id="cb83-29"><a href="#cb83-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>bel<span class="op">[</span>l<span class="op">]==</span>bel<span class="op">[</span>r<span class="op">]){</span></span>
<span id="cb83-30"><a href="#cb83-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>l<span class="op">;</span>i<span class="op">&lt;=</span>r<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb83-31"><a href="#cb83-31" aria-hidden="true" tabindex="-1"></a>                arr<span class="op">[</span>i<span class="op">]+=</span>k<span class="op">;</span></span>
<span id="cb83-32"><a href="#cb83-32" aria-hidden="true" tabindex="-1"></a>                sum<span class="op">[</span>bel<span class="op">[</span>i<span class="op">]]</span> <span class="op">+=</span> k<span class="op">;</span></span>
<span id="cb83-33"><a href="#cb83-33" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb83-34"><a href="#cb83-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb83-35"><a href="#cb83-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb83-36"><a href="#cb83-36" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb83-37"><a href="#cb83-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>l<span class="op">;</span>i<span class="op">&lt;=</span>ed<span class="op">[</span>bel<span class="op">[</span>l<span class="op">]];</span>i<span class="op">++){</span></span>
<span id="cb83-38"><a href="#cb83-38" aria-hidden="true" tabindex="-1"></a>            arr<span class="op">[</span>i<span class="op">]+=</span>k<span class="op">;</span></span>
<span id="cb83-39"><a href="#cb83-39" aria-hidden="true" tabindex="-1"></a>            sum<span class="op">[</span>bel<span class="op">[</span>i<span class="op">]]+=</span>k<span class="op">;</span></span>
<span id="cb83-40"><a href="#cb83-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb83-41"><a href="#cb83-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>st<span class="op">[</span>bel<span class="op">[</span>r<span class="op">]];</span>i<span class="op">&lt;=</span>r<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb83-42"><a href="#cb83-42" aria-hidden="true" tabindex="-1"></a>            arr<span class="op">[</span>i<span class="op">]+=</span>k<span class="op">;</span></span>
<span id="cb83-43"><a href="#cb83-43" aria-hidden="true" tabindex="-1"></a>            sum<span class="op">[</span>bel<span class="op">[</span>i<span class="op">]]+=</span>k<span class="op">;</span></span>
<span id="cb83-44"><a href="#cb83-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb83-45"><a href="#cb83-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>bel<span class="op">[</span>l<span class="op">]+</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;</span>bel<span class="op">[</span>r<span class="op">];</span>i<span class="op">++){</span></span>
<span id="cb83-46"><a href="#cb83-46" aria-hidden="true" tabindex="-1"></a>            tag<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> k<span class="op">;</span></span>
<span id="cb83-47"><a href="#cb83-47" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb83-48"><a href="#cb83-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb83-49"><a href="#cb83-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-50"><a href="#cb83-50" aria-hidden="true" tabindex="-1"></a>    LL query<span class="op">(</span><span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">){</span></span>
<span id="cb83-51"><a href="#cb83-51" aria-hidden="true" tabindex="-1"></a>        LL ret <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb83-52"><a href="#cb83-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>bel<span class="op">[</span>l<span class="op">]==</span>bel<span class="op">[</span>r<span class="op">]){</span></span>
<span id="cb83-53"><a href="#cb83-53" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>l<span class="op">;</span>i<span class="op">&lt;=</span>r<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb83-54"><a href="#cb83-54" aria-hidden="true" tabindex="-1"></a>                ret <span class="op">+=</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> tag<span class="op">[</span>bel<span class="op">[</span>i<span class="op">]];</span></span>
<span id="cb83-55"><a href="#cb83-55" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb83-56"><a href="#cb83-56" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb83-57"><a href="#cb83-57" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb83-58"><a href="#cb83-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>l<span class="op">;</span>i<span class="op">&lt;=</span>ed<span class="op">[</span>bel<span class="op">[</span>l<span class="op">]];</span>i<span class="op">++)</span></span>
<span id="cb83-59"><a href="#cb83-59" aria-hidden="true" tabindex="-1"></a>            ret <span class="op">+=</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> tag<span class="op">[</span>bel<span class="op">[</span>i<span class="op">]];</span></span>
<span id="cb83-60"><a href="#cb83-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>st<span class="op">[</span>bel<span class="op">[</span>r<span class="op">]];</span>i<span class="op">&lt;=</span>r<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb83-61"><a href="#cb83-61" aria-hidden="true" tabindex="-1"></a>            ret <span class="op">+=</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> tag<span class="op">[</span>bel<span class="op">[</span>i<span class="op">]];</span> </span>
<span id="cb83-62"><a href="#cb83-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>bel<span class="op">[</span>l<span class="op">]+</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;</span>bel<span class="op">[</span>r<span class="op">];</span>i<span class="op">++)</span></span>
<span id="cb83-63"><a href="#cb83-63" aria-hidden="true" tabindex="-1"></a>            ret <span class="op">+=</span> sum<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> tag<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> size<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb83-64"><a href="#cb83-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb83-65"><a href="#cb83-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb83-66"><a href="#cb83-66" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb83-67"><a href="#cb83-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-68"><a href="#cb83-68" aria-hidden="true" tabindex="-1"></a>BA ba<span class="op">;</span><span class="co">//注意，开了大数组，要声明在main函数外面，或者可以去用动态分配内存</span></span></code></pre></div>
<h2 id="平衡树pbds实现">平衡树（pbds实现）</h2>
<p>平衡树在ACM中用的极少，就不手搓了，大部分情况下都可以用set和pbds搞定。</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;ext/pb_ds/tree_policy.hpp&gt;</span><span class="pp"> </span><span class="co">//仅限g++可以使用</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> pbds <span class="op">=</span> __gnu_pbds<span class="op">;</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>pbds<span class="op">::</span>tree<span class="op">&lt;</span>LL<span class="op">,</span> pbds<span class="op">::</span><span class="dt">null_type</span><span class="op">,</span> <span class="bu">std::</span>less<span class="op">&lt;</span>LL<span class="op">&gt;,</span> </span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>           pbds<span class="op">::</span>rb_tree_tag<span class="op">,</span> pbds<span class="op">::</span>tree_order_statistics_node_update<span class="op">&gt;</span> <span class="fu">tr</span><span class="op">;</span></span></code></pre></div>
<p>声明如上，还是挺复杂的，但是ACM可以带资料所以不成问题。需要注意只能在g++上用，ACM赛场大多都有g++所以不是问题。</p>
<p><strong>模板参数解释</strong></p>
<p>LL是存储数据的类型；</p>
<p>pbds::null_type是映射规则（低版本g++为pbds::null_mapped_type，如果存入类型为std::map&lt;Key,Value&gt;则要填入Value）；</p>
<p>std::less&lt;LL&gt;则是我们选择大根还是小根；可选参数，默认为less</p>
<p>pbds::rb_tree_tag
则是我们选择的树的类型。总共有三种平衡树在pbds里，红黑树、splay、ov，但是后两个容易超时，一般不用。可选参数，默认为红黑树</p>
<p>pbds::tree_order_statistics_node_update是节点更新方法，如果使用order_of_key和find_by_key方法，则要用它。可选参数，但默认是null_node_update。</p>
<p><strong>方法</strong></p>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tr</span><span class="op">.</span>insert<span class="op">(</span>x<span class="op">);</span> <span class="co">//插入一个元素x，返回std::pair&lt;point_iterator, bool&gt;</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="co">//若成功，则是插入之后的迭代器和true，否则是x的迭代器和false</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="fu">tr</span><span class="op">.</span>erase<span class="op">(</span>x<span class="op">);</span>  <span class="co">//成功返回true，也可以把迭代器作为参数</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a><span class="fu">tr</span><span class="op">.</span>order_of_key<span class="op">(</span>x<span class="op">);</span>  <span class="co">//返回x的排名，0为第一名，x不一定要在树里</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a><span class="fu">tr</span><span class="op">.</span>find_by_order<span class="op">(</span>k<span class="op">);</span> <span class="co">//返回排名为k的元素的迭代器，0为第一名</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a><span class="fu">tr</span><span class="op">.</span>lower_bound<span class="op">(</span>x<span class="op">);</span>   <span class="co">//返回迭代器，这个函数不用多说了吧，和经常见到的一样</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a><span class="fu">tr</span><span class="op">.</span>upper_bound<span class="op">(</span>x<span class="op">);</span>   <span class="co">//返回迭代器</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a><span class="fu">tr</span><span class="op">.</span>join<span class="op">(</span>b<span class="op">);</span>          <span class="co">//将b树并入当前树，两棵树的类型要一样，不能有重复元素，b树将会被删除</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a><span class="fu">tr</span><span class="op">.</span>split<span class="op">(</span>x<span class="op">,</span>b<span class="op">);</span>       <span class="co">//小于等于x的保留在当前树，其他分给b树</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a><span class="fu">tr</span><span class="op">.</span>empty<span class="op">();</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a><span class="fu">tr</span><span class="op">.</span>size<span class="op">();</span></span></code></pre></div>
<p>以上操作均为O(logn)复杂度，除了最后两个是O(1)</p>
<p><strong>注意事项</strong></p>
<p>tree里面的元素是唯一的，有点类似与set。但我们并没有multi-tree去使用，做例如洛谷上的平衡树模板题，他要求元素可重复。此时我们有以下奇技淫巧</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>LL n<span class="op">;</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ope<span class="op">;</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    LL x<span class="op">;</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>ope<span class="op">&gt;&gt;</span>x<span class="op">;</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>ope<span class="op">==</span><span class="dv">1</span><span class="op">)</span> <span class="fu">tr</span><span class="op">.</span>insert<span class="op">((</span>x<span class="op">&lt;&lt;</span><span class="dv">20</span><span class="op">)+</span>i<span class="op">);</span></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>ope<span class="op">==</span><span class="dv">2</span><span class="op">)</span> <span class="fu">tr</span><span class="op">.</span>erase<span class="op">(</span><span class="fu">tr</span><span class="op">.</span>lower_bound<span class="op">(</span>x<span class="op">&lt;&lt;</span><span class="dv">20</span><span class="op">));</span></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>ope<span class="op">==</span><span class="dv">3</span><span class="op">)</span> <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="fu">tr</span><span class="op">.</span>order_of_key<span class="op">(</span>x<span class="op">&lt;&lt;</span><span class="dv">20</span><span class="op">)+</span><span class="dv">1</span><span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>ope<span class="op">==</span><span class="dv">4</span><span class="op">)</span> <span class="bu">std::</span>cout<span class="op">&lt;&lt;((*</span><span class="fu">tr</span><span class="op">.</span>find_by_order<span class="op">(</span>x<span class="op">-</span><span class="dv">1</span><span class="op">))&gt;&gt;</span><span class="dv">20</span><span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>ope<span class="op">==</span><span class="dv">5</span><span class="op">){</span></span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> it <span class="op">=</span> <span class="fu">tr</span><span class="op">.</span>lower_bound<span class="op">(</span>x<span class="op">&lt;&lt;</span><span class="dv">20</span><span class="op">);</span></span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>        it<span class="op">--;</span></span>
<span id="cb86-16"><a href="#cb86-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;((*</span>it<span class="op">)&gt;&gt;</span><span class="dv">20</span><span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb86-17"><a href="#cb86-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb86-18"><a href="#cb86-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span><span class="op">{</span></span>
<span id="cb86-19"><a href="#cb86-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> it <span class="op">=</span> <span class="fu">tr</span><span class="op">.</span>upper_bound<span class="op">((</span>x<span class="op">&lt;&lt;</span><span class="dv">20</span><span class="op">)+</span>n<span class="op">);</span></span>
<span id="cb86-20"><a href="#cb86-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;((*</span>it<span class="op">)&gt;&gt;</span><span class="dv">20</span><span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb86-21"><a href="#cb86-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb86-22"><a href="#cb86-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>假设有<span class="math inline">\(n\)</span>个操作，共<span class="math inline">\(6\)</span>种</p>
<ol type="1">
<li>插入<span class="math inline">\(x\)</span></li>
<li>删除<span class="math inline">\(x\)</span></li>
<li>查询<span class="math inline">\(x\)</span>的排名（比<span class="math inline">\(x\)</span>小的数的个数<span class="math inline">\(+1\)</span>）</li>
<li>查询排名为<span class="math inline">\(x\)</span>的数</li>
<li>求小于<span class="math inline">\(x\)</span>的最大的数</li>
<li>求大于<span class="math inline">\(x\)</span>的最小的数</li>
</ol>
<p>看代码，我们将<span class="math inline">\(x\)</span>左移20位，加上了操作序号，这样我们就可以实现可重复插入。只需要我们再最后把数字右移20位回来即可。erase注意是加入迭代器去erase，因为我们并没有等于x&lt;&lt;20的数字。最后一个操作，要<span class="math inline">\(+n\)</span>，来处理所有的相等的<span class="math inline">\(x\)</span></p>
<h2 id="字典树">01字典树</h2>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co">//01字典树，复杂度线性</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="co">//HDU4825</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">3500005</span><span class="op">;</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXBIT <span class="op">=</span> <span class="dv">35</span><span class="op">;</span><span class="co">//注意题目给的数据范围，这里2^32以下可以处理</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Trie<span class="op">{</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nxt<span class="op">[</span>MAXN<span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cnt<span class="op">;</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>    LL num<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> init<span class="op">(){</span></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;=</span>cnt<span class="op">;</span>i<span class="op">++)</span> <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span>j<span class="op">&lt;</span><span class="dv">2</span><span class="op">;</span>j<span class="op">++)</span> nxt<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;=</span>cnt<span class="op">;</span>i<span class="op">++)</span> num<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>        cnt <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> insert<span class="op">(</span>LL n<span class="op">){</span></span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">//插入一个自然数</span></span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cur <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span>LL i<span class="op">=</span>MAXBIT<span class="op">;</span>i<span class="op">&gt;=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">--){</span></span>
<span id="cb87-22"><a href="#cb87-22" aria-hidden="true" tabindex="-1"></a>            LL bit <span class="op">=</span> <span class="op">(</span>n<span class="op">&gt;&gt;</span>i<span class="op">)&amp;</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb87-23"><a href="#cb87-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(!</span>nxt<span class="op">[</span>cur<span class="op">][</span>bit<span class="op">]){</span></span>
<span id="cb87-24"><a href="#cb87-24" aria-hidden="true" tabindex="-1"></a>                nxt<span class="op">[</span>cur<span class="op">][</span>bit<span class="op">]</span> <span class="op">=</span> <span class="op">++</span>cnt<span class="op">;</span></span>
<span id="cb87-25"><a href="#cb87-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb87-26"><a href="#cb87-26" aria-hidden="true" tabindex="-1"></a>            cur <span class="op">=</span> nxt<span class="op">[</span>cur<span class="op">][</span>bit<span class="op">];</span></span>
<span id="cb87-27"><a href="#cb87-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb87-28"><a href="#cb87-28" aria-hidden="true" tabindex="-1"></a>        num<span class="op">[</span>cur<span class="op">]</span> <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb87-29"><a href="#cb87-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb87-30"><a href="#cb87-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb87-31"><a href="#cb87-31" aria-hidden="true" tabindex="-1"></a>    LL find_max<span class="op">(</span>LL x<span class="op">){</span></span>
<span id="cb87-32"><a href="#cb87-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">//查询x与数组内的所有数的异或的最大值</span></span>
<span id="cb87-33"><a href="#cb87-33" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cur<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb87-34"><a href="#cb87-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>MAXBIT<span class="op">;</span>i<span class="op">&gt;=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">--){</span></span>
<span id="cb87-35"><a href="#cb87-35" aria-hidden="true" tabindex="-1"></a>            LL bit <span class="op">=</span> <span class="op">(</span>x<span class="op">&gt;&gt;</span>i<span class="op">)&amp;</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb87-36"><a href="#cb87-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>nxt<span class="op">[</span>cur<span class="op">][</span>bit<span class="op">^</span><span class="dv">1</span><span class="op">])</span><span class="co">//尽量走与当前位不同的路径，最小值应改为走相同的</span></span>
<span id="cb87-37"><a href="#cb87-37" aria-hidden="true" tabindex="-1"></a>                cur <span class="op">=</span> nxt<span class="op">[</span>cur<span class="op">][</span>bit<span class="op">^</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb87-38"><a href="#cb87-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb87-39"><a href="#cb87-39" aria-hidden="true" tabindex="-1"></a>                cur <span class="op">=</span> nxt<span class="op">[</span>cur<span class="op">][</span>bit<span class="op">];</span></span>
<span id="cb87-40"><a href="#cb87-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb87-41"><a href="#cb87-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x<span class="op">^</span>num<span class="op">[</span>cur<span class="op">];</span></span>
<span id="cb87-42"><a href="#cb87-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb87-43"><a href="#cb87-43" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb87-44"><a href="#cb87-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-45"><a href="#cb87-45" aria-hidden="true" tabindex="-1"></a>Trie trie<span class="op">;</span></span></code></pre></div>
<p>可以通过01Trie来计算连续区间的异或最大值。要用到一个性质：</p>
<p><span class="math display">\[
a\oplus b\oplus b = a
\]</span></p>
<p>也就是说，我们可以把异或前缀全部插入到Trie里，然后以第i个数为结尾的区间的最大异或值就是find_max(pre[i])。注意特殊处理长度为1的区间。</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>LL ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>arr<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>arr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span>arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>    arr<span class="op">[</span>i<span class="op">]</span> <span class="op">^=</span> arr<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">];</span> </span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>trie<span class="op">.</span>insert<span class="op">(</span><span class="dv">0</span><span class="op">);</span><span class="co">//注意要先插入一个0</span></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>    ans <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>ans<span class="op">,</span>trie<span class="op">.</span>find_max<span class="op">(</span>arr<span class="op">[</span>i<span class="op">]));</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>    trie<span class="op">.</span>insert<span class="op">(</span>arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span></code></pre></div>
<h2 id="对顶堆">对顶堆</h2>
<div class="sourceCode" id="cb89"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="co">//动态维护一个集合的第k大数，每次操作logn</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a><span class="co">//spoj RMID2</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a><span class="co">//维护第k小只要维护第n-k大即可</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a><span class="co">//另外这个k是可以变化的，不需要固定，复杂度确实是logn</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> KthLargest<span class="op">{</span></span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>priority_queue<span class="op">&lt;</span>T<span class="op">,</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;,</span><span class="bu">std::</span>less<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&gt;</span> big<span class="op">{};</span></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>priority_queue<span class="op">&lt;</span>T<span class="op">,</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;,</span><span class="bu">std::</span>greater<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&gt;</span> small<span class="op">{};</span></span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> kth<span class="op">{};</span></span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> size<span class="op">{};</span></span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-19"><a href="#cb89-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> update<span class="op">(){</span></span>
<span id="cb89-20"><a href="#cb89-20" aria-hidden="true" tabindex="-1"></a>        kth <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>kth<span class="op">,</span>size<span class="op">);</span></span>
<span id="cb89-21"><a href="#cb89-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>kth<span class="op">&lt;</span>small<span class="op">.</span>size<span class="op">()){</span></span>
<span id="cb89-22"><a href="#cb89-22" aria-hidden="true" tabindex="-1"></a>            big<span class="op">.</span>push<span class="op">(</span>small<span class="op">.</span>top<span class="op">());</span></span>
<span id="cb89-23"><a href="#cb89-23" aria-hidden="true" tabindex="-1"></a>            small<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb89-24"><a href="#cb89-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb89-25"><a href="#cb89-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>kth<span class="op">&gt;</span>small<span class="op">.</span>size<span class="op">()){</span></span>
<span id="cb89-26"><a href="#cb89-26" aria-hidden="true" tabindex="-1"></a>            small<span class="op">.</span>push<span class="op">(</span>big<span class="op">.</span>top<span class="op">());</span></span>
<span id="cb89-27"><a href="#cb89-27" aria-hidden="true" tabindex="-1"></a>            big<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb89-28"><a href="#cb89-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb89-29"><a href="#cb89-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb89-30"><a href="#cb89-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-31"><a href="#cb89-31" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb89-32"><a href="#cb89-32" aria-hidden="true" tabindex="-1"></a>    KthLargest<span class="op">():</span>kth<span class="op">(</span><span class="dv">1</span><span class="op">),</span>size<span class="op">(</span><span class="dv">0</span><span class="op">){}</span></span>
<span id="cb89-33"><a href="#cb89-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-34"><a href="#cb89-34" aria-hidden="true" tabindex="-1"></a>    T findK<span class="op">(</span><span class="dt">size_t</span> k<span class="op">){</span></span>
<span id="cb89-35"><a href="#cb89-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">//找到第k大的数字</span></span>
<span id="cb89-36"><a href="#cb89-36" aria-hidden="true" tabindex="-1"></a>        kth <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb89-37"><a href="#cb89-37" aria-hidden="true" tabindex="-1"></a>        update<span class="op">();</span></span>
<span id="cb89-38"><a href="#cb89-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> small<span class="op">.</span>top<span class="op">();</span></span>
<span id="cb89-39"><a href="#cb89-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb89-40"><a href="#cb89-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-41"><a href="#cb89-41" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> eraseK<span class="op">(</span><span class="dt">size_t</span> k<span class="op">){</span></span>
<span id="cb89-42"><a href="#cb89-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">//移除第k大的数字</span></span>
<span id="cb89-43"><a href="#cb89-43" aria-hidden="true" tabindex="-1"></a>        kth <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb89-44"><a href="#cb89-44" aria-hidden="true" tabindex="-1"></a>        update<span class="op">();</span></span>
<span id="cb89-45"><a href="#cb89-45" aria-hidden="true" tabindex="-1"></a>        small<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb89-46"><a href="#cb89-46" aria-hidden="true" tabindex="-1"></a>        size<span class="op">--;</span></span>
<span id="cb89-47"><a href="#cb89-47" aria-hidden="true" tabindex="-1"></a>        update<span class="op">();</span></span>
<span id="cb89-48"><a href="#cb89-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb89-49"><a href="#cb89-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-50"><a href="#cb89-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> insert<span class="op">(</span>T x<span class="op">){</span></span>
<span id="cb89-51"><a href="#cb89-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">//插入一个数字</span></span>
<span id="cb89-52"><a href="#cb89-52" aria-hidden="true" tabindex="-1"></a>        size<span class="op">++;</span></span>
<span id="cb89-53"><a href="#cb89-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>small<span class="op">.</span>empty<span class="op">()</span> <span class="op">||</span> x<span class="op">&gt;=</span>small<span class="op">.</span>top<span class="op">()){</span></span>
<span id="cb89-54"><a href="#cb89-54" aria-hidden="true" tabindex="-1"></a>            small<span class="op">.</span>push<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb89-55"><a href="#cb89-55" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb89-56"><a href="#cb89-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb89-57"><a href="#cb89-57" aria-hidden="true" tabindex="-1"></a>            big<span class="op">.</span>push<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb89-58"><a href="#cb89-58" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb89-59"><a href="#cb89-59" aria-hidden="true" tabindex="-1"></a>        update<span class="op">();</span></span>
<span id="cb89-60"><a href="#cb89-60" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb89-61"><a href="#cb89-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-62"><a href="#cb89-62" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> getSize<span class="op">(){</span></span>
<span id="cb89-63"><a href="#cb89-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> size<span class="op">;</span></span>
<span id="cb89-64"><a href="#cb89-64" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb89-65"><a href="#cb89-65" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb89-66"><a href="#cb89-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-67"><a href="#cb89-67" aria-hidden="true" tabindex="-1"></a>KthLargest<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ddd<span class="op">;</span></span></code></pre></div>
<h2 id="单调栈">单调栈</h2>
<div class="sourceCode" id="cb90"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="co">//单调栈 luogu p5788</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="co">//本题定义f[i]为数列中第i个元素之后第一个大于a[i]的元素的下标（不存在则为0）</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="co">//很显然我们可以维护一个单调不增的栈</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a><span class="co">//当push的元素x大于栈顶t时，第一个大于t的元素就是x。反复出栈直到栈顶t小于等于x或栈空，入栈。</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 n</span></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> arr<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ans<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> stk<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>arr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb90-17"><a href="#cb90-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-18"><a href="#cb90-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> top <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb90-19"><a href="#cb90-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-20"><a href="#cb90-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb90-21"><a href="#cb90-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>top<span class="op">&amp;&amp;</span>arr<span class="op">[</span>stk<span class="op">[</span>top<span class="op">]]&lt;</span>arr<span class="op">[</span>i<span class="op">]){</span></span>
<span id="cb90-22"><a href="#cb90-22" aria-hidden="true" tabindex="-1"></a>            ans<span class="op">[</span>stk<span class="op">[</span>top<span class="op">]]</span> <span class="op">=</span> i<span class="op">;</span><span class="co">//这一行是具体的操作，因题而异；而其他行在这个for循环里都是固定的</span></span>
<span id="cb90-23"><a href="#cb90-23" aria-hidden="true" tabindex="-1"></a>            top<span class="op">--;</span></span>
<span id="cb90-24"><a href="#cb90-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb90-25"><a href="#cb90-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-26"><a href="#cb90-26" aria-hidden="true" tabindex="-1"></a>        stk<span class="op">[++</span>top<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb90-27"><a href="#cb90-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb90-28"><a href="#cb90-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-29"><a href="#cb90-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb90-30"><a href="#cb90-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">[</span>i<span class="op">]&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span></span>
<span id="cb90-31"><a href="#cb90-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb90-32"><a href="#cb90-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-33"><a href="#cb90-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb90-34"><a href="#cb90-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="单调队列">单调队列</h2>
<div class="sourceCode" id="cb91"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="co">//单调队列，luogu1886</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="co">//本题是滑动窗口，即在长度为n的数组中，给出一个长度为k的连续区间，从左向右滑动，求每个区间中的最大值和最小值</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="co">//求最小值时，我们可以维护一个单增的双端队列。x加入队尾时，如果队尾元素b&gt;=x，则把队尾弹出，直到b&lt;x或者栈空时把x入队。</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="co">//因为我们的区间长度有限，每次我们的区间左端点向右枚举+1时，判断队首元素的下标，如果小于区间左端点，就出队。</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a><span class="co">//之后留在队首的元素就是区间最小值</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a><span class="co">//具体可见代码。最大值维护同理。</span></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度n</span></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> arr<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>k<span class="op">;</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>k<span class="op">;</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>arr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>deque<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dq<span class="op">;</span></span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;</span>k<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(!</span>dq<span class="op">.</span>empty<span class="op">()&amp;&amp;</span>arr<span class="op">[</span>dq<span class="op">.</span>back<span class="op">()]&gt;=</span>arr<span class="op">[</span>i<span class="op">])</span> dq<span class="op">.</span>pop_back<span class="op">();</span></span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a>        dq<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-26"><a href="#cb91-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>k<span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb91-27"><a href="#cb91-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(!</span>dq<span class="op">.</span>empty<span class="op">()&amp;&amp;</span>arr<span class="op">[</span>dq<span class="op">.</span>back<span class="op">()]&gt;=</span>arr<span class="op">[</span>i<span class="op">])</span> dq<span class="op">.</span>pop_back<span class="op">();</span></span>
<span id="cb91-28"><a href="#cb91-28" aria-hidden="true" tabindex="-1"></a>        dq<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb91-29"><a href="#cb91-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>dq<span class="op">.</span>front<span class="op">()&lt;=</span>i<span class="op">-</span>k<span class="op">)</span> dq<span class="op">.</span>pop_front<span class="op">();</span></span>
<span id="cb91-30"><a href="#cb91-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>arr<span class="op">[</span>dq<span class="op">.</span>front<span class="op">()]&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span><span class="co">//输出最小值</span></span>
<span id="cb91-31"><a href="#cb91-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb91-32"><a href="#cb91-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-33"><a href="#cb91-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb91-34"><a href="#cb91-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-35"><a href="#cb91-35" aria-hidden="true" tabindex="-1"></a>    dq<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb91-36"><a href="#cb91-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-37"><a href="#cb91-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;</span>k<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb91-38"><a href="#cb91-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(!</span>dq<span class="op">.</span>empty<span class="op">()&amp;&amp;</span>arr<span class="op">[</span>dq<span class="op">.</span>back<span class="op">()]&lt;=</span>arr<span class="op">[</span>i<span class="op">])</span> dq<span class="op">.</span>pop_back<span class="op">();</span></span>
<span id="cb91-39"><a href="#cb91-39" aria-hidden="true" tabindex="-1"></a>        dq<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb91-40"><a href="#cb91-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb91-41"><a href="#cb91-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-42"><a href="#cb91-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>k<span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb91-43"><a href="#cb91-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(!</span>dq<span class="op">.</span>empty<span class="op">()&amp;&amp;</span>arr<span class="op">[</span>dq<span class="op">.</span>back<span class="op">()]&lt;=</span>arr<span class="op">[</span>i<span class="op">])</span> dq<span class="op">.</span>pop_back<span class="op">();</span></span>
<span id="cb91-44"><a href="#cb91-44" aria-hidden="true" tabindex="-1"></a>        dq<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb91-45"><a href="#cb91-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>dq<span class="op">.</span>front<span class="op">()&lt;=</span>i<span class="op">-</span>k<span class="op">)</span> dq<span class="op">.</span>pop_front<span class="op">();</span></span>
<span id="cb91-46"><a href="#cb91-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>arr<span class="op">[</span>dq<span class="op">.</span>front<span class="op">()]&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span><span class="co">//输出最大值</span></span>
<span id="cb91-47"><a href="#cb91-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb91-48"><a href="#cb91-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-49"><a href="#cb91-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb91-50"><a href="#cb91-50" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="st表">ST表</h2>
<p>对于经典的RMQ（即给定一个数组，求区间内的最大值）问题，有如下代码</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 单次查询 logn 预处理 nlogn</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P3865</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="co">//查询区间最大值</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="co">//也可以查询其他可重复贡献问题的信息</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a><span class="co">//可重复贡献指对于运算op，满足x op x = x。这样的运算有最大最小、gcd等。但显然求和不是。</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a><span class="co">//另外op还必须满足结合律。</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">100005</span><span class="op">;</span></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> LOGN <span class="op">=</span> <span class="dv">21</span><span class="op">;</span></span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fmax<span class="op">[</span>MAXN<span class="op">][</span>LOGN<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a><span class="co">//fmax[a][b]表示[a,a+2^b-1]中的最大值</span></span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> logn<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb92-17"><a href="#cb92-17" aria-hidden="true" tabindex="-1"></a><span class="co">//预先计算logn</span></span>
<span id="cb92-18"><a href="#cb92-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-19"><a href="#cb92-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb92-20"><a href="#cb92-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span></span>
<span id="cb92-21"><a href="#cb92-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">//数组大小以及查询次数</span></span>
<span id="cb92-22"><a href="#cb92-22" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">&#34;</span><span class="sc">%d%d</span><span class="st">&#34;</span><span class="op">,&amp;</span>n<span class="op">,&amp;</span>m<span class="op">);</span></span>
<span id="cb92-23"><a href="#cb92-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-24"><a href="#cb92-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb92-25"><a href="#cb92-25" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">&#34;</span><span class="sc">%d</span><span class="st">&#34;</span><span class="op">,&amp;</span>fmax<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb92-26"><a href="#cb92-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb92-27"><a href="#cb92-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-28"><a href="#cb92-28" aria-hidden="true" tabindex="-1"></a>    logn<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb92-29"><a href="#cb92-29" aria-hidden="true" tabindex="-1"></a>    logn<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb92-30"><a href="#cb92-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-31"><a href="#cb92-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">3</span><span class="op">;</span>i<span class="op">&lt;</span>MAXN<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb92-32"><a href="#cb92-32" aria-hidden="true" tabindex="-1"></a>        logn<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> logn<span class="op">[</span>i<span class="op">/</span><span class="dv">2</span><span class="op">]+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb92-33"><a href="#cb92-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">//预先计算logn</span></span>
<span id="cb92-34"><a href="#cb92-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb92-35"><a href="#cb92-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-36"><a href="#cb92-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>LOGN<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb92-37"><a href="#cb92-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">+(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>j<span class="op">)-</span><span class="dv">1</span><span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb92-38"><a href="#cb92-38" aria-hidden="true" tabindex="-1"></a>            fmax<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>fmax<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">],</span>fmax<span class="op">[</span>i<span class="op">+(</span><span class="dv">1</span><span class="op">&lt;&lt;(</span>j<span class="op">-</span><span class="dv">1</span><span class="op">))][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb92-39"><a href="#cb92-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb92-40"><a href="#cb92-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb92-41"><a href="#cb92-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-42"><a href="#cb92-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb92-43"><a href="#cb92-43" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a<span class="op">,</span>b<span class="op">;</span></span>
<span id="cb92-44"><a href="#cb92-44" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">&#34;</span><span class="sc">%d%d</span><span class="st">&#34;</span><span class="op">,&amp;</span>a<span class="op">,&amp;</span>b<span class="op">);</span></span>
<span id="cb92-45"><a href="#cb92-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">//查询[a,b]分为两部分，即[a,a+2^s-1]与[b-2^s+1,b]</span></span>
<span id="cb92-46"><a href="#cb92-46" aria-hidden="true" tabindex="-1"></a>        <span class="co">//完全不用担心这两个范围重叠，因为是求max</span></span>
<span id="cb92-47"><a href="#cb92-47" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> s <span class="op">=</span> logn<span class="op">[</span>b<span class="op">-</span>a<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb92-48"><a href="#cb92-48" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&#34;</span><span class="sc">%d\n</span><span class="st">&#34;</span><span class="op">,</span><span class="bu">std::</span>max<span class="op">(</span>fmax<span class="op">[</span>a<span class="op">][</span>s<span class="op">],</span>fmax<span class="op">[</span>b<span class="op">-(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>s<span class="op">)+</span><span class="dv">1</span><span class="op">][</span>s<span class="op">]));</span></span>
<span id="cb92-49"><a href="#cb92-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb92-50"><a href="#cb92-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-51"><a href="#cb92-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb92-52"><a href="#cb92-52" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="二分">二分</h1>
<h2 id="二分答案">二分答案</h2>
<p>给出一个通用代码</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> l <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> r <span class="op">=</span> MAXR<span class="op">;</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span><span class="op">(</span>l<span class="op">+</span><span class="dv">1</span><span class="op">&lt;</span>r<span class="op">){</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> mid <span class="op">=</span> <span class="op">(</span>l<span class="op">+</span>r<span class="op">)&gt;&gt;</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>judge<span class="op">(</span>mid<span class="op">))</span> l<span class="op">=</span>mid<span class="op">;</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> r <span class="op">=</span> mid<span class="op">;</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>judge<span class="op">(</span>l<span class="op">))</span> <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>l<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>r<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span></code></pre></div>
<p>当验证一个情况是否能满足题目的复杂度小于等于<span class="math inline">\(O(n)\)</span>，而且这些情况具有单调性（即例如若x&gt;y，x不能满足，则y一定不能满足）时，就可以通过二分去得到最符合题意的答案。二分这些情况的复杂度为<span class="math inline">\(O(\log
n)\)</span>，再乘上验证情况的复杂度得到总的复杂度。</p>
<p>judge函数应该根据题意写出。</p>
<p>如果是浮点数的二分，则不推荐使用EPS进行精度判断（有可能会丢精度）。而是使用计数器，一般迭代100次就能保证符合题目要求。</p>
<h2 id="二分查找">二分查找</h2>
<p>通常是在排好序上的数组中，查找第一个大于（或大于等于）x的元素。见STL用法中的lower_bound和upper_bound。每次查找的复杂度是logn</p>
<h2 id="二分求单调函数零点">二分求单调函数零点</h2>
<p>设函数<span class="math inline">\(f\)</span>在<span class="math inline">\([l,r]\)</span>上严格单调，<span class="math inline">\(mid=(l+r)/2\)</span>，显然有<span class="math inline">\(f(l)f(r)&lt;0\)</span>。迭代中，若<span class="math inline">\(f(l)f(mid)&lt;0\)</span>，则<span class="math inline">\(r=mid\)</span>，否则<span class="math inline">\(l=mid\)</span>。直到<span class="math inline">\(f(mid)=0\)</span>或者<span class="math inline">\(r-l&lt;EPS\)</span>或者迭代次数达到要求。收敛速度是线性收敛。</p>
<h1 id="三分法">三分法</h1>
<h2 id="三分法求单峰函数的极值点">三分法求单峰函数的极值点</h2>
<p>用二分求函数的导数的零点也可以，但是并不是每次都可以方便的求出导数。三分法可以不用求出导数。</p>
<p>设函数<span class="math inline">\(f\)</span>在<span class="math inline">\([l,r]\)</span>上单峰，意味着有且只有一个极大值<span class="math inline">\(x\)</span>，<span class="math inline">\(f\)</span>在<span class="math inline">\([l,x]\)</span>上严格单增，在<span class="math inline">\([x,r]\)</span>上严格单减。单谷函数则为极小值<span class="math inline">\(x\)</span>。</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="co">//三分法求单峰函数的极值点 luogu p3382</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="co">//收敛速度是线性收敛</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="co">//用二分求函数的导数的零点也可以，但是并不是每次都可以方便的求出导数。三分法可以不用求出导数。</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="co">//设函数f在[l,r]上单峰，意味着有且只有一个极大值x，f在[l,x]上严格单增，在[x,r]上严格单减。单谷函数则为极小值x。</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a><span class="co">//在[l,r]上取两个不等的点，设靠近l的是l1，靠近r的是r1。如果f(l1)&lt;f(r1)，说明极大值一定在[l1,r]，令l=l1</span></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a><span class="co">//如果f(l1)&gt;f(r1)，极大值一定在[l,r1]，令r=r1</span></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a><span class="co">//持续下去直到r-l&lt;EPS或者迭代次数足够</span></span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a><span class="co">//取l1和r1时，可以直接取三等分点，也可以取黄金分割点(l1=l+(r-l)(1-0.618),r1=r-(r-l)*(1-0.618))</span></span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a><span class="co">//还可以让l1=mid-EPS, r1=mid-EPS，但是要令l=mid而不是l=l1，防止死循环</span></span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> DB <span class="op">=</span> <span class="dt">double</span><span class="op">;</span></span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true" tabindex="-1"></a>DB <span class="at">const</span> EPS <span class="op">=</span> <span class="fl">1e-8</span><span class="op">;</span></span>
<span id="cb94-15"><a href="#cb94-15" aria-hidden="true" tabindex="-1"></a>DB l<span class="op">,</span>r<span class="op">;</span></span>
<span id="cb94-16"><a href="#cb94-16" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>l<span class="op">&gt;&gt;</span>r<span class="op">;</span></span>
<span id="cb94-17"><a href="#cb94-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-18"><a href="#cb94-18" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span><span class="op">(</span>r<span class="op">-</span>l<span class="op">&gt;</span>EPS<span class="op">){</span></span>
<span id="cb94-19"><a href="#cb94-19" aria-hidden="true" tabindex="-1"></a>    DB mid <span class="op">=</span> <span class="op">(</span>l<span class="op">+</span>r<span class="op">)/</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb94-20"><a href="#cb94-20" aria-hidden="true" tabindex="-1"></a>    DB f1 <span class="op">=</span> func<span class="op">(</span>mid<span class="op">-</span>EPS<span class="op">),</span> f2 <span class="op">=</span> func<span class="op">(</span>mid<span class="op">+</span>EPS<span class="op">);</span><span class="co">//func根据题目要求定义，是一元函数</span></span>
<span id="cb94-21"><a href="#cb94-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>f1<span class="op">&lt;</span>f2<span class="op">)</span></span>
<span id="cb94-22"><a href="#cb94-22" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> mid<span class="op">;</span></span>
<span id="cb94-23"><a href="#cb94-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb94-24"><a href="#cb94-24" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> mid<span class="op">;</span></span>
<span id="cb94-25"><a href="#cb94-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="三分套三分">三分套三分</h2>
<p>例如Luogu
P2571，这是一个二元函数要求最小值。我们发现这个函数在固定<span class="math inline">\(x\)</span>的时候<span class="math inline">\(y\)</span>是单谷的，固定<span class="math inline">\(y\)</span>的时候<span class="math inline">\(x\)</span>是单谷的。所以我们可以先三分一个变量，再固定这个变量三分另一个变量，最后得出答案。</p>
<p>注意，三分套三分是指不能先假设一个<span class="math inline">\(y\)</span>的定值，再三分<span class="math inline">\(x\)</span>，然后拿着计算出的<span class="math inline">\(x\)</span>再去三分<span class="math inline">\(y\)</span>。应当在三分<span class="math inline">\(x\)</span>的过程中，把<span class="math inline">\(x\)</span>当作参数，传入三分<span class="math inline">\(y\)</span>的函数中。它们不是先后关系，而是嵌套关系。</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> func <span class="op">=</span> <span class="op">[&amp;](</span>DB x<span class="op">,</span> DB y<span class="op">){</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">//这里是函数定义</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> sfy <span class="op">=</span> <span class="op">[&amp;](</span>DB x<span class="op">){</span><span class="co">//固定x，三分y</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>    DB ret <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>    DB l <span class="op">=</span> <span class="fl">0.0</span><span class="op">,</span> r <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>r<span class="op">-</span>l<span class="op">&gt;</span>EPS<span class="op">){</span></span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>        DB delta <span class="op">=</span> <span class="op">(</span>r<span class="op">-</span>l<span class="op">)/</span><span class="fl">3.0</span><span class="op">;</span></span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>        DB f1 <span class="op">=</span> func<span class="op">(</span>x<span class="op">,</span>l<span class="op">+</span>delta<span class="op">),</span> f2 <span class="op">=</span> func<span class="op">(</span>x<span class="op">,</span>r<span class="op">-</span>delta<span class="op">);</span></span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>f1<span class="op">&gt;</span>f2<span class="op">)</span></span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>            l <span class="op">=</span> l<span class="op">+</span>delta<span class="op">;</span></span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> r<span class="op">-</span>delta<span class="op">;</span></span>
<span id="cb95-15"><a href="#cb95-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb95-16"><a href="#cb95-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> func<span class="op">(</span>x<span class="op">,</span>l<span class="op">);</span></span>
<span id="cb95-17"><a href="#cb95-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb95-18"><a href="#cb95-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-19"><a href="#cb95-19" aria-hidden="true" tabindex="-1"></a>DB l<span class="op">=</span><span class="fl">0.0</span><span class="op">,</span>r<span class="op">=</span><span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb95-20"><a href="#cb95-20" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span><span class="op">(</span>r<span class="op">-</span>l<span class="op">&gt;</span>EPS<span class="op">){</span><span class="co">//三分x</span></span>
<span id="cb95-21"><a href="#cb95-21" aria-hidden="true" tabindex="-1"></a>    DB delta <span class="op">=</span> <span class="op">(</span>r<span class="op">-</span>l<span class="op">)/</span><span class="fl">3.0</span><span class="op">;</span></span>
<span id="cb95-22"><a href="#cb95-22" aria-hidden="true" tabindex="-1"></a>    DB f1 <span class="op">=</span> sfy<span class="op">(</span>l<span class="op">+</span>delta<span class="op">),</span> f2 <span class="op">=</span> sfy<span class="op">(</span>r<span class="op">-</span>delta<span class="op">);</span></span>
<span id="cb95-23"><a href="#cb95-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>f1<span class="op">&gt;</span>f2<span class="op">)</span></span>
<span id="cb95-24"><a href="#cb95-24" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> l<span class="op">+</span>delta<span class="op">;</span></span>
<span id="cb95-25"><a href="#cb95-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb95-26"><a href="#cb95-26" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> r<span class="op">-</span>delta<span class="op">;</span></span>
<span id="cb95-27"><a href="#cb95-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb95-28"><a href="#cb95-28" aria-hidden="true" tabindex="-1"></a><span class="co">//最后的答案是sfy(l)</span></span></code></pre></div>
<h2 id="三分答案-todo">三分答案 TODO</h2>
<h1 id="动态规划">动态规划</h1>
<h2 id="背包">01背包</h2>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 nW</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P1048</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">1005</span><span class="op">;</span></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> w<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> v<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb96-15"><a href="#cb96-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>W<span class="op">;</span><span class="co">//物品数，背包大小</span></span>
<span id="cb96-16"><a href="#cb96-16" aria-hidden="true" tabindex="-1"></a>    cin<span class="op">&gt;&gt;</span>W<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb96-17"><a href="#cb96-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb96-18"><a href="#cb96-18" aria-hidden="true" tabindex="-1"></a>        cin<span class="op">&gt;&gt;</span>w<span class="op">[</span>i<span class="op">]&gt;&gt;</span>v<span class="op">[</span>i<span class="op">];</span><span class="co">//物品体积，物品价值</span></span>
<span id="cb96-19"><a href="#cb96-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb96-20"><a href="#cb96-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb96-21"><a href="#cb96-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span>W<span class="op">;</span>j<span class="op">&gt;=</span>w<span class="op">[</span>i<span class="op">];</span>j<span class="op">--){</span></span>
<span id="cb96-22"><a href="#cb96-22" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span>dp<span class="op">[</span>j<span class="op">-</span>w<span class="op">[</span>i<span class="op">]]+</span>v<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb96-23"><a href="#cb96-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb96-24"><a href="#cb96-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb96-25"><a href="#cb96-25" aria-hidden="true" tabindex="-1"></a>    cout<span class="op">&lt;&lt;</span>dp<span class="op">[</span>W<span class="op">]&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb96-26"><a href="#cb96-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb96-27"><a href="#cb96-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="完全背包">完全背包</h2>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 nW</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P1616</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">10007</span><span class="op">;</span></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXW <span class="op">=</span> <span class="dv">10000007</span><span class="op">;</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL<span class="op">;</span></span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a>LL dp<span class="op">[</span>MAXW<span class="op">];</span></span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> w<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> v<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb97-17"><a href="#cb97-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>W<span class="op">;</span><span class="co">//物品数，背包大小</span></span>
<span id="cb97-18"><a href="#cb97-18" aria-hidden="true" tabindex="-1"></a>    cin<span class="op">&gt;&gt;</span>W<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb97-19"><a href="#cb97-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb97-20"><a href="#cb97-20" aria-hidden="true" tabindex="-1"></a>        cin<span class="op">&gt;&gt;</span>w<span class="op">[</span>i<span class="op">]&gt;&gt;</span>v<span class="op">[</span>i<span class="op">];</span><span class="co">//物品体积，物品价值</span></span>
<span id="cb97-21"><a href="#cb97-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb97-22"><a href="#cb97-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb97-23"><a href="#cb97-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span>w<span class="op">[</span>i<span class="op">];</span>j<span class="op">&lt;=</span>W<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb97-24"><a href="#cb97-24" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span>dp<span class="op">[</span>j<span class="op">-</span>w<span class="op">[</span>i<span class="op">]]+</span>v<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb97-25"><a href="#cb97-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb97-26"><a href="#cb97-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb97-27"><a href="#cb97-27" aria-hidden="true" tabindex="-1"></a>    cout<span class="op">&lt;&lt;</span>dp<span class="op">[</span>W<span class="op">]&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb97-28"><a href="#cb97-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb97-29"><a href="#cb97-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="多重背包">多重背包</h2>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度 Wsum(logk_i) </span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P1776</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a><span class="co">//即每种物品有ki个</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a><span class="co">//我们可以简单转化为01背包，但是复杂度太高；采用二进制分组的思想</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">100007</span><span class="op">;</span></span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXW <span class="op">=</span> <span class="dv">40007</span><span class="op">;</span></span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> LL<span class="op">;</span></span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb98-13"><a href="#cb98-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-14"><a href="#cb98-14" aria-hidden="true" tabindex="-1"></a>LL dp<span class="op">[</span>MAXW<span class="op">];</span></span>
<span id="cb98-15"><a href="#cb98-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> w<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb98-16"><a href="#cb98-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> v<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb98-17"><a href="#cb98-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-18"><a href="#cb98-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb98-19"><a href="#cb98-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m<span class="op">,</span>W<span class="op">;</span><span class="co">//物品种类数，背包大小</span></span>
<span id="cb98-20"><a href="#cb98-20" aria-hidden="true" tabindex="-1"></a>    cin<span class="op">&gt;&gt;</span>m<span class="op">&gt;&gt;</span>W<span class="op">;</span></span>
<span id="cb98-21"><a href="#cb98-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb98-22"><a href="#cb98-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb98-23"><a href="#cb98-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> c <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb98-24"><a href="#cb98-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> p<span class="op">,</span>h<span class="op">,</span>k<span class="op">;</span><span class="co">//物品价值，物品体积，物品数量</span></span>
<span id="cb98-25"><a href="#cb98-25" aria-hidden="true" tabindex="-1"></a>        cin<span class="op">&gt;&gt;</span>p<span class="op">&gt;&gt;</span>h<span class="op">&gt;&gt;</span>k<span class="op">;</span></span>
<span id="cb98-26"><a href="#cb98-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>k<span class="op">&gt;</span>c<span class="op">){</span></span>
<span id="cb98-27"><a href="#cb98-27" aria-hidden="true" tabindex="-1"></a>            k <span class="op">-=</span> c<span class="op">;</span></span>
<span id="cb98-28"><a href="#cb98-28" aria-hidden="true" tabindex="-1"></a>            v<span class="op">[++</span>n<span class="op">]</span> <span class="op">=</span> c<span class="op">*</span>p<span class="op">;</span></span>
<span id="cb98-29"><a href="#cb98-29" aria-hidden="true" tabindex="-1"></a>            w<span class="op">[</span>n<span class="op">]</span> <span class="op">=</span> c<span class="op">*</span>h<span class="op">;</span></span>
<span id="cb98-30"><a href="#cb98-30" aria-hidden="true" tabindex="-1"></a>            c <span class="op">*=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb98-31"><a href="#cb98-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb98-32"><a href="#cb98-32" aria-hidden="true" tabindex="-1"></a>        v<span class="op">[++</span>n<span class="op">]</span> <span class="op">=</span> p<span class="op">*</span>k<span class="op">;</span></span>
<span id="cb98-33"><a href="#cb98-33" aria-hidden="true" tabindex="-1"></a>        w<span class="op">[</span>n<span class="op">]</span> <span class="op">=</span> h<span class="op">*</span>k<span class="op">;</span></span>
<span id="cb98-34"><a href="#cb98-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb98-35"><a href="#cb98-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb98-36"><a href="#cb98-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span>W<span class="op">;</span>j<span class="op">&gt;=</span>w<span class="op">[</span>i<span class="op">];</span>j<span class="op">--){</span></span>
<span id="cb98-37"><a href="#cb98-37" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span>dp<span class="op">[</span>j<span class="op">-</span>w<span class="op">[</span>i<span class="op">]]+</span>v<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb98-38"><a href="#cb98-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb98-39"><a href="#cb98-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb98-40"><a href="#cb98-40" aria-hidden="true" tabindex="-1"></a>    cout<span class="op">&lt;&lt;</span>dp<span class="op">[</span>W<span class="op">]&lt;&lt;</span>endl<span class="op">;</span></span>
<span id="cb98-41"><a href="#cb98-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb98-42"><a href="#cb98-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="分组背包">分组背包</h2>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="co">//分组背包 复杂度=组数*背包容量*组内个数最大值</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p1757</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a><span class="co">//有g个组，每组物品有group[i].size()个，每个物品有价值v和体积w，总共n个物品，背包体积为m。每个组最多只能拿一个物品出来，求最大价值。</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> MAXN <span class="op">=</span> <span class="dv">1005</span><span class="op">;</span></span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> group<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//存储每一组的物品序号</span></span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> v<span class="op">[</span>MAXN<span class="op">],</span>w<span class="op">[</span>MAXN<span class="op">];</span><span class="co">//物品价值和体积</span></span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-15"><a href="#cb99-15" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">(){</span></span>
<span id="cb99-16"><a href="#cb99-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span></span>
<span id="cb99-17"><a href="#cb99-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>m<span class="op">&gt;&gt;</span>n<span class="op">;</span><span class="co">//背包容量;n件物品</span></span>
<span id="cb99-18"><a href="#cb99-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb99-19"><a href="#cb99-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb99-20"><a href="#cb99-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a<span class="op">,</span>b<span class="op">,</span>c<span class="op">;</span></span>
<span id="cb99-21"><a href="#cb99-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>a<span class="op">&gt;&gt;</span>b<span class="op">&gt;&gt;</span>c<span class="op">;</span></span>
<span id="cb99-22"><a href="#cb99-22" aria-hidden="true" tabindex="-1"></a>        w<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> a<span class="op">,</span> v<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> b<span class="op">,</span>group<span class="op">[</span>c<span class="op">].</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb99-23"><a href="#cb99-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb99-24"><a href="#cb99-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb99-25"><a href="#cb99-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="at">const</span> g <span class="op">=</span> <span class="dv">100</span><span class="op">;</span><span class="co">//本题中只说了有g个组，没有给出具体有多少个以及是否连续，采取遍历的方法</span></span>
<span id="cb99-26"><a href="#cb99-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>g<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb99-27"><a href="#cb99-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>group<span class="op">[</span>i<span class="op">].</span>size<span class="op">()==</span><span class="dv">0</span><span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb99-28"><a href="#cb99-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span>m<span class="op">;</span>j<span class="op">&gt;=</span><span class="dv">0</span><span class="op">;</span>j<span class="op">--){</span></span>
<span id="cb99-29"><a href="#cb99-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> k<span class="op">:</span>group<span class="op">[</span>i<span class="op">]){</span><span class="co">//注意这三个循环的顺序不能改变</span></span>
<span id="cb99-30"><a href="#cb99-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>j<span class="op">&gt;=</span>w<span class="op">[</span>k<span class="op">])</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span> dp<span class="op">[</span>j<span class="op">-</span>w<span class="op">[</span>k<span class="op">]]+</span>v<span class="op">[</span>k<span class="op">]);</span></span>
<span id="cb99-31"><a href="#cb99-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb99-32"><a href="#cb99-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb99-33"><a href="#cb99-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb99-34"><a href="#cb99-34" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>dp<span class="op">[</span>m<span class="op">]&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb99-35"><a href="#cb99-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb99-36"><a href="#cb99-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb99-37"><a href="#cb99-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-38"><a href="#cb99-38" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb99-39"><a href="#cb99-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb99-40"><a href="#cb99-40" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb99-41"><a href="#cb99-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-42"><a href="#cb99-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> T<span class="op">;</span></span>
<span id="cb99-43"><a href="#cb99-43" aria-hidden="true" tabindex="-1"></a>    T<span class="op">=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb99-44"><a href="#cb99-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>T<span class="op">--){</span></span>
<span id="cb99-45"><a href="#cb99-45" aria-hidden="true" tabindex="-1"></a>        solve<span class="op">();</span></span>
<span id="cb99-46"><a href="#cb99-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb99-47"><a href="#cb99-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-48"><a href="#cb99-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb99-49"><a href="#cb99-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="最长上升子序列">最长上升子序列</h2>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="co">//最长上升子序列 复杂度nlogn</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu B3637</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MAXN <span class="op">=</span> <span class="dv">100005</span><span class="op">;</span></span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> arr<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a><span class="co">//dp[i]表示长度为i的上升子序列的最后一个元素的最小值</span></span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true" tabindex="-1"></a><span class="co">//例如1 2 5 3 4 1。</span></span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true" tabindex="-1"></a><span class="co">//最开始dp[1]=1，arr[2]=2&gt;dp[1]，所以插入dp[2]=2;arr[3]同理，得到dp={1,2,5};到arr[4]=3时，我们找到第一个大于等于3的元素，即dp[3]，替换他，得到dp={1,2,3};接下来到arr[5]=4，现在4&gt;3，可以插入末尾得到dp={1,2,3,4}，显然我们刚刚的操作把5换成3，让后面的数更有可能直接加入到数组末尾了。最后arr[6]=1，由于我们求的是最长上升子序列，而不是最长不下降，所以替换不影响。</span></span>
<span id="cb100-14"><a href="#cb100-14" aria-hidden="true" tabindex="-1"></a><span class="co">//注意dp里面的数字并不是最长的序列，例如我们加一个0进去，dp={0,2,3,4}，但是0是在最后的，不存在0,2,3,4这个序列。我们只能计算长度。</span></span>
<span id="cb100-15"><a href="#cb100-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-16"><a href="#cb100-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb100-17"><a href="#cb100-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb100-18"><a href="#cb100-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb100-19"><a href="#cb100-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb100-20"><a href="#cb100-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb100-21"><a href="#cb100-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb100-22"><a href="#cb100-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb100-23"><a href="#cb100-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>arr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb100-24"><a href="#cb100-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb100-25"><a href="#cb100-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb100-26"><a href="#cb100-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>memset<span class="op">(</span>dp<span class="op">,</span><span class="bn">0x3f</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>dp<span class="op">));</span></span>
<span id="cb100-27"><a href="#cb100-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb100-28"><a href="#cb100-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxv <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb100-29"><a href="#cb100-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb100-30"><a href="#cb100-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span><span class="bu">std::</span>lower_bound<span class="op">(</span>dp<span class="op">,</span>dp<span class="op">+</span>n<span class="op">,</span>arr<span class="op">[</span>i<span class="op">])</span> <span class="op">=</span> arr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb100-31"><a href="#cb100-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">//换成最长不下降子序列时，用upper_bound</span></span>
<span id="cb100-32"><a href="#cb100-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb100-33"><a href="#cb100-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb100-34"><a href="#cb100-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>dp<span class="op">[</span>ans<span class="op">]!=</span>maxv<span class="op">)</span> ans<span class="op">++;</span></span>
<span id="cb100-35"><a href="#cb100-35" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb100-36"><a href="#cb100-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-37"><a href="#cb100-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb100-38"><a href="#cb100-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="dilworth定理">Dilworth定理</h2>
<p>把一个序列分为若干不上升子序列，其序列总数的最小值等于最长上升子序列的长度</p>
<h2 id="最长公共子序列">最长公共子序列</h2>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="co">//最长公共子序列，复杂度nm</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a><span class="co">//hdu 1159</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p1439因为是排列，可以转化为LIS问题，复杂度是nlogn。但hdu1159没有这种性质，复杂度到不了nlogn</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXN </span><span class="dv">505</span></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> lcs<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> s1<span class="op">,</span> <span class="bu">std::</span>string<span class="op"> </span><span class="at">const</span> <span class="op">&amp;</span> s2<span class="op">){</span></span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n1<span class="op">=</span>s1<span class="op">.</span>size<span class="op">(),</span>n2<span class="op">=</span>s2<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>memset<span class="op">(</span>dp<span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>dp<span class="op">));</span></span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb101-15"><a href="#cb101-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n1<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb101-16"><a href="#cb101-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>n2<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb101-17"><a href="#cb101-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>s1<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]==</span>s2<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span></span>
<span id="cb101-18"><a href="#cb101-18" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb101-19"><a href="#cb101-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span></span>
<span id="cb101-20"><a href="#cb101-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">],</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb101-21"><a href="#cb101-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb101-22"><a href="#cb101-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb101-23"><a href="#cb101-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n1<span class="op">][</span>n2<span class="op">];</span></span>
<span id="cb101-24"><a href="#cb101-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb101-25"><a href="#cb101-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-26"><a href="#cb101-26" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb101-27"><a href="#cb101-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb101-28"><a href="#cb101-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb101-29"><a href="#cb101-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb101-30"><a href="#cb101-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>s1<span class="op">,</span>s2<span class="op">;</span></span>
<span id="cb101-31"><a href="#cb101-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb101-32"><a href="#cb101-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span><span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>s1<span class="op">&gt;&gt;</span>s2<span class="op">){</span></span>
<span id="cb101-33"><a href="#cb101-33" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>lcs<span class="op">(</span>s1<span class="op">,</span>s2<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb101-34"><a href="#cb101-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb101-35"><a href="#cb101-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb101-36"><a href="#cb101-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb101-37"><a href="#cb101-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="斜率优化todo">斜率优化TODO</h2>
<h2 id="四边形不等式todo">四边形不等式TODO</h2>
<h2 id="悬线法">悬线法</h2>
<div class="sourceCode" id="cb102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu p1387</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="co">//悬线法求符合条件的最大矩形/正方形，复杂度 nm</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> grid<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> l<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">],</span> r<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">],</span> u<span class="op">[</span>MAXN<span class="op">][</span>MAXN<span class="op">];</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a><span class="co">//l,r分别表示从当前格向上的悬线最多能向左向右扩展多少格（含自己）</span></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a><span class="co">//u表示当前格向上能扩展多少格（含自己），即悬线</span></span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> dp<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> m<span class="op">){</span></span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>m<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span> l<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> l<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]+</span><span class="dv">1</span><span class="op">;</span><span class="co">//若(i,j-1)可选，当然首先要(i,j)可选，(i,j-1)不可选时l[i][j-1]会等于0，l[i][j]就会等于1</span></span>
<span id="cb102-13"><a href="#cb102-13" aria-hidden="true" tabindex="-1"></a>            <span class="co">//这里的if条件看情况选择，下面同理</span></span>
<span id="cb102-14"><a href="#cb102-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb102-15"><a href="#cb102-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb102-16"><a href="#cb102-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb102-17"><a href="#cb102-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span>m<span class="op">;</span>j<span class="op">&gt;=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">--){</span></span>
<span id="cb102-18"><a href="#cb102-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span> r<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> r<span class="op">[</span>i<span class="op">][</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]+</span><span class="dv">1</span><span class="op">;</span><span class="co">//若(i,j+1)可选</span></span>
<span id="cb102-19"><a href="#cb102-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb102-20"><a href="#cb102-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb102-21"><a href="#cb102-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb102-22"><a href="#cb102-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;=</span>m<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb102-23"><a href="#cb102-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]){</span></span>
<span id="cb102-24"><a href="#cb102-24" aria-hidden="true" tabindex="-1"></a>                u<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> u<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb102-25"><a href="#cb102-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>grid<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]){</span><span class="co">//若(i-1,j)可选</span></span>
<span id="cb102-26"><a href="#cb102-26" aria-hidden="true" tabindex="-1"></a>                    l<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>l<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> l<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb102-27"><a href="#cb102-27" aria-hidden="true" tabindex="-1"></a>                    r<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>r<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> r<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb102-28"><a href="#cb102-28" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb102-29"><a href="#cb102-29" aria-hidden="true" tabindex="-1"></a>                <span class="co">//然后在这里对ans进行该有的操作，因题而异</span></span>
<span id="cb102-30"><a href="#cb102-30" aria-hidden="true" tabindex="-1"></a>                <span class="co">//对于(i,j)这一格来说，它对应的悬线向左右拓展能得到的最大矩形面积为</span></span>
<span id="cb102-31"><a href="#cb102-31" aria-hidden="true" tabindex="-1"></a>                <span class="co">//u[i][j]*(l[i][j]+r[i][j]-1)</span></span>
<span id="cb102-32"><a href="#cb102-32" aria-hidden="true" tabindex="-1"></a>                <span class="co">//最大正方形为</span></span>
<span id="cb102-33"><a href="#cb102-33" aria-hidden="true" tabindex="-1"></a>                <span class="co">//min(u[i][j],l[i][j]+r[i][j]-1)的平方</span></span>
<span id="cb102-34"><a href="#cb102-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb102-35"><a href="#cb102-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb102-36"><a href="#cb102-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb102-37"><a href="#cb102-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="数位dp">数位DP</h2>
<p>数位DP是对有多少数符合特性的计数问题。通常他的题目数据范围会很大，比如<span class="math inline">\(10^{18}\)</span>。题目通常也会要求我们的数字要在某个范围内，还有可能会要求符合题意的一对、一组数。</p>
<p>我们通常会用记忆化搜索来实现。</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="co">//数位dp模板题，常用记忆化搜索实现</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a><span class="co">//hdu 2089</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span class="co">//本题要求，[n,m]之间的所有整数，不含4，不含62（连续的）的数字有多少个</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#define pb </span>push_back</span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> digit<span class="op">;</span><span class="co">//用于存储getSum中x的每一位，最高位从0下标开始</span></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span><span class="dv">8</span><span class="op">][</span><span class="dv">12</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span><span class="co">//dp[pos][last][limit]</span></span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a><span class="co">//pos代表搜索到第几位，如五位数，pos==0说明搜索到高位第一位，pos==4说明搜索到个位</span></span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true" tabindex="-1"></a><span class="co">//last代表上一位搜索的数字是多少，如果last==11，10这样的数字则代表目前在搜索pos==0。设置为11还是10还是别的什么要看题目对只有一位数时的要求</span></span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true" tabindex="-1"></a><span class="co">//limit代表本位数字的取值有没有限制，例如上限是12345，现在搜到了12???，要搜第三位，显然第三位只能取0,1,2,3，limit==true。又如搜到了11???，第三位就可以取0-9，limit==false。</span></span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true" tabindex="-1"></a><span class="co">//limit==true当且仅当上一位limit也为true且取得最大值（第一位特判）</span></span>
<span id="cb103-18"><a href="#cb103-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-19"><a href="#cb103-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfs<span class="op">(</span><span class="dt">int</span> pos<span class="op">,</span> <span class="dt">int</span> last<span class="op">,</span> <span class="dt">bool</span> limit<span class="op">){</span></span>
<span id="cb103-20"><a href="#cb103-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ret <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb103-21"><a href="#cb103-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>pos<span class="op">==</span>digit<span class="op">.</span>size<span class="op">())</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span><span class="co">//搜索终点，由于不是非法状态所以返回1</span></span>
<span id="cb103-22"><a href="#cb103-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>dp<span class="op">[</span>pos<span class="op">][</span>last<span class="op">][</span>limit<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> dp<span class="op">[</span>pos<span class="op">][</span>last<span class="op">][</span>limit<span class="op">];</span></span>
<span id="cb103-23"><a href="#cb103-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> v<span class="op">=</span><span class="dv">0</span><span class="op">;</span>v<span class="op">&lt;=(</span>limit <span class="op">?</span> digit<span class="op">[</span>pos<span class="op">]</span> <span class="op">:</span> <span class="dv">9</span><span class="op">);</span>v<span class="op">++){</span></span>
<span id="cb103-24"><a href="#cb103-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">((</span>last<span class="op">==</span><span class="dv">6</span> <span class="op">&amp;&amp;</span> v<span class="op">==</span><span class="dv">2</span><span class="op">)</span> <span class="op">||</span> v<span class="op">==</span><span class="dv">4</span><span class="op">)</span> <span class="cf">continue</span><span class="op">;</span><span class="co">//非法状态</span></span>
<span id="cb103-25"><a href="#cb103-25" aria-hidden="true" tabindex="-1"></a>        ret <span class="op">+=</span> dfs<span class="op">(</span>pos<span class="op">+</span><span class="dv">1</span><span class="op">,</span> v<span class="op">,</span> limit <span class="op">&amp;&amp;</span> v<span class="op">==</span>digit<span class="op">[</span>pos<span class="op">]);</span></span>
<span id="cb103-26"><a href="#cb103-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb103-27"><a href="#cb103-27" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>pos<span class="op">][</span>last<span class="op">][</span>limit<span class="op">]</span> <span class="op">=</span> ret<span class="op">;</span></span>
<span id="cb103-28"><a href="#cb103-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb103-29"><a href="#cb103-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb103-30"><a href="#cb103-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-31"><a href="#cb103-31" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> getSum<span class="op">(</span><span class="dt">int</span> x<span class="op">){</span></span>
<span id="cb103-32"><a href="#cb103-32" aria-hidden="true" tabindex="-1"></a>    digit<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb103-33"><a href="#cb103-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>memset<span class="op">(</span>dp<span class="op">,-</span><span class="dv">1</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>dp<span class="op">));</span></span>
<span id="cb103-34"><a href="#cb103-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>x<span class="op">){</span><span class="co">//注意如果某些题0也在范围内要特判</span></span>
<span id="cb103-35"><a href="#cb103-35" aria-hidden="true" tabindex="-1"></a>        digit<span class="op">.</span>pb<span class="op">(</span>x<span class="op">%</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb103-36"><a href="#cb103-36" aria-hidden="true" tabindex="-1"></a>        x<span class="op">/=</span><span class="dv">10</span><span class="op">;</span></span>
<span id="cb103-37"><a href="#cb103-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb103-38"><a href="#cb103-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>reverse<span class="op">(</span>digit<span class="op">.</span>begin<span class="op">(),</span>digit<span class="op">.</span>end<span class="op">());</span><span class="co">//高位到低位存</span></span>
<span id="cb103-39"><a href="#cb103-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dfs<span class="op">(</span><span class="dv">0</span><span class="op">,</span><span class="dv">10</span><span class="op">,</span><span class="kw">true</span><span class="op">);</span></span>
<span id="cb103-40"><a href="#cb103-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb103-41"><a href="#cb103-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-42"><a href="#cb103-42" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> m<span class="op">){</span></span>
<span id="cb103-43"><a href="#cb103-43" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>getSum<span class="op">(</span>m<span class="op">)-</span>getSum<span class="op">(</span>n<span class="op">-</span><span class="dv">1</span><span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb103-44"><a href="#cb103-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb103-45"><a href="#cb103-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-46"><a href="#cb103-46" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb103-47"><a href="#cb103-47" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb103-48"><a href="#cb103-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb103-49"><a href="#cb103-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-50"><a href="#cb103-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">,</span>m<span class="op">;</span></span>
<span id="cb103-51"><a href="#cb103-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span><span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>m<span class="op">){</span></span>
<span id="cb103-52"><a href="#cb103-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>n<span class="op">==</span><span class="dv">0</span> <span class="op">&amp;&amp;</span> m<span class="op">==</span><span class="dv">0</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb103-53"><a href="#cb103-53" aria-hidden="true" tabindex="-1"></a>        solve<span class="op">(</span>n<span class="op">,</span>m<span class="op">);</span></span>
<span id="cb103-54"><a href="#cb103-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb103-55"><a href="#cb103-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-56"><a href="#cb103-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb103-57"><a href="#cb103-57" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>下面再给出一例，求一对数字的、与位运算有关的，拆分成二进制的题。</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="co">//数位dp另一例</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="co">//atcoder abc317_f</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a><span class="co">//本题给定n,a1,a2,a3。要求求三元组&lt;x1,x2,x3&gt;的个数，满足</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a><span class="co">//1. 1&lt;=xi&lt;=n，对所有i</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a><span class="co">//2. xi是ai的任意倍数，对所有i</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a><span class="co">//3. x1^x2^x3=0</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a><span class="co">//其中n取值[1,1e18]</span></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a><span class="co">//ai取值[1,10]</span></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#define pb </span>push_back</span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> LL <span class="op">=</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb104-12"><a href="#cb104-12" aria-hidden="true" tabindex="-1"></a>LL <span class="at">const</span> MOD <span class="op">=</span> <span class="dv">998244353</span><span class="op">;</span></span>
<span id="cb104-13"><a href="#cb104-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-14"><a href="#cb104-14" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> digit<span class="op">;</span></span>
<span id="cb104-15"><a href="#cb104-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dp<span class="op">[</span><span class="dv">80</span><span class="op">][</span><span class="dv">12</span><span class="op">][</span><span class="dv">12</span><span class="op">][</span><span class="dv">12</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb104-16"><a href="#cb104-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a1<span class="op">,</span>a2<span class="op">,</span>a3<span class="op">;</span></span>
<span id="cb104-17"><a href="#cb104-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-18"><a href="#cb104-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfs<span class="op">(</span><span class="dt">int</span> pos<span class="op">,</span> <span class="dt">int</span> r1<span class="op">,</span> <span class="dt">int</span> r2<span class="op">,</span> <span class="dt">int</span> r3<span class="op">,</span></span>
<span id="cb104-19"><a href="#cb104-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> l1<span class="op">,</span> <span class="dt">bool</span> l2<span class="op">,</span> <span class="dt">bool</span> l3<span class="op">,</span></span>
<span id="cb104-20"><a href="#cb104-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> z1<span class="op">,</span> <span class="dt">bool</span> z2<span class="op">,</span> <span class="dt">bool</span> z3<span class="op">){</span></span>
<span id="cb104-21"><a href="#cb104-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">//分布代表着，pos位数字，上一位搜索到的x1除以a1的余数,...,x1的limit,...,x1是否前面全是前导0</span></span>
<span id="cb104-22"><a href="#cb104-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ret <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb104-23"><a href="#cb104-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>pos<span class="op">==-</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb104-24"><a href="#cb104-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">!</span>z1 <span class="op">&amp;&amp;</span> <span class="op">!</span>z2 <span class="op">&amp;&amp;</span> <span class="op">!</span>z3 <span class="op">&amp;&amp;</span> <span class="op">!</span>r1 <span class="op">&amp;&amp;</span> <span class="op">!</span>r2 <span class="op">&amp;&amp;</span> <span class="op">!</span>r3<span class="op">;</span></span>
<span id="cb104-25"><a href="#cb104-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">//每个数都没有前导零（即填入了至少一个数字），以及余数都是0（即xi已经是ai的倍数了）</span></span>
<span id="cb104-26"><a href="#cb104-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb104-27"><a href="#cb104-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>dp<span class="op">[</span>pos<span class="op">][</span>r1<span class="op">][</span>r2<span class="op">][</span>r3<span class="op">][</span>l1<span class="op">][</span>l2<span class="op">][</span>l3<span class="op">][</span>z1<span class="op">][</span>z2<span class="op">][</span>z3<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> dp<span class="op">[</span>pos<span class="op">][</span>r1<span class="op">][</span>r2<span class="op">][</span>r3<span class="op">][</span>l1<span class="op">][</span>l2<span class="op">][</span>l3<span class="op">][</span>z1<span class="op">][</span>z2<span class="op">][</span>z3<span class="op">];</span></span>
<span id="cb104-28"><a href="#cb104-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb104-29"><a href="#cb104-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m1 <span class="op">=</span> l1 <span class="op">?</span> digit<span class="op">[</span>pos<span class="op">]</span> <span class="op">:</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb104-30"><a href="#cb104-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m2 <span class="op">=</span> l2 <span class="op">?</span> digit<span class="op">[</span>pos<span class="op">]</span> <span class="op">:</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb104-31"><a href="#cb104-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m3 <span class="op">=</span> l3 <span class="op">?</span> digit<span class="op">[</span>pos<span class="op">]</span> <span class="op">:</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb104-32"><a href="#cb104-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb104-33"><a href="#cb104-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span>LL i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;=</span>m1<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb104-34"><a href="#cb104-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span>LL j<span class="op">=</span><span class="dv">0</span><span class="op">;</span>j<span class="op">&lt;=</span>m2<span class="op">;</span>j<span class="op">++){</span></span>
<span id="cb104-35"><a href="#cb104-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span>LL k<span class="op">=</span><span class="dv">0</span><span class="op">;</span>k<span class="op">&lt;=</span>m3<span class="op">;</span>k<span class="op">++){</span></span>
<span id="cb104-36"><a href="#cb104-36" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">((</span>i<span class="op">^</span>j<span class="op">^</span>k<span class="op">)!=</span><span class="dv">0</span><span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb104-37"><a href="#cb104-37" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb104-38"><a href="#cb104-38" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> newr1 <span class="op">=</span> <span class="op">((</span>LL<span class="op">)</span>r1<span class="op">+(</span>i<span class="op">&lt;&lt;</span>pos<span class="op">))%</span>a1<span class="op">;</span><span class="co">//计算新的余数</span></span>
<span id="cb104-39"><a href="#cb104-39" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> newr2 <span class="op">=</span> <span class="op">((</span>LL<span class="op">)</span>r2<span class="op">+(</span>j<span class="op">&lt;&lt;</span>pos<span class="op">))%</span>a2<span class="op">;</span></span>
<span id="cb104-40"><a href="#cb104-40" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> newr3 <span class="op">=</span> <span class="op">((</span>LL<span class="op">)</span>r3<span class="op">+(</span>k<span class="op">&lt;&lt;</span>pos<span class="op">))%</span>a3<span class="op">;</span></span>
<span id="cb104-41"><a href="#cb104-41" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb104-42"><a href="#cb104-42" aria-hidden="true" tabindex="-1"></a>                ret <span class="op">=</span> <span class="op">(</span>ret <span class="op">+</span> dfs<span class="op">(</span>pos<span class="op">-</span><span class="dv">1</span><span class="op">,</span>newr1<span class="op">,</span>newr2<span class="op">,</span>newr3<span class="op">,</span></span>
<span id="cb104-43"><a href="#cb104-43" aria-hidden="true" tabindex="-1"></a>                l1<span class="op">&amp;&amp;</span>i<span class="op">==</span>digit<span class="op">[</span>pos<span class="op">],</span> l2<span class="op">&amp;&amp;</span>j<span class="op">==</span>digit<span class="op">[</span>pos<span class="op">],</span>l3<span class="op">&amp;&amp;</span>k<span class="op">==</span>digit<span class="op">[</span>pos<span class="op">],</span></span>
<span id="cb104-44"><a href="#cb104-44" aria-hidden="true" tabindex="-1"></a>                z1<span class="op">&amp;&amp;</span>i<span class="op">==</span><span class="dv">0</span><span class="op">,</span>z2<span class="op">&amp;&amp;</span>j<span class="op">==</span><span class="dv">0</span><span class="op">,</span>z3<span class="op">&amp;&amp;</span>k<span class="op">==</span><span class="dv">0</span><span class="op">))%</span>MOD<span class="op">;</span></span>
<span id="cb104-45"><a href="#cb104-45" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb104-46"><a href="#cb104-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb104-47"><a href="#cb104-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb104-48"><a href="#cb104-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb104-49"><a href="#cb104-49" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>pos<span class="op">][</span>r1<span class="op">][</span>r2<span class="op">][</span>r3<span class="op">][</span>l1<span class="op">][</span>l2<span class="op">][</span>l3<span class="op">][</span>z1<span class="op">][</span>z2<span class="op">][</span>z3<span class="op">]</span> <span class="op">=</span> ret<span class="op">;</span></span>
<span id="cb104-50"><a href="#cb104-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb104-51"><a href="#cb104-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb104-52"><a href="#cb104-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-53"><a href="#cb104-53" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> getSum<span class="op">(</span>LL x<span class="op">){</span></span>
<span id="cb104-54"><a href="#cb104-54" aria-hidden="true" tabindex="-1"></a>    digit<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb104-55"><a href="#cb104-55" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>memset<span class="op">(</span>dp<span class="op">,-</span><span class="dv">1</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>dp<span class="op">));</span></span>
<span id="cb104-56"><a href="#cb104-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>x<span class="op">){</span></span>
<span id="cb104-57"><a href="#cb104-57" aria-hidden="true" tabindex="-1"></a>        digit<span class="op">.</span>pb<span class="op">(</span>x<span class="op">%</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb104-58"><a href="#cb104-58" aria-hidden="true" tabindex="-1"></a>        x<span class="op">/=</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb104-59"><a href="#cb104-59" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span><span class="co">//本题低位到高位存更方便，方便移位运算</span></span>
<span id="cb104-60"><a href="#cb104-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dfs<span class="op">(</span>digit<span class="op">.</span>size<span class="op">()-</span><span class="dv">1</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb104-61"><a href="#cb104-61" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb104-62"><a href="#cb104-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-63"><a href="#cb104-63" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">(){</span></span>
<span id="cb104-64"><a href="#cb104-64" aria-hidden="true" tabindex="-1"></a>    LL n<span class="op">;</span></span>
<span id="cb104-65"><a href="#cb104-65" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>a1<span class="op">&gt;&gt;</span>a2<span class="op">&gt;&gt;</span>a3<span class="op">;</span></span>
<span id="cb104-66"><a href="#cb104-66" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>getSum<span class="op">(</span>n<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb104-67"><a href="#cb104-67" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>选择低位到高位还是高位到低位应该根据题目的不同来选择。</p>
<p>另外如果满足limit为真的情况出现的概率远低于为假的，那么可以把limit这一维省略掉，dp数组里面只记录limit为假的情况。</p>
<p>低位到高位存还有一个好处。我们知道高位到低位存时，由于数字长度不一样，比如a有5位，b有10位，把a的dp数组求完后，求b时就必须再次清空成-1。原因是，对于a的pos为1，也就是从高到低第二位，其实对应这b的pos为6，我们就不能用a中求出的dp带进去b里面计算了。</p>
<p>而低位到高位就没有这个问题，大家的最低位都是平等的从0下标开始的，可以进行复用。清零为-1只需要程序最开始的时候清零一次即可。有时候程序有多个case会避免TLE。</p>
<h1 id="概率论">概率论</h1>
<h2 id="处理分数期望概率">处理分数期望、概率</h2>
<p>有时候，题目中的期望是一个分数<span class="math inline">\(\frac{P}{Q}\)</span>，而为了防止精度问题，往往会要求输出一个<span class="math inline">\(R\)</span>，满足</p>
<p><span class="math display">\[
R\times Q\equiv P(mod\ 998244353)
\]</span></p>
<p>此时</p>
<p><span class="math display">\[
R = (P\times Q^{-1})\%998244353
\]</span></p>
<p><span class="math inline">\(Q^{-1}\)</span>是<span class="math inline">\(Q\)</span>在模<span class="math inline">\(998244353\)</span>意义下的乘法逆元</p>
<h1 id="杂项">杂项</h1>
<h2 id="快速幂">快速幂</h2>
<div class="sourceCode" id="cb105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度logn</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="co">//快速幂</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu P1226</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> LL <span class="op">=</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>LL qPow<span class="op">(</span>LL x<span class="op">,</span> LL p<span class="op">){</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//x^p</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a>    LL res <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>p<span class="op">){</span></span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>p<span class="op">&amp;</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>            res <span class="op">=</span> res <span class="op">*</span> x<span class="op">;</span></span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a>        x <span class="op">*=</span> x<span class="op">;</span></span>
<span id="cb105-14"><a href="#cb105-14" aria-hidden="true" tabindex="-1"></a>        p<span class="op">&gt;&gt;=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb105-15"><a href="#cb105-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb105-16"><a href="#cb105-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb105-17"><a href="#cb105-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb105-18"><a href="#cb105-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-19"><a href="#cb105-19" aria-hidden="true" tabindex="-1"></a>LL qPowMod<span class="op">(</span>LL x<span class="op">,</span> LL p<span class="op">,</span> LL m<span class="op">){</span></span>
<span id="cb105-20"><a href="#cb105-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">//x^p % m</span></span>
<span id="cb105-21"><a href="#cb105-21" aria-hidden="true" tabindex="-1"></a>    LL res <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb105-22"><a href="#cb105-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>p<span class="op">){</span></span>
<span id="cb105-23"><a href="#cb105-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>p<span class="op">&amp;</span><span class="dv">1</span><span class="op">){</span></span>
<span id="cb105-24"><a href="#cb105-24" aria-hidden="true" tabindex="-1"></a>            res <span class="op">=</span> <span class="op">(</span>res <span class="op">*</span> x<span class="op">)%</span>m<span class="op">;</span></span>
<span id="cb105-25"><a href="#cb105-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb105-26"><a href="#cb105-26" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> <span class="op">(</span>x<span class="op">*</span>x<span class="op">)%</span>m<span class="op">;</span></span>
<span id="cb105-27"><a href="#cb105-27" aria-hidden="true" tabindex="-1"></a>        p<span class="op">&gt;&gt;=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb105-28"><a href="#cb105-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb105-29"><a href="#cb105-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb105-30"><a href="#cb105-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="离散化">离散化</h2>
<p>有两种，一种是unique函数版，一种是树状数组求逆序对里使用的，都可以，区别是，那个对于相同的数字根据先后顺序确定大小，这个则是一样大</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="co">//复杂度nlogn</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="co">//离散化 例如将1,500,40,1000保持相对大小不变，离散化为1,3,2,4</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="co">//luogu B3694</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> arr<span class="op">,</span>assi<span class="op">;</span></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">(){</span></span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a>    arr<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a>    assi<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb106-16"><a href="#cb106-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb106-17"><a href="#cb106-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>a<span class="op">;</span></span>
<span id="cb106-18"><a href="#cb106-18" aria-hidden="true" tabindex="-1"></a>        arr<span class="op">.</span>push_back<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb106-19"><a href="#cb106-19" aria-hidden="true" tabindex="-1"></a>        assi<span class="op">.</span>push_back<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb106-20"><a href="#cb106-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb106-21"><a href="#cb106-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>assi<span class="op">.</span>begin<span class="op">(),</span>assi<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb106-22"><a href="#cb106-22" aria-hidden="true" tabindex="-1"></a>    assi<span class="op">.</span>erase<span class="op">(</span><span class="bu">std::</span>unique<span class="op">(</span>assi<span class="op">.</span>begin<span class="op">(),</span>assi<span class="op">.</span>end<span class="op">()),</span>assi<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb106-23"><a href="#cb106-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-24"><a href="#cb106-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb106-25"><a href="#cb106-25" aria-hidden="true" tabindex="-1"></a>        arr<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>upper_bound<span class="op">(</span>assi<span class="op">.</span>begin<span class="op">(),</span>assi<span class="op">.</span>end<span class="op">(),</span>arr<span class="op">[</span>i<span class="op">])-</span>assi<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb106-26"><a href="#cb106-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb106-27"><a href="#cb106-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-28"><a href="#cb106-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb106-29"><a href="#cb106-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>arr<span class="op">[</span>i<span class="op">]&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">;</span></span>
<span id="cb106-30"><a href="#cb106-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb106-31"><a href="#cb106-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb106-32"><a href="#cb106-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="莫队算法">莫队算法</h2>
<div class="sourceCode" id="cb107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="co">//对于序列上的区域离线询问问题，如果[l,r]的答案能够O(1)拓展得到</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a><span class="co">//[l-1,r],[l+1,r],[l,r-1],[l,r+1]的答案，那么就可以在O(n sqrt(n))中解决所有询问</span></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="co">//SPOJ DQUERY</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a><span class="co">//本题是给定若干个区间[l,r]，查询这个范围内有多少个不同的数</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> arr<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sq<span class="op">;</span><span class="co">//分块数sq = sqrt(n)</span></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Query<span class="op">{</span></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l<span class="op">,</span>r<span class="op">,</span>id<span class="op">;</span><span class="co">//询问区间和询问下标</span></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span>Query <span class="at">const</span> <span class="op">&amp;</span> x<span class="op">)</span><span class="at">const</span><span class="op">{</span></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>l<span class="op">/</span>sq <span class="op">!=</span> x<span class="op">.</span>l<span class="op">/</span>sq<span class="op">)</span><span class="co">//根据归属于哪个块排序</span></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> l<span class="op">&lt;</span>x<span class="op">.</span>l<span class="op">;</span></span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>l<span class="op">/</span>sq <span class="op">&amp;</span> <span class="dv">1</span><span class="op">)</span>      <span class="co">//玄学奇偶排序</span></span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> r<span class="op">&lt;</span>x<span class="op">.</span>r<span class="op">;</span></span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> r<span class="op">&gt;</span>x<span class="op">.</span>r<span class="op">;</span></span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  </span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>Q<span class="op">[</span>MAXQ<span class="op">];</span></span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-19"><a href="#cb107-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ans<span class="op">[</span>MAXQ<span class="op">],</span> cnt<span class="op">[</span>MAXA<span class="op">],</span> cur<span class="op">;</span></span>
<span id="cb107-20"><a href="#cb107-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> l<span class="op">=</span><span class="dv">1</span><span class="op">,</span>r<span class="op">=</span><span class="dv">0</span><span class="op">;</span><span class="co">//初始化询问区间</span></span>
<span id="cb107-21"><a href="#cb107-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-22"><a href="#cb107-22" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">void</span> add<span class="op">(</span><span class="dt">int</span> p<span class="op">){</span></span>
<span id="cb107-23"><a href="#cb107-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>cnt<span class="op">[</span>arr<span class="op">[</span>p<span class="op">]]==</span><span class="dv">0</span><span class="op">)</span><span class="co">//新增一种数</span></span>
<span id="cb107-24"><a href="#cb107-24" aria-hidden="true" tabindex="-1"></a>        cur<span class="op">++;</span></span>
<span id="cb107-25"><a href="#cb107-25" aria-hidden="true" tabindex="-1"></a>    cnt<span class="op">[</span>arr<span class="op">[</span>p<span class="op">]]++;</span></span>
<span id="cb107-26"><a href="#cb107-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb107-27"><a href="#cb107-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-28"><a href="#cb107-28" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">void</span> del<span class="op">(</span><span class="dt">int</span> p<span class="op">){</span></span>
<span id="cb107-29"><a href="#cb107-29" aria-hidden="true" tabindex="-1"></a>    cnt<span class="op">[</span>arr<span class="op">[</span>p<span class="op">]]--;</span></span>
<span id="cb107-30"><a href="#cb107-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>cnt<span class="op">[</span>arr<span class="op">[</span>p<span class="op">]]==</span><span class="dv">0</span><span class="op">)</span><span class="co">//把一种数全部删完</span></span>
<span id="cb107-31"><a href="#cb107-31" aria-hidden="true" tabindex="-1"></a>        cur<span class="op">--;</span></span>
<span id="cb107-32"><a href="#cb107-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb107-33"><a href="#cb107-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-34"><a href="#cb107-34" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb107-35"><a href="#cb107-35" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb107-36"><a href="#cb107-36" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb107-37"><a href="#cb107-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-38"><a href="#cb107-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb107-39"><a href="#cb107-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">;</span></span>
<span id="cb107-40"><a href="#cb107-40" aria-hidden="true" tabindex="-1"></a>    sq <span class="op">=</span> <span class="bu">std::</span>sqrt<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb107-41"><a href="#cb107-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++)</span> <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>arr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb107-42"><a href="#cb107-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> q<span class="op">;</span></span>
<span id="cb107-43"><a href="#cb107-43" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>q<span class="op">;</span></span>
<span id="cb107-44"><a href="#cb107-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>q<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb107-45"><a href="#cb107-45" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>Q<span class="op">[</span>i<span class="op">].</span>l<span class="op">&gt;&gt;</span>Q<span class="op">[</span>i<span class="op">].</span>r<span class="op">;</span></span>
<span id="cb107-46"><a href="#cb107-46" aria-hidden="true" tabindex="-1"></a>        Q<span class="op">[</span>i<span class="op">].</span>id <span class="op">=</span> i<span class="op">;</span><span class="co">//把询问离线</span></span>
<span id="cb107-47"><a href="#cb107-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb107-48"><a href="#cb107-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>Q<span class="op">,</span>Q<span class="op">+</span>q<span class="op">);</span></span>
<span id="cb107-49"><a href="#cb107-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb107-50"><a href="#cb107-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>q<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb107-51"><a href="#cb107-51" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>l<span class="op">&gt;</span>Q<span class="op">[</span>i<span class="op">].</span>l<span class="op">)</span></span>
<span id="cb107-52"><a href="#cb107-52" aria-hidden="true" tabindex="-1"></a>            add<span class="op">(--</span>l<span class="op">);</span><span class="co">//当前区间l大于查询的l，要把左边的数加进来</span></span>
<span id="cb107-53"><a href="#cb107-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>r<span class="op">&lt;</span>Q<span class="op">[</span>i<span class="op">].</span>r<span class="op">)</span></span>
<span id="cb107-54"><a href="#cb107-54" aria-hidden="true" tabindex="-1"></a>            add<span class="op">(++</span>r<span class="op">);</span><span class="co">//当前区间r小于查询的r，要把右边的数加进来</span></span>
<span id="cb107-55"><a href="#cb107-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>l<span class="op">&lt;</span>Q<span class="op">[</span>i<span class="op">].</span>l<span class="op">)</span></span>
<span id="cb107-56"><a href="#cb107-56" aria-hidden="true" tabindex="-1"></a>            del<span class="op">(</span>l<span class="op">++);</span><span class="co">//当前区间l小于查询的l，要把左边的数删掉</span></span>
<span id="cb107-57"><a href="#cb107-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>r<span class="op">&gt;</span>Q<span class="op">[</span>i<span class="op">].</span>r<span class="op">)</span></span>
<span id="cb107-58"><a href="#cb107-58" aria-hidden="true" tabindex="-1"></a>            del<span class="op">(</span>r<span class="op">--);</span><span class="co">//当前区间r大于查询的r，要把右边的数删掉</span></span>
<span id="cb107-59"><a href="#cb107-59" aria-hidden="true" tabindex="-1"></a>        <span class="co">//注意上述顺序，扩张区间是先移动再更新，缩减区间是先更新再移动</span></span>
<span id="cb107-60"><a href="#cb107-60" aria-hidden="true" tabindex="-1"></a>        <span class="co">//四个操作的具体实现可能会有不一样，具体题目具体讨论</span></span>
<span id="cb107-61"><a href="#cb107-61" aria-hidden="true" tabindex="-1"></a>        ans<span class="op">[</span>Q<span class="op">[</span>i<span class="op">].</span>id<span class="op">]</span> <span class="op">=</span> cur<span class="op">;</span></span>
<span id="cb107-62"><a href="#cb107-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb107-63"><a href="#cb107-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb107-64"><a href="#cb107-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>q<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb107-65"><a href="#cb107-65" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">[</span>i<span class="op">]&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb107-66"><a href="#cb107-66" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb107-67"><a href="#cb107-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-68"><a href="#cb107-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb107-69"><a href="#cb107-69" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="分数规划">0/1分数规划</h2>
<p>0/1分数规划的目的是如下列式子取值最大化</p>
<p><span class="math display">\[
\dfrac{\sum^n_{i=1}a_ix_i}{\sum^n_{i=1}b_ix_i}
\]</span></p>
<p>其中<span class="math inline">\(\{a_i\}\)</span>和<span class="math inline">\(\{b_i\}\)</span>是给定的数列，而<span class="math inline">\(\{x_i\}\)</span>是要求的一组解，其取值只能是<span class="math inline">\(0\)</span>或<span class="math inline">\(1\)</span>。或者说，给定<span class="math inline">\(n\)</span>对数<span class="math inline">\(a_i,b_i\)</span>，从中选出若干对（通常题目要求恰好选<span class="math inline">\(k\)</span>对），使选出的数对的<span class="math inline">\(a\)</span>之和和<span class="math inline">\(b\)</span>之和的商最大。</p>
<p>我们转化成二分答案，验证一个值<span class="math inline">\(m\)</span>，上式的取值能否大于等于<span class="math inline">\(m\)</span>。转化一下就可以得到，是否存在一组解<span class="math inline">\(x_1,\cdots,x_n\)</span>，满足</p>
<p><span class="math display">\[
\sum^n_{i=1}(a_i-m\times b_i)\times x_i\geq 0
\]</span></p>
<p>如果存在则说明<span class="math inline">\(m\)</span>比最大值要小，否则<span class="math inline">\(m\)</span>比最大值要大，满足二分性。</p>
<p>我们可以计算每一个<span class="math inline">\((a_i-m\times
b_i)\)</span>，如果题目说可以任意选择若干对，则只要有一个非负数，就能满足条件。如果要求恰好选<span class="math inline">\(k\)</span>对，那么我们全部算出来然后排序，选择最大的<span class="math inline">\(k\)</span>个，其和非负就能满足条件。</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="co">//0/1分数规划，复杂度n log^2 n</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="co">//nowcoder NC14662</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="co">//介绍见markdown</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>LL a<span class="op">[</span>MAXN<span class="op">],</span>b<span class="op">[</span>MAXN<span class="op">];</span></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">,</span>k<span class="op">;</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> judge<span class="op">(</span>DB mid<span class="op">){</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>DB<span class="op">&gt;</span> vec<span class="op">;</span></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>        vec<span class="op">.</span>pb<span class="op">(</span>a<span class="op">[</span>i<span class="op">]-</span>mid<span class="op">*</span>b<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>vec<span class="op">.</span>begin<span class="op">(),</span>vec<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>    DB sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span>n<span class="op">-</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&gt;=</span><span class="dv">0</span> <span class="op">&amp;&amp;</span> n<span class="op">-</span><span class="dv">1</span><span class="op">-</span>i<span class="op">+</span><span class="dv">1</span><span class="op">&lt;=</span>k<span class="op">;</span>i<span class="op">--)</span> sum<span class="op">+=</span>vec<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>sum<span class="op">&gt;=</span><span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb108-16"><a href="#cb108-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb108-17"><a href="#cb108-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb108-18"><a href="#cb108-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-19"><a href="#cb108-19" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">(){</span></span>
<span id="cb108-20"><a href="#cb108-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>n<span class="op">&gt;&gt;</span>k<span class="op">;</span></span>
<span id="cb108-21"><a href="#cb108-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span>n<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb108-22"><a href="#cb108-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>b<span class="op">[</span>i<span class="op">]&gt;&gt;</span>a<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb108-23"><a href="#cb108-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb108-24"><a href="#cb108-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb108-25"><a href="#cb108-25" aria-hidden="true" tabindex="-1"></a>    DB l<span class="op">=</span><span class="dv">0</span><span class="op">,</span> r<span class="op">=</span><span class="fl">1e13</span><span class="op">;</span></span>
<span id="cb108-26"><a href="#cb108-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=</span><span class="dv">100</span><span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb108-27"><a href="#cb108-27" aria-hidden="true" tabindex="-1"></a>        DB mid <span class="op">=</span> <span class="op">(</span>l<span class="op">+</span>r<span class="op">)/</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb108-28"><a href="#cb108-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>judge<span class="op">(</span>mid<span class="op">))</span> l <span class="op">=</span> mid<span class="op">;</span></span>
<span id="cb108-29"><a href="#cb108-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> r <span class="op">=</span> mid<span class="op">;</span></span>
<span id="cb108-30"><a href="#cb108-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb108-31"><a href="#cb108-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;(</span>LL<span class="op">)</span>r<span class="op">&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb108-32"><a href="#cb108-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="表达式求值-可能需要进一步完善todo">表达式求值
可能需要进一步完善TODO</h2>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">bool</span> isOper<span class="op">(</span><span class="dt">char</span> c<span class="op">){</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c<span class="op">==</span><span class="ch">&#39;+&#39;</span><span class="op">||</span>c<span class="op">==</span><span class="ch">&#39;-&#39;</span><span class="op">||</span>c<span class="op">==</span><span class="ch">&#39;*&#39;</span><span class="op">||</span>c<span class="op">==</span><span class="ch">&#39;/&#39;</span><span class="op">;</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">bool</span> isDigit<span class="op">(</span><span class="dt">char</span> c<span class="op">){</span></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c<span class="op">&gt;=</span><span class="ch">&#39;0&#39;</span> <span class="op">&amp;&amp;</span> c<span class="op">&lt;=</span><span class="ch">&#39;9&#39;</span><span class="op">;</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">int</span> priority<span class="op">(</span><span class="dt">char</span> oper<span class="op">){</span></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>oper<span class="op">==</span><span class="ch">&#39;+&#39;</span> <span class="op">||</span> oper<span class="op">==</span><span class="ch">&#39;-&#39;</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span>oper<span class="op">==</span><span class="ch">&#39;*&#39;</span> <span class="op">||</span> oper<span class="op">==</span><span class="ch">&#39;/&#39;</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>toRPN<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>expr<span class="op">){</span></span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>ret<span class="op">;</span></span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>stack<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> oper<span class="op">;</span></span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> esize <span class="op">=</span> expr<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>esize<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span><span class="op">&amp;</span> c <span class="op">=</span> expr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb109-22"><a href="#cb109-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>c<span class="op">==</span><span class="ch">&#39; &#39;</span><span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb109-23"><a href="#cb109-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>isOper<span class="op">(</span>c<span class="op">)){</span></span>
<span id="cb109-24"><a href="#cb109-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>c<span class="op">==</span><span class="ch">&#39;-&#39;</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>i<span class="op">==</span><span class="dv">0</span> <span class="op">||</span> expr<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]==</span><span class="ch">&#39;(&#39;</span><span class="op">)){</span></span>
<span id="cb109-25"><a href="#cb109-25" aria-hidden="true" tabindex="-1"></a>                <span class="co">//判断一元运算符负号，这里采用了加个0-前缀的方法，如果题目要求输出RPN其实是做不到的</span></span>
<span id="cb109-26"><a href="#cb109-26" aria-hidden="true" tabindex="-1"></a>                <span class="co">//</span><span class="al">TODO</span><span class="co">: 把toRPN返回一个vector，实现真正的RPN</span></span>
<span id="cb109-27"><a href="#cb109-27" aria-hidden="true" tabindex="-1"></a>                ret<span class="op">.</span>push_back<span class="op">(</span><span class="ch">&#39;0&#39;</span><span class="op">);</span></span>
<span id="cb109-28"><a href="#cb109-28" aria-hidden="true" tabindex="-1"></a>                ret<span class="op">.</span>push_back<span class="op">(</span><span class="ch">&#39; &#39;</span><span class="op">);</span></span>
<span id="cb109-29"><a href="#cb109-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb109-30"><a href="#cb109-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span><span class="op">(!</span>oper<span class="op">.</span>empty<span class="op">()</span> <span class="op">&amp;&amp;</span> priority<span class="op">(</span>oper<span class="op">.</span>top<span class="op">())&gt;=</span>priority<span class="op">(</span>c<span class="op">)){</span></span>
<span id="cb109-31"><a href="#cb109-31" aria-hidden="true" tabindex="-1"></a>                <span class="co">//如果是右结合运算符，则要改成大于，如果只有一部分是右结合运算符，分类讨论</span></span>
<span id="cb109-32"><a href="#cb109-32" aria-hidden="true" tabindex="-1"></a>                ret<span class="op">.</span>push_back<span class="op">(</span>oper<span class="op">.</span>top<span class="op">());</span></span>
<span id="cb109-33"><a href="#cb109-33" aria-hidden="true" tabindex="-1"></a>                ret<span class="op">.</span>push_back<span class="op">(</span><span class="ch">&#39; &#39;</span><span class="op">);</span></span>
<span id="cb109-34"><a href="#cb109-34" aria-hidden="true" tabindex="-1"></a>                oper<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb109-35"><a href="#cb109-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb109-36"><a href="#cb109-36" aria-hidden="true" tabindex="-1"></a>            oper<span class="op">.</span>push<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb109-37"><a href="#cb109-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb109-38"><a href="#cb109-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>c<span class="op">==</span><span class="ch">&#39;(&#39;</span><span class="op">){</span></span>
<span id="cb109-39"><a href="#cb109-39" aria-hidden="true" tabindex="-1"></a>            oper<span class="op">.</span>push<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb109-40"><a href="#cb109-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb109-41"><a href="#cb109-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>c<span class="op">==</span><span class="ch">&#39;)&#39;</span><span class="op">){</span></span>
<span id="cb109-42"><a href="#cb109-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span><span class="op">(</span>oper<span class="op">.</span>top<span class="op">()!=</span><span class="ch">&#39;(&#39;</span><span class="op">){</span></span>
<span id="cb109-43"><a href="#cb109-43" aria-hidden="true" tabindex="-1"></a>                ret<span class="op">.</span>push_back<span class="op">(</span>oper<span class="op">.</span>top<span class="op">());</span></span>
<span id="cb109-44"><a href="#cb109-44" aria-hidden="true" tabindex="-1"></a>                ret<span class="op">.</span>push_back<span class="op">(</span><span class="ch">&#39; &#39;</span><span class="op">);</span></span>
<span id="cb109-45"><a href="#cb109-45" aria-hidden="true" tabindex="-1"></a>                oper<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb109-46"><a href="#cb109-46" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb109-47"><a href="#cb109-47" aria-hidden="true" tabindex="-1"></a>            oper<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb109-48"><a href="#cb109-48" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb109-49"><a href="#cb109-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb109-50"><a href="#cb109-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span><span class="op">(</span>i<span class="op">&lt;</span>esize <span class="op">&amp;&amp;</span> isDigit<span class="op">(</span>expr<span class="op">[</span>i<span class="op">])){</span></span>
<span id="cb109-51"><a href="#cb109-51" aria-hidden="true" tabindex="-1"></a>                ret<span class="op">.</span>push_back<span class="op">(</span>expr<span class="op">[</span>i<span class="op">++]);</span></span>
<span id="cb109-52"><a href="#cb109-52" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb109-53"><a href="#cb109-53" aria-hidden="true" tabindex="-1"></a>            ret<span class="op">.</span>push_back<span class="op">(</span><span class="ch">&#39; &#39;</span><span class="op">);</span></span>
<span id="cb109-54"><a href="#cb109-54" aria-hidden="true" tabindex="-1"></a>            i<span class="op">--;</span></span>
<span id="cb109-55"><a href="#cb109-55" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb109-56"><a href="#cb109-56" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb109-57"><a href="#cb109-57" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb109-58"><a href="#cb109-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(!</span>oper<span class="op">.</span>empty<span class="op">()){</span></span>
<span id="cb109-59"><a href="#cb109-59" aria-hidden="true" tabindex="-1"></a>        ret<span class="op">.</span>push_back<span class="op">(</span>oper<span class="op">.</span>top<span class="op">());</span></span>
<span id="cb109-60"><a href="#cb109-60" aria-hidden="true" tabindex="-1"></a>        ret<span class="op">.</span>push_back<span class="op">(</span><span class="ch">&#39; &#39;</span><span class="op">);</span></span>
<span id="cb109-61"><a href="#cb109-61" aria-hidden="true" tabindex="-1"></a>        oper<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb109-62"><a href="#cb109-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb109-63"><a href="#cb109-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb109-64"><a href="#cb109-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb109-65"><a href="#cb109-65" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb109-66"><a href="#cb109-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-67"><a href="#cb109-67" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> processOper<span class="op">(</span><span class="bu">std::</span>stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span> st<span class="op">,</span> <span class="dt">char</span> oper<span class="op">){</span></span>
<span id="cb109-68"><a href="#cb109-68" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> r <span class="op">=</span> st<span class="op">.</span>top<span class="op">();</span></span>
<span id="cb109-69"><a href="#cb109-69" aria-hidden="true" tabindex="-1"></a>    st<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb109-70"><a href="#cb109-70" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l <span class="op">=</span> st<span class="op">.</span>top<span class="op">();</span></span>
<span id="cb109-71"><a href="#cb109-71" aria-hidden="true" tabindex="-1"></a>    st<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb109-72"><a href="#cb109-72" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb109-73"><a href="#cb109-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span><span class="op">(</span>oper<span class="op">){</span></span>
<span id="cb109-74"><a href="#cb109-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="ch">&#39;+&#39;</span><span class="op">:</span></span>
<span id="cb109-75"><a href="#cb109-75" aria-hidden="true" tabindex="-1"></a>            st<span class="op">.</span>push<span class="op">(</span>l<span class="op">+</span>r<span class="op">);</span></span>
<span id="cb109-76"><a href="#cb109-76" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb109-77"><a href="#cb109-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="ch">&#39;-&#39;</span><span class="op">:</span></span>
<span id="cb109-78"><a href="#cb109-78" aria-hidden="true" tabindex="-1"></a>            st<span class="op">.</span>push<span class="op">(</span>l<span class="op">-</span>r<span class="op">);</span></span>
<span id="cb109-79"><a href="#cb109-79" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb109-80"><a href="#cb109-80" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="ch">&#39;*&#39;</span><span class="op">:</span></span>
<span id="cb109-81"><a href="#cb109-81" aria-hidden="true" tabindex="-1"></a>            st<span class="op">.</span>push<span class="op">(</span>l<span class="op">*</span>r<span class="op">);</span></span>
<span id="cb109-82"><a href="#cb109-82" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb109-83"><a href="#cb109-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="ch">&#39;/&#39;</span><span class="op">:</span></span>
<span id="cb109-84"><a href="#cb109-84" aria-hidden="true" tabindex="-1"></a>            st<span class="op">.</span>push<span class="op">(</span>l<span class="op">/</span>r<span class="op">);</span></span>
<span id="cb109-85"><a href="#cb109-85" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb109-86"><a href="#cb109-86" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb109-87"><a href="#cb109-87" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb109-88"><a href="#cb109-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-89"><a href="#cb109-89" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> RPNCalc<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>expr<span class="op">){</span></span>
<span id="cb109-90"><a href="#cb109-90" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ret <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb109-91"><a href="#cb109-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-92"><a href="#cb109-92" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> number<span class="op">;</span></span>
<span id="cb109-93"><a href="#cb109-93" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> esize <span class="op">=</span> expr<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb109-94"><a href="#cb109-94" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>esize<span class="op">;</span>i<span class="op">++){</span></span>
<span id="cb109-95"><a href="#cb109-95" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span><span class="op">&amp;</span> c <span class="op">=</span> expr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb109-96"><a href="#cb109-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>c<span class="op">==</span><span class="ch">&#39; &#39;</span><span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb109-97"><a href="#cb109-97" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span><span class="op">(</span>isOper<span class="op">(</span>c<span class="op">)){</span></span>
<span id="cb109-98"><a href="#cb109-98" aria-hidden="true" tabindex="-1"></a>            processOper<span class="op">(</span>number<span class="op">,</span> c<span class="op">);</span></span>
<span id="cb109-99"><a href="#cb109-99" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb109-100"><a href="#cb109-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span><span class="op">{</span></span>
<span id="cb109-101"><a href="#cb109-101" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> res <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb109-102"><a href="#cb109-102" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span><span class="op">(</span>i<span class="op">&lt;</span>esize <span class="op">&amp;&amp;</span> isDigit<span class="op">(</span>expr<span class="op">[</span>i<span class="op">])){</span></span>
<span id="cb109-103"><a href="#cb109-103" aria-hidden="true" tabindex="-1"></a>                res <span class="op">=</span> res<span class="op">*</span><span class="dv">10</span> <span class="op">+</span> expr<span class="op">[</span>i<span class="op">++]</span> <span class="op">-</span> <span class="ch">&#39;0&#39;</span><span class="op">;</span></span>
<span id="cb109-104"><a href="#cb109-104" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb109-105"><a href="#cb109-105" aria-hidden="true" tabindex="-1"></a>            i<span class="op">--;</span></span>
<span id="cb109-106"><a href="#cb109-106" aria-hidden="true" tabindex="-1"></a>            number<span class="op">.</span>push<span class="op">(</span>res<span class="op">);</span></span>
<span id="cb109-107"><a href="#cb109-107" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb109-108"><a href="#cb109-108" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb109-109"><a href="#cb109-109" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb109-110"><a href="#cb109-110" aria-hidden="true" tabindex="-1"></a>    ret <span class="op">=</span> number<span class="op">.</span>top<span class="op">();</span></span>
<span id="cb109-111"><a href="#cb109-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-112"><a href="#cb109-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb109-113"><a href="#cb109-113" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb109-114"><a href="#cb109-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-115"><a href="#cb109-115" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> exprCalc<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>expr<span class="op">){</span></span>
<span id="cb109-116"><a href="#cb109-116" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ret <span class="op">=</span> RPNCalc<span class="op">(</span>toRPN<span class="op">(</span>expr<span class="op">));</span></span>
<span id="cb109-117"><a href="#cb109-117" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb109-118"><a href="#cb109-118" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb109-119"><a href="#cb109-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-120"><a href="#cb109-120" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(){</span></span>
<span id="cb109-121"><a href="#cb109-121" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios<span class="bu">::</span>sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb109-122"><a href="#cb109-122" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb109-123"><a href="#cb109-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-124"><a href="#cb109-124" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>str<span class="op">;</span></span>
<span id="cb109-125"><a href="#cb109-125" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>str<span class="op">;</span></span>
<span id="cb109-126"><a href="#cb109-126" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb109-127"><a href="#cb109-127" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>toRPN<span class="op">(</span>str<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb109-128"><a href="#cb109-128" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>exprCalc<span class="op">(</span>str<span class="op">)&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb109-129"><a href="#cb109-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-130"><a href="#cb109-130" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb109-131"><a href="#cb109-131" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="艾弗森括号">艾弗森括号</h2>
<p>艾弗森括号常表示为<span class="math inline">\([A]\)</span>，其中<span class="math inline">\(A\)</span>是一个二值表达式。用三元运算符可以等价为<span class="math inline">\([A]\leftrightarrow A?1:0\)</span>。</p>
<p>例如<span class="math inline">\([\gcd(a,b)==1]\)</span>，就意味着，如果<span class="math inline">\(a,b\)</span>互质，式子的值为<span class="math inline">\(1\)</span>，否则为<span class="math inline">\(0\)</span>。</p>
<h2 id="向上向下取整">向上、向下取整</h2>
<p>在C++中，如果我们对一个double或者float用强制类型转换</p>
<pre><code>double x = 1.1;
std::cout&lt;&lt;(int)x&lt;&lt;&#34;\n&#34;;</code></pre>
<p>这其实看起来像是向下取整，实际上却不是。它是省略小数部分，实为向<span class="math inline">\(0\)</span>取整。C++的整数除法也是向零取整的，而Python则是向下取整。具体表现为C++中<span class="math inline">\(-7/2\)</span>为<span class="math inline">\(-3\)</span>，Python中<span class="math inline">\(-7//2\)</span>为<span class="math inline">\(-4\)</span>。</p>
<p>C++本身也有std::floor()和std::ceil()，但是只能针对浮点数使用。</p>
<p>我们一般会在结果非负的时候，用以下方式计算向上向下取整</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> a<span class="op">/</span>b<span class="op">;</span><span class="co">//a/b向下取整</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> y <span class="op">=</span> <span class="op">(</span>a<span class="op">+</span>b<span class="op">-</span><span class="dv">1</span><span class="op">)/</span>b<span class="op">;</span><span class="co">//a/b向上取整</span></span></code></pre></div>
<p>而对于负数结果，我们有一个性质</p>
<p><span class="math display">\[
-\lfloor x\rfloor= \lceil -x\rceil
\]</span></p>
<p><span class="math display">\[
-\lceil x\rceil= \lfloor -x\rfloor
\]</span></p>
<p>转换即可。</p>
<h1 id="c-stl用法">C++ STL用法</h1>
<h2 id="stdswap">std::swap</h2>
<p>交换两个元素的内容（也可以交换数组，不重要不介绍）。复杂度：常数。</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">,</span>b<span class="op">;</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>swap<span class="op">(</span>a<span class="op">,</span>b<span class="op">);</span></span></code></pre></div>
<p>注意其中的两个参数，类型要相同。不能一个是LL一个是int。</p>
<h2 id="stdsort">std::sort</h2>
<p>对数组、vector等进行排序。复杂度nlogn。</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>sort<span class="op">(</span>a<span class="op">,</span>a<span class="op">+</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>sort<span class="op">(</span>vec<span class="op">.</span>begin<span class="op">(),</span>vec<span class="op">.</span>end<span class="op">());</span></span></code></pre></div>
<p>注意排序范围是左闭右开区间。</p>
<p>通常会按照类型的&lt;操作符来进行比较。如果对结构体进行排序，可以重载运算符或者设定cmp函数。注意这两种方法一定不能是小于等于或者大于等于的运算，必须只使用小于号或者大于号（严格弱序）。</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> cmp<span class="op">(</span><span class="at">const</span> Type1<span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> Type2<span class="op">&amp;</span> b<span class="op">);</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="co">//然后在sort中加入第三个参数</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>sort<span class="op">(</span>a<span class="op">,</span>a<span class="op">+</span><span class="dv">5</span><span class="op">,</span>cmp<span class="op">);</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> node<span class="op">{</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="at">const</span> node<span class="op">&amp;</span> a<span class="op">);</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a><span class="co">//不用添加cmp参数</span></span></code></pre></div>
<h2 id="stdlower_boundstdupper_bound">std::lower_bound,std::upper_bound</h2>
<p>对某个已经排序好的数组，查找第一个大于等于（lower_bound）或者大于(upper_bound)某个给定值的元素。复杂度：logn（对于随机访问的迭代器），n（对于其他迭代器）。</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">5</span><span class="op">]={</span><span class="dv">0</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">6</span><span class="op">};</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> first <span class="op">=</span> <span class="bu">std::</span>lower_bound<span class="op">(</span>a<span class="op">,</span>a<span class="op">+</span><span class="dv">5</span><span class="op">,</span><span class="dv">3</span><span class="op">);</span></span></code></pre></div>
<p>同样是左闭右开区间，第三个参数是指定的值。如果找到就会返回所查找元素的迭代器（或者指针）。找不到就会返回末尾元素的后一个指针（或者end迭代器）。</p>
<p>如果需要自定义比较方法，同sort函数。</p>
<h2 id="stdmaxstdmin">std::max,std::min</h2>
<p>对于两个元素返回最大值和最小值。复杂度：准确一次比较。</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">=</span><span class="dv">1</span><span class="op">,</span>b<span class="op">=</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxv <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>a<span class="op">,</span>b<span class="op">);</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minv <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>a<span class="op">,</span>b<span class="op">);</span></span></code></pre></div>
<p>同样，两个参数类型相同。自定义比较方法同sort。如果要比较三四个元素，可以使用initializer_list，例如std::max({1,2,3,4,5});</p>
<h2 id="stdmax_elementstdmin_element">std::max_element,std::min_element</h2>
<p>返回一个范围内的最大（最小元素）的迭代器（指针）。复杂度，准确比较max(N-1,0)次</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span><span class="dv">3</span><span class="op">,</span><span class="dv">1</span><span class="op">,-</span><span class="dv">14</span><span class="op">,</span><span class="dv">9</span><span class="op">};</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;*</span><span class="bu">std::</span>max_element<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span>v<span class="op">.</span>end<span class="op">())&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span></code></pre></div>
<h2 id="stdabs">std::abs</h2>
<p>计算绝对值。复杂度：文档没写但应该是常数。</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> b <span class="op">=</span> <span class="bu">std::</span>abs<span class="op">(</span>a<span class="op">);</span></span></code></pre></div>
<p>注意，函数只有float,double,long
double的返回值类型。使用时如果给予整数参数会自动转换，这是否会导致精度问题有待观察。</p>
<h2 id="stdstring">std::string</h2>
<h3 id="swap">::swap</h3>
<p>将两个字符串互换。复杂度：常数。</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>str <span class="op">=</span> <span class="st">&#34;123456&#34;</span><span class="op">;</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>str2 <span class="op">=</span> <span class="st">&#34;456789&#34;</span><span class="op">;</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>str<span class="op">.</span>swap<span class="op">(</span>str2<span class="op">);</span></span></code></pre></div>
<h3 id="beginstdend">::begin,std::end</h3>
<p>返回字符串的起始得带器和结尾迭代器。</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>str<span class="op">.</span>begin<span class="op">();</span>str<span class="op">.</span>end<span class="op">();</span></span></code></pre></div>
<h3 id="size">::size</h3>
<p>返回字符串的大小。</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>str<span class="op">.</span>size<span class="op">();</span></span></code></pre></div>
<h3 id="push_back">::push_back</h3>
<p>向字符串末尾添加一个字符，同时大小加一。复杂度：常数。</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>str<span class="op">.</span>push_back<span class="op">(</span><span class="ch">&#39;a&#39;</span><span class="op">);</span></span></code></pre></div>
<h3 id="pop_back">::pop_back</h3>
<p>将字符串末尾的字符弹出，同时大小减一。如果字符串为空则未定义。复杂度：常数。</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>str<span class="op">.</span>pop_back<span class="op">();</span></span></code></pre></div>
<h3 id="find">::find</h3>
<p>在字符串中寻找某个子串是否存在。复杂度：没有规定，编译器不一定都是使用的kmp算法。</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="bu">::</span>size_type<span class="op"> </span>n<span class="op">;</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>s <span class="op">=</span> <span class="st">&#34;this is a string&#34;</span><span class="op">;</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> s<span class="op">.</span>find<span class="op">(</span><span class="st">&#34;is&#34;</span><span class="op">);</span></span></code></pre></div>
<p>如果找到则返回首个匹配的首字母位置。否则返回std::string::npos。如果是int
n作为s.find的接收端，则会在找不到时接收到-1。</p>
<h3 id="replace">::replace</h3>
<p>将字符串的某个片段替换为另一个字符串</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>s <span class="op">=</span> <span class="st">&#34;abcd efgh&#34;</span><span class="op">;</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>s<span class="op">.</span>replace<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="st">&#34;aaaa&#34;</span><span class="op">);</span></span></code></pre></div>
<p>第一个参数是开始位置的下标，第二个参数是指从开始位置有几个字符，第三个参数是将要替换进去的字符串，上式结果是”aaaaa
efgh”。</p>
<h3 id="substr">::substr</h3>
<p>获取自字符串</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>s <span class="op">=</span> <span class="st">&#34;abcd efgh&#34;</span><span class="op">;</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>b <span class="op">=</span> s<span class="op">.</span>substr<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">3</span><span class="op">);</span></span></code></pre></div>
<p>从下标1开始的3个字符，即b=“bcd”。</p>
<h2 id="stdmemset">std::memset</h2>
<p>将值复制到dest所指对象的前count个字节中。复杂度：没有规定。</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">20</span><span class="op">];</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>memset<span class="op">(</span>a<span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>a<span class="op">));</span></span></code></pre></div>
<p>注意，赋的值不能随便取，这个函数是一个字节一个字节地去赋值的。如果取1并不会得到全部赋值为1的效果，通常只会取0和-1。</p>
<h2 id="stdcopy">std::copy</h2>
<p>将一个范围的值复制给另一个范围，复杂度：准确赋值 (last - first)
次</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">10</span><span class="op">],</span>b<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>copy<span class="op">(</span>a<span class="op">,</span>a<span class="op">+</span><span class="dv">10</span><span class="op">,</span>b<span class="op">);</span><span class="co">//源起点，源终点，目的地起点</span></span></code></pre></div>
<p>需要注意的点是，不要数组越界，包括源不要越界，目标的大小也要足够复制。类型要一致。以及，目标起点的地址不能在源之内，否则行为是未定义的。</p>
<h2 id="stdfill">std::fill</h2>
<p>将给定值填写到整个范围中，复杂度：准确赋值 std::distance(first, last)
次。</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span><span class="op">};</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>fill<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">(),</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p>之后v变成全-1的vector。</p>
<p>可以对C数组使用指针，和memset不一样的是，memset是字节赋值，fill并不会把4字节的int每一个字节都赋值一次。</p>
<p>注意，如果你对结构体数组使用，你不能直接像memset一样全部memset为0。你要创建一个你认为的初始化应该有的值，再fill进去。</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A<span class="op">{</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">,</span>b<span class="op">;</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>a<span class="op">[</span><span class="dv">100</span><span class="op">];</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>memset<span class="op">(</span>a<span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="kw">sizeof</span><span class="op">(</span>a<span class="op">));</span></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a><span class="co">//std::fill(a,a+100,0);//出错</span></span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a>A tmp <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>fill<span class="op">(</span>a<span class="op">,</span>a<span class="op">+</span><span class="dv">100</span><span class="op">,</span>tmp<span class="op">);</span></span></code></pre></div>
<h2 id="stdmap">std::map</h2>
<p>map是有序键值对容器，通常用红黑树实现。元素的键是唯一的。</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Key<span class="op">,</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> T<span class="op">,</span></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Compare <span class="op">=</span> <span class="bu">std::</span>less<span class="op">&lt;</span>Key<span class="op">&gt;,</span></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Allocator <span class="op">=</span> <span class="bu">std::</span>allocator<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="at">const</span> Key<span class="op">,</span> T<span class="op">&gt;</span> <span class="op">&gt;</span></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="kw">class</span> map<span class="op">;</span></span></code></pre></div>
<p>可以通过迭代器来遍历</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="bu">std::</span>map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span><span class="dt">int</span><span class="op">&gt;::</span>iterator it <span class="op">=</span> mp<span class="op">.</span>begin<span class="op">();</span>it<span class="op">!=</span>mp<span class="op">.</span>end<span class="op">();</span>it<span class="op">++);</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a><span class="co">//访问元素用it-&gt;first和it-&gt;second</span></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a><span class="co">//或者</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> it<span class="op">:</span>mp<span class="op">);</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a><span class="co">//访问元素用it.first和it.second</span></span></code></pre></div>
<h3 id="自定义比较函数">自定义比较函数</h3>
<p>map通常会按照key的大小关系进行升序排列。如果要自定义比较函数，则</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> cmp<span class="op">{</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">()(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> a<span class="op">,</span> <span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> b<span class="op">)</span> <span class="at">const</span><span class="op">{</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a<span class="op">&gt;</span>b<span class="op">;</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span><span class="bu">std::</span>string<span class="op">,</span>cmp<span class="op">&gt;</span> mp<span class="op">;</span></span></code></pre></div>
<h3 id="empty">::empty</h3>
<p>检测是否为空。</p>
<h3 id="size-1">::size</h3>
<p>返回大小。</p>
<h3 id="clear">::clear</h3>
<p>清除所有内容。复杂度：线性。</p>
<h3 id="erase">::erase</h3>
<p>提供迭代器，删除迭代器所指的键值对。复杂度：常数。</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> it <span class="op">=</span> mp<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>mp<span class="op">.</span>erase<span class="op">(</span>it<span class="op">);</span></span></code></pre></div>
<p>当然也可以提供两个迭代器，删除这之间的所有元素（左闭右开区间）</p>
<h3 id="find-1">::find</h3>
<p>寻找key等于给定值的元素，返回迭代器。如果没有找到则返回end迭代器。复杂度：对数。</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> it <span class="op">=</span> mp<span class="op">.</span>find<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<h3 id="lower_boundupper_bound">::lower_bound,::upper_bound</h3>
<p>寻找首个大于等于(或大于，对upper_bound)给定值的key。复杂度：对数。</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> it <span class="op">=</span> mp<span class="op">.</span>lower_bound<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<h2 id="stdunordered_map">std::unordered_map</h2>
<p>可以看作是无序的map，通常由哈希表实现。这意味着map中和排序有关的函数都不能使用。</p>
<p><strong>警告</strong></p>
<p>unordered_map可能不能用auto
x:mp或者迭代器遍历。它的遍历可能是遍历bucket，而不是遍历元素。但是只是查找是可以的。</p>
<p>这里的bucket是指哈希桶，也就是用拉链法实现的hash表。</p>
<h2 id="stdset">std::set</h2>
<p>set是关联容器，含有Key类型对象的已排序集，通常用红黑树实现。</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Key<span class="op">,</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Compare <span class="op">=</span> <span class="bu">std::</span>less<span class="op">&lt;</span>Key<span class="op">&gt;,</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Allocator <span class="op">=</span> <span class="bu">std::</span>allocator<span class="op">&lt;</span>Key<span class="op">&gt;</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="kw">class</span> set<span class="op">;</span></span></code></pre></div>
<p>遍历的方式与map相同。</p>
<h3 id="使用方法">使用方法</h3>
<p>自定义比较函数,empty,size,clear,erase,find,lower_bound,upper_bound都与map相同。</p>
<h3 id="insert">::insert</h3>
<p>map可以用[]进行插入，但是set只能用insert函数。</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>set<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> st<span class="op">;</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>st<span class="op">.</span>insert<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p>返回值是一个pair，first是迭代器，指向被插入进去的元素（如果插入不成功则指向没插进去的元素），second是bool，插入成功时为true，否则为false。</p>
<h3 id="修改内部元素">修改内部元素</h3>
<p>有时候，我们需要修改内部元素。由于例如begin函数返回的迭代器是const的，我们无法直接修改数据。但我们可以给变量添加mutable修饰。这样我们就可以不用拿出来一个元素再插回去。例子可见珂朵莉树。</p>
<p>注意，如果你修改的数据和排序依据有关，set不会维护内部有序。要维护还得是拿出来再插入进去。</p>
<h2 id="stdunordered_set">std::unordered_set</h2>
<p>用哈希实现，没有内部排序。</p>
<p><strong>警告</strong></p>
<p>可能跟unordered_map一样不能遍历。</p>
<h2 id="stdmultiset">std::multiset</h2>
<p>与普通的set不同的是，可以插入多个相同的元素。这在一些情况下是有用的，而且它还是满足内部有序。</p>
<p>可以用::count(x)来统计Key为x的元素的数量，普通的set也有这个方法，但是要么是0要么是1，与find功能可以说是重复。但是multiset可以统计数量。</p>
<p>注意，用erase方法时，如果给出的是一个值，那么会把等于这个值的元素都删掉，如果给出迭代器，那么之后删一个。所以，只想删一个等于这个值的元素时，用erase(find(…))</p>
<h2 id="stdstack">std::stack</h2>
<p>栈，有先入后出特性。</p>
<h3 id="top">::top</h3>
<p>访问栈顶元素，复杂度：常数。</p>
<h3 id="empty-1">::empty</h3>
<p>检查是否为空，复杂度：常数</p>
<h3 id="size-2">::size</h3>
<p>返回元素个数，复杂度：常数</p>
<h3 id="push">::push</h3>
<p>将元素推入栈，复杂度：通常和deque的push_back相同，即常数</p>
<h3 id="pop">::pop</h3>
<p>将栈顶弹出，复杂度：通常和deque的pop_back相同，即常数</p>
<h3 id="emplace">::emplace</h3>
<p>在顶部原位构造元素，通常会用在栈的元素是结构体的时候，复杂度：通常和deque的emplace_back相同，即常数</p>
<h2 id="stdqueue">std::queue</h2>
<p>队列，拥有先入先出特性。</p>
<h3 id="front">::front</h3>
<p>访问队首元素，复杂度：常数</p>
<h3 id="back">::back</h3>
<p>访问队尾元素，复杂度：常数</p>
<h3 id="其他方法">其他方法</h3>
<p>同stack，不过push是推入队尾，pop是弹出队首。</p>
<h2 id="stdpriority_queue">std::priority_queue</h2>
<p>优先队列，提供常数时间的最大（或最小）元素查找，以及对数时间的插入与删除。</p>
<h3 id="自定义比较方法">自定义比较方法</h3>
<p>通常我们会重载元素的运算符来自定义</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> node <span class="op">{</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> dis<span class="op">,</span> u<span class="op">;</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;(</span><span class="at">const</span> node<span class="op">&amp;</span> a<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> dis <span class="op">&gt;</span> a<span class="op">.</span>dis<span class="op">;</span> <span class="op">}</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>priority_queue<span class="op">&lt;</span>node<span class="op">,</span> vector<span class="op">&lt;</span>node<span class="op">&gt;,</span> greater<span class="op">&lt;</span>node<span class="op">&gt;</span> <span class="op">&gt;</span> pq<span class="op">;</span></span></code></pre></div>
<h3 id="方法">方法</h3>
<p>其方法与stack相同，只不过没有先入后出特性，插入元素或弹出元素后会根据大小关系进行排序，保证栈顶是最大的（或最小的）元素。</p>
<h2 id="stddeque">std::deque</h2>
<p>双端队列，允许在队首和队尾进行插入和删除。另外，在 deque
任一端插入或删除不会非法化指向其余元素的指针或引用。通常也会用来实现单调队列。</p>
<h3 id="方法-1">方法</h3>
<p>size、empty与stack、queue相同。其pop_back、push_back、pop_front、push_front、emplace_front、emplace_back用法也类似。</p>
<h2 id="stdvector">std::vector</h2>
<p>通常可以理解为一个可以变化长度的数组。</p>
<h3 id="声明方法">声明方法</h3>
<div class="sourceCode" id="cb140"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">;</span><span class="co">//声明一个初始大小为0的vector</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec2<span class="op">(</span>n<span class="op">);</span><span class="co">//声明一个初始大小为n的vector，每个元素都会初始化为0</span></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec3<span class="op">(</span>n<span class="op">,</span><span class="dv">1</span><span class="op">);</span><span class="co">//与上一个不同的是，每一个元素都会初始化为1</span></span></code></pre></div>
<h3 id="元素访问">元素访问</h3>
<div class="sourceCode" id="cb141"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>vec<span class="op">[</span><span class="dv">5</span><span class="op">];</span><span class="co">//像数组一样访问</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>vec<span class="op">.</span>at<span class="op">(</span><span class="dv">5</span><span class="op">);</span><span class="co">//与上一个方法的差别在会进行越界检查</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>vec<span class="op">.</span>front<span class="op">();</span><span class="co">//访问第一个元素</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>vec<span class="op">.</span>back<span class="op">();</span><span class="co">//访问最后一个元素</span></span></code></pre></div>
<h3 id="size-3">::size</h3>
<p>获取大小，复杂度：常数</p>
<h3 id="empty-2">::empty</h3>
<p>查看是否为空，复杂度：常数</p>
<h3 id="push_back-1">::push_back</h3>
<p>向末尾添加元素，复杂度：常数</p>
<h3 id="pop_back-1">::pop_back</h3>
<p>把末尾元素弹出，复杂度：常数</p>
<h3 id="emplace_back">::emplace_back</h3>
<p>在末尾原位构造元素，复杂度：常数</p>
<h3 id="resize">::resize</h3>
<p>重新指定vector的大小，会改变size()，resize有两个参数(new_size,
value)，第一个为要分配的大小，第二个为指定的初始值（可以忽略，此时调用默认构造函数）。注意只有加大size时，新增的元素会被赋值。</p>
<h3 id="reserve">::reserve</h3>
<p>给vector预留空间，但不会改变size()的大小。参数只有一个，为预留的元素个数。</p>
<p>如果dfs中参数引用的vector会导致RE，可以试试预留足够的大小。</p>
<h3 id="stdvectorbool">std::vector&lt;bool&gt;</h3>
<p>这是一个特化的vector，它每一个元素所占的空间是一位，而不是sizeof(bool)（通常是一字节）。</p>
<p>不建议使用，除非非常了解会发生什么。</p>
<p>operator[]返回的不是bool类型，返回的是一个proxy reference。</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> c<span class="op">{</span><span class="kw">false</span><span class="op">,</span><span class="kw">true</span><span class="op">,</span><span class="kw">true</span><span class="op">};</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> a <span class="op">=</span> c<span class="op">[</span><span class="dv">0</span><span class="op">];</span><span class="co">//经过了强制类型转换</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> b <span class="op">=</span> c<span class="op">[</span><span class="dv">0</span><span class="op">];</span><span class="co">//没有转换，本身b就是引用了</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="kw">true</span><span class="op">;</span><span class="co">//c是0 1 1</span></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="kw">true</span><span class="op">;</span><span class="co">//c是1 1 1</span></span></code></pre></div>
<h2 id="stdbitset">std::bitset</h2>
<p>表示一串二进制位。</p>
<h3 id="声明方法-1">声明方法</h3>
<div class="sourceCode" id="cb143"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>bitset<span class="op">&lt;</span><span class="dv">100</span><span class="op">&gt;</span> bs<span class="op">;</span><span class="co">//声明一个位数为100位的bitset</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>bitset<span class="op">&lt;</span><span class="dv">4</span><span class="op">&gt;</span> bs2<span class="op">{</span><span class="bn">0xA</span><span class="op">};</span><span class="co">//声明一个四位的bitset，其值等于0xA</span></span></code></pre></div>
<h3 id="元素访问-1">元素访问</h3>
<p>同数组的访问方式。同样也可以用数组的方式进行修改。</p>
<h3 id="allanynone">::all,::any,::none</h3>
<p>检查是否全部，存在、没有元素被设置为true。</p>
<h3 id="count">::count</h3>
<p>返回设置为true的数量。</p>
<h3 id="运算">运算</h3>
<p>bitset和bitset之间能用所有的位运算符。也可以用等号和不等号比较。</p>
<h3 id="flip">::flip</h3>
<p>翻转某一位的值。</p>
<p>如果没有提供位置，就翻转所有。</p>
<h3 id="to_string">::to_string</h3>
<p>转化为二进制数的字符串。</p>
<h3 id="to_ulongto_ullong">::to_ulong,::to_ullong</h3>
<p>转化为unsigned long和unsigned long long。</p>
<h3 id="set">::set</h3>
<p>设置某一位为1，如果没有提供位置，则将所有位设为1</p>
<h3 id="reset">::reset</h3>
<p>设置某一位为0，如果没有提供位置，则将所有位设置为0</p>
<h2 id="stdpair">std::pair</h2>
<p>定义一个二元组，例如std::pair&lt;int,int&gt;,
std::pair&lt;int,std::string&gt;等。其定义是在&lt;utility&gt;中，但是也可以#include
&lt;algorithm&gt;来使用</p>
<h3 id="元素访问-2">元素访问</h3>
<div class="sourceCode" id="cb144"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span><span class="dt">int</span><span class="op">&gt;</span> p<span class="op">;</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>p<span class="op">-&gt;</span>first<span class="op">;</span><span class="co">//访问第一个元素</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>p<span class="op">-&gt;</span>second<span class="op">;</span><span class="co">//访问第二个元素</span></span></code></pre></div>
<h3 id="swap-1">::swap</h3>
<p>交换两个元素的内容。复杂度：没有定义。</p>
<h3 id="stdmake_pair">std::make_pair</h3>
<div class="sourceCode" id="cb145"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> p <span class="op">=</span> <span class="bu">std::</span>make_pair<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">);</span><span class="co">//自动推断类型为std::pair&lt;int,int&gt;</span></span></code></pre></div>
<h2 id="stdtuple">std::tuple</h2>
<p>定义一个多元组，可以说pair是tuple的特例。其定义是在&lt;utility&gt;中，但是也可以#include
&lt;algorithm&gt;来使用</p>
<h3 id="元素访问-3">元素访问</h3>
<p>根据下标可以如下访问</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> t <span class="op">=</span> <span class="bu">std::</span>make_tuple<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="st">&#34;Foo&#34;</span><span class="op">,</span> <span class="fl">3.14</span><span class="op">);</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>t<span class="op">);</span><span class="co">//1</span></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>t<span class="op">);</span><span class="co">//Foo</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;(</span>t<span class="op">);</span><span class="co">//3.14</span></span></code></pre></div>
<h3 id="stdmake_tuple">std::make_tuple</h3>
<p>同pair。</p>
<p>如果一个函数要返回tuple</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> foo_tuple<span class="op">()</span> </span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">};</span>  <span class="co">// N4387 前错误</span></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;{</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">};</span>  <span class="co">// 始终有效</span></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>make_tuple<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span> <span class="co">// 始终有效</span></span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>需要注意兼容性，有些编译器不支持第一种返回方式。</p>
<h3 id="stdtie">std::tie</h3>
<p>将tuple解包。</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> t <span class="op">=</span> <span class="bu">std::</span>make_tuple<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="st">&#34;Foo&#34;</span><span class="op">);</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">,</span>b<span class="op">;</span></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>str<span class="op">;</span></span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>tie<span class="op">(</span>a<span class="op">,</span>b<span class="op">,</span>str<span class="op">)</span> <span class="op">=</span> t<span class="op">;</span></span></code></pre></div>
<p>当然也可以用auto，都不需要指定变量类型。</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span><span class="op">[</span>c<span class="op">,</span>d<span class="op">,</span>str2<span class="op">]</span> <span class="op">=</span> t<span class="op">;</span></span></code></pre></div>
<h2 id="stdnext_permutation-stdprev_permutation">std::next_permutation,
std::prev_permutation</h2>
<div class="sourceCode" id="cb150"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> next_permutation <span class="op">(</span>Iterator first<span class="op">,</span> Iterator last<span class="op">);</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> prev_permutation<span class="op">(</span>Iterator first<span class="op">,</span> Iterator last<span class="op">);</span></span></code></pre></div>
<p>这两个算法都是“原地”算法，也就是说会直接更改原数组，而不会返回一个新数组。这两个函数的作用是，获取按字典序比当前排列小1号的排列，以及大1号的排列。</p>
<p>例如123是一个排列，比它正好大1号的排列是132，再大1号的是213。比321小1号的是312。</p>
<p>用法如下</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>string number <span class="op">=</span> <span class="st">&#34;213&#34;</span><span class="op">;</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>next_permutation<span class="op">(</span>number<span class="op">.</span>begin<span class="op">(),</span> number<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> number<span class="op">;</span></span></code></pre></div>
<p>输出231。</p>
<p>如果当前已经是最小的还要得到更小的，则返回false。已经是最大的还要得到更大的，则返回false。其他情况返回true。</p>
<p>复杂度：线性。</p>
<h2 id="stdunique">std::unique</h2>
<p>对一个已经排好序的数组去除重复元素。或者说是，移除一个一般数组中相邻的、相同的元素。复杂度：线性。</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>Iterator unique<span class="op">(</span>Iterator first<span class="op">,</span> Iterator last<span class="op">);</span></span></code></pre></div>
<p>给出一个范围来进行这个操作。具体用例可以见离散化一节。</p>
<p>返回值是新数组的末尾的迭代器。</p>
<h2 id="stdcin">std::cin</h2>
<h3 id="输入十六进制八进制二进制">输入十六进制、八进制、二进制</h3>
<div class="sourceCode" id="cb153"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cin<span class="op">&gt;&gt;</span><span class="bu">std::</span>hex<span class="op">&gt;&gt;</span>a<span class="op">;</span><span class="co">//16进制</span></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cin<span class="op">&gt;&gt;</span><span class="bu">std::</span>dec<span class="op">&gt;&gt;</span>a<span class="op">;</span><span class="co">//10进制</span></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cin<span class="op">&gt;&gt;</span><span class="bu">std::</span>oct<span class="op">&gt;&gt;</span>a<span class="op">;</span><span class="co">//8进制</span></span></code></pre></div>
<p>注意，使用一次std::hex之后所有的输入都会是十六进制，需要用std::dec输入一次十进制才会转换回来。</p>
<p>输入二进制可以考虑用bitset</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>bitset<span class="op">&lt;</span><span class="dv">32</span><span class="op">&gt;</span> bs<span class="op">;</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cin<span class="op">&gt;&gt;</span>bs<span class="op">;</span></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>bs<span class="op">.</span>to_ulong<span class="op">();</span></span></code></pre></div>
<h3 id="输入不忽略空格回车">输入不忽略空格、回车</h3>
<p>虽然可以用cin.get()和cin.getline()来实现，但是我们还是考虑用getchar比较好，当getchar返回EOF时代表输入结束。类似于逗号表达式返回最后一个的值，等号表达式返回等号左边的值，所以我们可以写(c=getchar())!=EOF。</p>
<h2 id="stdcout">std::cout</h2>
<h3 id="输出十六进制八进制二进制">输出十六进制、八进制、二进制</h3>
<div class="sourceCode" id="cb155"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">16</span><span class="op">;</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="bu">std::</span>hex<span class="op">&lt;&lt;</span>a<span class="op">;</span><span class="co">//16进制</span></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="bu">std::</span>oct<span class="op">&lt;&lt;</span>a<span class="op">;</span><span class="co">//8进制</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="bu">std::</span>dec<span class="op">&lt;&lt;</span>a<span class="op">;</span><span class="co">//10进制</span></span></code></pre></div>
<p>使用注意事项同前。</p>
<p>输出二进制也是考虑用bitset</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>bitset<span class="op">&lt;</span><span class="dv">32</span><span class="op">&gt;</span> bs<span class="op">{</span><span class="dv">64</span><span class="op">};</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string<span class="op"> </span>ans <span class="op">=</span> bs<span class="op">.</span>to_string<span class="op">();</span></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>ans<span class="op">.</span>substr<span class="op">(</span>ans<span class="op">.</span>find<span class="op">(</span><span class="ch">&#39;1&#39;</span><span class="op">),</span><span class="dt">int</span><span class="op">(</span>ans<span class="op">.</span>end<span class="op">()-</span>ans<span class="op">.</span>begin<span class="op">()))&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span></code></pre></div>
<p>需要去除前导0，如果直接输出bs或者其to_string的话会带有前导0</p>
<h3 id="浮点数精度">浮点数精度</h3>
<div class="sourceCode" id="cb157"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="bu">std::</span>fixed<span class="op">;</span><span class="co">//如果不用这个，则为有效数字四位。</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">.</span>precision<span class="op">(</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>a<span class="op">;</span><span class="co">//这里输出小数点后4位。</span></span></code></pre></div>
<h2 id="scanf-todo">scanf TODO</h2>
<h3 id="输入十六进制八进制二进制-1">输入十六进制、八进制、二进制</h3>
<h2 id="printf-todo">printf TODO</h2>
<h3 id="输出十六进制八进制二进制-1">输出十六进制、八进制、二进制</h3>
<h2 id="正则表达式">正则表达式</h2>
<h3 id="正则表达式语法">正则表达式语法</h3>
<table>
<colgroup>
<col style="width: 33%"/>
<col style="width: 33%"/>
<col style="width: 33%"/>
</colgroup>
<thead>
<tr class="header">
<th>符号</th>
<th>功能</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>literal</td>
<td>匹配字符串的值</td>
<td>foo</td>
</tr>
<tr class="even">
<td>\</td>
<td>转义符，将一些正则表达式需要的符号进行转义</td>
<td>\.</td>
</tr>
<tr class="odd">
<td>()</td>
<td>括选一些字符，方便星号、加号等当作一个整体处理</td>
<td>a(abc)*</td>
</tr>
<tr class="even">
<td>re1|re2</td>
<td>匹配re1或匹配re2的值</td>
<td>foo|bar</td>
</tr>
<tr class="odd">
<td>.</td>
<td>匹配换行符以外的单字符</td>
<td>a.b</td>
</tr>
<tr class="even">
<td>^</td>
<td>在字符串开头匹配（在方括号里除外）</td>
<td>^Dear</td>
</tr>
<tr class="odd">
<td>$</td>
<td>在字符串的结尾匹配</td>
<td>\.sh$</td>
</tr>
<tr class="even">
<td>*</td>
<td>匹配星号前面的零次、一次或多次</td>
<td>a(abc)*</td>
</tr>
<tr class="odd">
<td>+</td>
<td>匹配加号前面的一次或多次</td>
<td>a(abc)+</td>
</tr>
<tr class="even">
<td>?</td>
<td>匹配问号前面的零次或一次</td>
<td>a(abc)?</td>
</tr>
<tr class="odd">
<td>{N}</td>
<td>指定匹配次数</td>
<td>a(abc){5}</td>
</tr>
<tr class="even">
<td>{M,N}</td>
<td>匹配出现次数在M,N之间的，如果左边留空代表0次，右边留空代表任意次</td>
<td>a(abc){2,8}</td>
</tr>
<tr class="odd">
<td>[…]</td>
<td>匹配其中的任意字符</td>
<td>[aeiou],[0-9A-Za-z]</td>
</tr>
<tr class="even">
<td>[^…]</td>
<td>匹配除了其中字符的任意字符</td>
<td>[^aeiou]</td>
</tr>
<tr class="odd">
<td>\n</td>
<td>匹配回车符</td>
<td></td>
</tr>
<tr class="even">
<td>\s</td>
<td>匹配任何空白字符</td>
<td></td>
</tr>
<tr class="odd">
<td>\S</td>
<td>匹配任何非空字符</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>贪婪匹配</strong></p>
<p>*，+都是贪婪匹配的，也就是说，如果用”&lt;.*&gt;“匹配”&lt;h1&gt;测试&lt;/h1&gt;“会匹配到全文，而不是只匹配到”&lt;h1&gt;“这叫做贪婪匹配。如果遇到第一个满足的就停下，要用”&lt;.*?&gt;“”</p>
<h3 id="c正则表达式库">C++正则表达式库</h3>
<h4 id="stdregex">std::regex</h4>
<p>一个类型，可以设定匹配的模式串。</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>regex<span class="op"> </span>pattern<span class="op">(</span><span class="st">&#34;.*&lt;.*?&gt;.*&#34;</span><span class="op">);</span></span></code></pre></div>
<p>后续如果要更换pattern的内容，可以使用pattern.assign(“sth.”)或者直接pattern
= “sth.”</p>
<h4 id="stdsmatch">std::smatch</h4>
<p>一个类型，可以用于接收匹配的结果。</p>
<h4 id="stdregex_match">std::regex_match</h4>
<p>用于测试字符串是否匹配模式串</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> regex_match<span class="op">(</span>string s<span class="op">,</span>regex pattern<span class="op">);</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> regex_match<span class="op">(</span>string s<span class="op">,</span>smatch res<span class="op">,</span>regex pattern<span class="op">);</span></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> regex_match<span class="op">(</span>s<span class="op">.</span>cbegin<span class="op">(),</span>s<span class="op">.</span>cend<span class="op">(),</span>smatch res<span class="op">,</span>regex pattern<span class="op">);</span></span></code></pre></div>
<p>如果匹配到，就会返回1，否则返回0。</p>
<p>s代表被匹配的字符串，pattern代表模式串。res代表，如果这个字符串被匹配了，就会返回这个字符串。注意这里是完全匹配，后面介绍的search函数是子串匹配。</p>
<p>res是smatch类型，不能直接cout，要输出res[0]。</p>
<p>如果要传入一个字符串的范围，需要传入const_iterator，也就是s.cbegin()和s.cend()返回的版本（这其实是因为smatch的模板是const_iterator，如果是c风格字符数组，传入的是头尾指针，则要用cmatch）。此时如果匹配上，返回res是这个范围的字符串，而不是整个。</p>
<p>const_iterator不是指迭代器指的位置不能变，而是指你不能通过这个迭代器去修改元素。</p>
<h4 id="stdregex_search">std::regex_search</h4>
<div class="sourceCode" id="cb160"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> regex_search<span class="op">(</span>string s<span class="op">,</span>regex pattern<span class="op">);</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> regex_search<span class="op">(</span>string s<span class="op">,</span>smatch res<span class="op">,</span>regex pattern<span class="op">);</span></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> regex_search<span class="op">(</span>s<span class="op">.</span>cbegin<span class="op">(),</span>s<span class="op">.</span>cend<span class="op">(),</span>smatch res<span class="op">,</span>regex pattern<span class="op">);</span></span></code></pre></div>
<p>参数、返回值同前。</p>
<p>只不过，这个东西不是完全匹配，只要有任意子串匹配，就会返回1。而且只要匹配到一个就会返回（当然这里要注意贪婪和非贪婪），不会再往后搜索，所以如果你使用res[1]是不会输出第二个结果的。res[0]返回的是匹配到的子串的结果，res[1]以后的东西也有含义，但是我暂时觉得没什么用。</p>
<p>res[0]的类型是sub_match，可以使用.second方法得到res[0]在s中的匹配结果位置的末尾的迭代器，所以要遍历所有匹配的子序列，可以这么写：</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span><span class="op">(</span><span class="bu">std::</span>regex_search<span class="op">(</span>it_begin<span class="op">,</span>it_end<span class="op">,</span>res<span class="op">,</span>pattern<span class="op">)){</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>cout<span class="op">&lt;&lt;</span>res<span class="op">[</span><span class="dv">0</span><span class="op">]&lt;&lt;</span><span class="st">&#34; &#34;</span><span class="op">&lt;&lt;</span>res<span class="op">.</span>position<span class="op">()&lt;&lt;</span><span class="st">&#34;</span><span class="sc">\n</span><span class="st">&#34;</span><span class="op">;</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>   it_begin <span class="op">=</span> res<span class="op">[</span><span class="dv">0</span><span class="op">].</span>second<span class="op">;</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>其中你还可以用.position返回子串开头的位置（相对于it_begin而言）。</p>
<h4 id="stdregex_replace">std::regex_replace</h4>
<div class="sourceCode" id="cb162"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a>string regex_replace<span class="op">(</span>string s<span class="op">,</span>regex p<span class="op">,</span>string rs<span class="op">)</span></span></code></pre></div>
<p>s为源字符串，p为模式串，rs为匹配到的子串将会被替换成的字符串。</p>
<p>返回替换后的字符串。</p>
<p>这里会替换一切匹配到的子串，不像search一样麻烦。</p>
<p>如果我们只替换被匹配的子串的一部分，我们可以用如下方法</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a>string s <span class="op">=</span> <span class="st">&#34;abcd123abcd&#34;</span><span class="op">;</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>regex p<span class="op">(</span><span class="st">&#34;(abcd)([0-9]+)&#34;</span><span class="op">);</span></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>string ss <span class="op">=</span> regex_replace<span class="op">(</span>s<span class="op">,</span>p<span class="op">,</span><span class="st">&#34;a$2&#34;</span><span class="op">);</span></span></code></pre></div>
<p>则我们的ss会变成a123abcd。$2代表的是第二个捕捉组的意思（这里下标又是从1开始的，而不是0）。捕捉组是括号括起来的算一组。</p>
<table>
<thead>
<tr class="header">
<th>转义符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>$n</td>
<td>表示第n个捕捉组捕捉到的字符串</td>
</tr>
<tr class="even">
<td>$&amp;</td>
<td>表示匹配到的整个子串，相当于$0</td>
</tr>
<tr class="odd">
<td>$`</td>
<td>在源字符串中，在匹配到的子串左边的部分</td>
</tr>
<tr class="even">
<td>$&#39;</td>
<td>在源字符串中，在匹配到的子串右边的部分</td>
</tr>
<tr class="odd">
<td>$$</td>
<td>美元符号</td>
</tr>
</tbody>
</table>



</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
        
            <a href="/tags/%E6%A8%A1%E6%9D%BF/">模板</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/atcoder-beginner-conteset-263-e%E6%A6%82%E7%8E%87dp/">
        
        

        <div class="article-details">
            <h2 class="article-title">Atcoder Beginner Conteset 263 E（概率DP）</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97%E7%9A%84%E5%88%86%E9%85%8D%E5%BE%8B/">
        
        

        <div class="article-details">
            <h2 class="article-title">取余运算的分配律</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/">
        
        
            <div class="article-image">
                <img src="/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/1.79caa0d7397355f82035319e18420be7_hue13a31d22502e6414becf06d466eec8f_119570_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-ecqg1zlzVfggNTGeGEIL5w==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">算法题-网络设备管理</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%90%91%E9%87%8F/">
        
        

        <div class="article-details">
            <h2 class="article-title">算法题-向量</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%9C%89%E9%99%90%E5%B0%8F%E6%95%B0/">
        
        

        <div class="article-details">
            <h2 class="article-title">算法题-有限小数</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="kegalas/blogComments"
        issue-term="pathname"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2023 KegalaS的个人博客
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.4.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#字符串">字符串</a>
      <ol>
        <li><a href="#kmp">KMP</a></li>
        <li><a href="#字典树trie">字典树(Trie)</a></li>
        <li><a href="#字符串哈希">字符串哈希</a></li>
        <li><a href="#ac自动机">AC自动机</a></li>
        <li><a href="#最小表示法">最小表示法</a></li>
        <li><a href="#manacher">Manacher</a></li>
        <li><a href="#z函数">Z函数</a></li>
        <li><a href="#后缀数组">后缀数组</a></li>
        <li><a href="#后缀自动机">后缀自动机</a></li>
        <li><a href="#广义后缀自动机">广义后缀自动机</a></li>
        <li><a href="#回文字动机">回文字动机</a></li>
        <li><a href="#序列自动机">序列自动机</a></li>
      </ol>
    </li>
    <li><a href="#数论">数论</a>
      <ol>
        <li><a href="#欧几里得算法">欧几里得算法</a></li>
        <li><a href="#扩展欧几里得">扩展欧几里得</a></li>
        <li><a href="#欧拉筛">欧拉筛</a></li>
        <li><a href="#miller-rabin素数测试">Miller-Rabin素数测试</a></li>
        <li><a href="#乘法逆元">乘法逆元</a></li>
        <li><a href="#线性求逆元">线性求逆元</a></li>
        <li><a href="#线性同余方程">线性同余方程</a></li>
        <li><a href="#中国剩余定理">中国剩余定理</a></li>
        <li><a href="#积性函数">积性函数</a></li>
        <li><a href="#欧拉函数-todo习题">欧拉函数
TODO：习题</a></li>
        <li><a href="#狄利克雷卷积">狄利克雷卷积</a></li>
        <li><a href="#莫比乌斯反演-todo习题">莫比乌斯反演 TODO：习题</a></li>
        <li><a href="#数论分块">数论分块</a></li>
        <li><a href="#杜教筛">杜教筛</a></li>
      </ol>
    </li>
    <li><a href="#图论">图论</a>
      <ol>
        <li><a href="#存图">存图</a>
          <ol>
            <li><a href="#邻接矩阵">邻接矩阵</a></li>
            <li><a href="#邻接表vector版">邻接表（vector版）</a></li>
            <li><a href="#链式前向星vector版">链式前向星（vector版）</a></li>
            <li><a href="#链式前向星传统数组版">链式前向星（传统数组版）</a></li>
          </ol>
        </li>
        <li><a href="#最短路">最短路</a>
          <ol>
            <li><a href="#dijkstra">Dijkstra</a></li>
            <li><a href="#bellman-ford">Bellman-Ford</a></li>
            <li><a href="#spfa">SPFA</a></li>
            <li><a href="#floyd">Floyd</a></li>
            <li><a href="#johnson-todo">Johnson TODO</a></li>
          </ol>
        </li>
        <li><a href="#差分约束">差分约束</a></li>
        <li><a href="#拓扑排序">拓扑排序</a></li>
        <li><a href="#最小生成树">最小生成树</a>
          <ol>
            <li><a href="#kruskal">Kruskal</a></li>
            <li><a href="#prim算法">Prim算法</a></li>
          </ol>
        </li>
        <li><a href="#最小树形图朱刘算法">最小树形图（朱刘算法）</a></li>
        <li><a href="#二分图判定">二分图判定</a></li>
        <li><a href="#二分图匹配">二分图匹配</a>
          <ol>
            <li><a href="#最大匹配匈牙利算法">最大匹配（匈牙利算法）</a></li>
            <li><a href="#二分图的相关定理">二分图的相关定理</a></li>
            <li><a href="#最大匹配转换为网络流模型">最大匹配转换为网络流模型</a></li>
            <li><a href="#二分图最大权完美匹配km算法-todo-bfs版">二分图最大权完美匹配（KM算法）
TODO: BFS版</a></li>
            <li><a href="#最大权匹配转化为费用流">最大权匹配转化为费用流</a></li>
          </ol>
        </li>
        <li><a href="#动态维护二分图判定-todo-例题">动态维护二分图判定 TODO:
例题</a></li>
        <li><a href="#网络流">网络流</a>
          <ol>
            <li><a href="#最大流">最大流</a></li>
            <li><a href="#isap算法-todo">ISAP算法
TODO</a></li>
            <li><a href="#最大流最小割定理">最大流最小割定理</a></li>
            <li><a href="#最小费用最大流">最小费用最大流</a></li>
            <li><a href="#上下界流">上下界流</a></li>
          </ol>
        </li>
        <li><a href="#割边tarjan算法">割边（Tarjan算法）</a></li>
        <li><a href="#割点tarjan算法">割点（Tarjan算法）</a></li>
        <li><a href="#强连通分量tarjan算法">强连通分量（Tarjan算法）</a></li>
        <li><a href="#sat问题">2-SAT问题</a></li>
        <li><a href="#边双联通分量">边双联通分量</a></li>
        <li><a href="#边双联通缩点todo">边双联通缩点TODO</a></li>
        <li><a href="#点双联通分量">点双联通分量</a></li>
        <li><a href="#点双联通缩点todo">点双联通缩点TODO</a></li>
        <li><a href="#树的直径">树的直径</a></li>
        <li><a href="#树的重心">树的重心</a></li>
        <li><a href="#倍增求最近公共祖先">倍增求最近公共祖先</a></li>
        <li><a href="#虚树-todo">虚树 TODO</a></li>
        <li><a href="#点分治">点分治</a></li>
        <li><a href="#重链剖分">重链剖分</a>
          <ol>
            <li><a href="#重链剖分求lca">重链剖分求LCA</a></li>
            <li><a href="#重链剖分线段树维护树上路径点权和">重链剖分+线段树维护树上路径点权和</a></li>
          </ol>
        </li>
        <li><a href="#长链剖分">长链剖分</a>
          <ol>
            <li><a href="#求k级祖先">求K级祖先</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#计算几何-todo">计算几何 TODO</a>
      <ol>
        <li><a href="#基础板子">基础板子</a></li>
        <li><a href="#二维凸包">二维凸包</a>
          <ol>
            <li><a href="#andrew扫描法">Andrew扫描法</a></li>
          </ol>
        </li>
        <li><a href="#旋转卡壳求最远点对">旋转卡壳求最远点对</a></li>
        <li><a href="#平面最近点对">平面最近点对</a></li>
        <li><a href="#扫描线算法">扫描线算法</a></li>
        <li><a href="#二维数点">二维数点</a></li>
        <li><a href="#pick定理">Pick定理</a></li>
      </ol>
    </li>
    <li><a href="#组合数学">组合数学</a>
      <ol>
        <li><a href="#用乘法逆元计算组合数">用乘法逆元计算组合数</a></li>
        <li><a href="#组合数的性质">组合数的性质</a></li>
        <li><a href="#圆排列">圆排列</a></li>
        <li><a href="#二项式反演">二项式反演</a></li>
        <li><a href="#斐波那契数列的性质">斐波那契数列的性质</a></li>
        <li><a href="#和式性质">和式性质</a>
          <ol>
            <li><a href="#基本性质">基本性质</a></li>
            <li><a href="#多重和式分配律">多重和式分配律</a></li>
            <li><a href="#多重和式次序交换">多重和式次序交换</a></li>
          </ol>
        </li>
        <li><a href="#卡特兰数">卡特兰数</a></li>
        <li><a href="#生成函数">生成函数</a></li>
        <li><a href="#稳定婚姻问题gale-shapley算法-todo">稳定婚姻问题(Gale-Shapley算法)
TODO</a></li>
      </ol>
    </li>
    <li><a href="#数据结构">数据结构</a>
      <ol>
        <li><a href="#树状数组">树状数组</a>
          <ol>
            <li><a href="#树状数组求逆序对">树状数组求逆序对</a></li>
            <li><a href="#二维树状数组">二维树状数组</a></li>
          </ol>
        </li>
        <li><a href="#并查集">并查集</a></li>
        <li><a href="#线段树">线段树</a></li>
        <li><a href="#珂朵莉树">珂朵莉树</a></li>
        <li><a href="#分块">分块</a></li>
        <li><a href="#平衡树pbds实现">平衡树（pbds实现）</a></li>
        <li><a href="#字典树">01字典树</a></li>
        <li><a href="#对顶堆">对顶堆</a></li>
        <li><a href="#单调栈">单调栈</a></li>
        <li><a href="#单调队列">单调队列</a></li>
        <li><a href="#st表">ST表</a></li>
      </ol>
    </li>
    <li><a href="#二分">二分</a>
      <ol>
        <li><a href="#二分答案">二分答案</a></li>
        <li><a href="#二分查找">二分查找</a></li>
        <li><a href="#二分求单调函数零点">二分求单调函数零点</a></li>
      </ol>
    </li>
    <li><a href="#三分法">三分法</a>
      <ol>
        <li><a href="#三分法求单峰函数的极值点">三分法求单峰函数的极值点</a></li>
        <li><a href="#三分套三分">三分套三分</a></li>
        <li><a href="#三分答案-todo">三分答案
TODO</a></li>
      </ol>
    </li>
    <li><a href="#动态规划">动态规划</a>
      <ol>
        <li><a href="#背包">01背包</a></li>
        <li><a href="#完全背包">完全背包</a></li>
        <li><a href="#多重背包">多重背包</a></li>
        <li><a href="#分组背包">分组背包</a></li>
        <li><a href="#最长上升子序列">最长上升子序列</a></li>
        <li><a href="#dilworth定理">Dilworth定理</a></li>
        <li><a href="#最长公共子序列">最长公共子序列</a></li>
        <li><a href="#斜率优化todo">斜率优化TODO</a></li>
        <li><a href="#四边形不等式todo">四边形不等式TODO</a></li>
        <li><a href="#悬线法">悬线法</a></li>
        <li><a href="#数位dp">数位DP</a></li>
      </ol>
    </li>
    <li><a href="#概率论">概率论</a>
      <ol>
        <li><a href="#处理分数期望概率">处理分数期望、概率</a></li>
      </ol>
    </li>
    <li><a href="#杂项">杂项</a>
      <ol>
        <li><a href="#快速幂">快速幂</a></li>
        <li><a href="#离散化">离散化</a></li>
        <li><a href="#莫队算法">莫队算法</a></li>
        <li><a href="#分数规划">0/1分数规划</a></li>
        <li><a href="#表达式求值-可能需要进一步完善todo">表达式求值
可能需要进一步完善TODO</a></li>
        <li><a href="#艾弗森括号">艾弗森括号</a></li>
        <li><a href="#向上向下取整">向上、向下取整</a></li>
      </ol>
    </li>
    <li><a href="#c-stl用法">C++ STL用法</a>
      <ol>
        <li><a href="#stdswap">std::swap</a></li>
        <li><a href="#stdsort">std::sort</a></li>
        <li><a href="#stdlower_boundstdupper_bound">std::lower_bound,std::upper_bound</a></li>
        <li><a href="#stdmaxstdmin">std::max,std::min</a></li>
        <li><a href="#stdmax_elementstdmin_element">std::max_element,std::min_element</a></li>
        <li><a href="#stdabs">std::abs</a></li>
        <li><a href="#stdstring">std::string</a>
          <ol>
            <li><a href="#swap">::swap</a></li>
            <li><a href="#beginstdend">::begin,std::end</a></li>
            <li><a href="#size">::size</a></li>
            <li><a href="#push_back">::push_back</a></li>
            <li><a href="#pop_back">::pop_back</a></li>
            <li><a href="#find">::find</a></li>
            <li><a href="#replace">::replace</a></li>
            <li><a href="#substr">::substr</a></li>
          </ol>
        </li>
        <li><a href="#stdmemset">std::memset</a></li>
        <li><a href="#stdcopy">std::copy</a></li>
        <li><a href="#stdfill">std::fill</a></li>
        <li><a href="#stdmap">std::map</a>
          <ol>
            <li><a href="#自定义比较函数">自定义比较函数</a></li>
            <li><a href="#empty">::empty</a></li>
            <li><a href="#size-1">::size</a></li>
            <li><a href="#clear">::clear</a></li>
            <li><a href="#erase">::erase</a></li>
            <li><a href="#find-1">::find</a></li>
            <li><a href="#lower_boundupper_bound">::lower_bound,::upper_bound</a></li>
          </ol>
        </li>
        <li><a href="#stdunordered_map">std::unordered_map</a></li>
        <li><a href="#stdset">std::set</a>
          <ol>
            <li><a href="#使用方法">使用方法</a></li>
            <li><a href="#insert">::insert</a></li>
            <li><a href="#修改内部元素">修改内部元素</a></li>
          </ol>
        </li>
        <li><a href="#stdunordered_set">std::unordered_set</a></li>
        <li><a href="#stdmultiset">std::multiset</a></li>
        <li><a href="#stdstack">std::stack</a>
          <ol>
            <li><a href="#top">::top</a></li>
            <li><a href="#empty-1">::empty</a></li>
            <li><a href="#size-2">::size</a></li>
            <li><a href="#push">::push</a></li>
            <li><a href="#pop">::pop</a></li>
            <li><a href="#emplace">::emplace</a></li>
          </ol>
        </li>
        <li><a href="#stdqueue">std::queue</a>
          <ol>
            <li><a href="#front">::front</a></li>
            <li><a href="#back">::back</a></li>
            <li><a href="#其他方法">其他方法</a></li>
          </ol>
        </li>
        <li><a href="#stdpriority_queue">std::priority_queue</a>
          <ol>
            <li><a href="#自定义比较方法">自定义比较方法</a></li>
            <li><a href="#方法">方法</a></li>
          </ol>
        </li>
        <li><a href="#stddeque">std::deque</a>
          <ol>
            <li><a href="#方法-1">方法</a></li>
          </ol>
        </li>
        <li><a href="#stdvector">std::vector</a>
          <ol>
            <li><a href="#声明方法">声明方法</a></li>
            <li><a href="#元素访问">元素访问</a></li>
            <li><a href="#size-3">::size</a></li>
            <li><a href="#empty-2">::empty</a></li>
            <li><a href="#push_back-1">::push_back</a></li>
            <li><a href="#pop_back-1">::pop_back</a></li>
            <li><a href="#emplace_back">::emplace_back</a></li>
            <li><a href="#resize">::resize</a></li>
            <li><a href="#reserve">::reserve</a></li>
            <li><a href="#stdvectorbool">std::vector&lt;bool&gt;</a></li>
          </ol>
        </li>
        <li><a href="#stdbitset">std::bitset</a>
          <ol>
            <li><a href="#声明方法-1">声明方法</a></li>
            <li><a href="#元素访问-1">元素访问</a></li>
            <li><a href="#allanynone">::all,::any,::none</a></li>
            <li><a href="#count">::count</a></li>
            <li><a href="#运算">运算</a></li>
            <li><a href="#flip">::flip</a></li>
            <li><a href="#to_string">::to_string</a></li>
            <li><a href="#to_ulongto_ullong">::to_ulong,::to_ullong</a></li>
            <li><a href="#set">::set</a></li>
            <li><a href="#reset">::reset</a></li>
          </ol>
        </li>
        <li><a href="#stdpair">std::pair</a>
          <ol>
            <li><a href="#元素访问-2">元素访问</a></li>
            <li><a href="#swap-1">::swap</a></li>
            <li><a href="#stdmake_pair">std::make_pair</a></li>
          </ol>
        </li>
        <li><a href="#stdtuple">std::tuple</a>
          <ol>
            <li><a href="#元素访问-3">元素访问</a></li>
            <li><a href="#stdmake_tuple">std::make_tuple</a></li>
            <li><a href="#stdtie">std::tie</a></li>
          </ol>
        </li>
        <li><a href="#stdnext_permutation-stdprev_permutation">std::next_permutation,
std::prev_permutation</a></li>
        <li><a href="#stdunique">std::unique</a></li>
        <li><a href="#stdcin">std::cin</a>
          <ol>
            <li><a href="#输入十六进制八进制二进制">输入十六进制、八进制、二进制</a></li>
            <li><a href="#输入不忽略空格回车">输入不忽略空格、回车</a></li>
          </ol>
        </li>
        <li><a href="#stdcout">std::cout</a>
          <ol>
            <li><a href="#输出十六进制八进制二进制">输出十六进制、八进制、二进制</a></li>
            <li><a href="#浮点数精度">浮点数精度</a></li>
          </ol>
        </li>
        <li><a href="#scanf-todo">scanf TODO</a>
          <ol>
            <li><a href="#输入十六进制八进制二进制-1">输入十六进制、八进制、二进制</a></li>
          </ol>
        </li>
        <li><a href="#printf-todo">printf TODO</a>
          <ol>
            <li><a href="#输出十六进制八进制二进制-1">输出十六进制、八进制、二进制</a></li>
          </ol>
        </li>
        <li><a href="#正则表达式">正则表达式</a>
          <ol>
            <li><a href="#正则表达式语法">正则表达式语法</a></li>
            <li><a href="#c正则表达式库">C++正则表达式库</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>

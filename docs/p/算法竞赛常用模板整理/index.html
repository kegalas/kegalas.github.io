<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='包含ICPC竞赛常用的一些模板'><title>算法竞赛常用模板整理</title>

<link rel='canonical' href='https://kegalas.top/p/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='算法竞赛常用模板整理'>
<meta property='og:description' content='包含ICPC竞赛常用的一些模板'>
<meta property='og:url' content='https://kegalas.top/p/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/'>
<meta property='og:site_name' content='KegalaS的个人博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='算法' /><meta property='article:tag' content='模板' /><meta property='article:tag' content='干货' /><meta property='article:published_time' content='2021-12-18T15:57:37&#43;08:00'/><meta property='article:modified_time' content='2021-12-18T15:57:37&#43;08:00'/>
<meta name="twitter:title" content="算法竞赛常用模板整理">
<meta name="twitter:description" content="包含ICPC竞赛常用的一些模板">
    <link rel="shortcut icon" href="/images/favicon.ico" />

    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E7%AE%97%E6%B3%95/" >
                算法
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/">算法竞赛常用模板整理</a>
    </h2>

    
    <h3 class="article-subtitle">
        包含ICPC竞赛常用的一些模板
    </h3>
    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Dec 18, 2021</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 117 分钟
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;set&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdint&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bitset&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;deque&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;regex&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;list&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unordered_map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unordered_set&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define debug(a) std::cout&lt;&lt;#a&lt;&lt;&#34;=&#34;&lt;&lt;(a)&lt;&lt;&#34;\n&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rep(i,x,y) for(int i=(x);i&lt;=(y);i++)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rrep(i,x,y) for(int i=(x);i&gt;=(y);i--)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define mms(x) memset((x), 0, sizeof(x))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define pb push_back
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define mkp std::make_pair
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define fi first
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define se second
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> ULL <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> DB <span style="color:#f92672">=</span> <span style="color:#66d9ef">double</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LD <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">double</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> ui <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsigned</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> i128 <span style="color:#f92672">=</span> __int128;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> pii <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> pll <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>LL,LL<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">200005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7fffffff</span>;
</span></span><span style="display:flex;"><span>DB <span style="color:#66d9ef">const</span> EPS <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e-8</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MOD <span style="color:#f92672">=</span> <span style="color:#ae81ff">998244353</span>;
</span></span><span style="display:flex;"><span>DB <span style="color:#66d9ef">const</span> PI <span style="color:#f92672">=</span> acos(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>arr[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> T;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>T;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//T=1;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span>(T<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>	    solve();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="字符串">字符串</h1>
<h2 id="kmp">KMP</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//kmp,luogu3375
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> prefixFunc(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> str){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//输入一个字符串，输出该字符串的前缀函数表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//前缀函数pi[i]是满足s[0...x-1]==s[i-x+1...i]的最大的x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//如果输入不是字符串而是一个数组，也可以很方便的修改为vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> str.length();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ans(n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//ans[0]=0，因为只看真前缀和真后缀
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span>(j <span style="color:#f92672">&amp;&amp;</span> str[i]<span style="color:#f92672">!=</span>str[j]) j <span style="color:#f92672">=</span> ans[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(str[i]<span style="color:#f92672">==</span>str[j]) j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        ans[i] <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> KMP(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s, std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> p){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//输入主串和模式串，返回所有匹配的开始下标，下标从0开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> pf <span style="color:#f92672">=</span> prefixFunc(p);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ns <span style="color:#f92672">=</span> s.size(), np <span style="color:#f92672">=</span> p.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>ns;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(j <span style="color:#f92672">&amp;&amp;</span> s[i]<span style="color:#f92672">!=</span>p[j]) j <span style="color:#f92672">=</span> pf[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(s[i]<span style="color:#f92672">==</span>p[j]) j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">==</span>np){
</span></span><span style="display:flex;"><span>            vec.push_back(i<span style="color:#f92672">-</span>j<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>            j <span style="color:#f92672">=</span> pf[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> vec;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//我们可以通过把模式串和主串拼在一起，p+#+s，然后求这个字符串的前缀函数表（#代表不在主串、模式串字符集内的一个符号），然后pi[i]如果等于模式串的长度，那么i是匹配模式串的子串的起点。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//关于最小循环结，设字符串下标从1开始，长度为n，则如果n%(n-pf[n])==0，则有循环节，并且长度为n-pf[n]（当然长度可以为n）
</span></span></span></code></pre></div><h2 id="字典树trie">字典树(Trie)</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 插入或查找一次 模板串长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p8306
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Trie</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nxt[MAXM][<span style="color:#ae81ff">26</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> cnt;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;=</span>cnt;i<span style="color:#f92672">++</span>) <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">26</span>;j<span style="color:#f92672">++</span>) nxt[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//起始节点编号为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> c:s){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>nxt[cur][c<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>]){
</span></span><span style="display:flex;"><span>                nxt[cur][c<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>]<span style="color:#f92672">=++</span>cnt;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">=</span> nxt[cur][c<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">find_prefix</span>(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cur<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> c:s){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nxt[cur][c<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>]){
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }            
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">=</span> nxt[cur][c<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Trie trie;
</span></span></code></pre></div><h2 id="字符串哈希">字符串哈希</h2>
<p>主要是用于判断两个字符串是否相等。通常我们的Hash函数会把字符串看成是某个进制下的自然数。把这个自然数对某个大质数取模得到Hash值。</p>
<p>求Hash的复杂度是<span class="math inline">\(O(n)\)</span>，如果我们要比较一大群字符串里有多少不同的，我们不应该两两比较，而要把它们的Hash全部记录下来，再去排序Hash、比较。</p>
<p>这种哈希函数的性质为：</p>
<ol>
<li>设已知字符串<span class="math inline">\(S\)</span>的Hash值为<span class="math inline">\(H(S)\)</span>，那么添加一个字符<span class="math inline">\(c\)</span>后的新字符串的Hash值为<span class="math inline">\(H(S+c)=(H(S)*base+value[c])\%MOD\)</span>。其中<span class="math inline">\(value[c]\)</span>表示<span class="math inline">\(c\)</span>代表的数值，如果用char类型直接把<span class="math inline">\(c\)</span>转换为int或者ULL什么的就行了</li>
<li>已知<span class="math inline">\(H(S)\)</span>和<span class="math inline">\(H(S+T)\)</span>，则<span class="math inline">\(H(T)=(H(S+T)-H(S)*base^{length(T)})\%MOD\)</span>，直观理解的话，就是在<span class="math inline">\(base\)</span>进制下，在S后面补<span class="math inline">\(0\)</span>，把<span class="math inline">\(S\)</span>左端和<span class="math inline">\(S+T\)</span>左端对齐，相减得到<span class="math inline">\(H(T)\)</span>。利用这个性质可以方便地先预处理字符串所有前缀的Hash，然后查询连续子串的Hash。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//自然溢出法，相当于对2^64取模的单哈希，是比较容易被特殊数据卡掉的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P3370
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> ULL <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span>ULL <span style="color:#a6e22e">H</span>(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> str){
</span></span><span style="display:flex;"><span>    ULL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    ULL <span style="color:#66d9ef">const</span> base <span style="color:#f92672">=</span> <span style="color:#ae81ff">131</span>;<span style="color:#75715e">//ascii也就128个字符，质数131作为底数足够
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> c:str){
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> ret<span style="color:#f92672">*</span>base<span style="color:#f92672">+</span>(ULL)c;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//双哈希法，两个字符串的两个哈希必须分别相同，才会被考虑为相同的字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//比起单哈希，更不容易被卡
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P3370
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ULL <span style="color:#66d9ef">const</span> MOD1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">998244353</span>;
</span></span><span style="display:flex;"><span>ULL <span style="color:#66d9ef">const</span> MOD2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e9</span><span style="color:#f92672">+</span><span style="color:#ae81ff">7</span>;
</span></span><span style="display:flex;"><span>ULL <span style="color:#66d9ef">const</span> base <span style="color:#f92672">=</span> <span style="color:#ae81ff">131</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Data</span>{<span style="color:#75715e">//把字符串的两个哈希捆起来，便于排序比较等操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ULL x,y;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ULL <span style="color:#a6e22e">H1</span>(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> str){
</span></span><span style="display:flex;"><span>    ULL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> c:str){
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> (ret<span style="color:#f92672">*</span>base<span style="color:#f92672">+</span>(ULL)c)<span style="color:#f92672">%</span>MOD1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ULL <span style="color:#a6e22e">H2</span>(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> str){
</span></span><span style="display:flex;"><span>    ULL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> c:str){
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> (ret<span style="color:#f92672">*</span>base<span style="color:#f92672">+</span>(ULL)c)<span style="color:#f92672">%</span>MOD2;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="ac自动机">AC自动机</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 文本串长度+模板串长度之和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//AC自动机，luogu P3808
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//AC自动机会把Trie修改掉，并不是插入时候的字典树了，实际上变成了一张图+fail指针。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//trie数组表示从当前状态添加一个字符后到达的状态，fail数组表示，目前为止匹配，但是添加下一个字符后不匹配了，跳转至最长的后缀状态（不包括添加的下一个字符）。可以反复跳转。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//注意，一个状态是可行状态，当且仅当它自己可行，或者fail指针指向的状态可行，或者fail[fail]可行，以此类推
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AC</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> trie[MAXN][<span style="color:#ae81ff">26</span>], total;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> end[MAXN],fail[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">int</span> m){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            end[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            fail[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">26</span>;j<span style="color:#f92672">++</span>) trie[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        total <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> str){
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e">//插入模式串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> c:str){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>trie[u][c<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>]){
</span></span><span style="display:flex;"><span>				trie[u][c<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>total;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			u <span style="color:#f92672">=</span> trie[u][c<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>];
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		end[u]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buildFail</span>(){
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e">//构建fail指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> qu;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">26</span>;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(trie[<span style="color:#ae81ff">0</span>][i]) qu.push(trie[<span style="color:#ae81ff">0</span>][i]);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>qu.empty()){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> qu.front();
</span></span><span style="display:flex;"><span>			qu.pop();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">26</span>;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span>(trie[u][i]){
</span></span><span style="display:flex;"><span>					fail[trie[u][i]] <span style="color:#f92672">=</span> trie[fail[u]][i];	
</span></span><span style="display:flex;"><span>					qu.push(trie[u][i]);
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>					trie[u][i] <span style="color:#f92672">=</span> trie[fail[u]][i];
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">query</span>(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> str){
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e">//查询主串str中出现了几个模式串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> c:str){
</span></span><span style="display:flex;"><span>			u <span style="color:#f92672">=</span> trie[u][c<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> u ; j <span style="color:#f92672">&amp;&amp;</span> end[j] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ; j <span style="color:#f92672">=</span> fail[j]){
</span></span><span style="display:flex;"><span>				res <span style="color:#f92672">+=</span> end[j];
</span></span><span style="display:flex;"><span>				end[j] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="最小表示法">最小表示法</h2>
<p>例如S = bcda, 则S的循环同构有cdab, dabc, abcd，其中字典序最小的是abcd，最小表示法就是求这个字典序最小的。当然题目里面可能是算数组里面字典序最小的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//最小表示法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P1368
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//复杂度 O(n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> arr[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">minStr</span>(<span style="color:#66d9ef">int</span> n){<span style="color:#75715e">//数组下标从0开始，共n个；返回最小表示的开始下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, k<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>n <span style="color:#f92672">&amp;&amp;</span> j<span style="color:#f92672">&lt;</span>n <span style="color:#f92672">&amp;&amp;</span> k<span style="color:#f92672">&lt;</span>n){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(arr[(i<span style="color:#f92672">+</span>k)<span style="color:#f92672">%</span>n]<span style="color:#f92672">==</span>arr[(j<span style="color:#f92672">+</span>k)<span style="color:#f92672">%</span>n]){
</span></span><span style="display:flex;"><span>            k<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(arr[(i<span style="color:#f92672">+</span>k)<span style="color:#f92672">%</span>n]<span style="color:#f92672">&gt;</span>arr[(j<span style="color:#f92672">+</span>k)<span style="color:#f92672">%</span>n]){<span style="color:#75715e">//最大表示法时就把这一段和下一段换一下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            i <span style="color:#f92672">+=</span> k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            j <span style="color:#f92672">+=</span> k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">==</span>j) j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>min(i,j);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="manacher">Manacher</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span><span style="color:#75715e">//manacher 算法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P3805
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//复杂度O(n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> getD1(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> str){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//返回字符串以某一位为中心的，最长的（奇数长度）回文子串的长度半径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//例如abcba中，d1[2] = 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> str.size();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> d(n);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,l<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,r<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> l<span style="color:#f92672">+</span>r<span style="color:#f92672">-</span>i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> dj <span style="color:#f92672">=</span> j<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">?</span>d[j]<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        d[i] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(std<span style="color:#f92672">::</span>min(dj,j<span style="color:#f92672">-</span>l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>),<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">-</span>dj<span style="color:#f92672">&lt;</span>l){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">-</span>d[i]<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> i<span style="color:#f92672">+</span>d[i]<span style="color:#f92672">&lt;</span>n <span style="color:#f92672">&amp;&amp;</span> str[i<span style="color:#f92672">-</span>d[i]]<span style="color:#f92672">==</span>str[i<span style="color:#f92672">+</span>d[i]])
</span></span><span style="display:flex;"><span>                d[i]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            l <span style="color:#f92672">=</span> i<span style="color:#f92672">-</span>d[i]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, r <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span>d[i]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> d;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> getD2(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> str){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//返回字符串以某一位的左边间隙为中心的，最长的（偶数长度）回文子串的长度半径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//例如abba中，d2[2] = 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> str.size();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> d(n);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,l<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,r<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> l<span style="color:#f92672">+</span>r<span style="color:#f92672">-</span>i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> dj <span style="color:#f92672">=</span> j<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">?</span>d[j]<span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        d[i] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(std<span style="color:#f92672">::</span>min(dj,j<span style="color:#f92672">-</span>l),<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">-</span>dj<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span>l){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">-</span>d[i]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> i<span style="color:#f92672">+</span>d[i]<span style="color:#f92672">&lt;</span>n <span style="color:#f92672">&amp;&amp;</span> str[i<span style="color:#f92672">-</span>d[i]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">==</span>str[i<span style="color:#f92672">+</span>d[i]])
</span></span><span style="display:flex;"><span>                d[i]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            l <span style="color:#f92672">=</span> i<span style="color:#f92672">-</span>d[i], r <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span>d[i]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> d;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="z函数">Z函数</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//Z函数，复杂度O(n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P5410
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> zFunc(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> str){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//求出一个字符串的z函数，即满足z[i]是s[0...x-1]==s[i...i+x-1]的最大的x，这个子串也叫做LCP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//特别的z[0]=0，也有些题目是等于串长，需要自行调整
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//kmp里面添加字符集外字符的操作在这里也可以用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> str.size();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> z(n);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,l<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,r<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(z[i<span style="color:#f92672">-</span>l]<span style="color:#f92672">&lt;</span>r<span style="color:#f92672">-</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            z[i] <span style="color:#f92672">=</span> z[i<span style="color:#f92672">-</span>l];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            z[i] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(r<span style="color:#f92672">-</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">+</span>z[i]<span style="color:#f92672">&lt;</span>n <span style="color:#f92672">&amp;&amp;</span> str[z[i]]<span style="color:#f92672">==</span>str[i<span style="color:#f92672">+</span>z[i]])
</span></span><span style="display:flex;"><span>                z[i]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            l <span style="color:#f92672">=</span> i, r <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> z[i] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> z;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="后缀数组">后缀数组</h2>
<p>首先是<span class="math inline">\(O(n\log^2n)\)</span>的，没有用到基数排序（因为我不排除会求某种只给出偏序关系的后缀数组）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//求后缀数组，复杂度O(nlog^2n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p3809
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> rk[MAXN<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>],sa[MAXN],tarr[MAXN<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//rk[i]表示后缀i（从1开始，后缀i代表字符串从i开始到结束的子串）的排名，sa[i]表示所有后缀第i小的起点序号，排名和编号都从1开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">getSA</span>(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> s.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        rk[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> sa[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        sa[i] <span style="color:#f92672">=</span> i, rk[i] <span style="color:#f92672">=</span> s[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> w<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;w<span style="color:#f92672">&lt;</span>n;w<span style="color:#f92672">&lt;&lt;=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> rp <span style="color:#f92672">=</span> [<span style="color:#f92672">&amp;</span>](<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>make_pair(rk[x],rk[x<span style="color:#f92672">+</span>w]);};
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>sort(sa<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,sa<span style="color:#f92672">+</span>n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,[<span style="color:#f92672">&amp;</span>](<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y){<span style="color:#66d9ef">return</span> rp(x)<span style="color:#f92672">&lt;</span>rp(y);});
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,p<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            tarr[sa[i]] <span style="color:#f92672">=</span> rp(sa[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])<span style="color:#f92672">==</span>rp(sa[i]) <span style="color:#f92672">?</span> p:<span style="color:#f92672">++</span>p;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>copy(tarr<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,tarr<span style="color:#f92672">+</span>n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,rk<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>再给出<span class="math inline">\(O(n\log n)\)</span>的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//求后缀数组，复杂度O(nlogn)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p3809
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> rk[MAXN<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>],sa[MAXN],tarr[MAXN<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>],cnt[MAXN],rkt[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//rk[i]表示后缀i（从1开始，后缀i代表字符串从i开始到结束的子串）的排名，sa[i]表示所有后缀第i小的起点序号，排名和编号都从1开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">getSA</span>(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> s.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        rk[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> sa[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> <span style="color:#ae81ff">128</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">++</span>cnt[rk[i]<span style="color:#f92672">=</span>s[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        cnt[i] <span style="color:#f92672">+=</span> cnt[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>n;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>        sa[cnt[rk[i]]<span style="color:#f92672">--</span>] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> w<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;;w<span style="color:#f92672">&lt;&lt;=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>n;i<span style="color:#f92672">&gt;</span>n<span style="color:#f92672">-</span>w;i<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>            tarr[n<span style="color:#f92672">-</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,p<span style="color:#f92672">=</span>w;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(sa[i]<span style="color:#f92672">&gt;</span>w) tarr[<span style="color:#f92672">++</span>p]<span style="color:#f92672">=</span>sa[i]<span style="color:#f92672">-</span>w;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>fill(cnt<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,cnt<span style="color:#f92672">+</span>m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            cnt[rkt[i] <span style="color:#f92672">=</span> rk[tarr[i]]]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            cnt[i]<span style="color:#f92672">+=</span>cnt[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>n;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>            sa[cnt[rkt[i]]<span style="color:#f92672">--</span>] <span style="color:#f92672">=</span> tarr[i];
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> rp <span style="color:#f92672">=</span> [<span style="color:#f92672">&amp;</span>](<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>make_pair(rk[x],rk[x<span style="color:#f92672">+</span>w]);};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            tarr[sa[i]] <span style="color:#f92672">=</span> rp(sa[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])<span style="color:#f92672">==</span>rp(sa[i]) <span style="color:#f92672">?</span> m:<span style="color:#f92672">++</span>m;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>copy(tarr<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,tarr<span style="color:#f92672">+</span>n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,rk<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">==</span>m) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="后缀自动机">后缀自动机</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//后缀自动机，构建SAM的复杂度为O(n)，空间复杂度为O(|S|n)，|S|为字符集的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p3804
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//SAM是动态构建的，每次插入一个字符即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">State</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fa,len,next[<span style="color:#ae81ff">26</span>];<span style="color:#75715e">//似乎有些编译器next是保留字，需要注意
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">//endpos(p)为模式串p在s中所有出现的结束位置的集合，例如aababc中，ab出现了两次，结束位置是{3,5}。endpos等价类即，endpos相同的子串构成的集合。例如b和ab都是结束在{3,5}，则它们是等价类。这说明它们总是一起出现，可以归到一个节点，并且长度小的一定是长度大的的后缀。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//next[ch]表示接受ch后的状态；fa表示该状态在parent tree上的父节点；len表示该状态对应的endpos等价类中最长串的长度。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//假设b是a的fa，a等价类的最长字符串为s，则b的最长字符串为，s的所有后缀中，不在等价类a里的，最长的字符串。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//SAM可以接受字符串的所有后缀，但是它包含了所有子串的信息。也就是从任意一个状态开始的路径，都是字符串的子串。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//可行状态是last状态，以及fa[last]、fa[fa[last]]直到根节点（空字符串）。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//除了等价类的最长字符串长度len，我们也可以计算minlen。等价类里所有字符串的长度恰好覆盖[minlen,len]之间的每一个整数。除了根节点，st[i].minlen = st[fa[i]].len+1;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//每个状态i对应的子串数量是st[i].len-st[st[i].fa].len
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//算法并没有维护endpos等效类中，字符串出现的位置个数，需要自己去树形dp。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//注意，aababb中，ab的等价类为{3,5}，根据ab前面一个字符不同可以划分不同的等价类，例如aab和bab划分为{3},{5}。但是a的等价类为{1,2,4}，因为第一个的前面一个字符是空字符，只能划分出两个，即aa{2},ba{4}，树形DP需要在parent tree上注意缺少的这一部分。在建SAM时预处理dp[cur] = 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SAM</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    State st[MAXN<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>];<span style="color:#75715e">//SAM总状态数不会超过2n-1，总转移数不超过3n-4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, last <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//起始节点编号为1；last表示加入新字符前整个字符串所在的等价类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> ch){
</span></span><span style="display:flex;"><span>        ch <span style="color:#f92672">=</span> ch<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>cnt;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        st[cur].len <span style="color:#f92672">=</span> st[last].len <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(p<span style="color:#f92672">=</span>last;p<span style="color:#f92672">&amp;&amp;!</span>st[p].next[ch];p<span style="color:#f92672">=</span>st[p].fa)
</span></span><span style="display:flex;"><span>            st[p].next[ch] <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//对于每一个father状态，如果不存在ch的转移边，则连到cur
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> q <span style="color:#f92672">=</span> st[p].next[ch];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(q<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//加入了从未加入的字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            st[cur].fa <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(st[p].len <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> st[q].len){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//p到q是连续的转移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            st[cur].fa <span style="color:#f92672">=</span> q;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//不连续的转移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//会新增一个节点r,拥有q的所有出边，father与q相同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>cnt;
</span></span><span style="display:flex;"><span>            st[r] <span style="color:#f92672">=</span> st[q];
</span></span><span style="display:flex;"><span>            st[r].len <span style="color:#f92672">=</span> st[p].len <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(;p<span style="color:#f92672">&amp;&amp;</span>st[p].next[ch]<span style="color:#f92672">==</span>q;p<span style="color:#f92672">=</span>st[p].fa){
</span></span><span style="display:flex;"><span>                st[p].next[ch]<span style="color:#f92672">=</span>r;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            st[cur].fa <span style="color:#f92672">=</span> st[q].fa <span style="color:#f92672">=</span> r;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        last <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SAM sam;
</span></span></code></pre></div><h2 id="广义后缀自动机">广义后缀自动机</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//广义后缀自动机，其实就是插入多个字符串的后缀自动机，但只能离线build
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p6139
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//后缀自动机的性质都可以用过来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">State</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fa,len,next[<span style="color:#ae81ff">26</span>];<span style="color:#75715e">//似乎有些编译器next是保留字，需要注意
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GSA</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    State st[MAXN<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//起始节点编号为1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> last, <span style="color:#66d9ef">int</span> ch){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//传入的是即将插入的字符的父节点编号，以及该字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//只用在build里，不要直接把字符串插入，应该先insertTrie再build
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> st[last].next[ch];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        st[cur].len <span style="color:#f92672">=</span> st[last].len <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(p<span style="color:#f92672">=</span>st[last].fa;p <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>st[p].next[ch];p<span style="color:#f92672">=</span>st[p].fa)
</span></span><span style="display:flex;"><span>            st[p].next[ch] <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> q <span style="color:#f92672">=</span> st[p].next[ch];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(q<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>            st[cur].fa <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(st[p].len<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">==</span>st[q].len){
</span></span><span style="display:flex;"><span>            st[cur].fa <span style="color:#f92672">=</span> q;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>cnt;
</span></span><span style="display:flex;"><span>            st[r].fa <span style="color:#f92672">=</span> st[q].fa;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">26</span>;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(st[st[q].next[i]].len)
</span></span><span style="display:flex;"><span>                    st[r].next[i] <span style="color:#f92672">=</span> st[q].next[i];
</span></span><span style="display:flex;"><span>            st[r].len <span style="color:#f92672">=</span> st[p].len<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(;p <span style="color:#f92672">&amp;&amp;</span> st[p].next[ch]<span style="color:#f92672">==</span>q;p<span style="color:#f92672">=</span>st[p].fa)
</span></span><span style="display:flex;"><span>                st[p].next[ch] <span style="color:#f92672">=</span> r;
</span></span><span style="display:flex;"><span>            st[cur].fa <span style="color:#f92672">=</span> st[q].fa <span style="color:#f92672">=</span> r;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> cur;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//返回插入节点编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build</span>(){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span>pii<span style="color:#f92672">&gt;</span> qu;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">26</span>;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(st[<span style="color:#ae81ff">1</span>].next[i]) qu.push({<span style="color:#ae81ff">1</span>,i});
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>qu.empty()){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> fa <span style="color:#f92672">=</span> qu.front().first;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> ch <span style="color:#f92672">=</span> qu.front().second;
</span></span><span style="display:flex;"><span>            qu.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> insert(fa,ch);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">26</span>;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(st[p].next[i]) qu.push({p,i});
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insertTrie</span>(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> str){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> c:str){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>st[cur].next[c<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>]){
</span></span><span style="display:flex;"><span>                st[cur].next[c<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>]<span style="color:#f92672">=++</span>cnt;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">=</span> st[cur].next[c<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GSA gsa;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>string str;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>str;
</span></span><span style="display:flex;"><span>        gsa.insertTrie(str);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    gsa.build();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="回文字动机">回文字动机</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//回文字动机，复杂度：线性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p5496
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">State</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> len, fail, next[<span style="color:#ae81ff">26</span>];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//PAM的每一个状态代表原字符串的一个回文子串，每一个转移代表从当前状态字符串的前后同时加一个相同字符后的状态。可以接受其所有回文子串。除了奇根都是可行状态（当然不能为空时偶根不可行）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//fail指针指向该状态的最长回文真后缀。例如ayawaya就指向aya。总体和AC自动机的fail转移很像，都是没有ch的转移，则看fail有没有ch的转移，若fail没有则看fail[fail]的，以此类推。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//回文串分为奇长度和偶长度的，所以PAM有奇根和偶根，偶根的fail指向奇根，奇根不可能失配。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//PAM和SAM一样是动态构建的。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PAM</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> last,cnt,pos;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//last代表上个前缀的最长回文后缀的状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    State st[MAXN];<span style="color:#75715e">//最多有n+2个状态和n个转移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>string str;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s){
</span></span><span style="display:flex;"><span>        last <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,pos <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#75715e">//起始两个根为1奇根，2偶根，len分别为-1和0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        st[<span style="color:#ae81ff">1</span>].len <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, st[<span style="color:#ae81ff">2</span>].len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, st[<span style="color:#ae81ff">2</span>].fail <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        str <span style="color:#f92672">=</span> s;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">up</span>(<span style="color:#66d9ef">int</span> p){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(str[pos<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>st[p].len]<span style="color:#f92672">!=</span>str[pos])
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> st[p].fail;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> ch){
</span></span><span style="display:flex;"><span>        pos<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        ch <span style="color:#f92672">=</span> ch<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> up(last);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span> q <span style="color:#f92672">=</span> st[p].next[ch];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>q){
</span></span><span style="display:flex;"><span>            q<span style="color:#f92672">=++</span>cnt;
</span></span><span style="display:flex;"><span>            st[q].len <span style="color:#f92672">=</span> st[p].len<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>            st[q].fail <span style="color:#f92672">=</span> p<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">?</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">:</span> st[up(st[p].fail)].next[ch];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        last <span style="color:#f92672">=</span> q;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PAM pam;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string str
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>str;
</span></span><span style="display:flex;"><span>	pam.init(str);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> c:str){
</span></span><span style="display:flex;"><span>        pam.insert(c);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="序列自动机">序列自动机</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//序列自动机，复杂度 O(n|S|)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p5826
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//字符集很大时需要用可持久化线段树维护next
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">State</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> next[<span style="color:#ae81ff">26</span>];  
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//SQA接受字符串的所有子序列（不需要连续，可以为空）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SQA</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    State st[MAXN];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build</span>(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> str){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nxt[<span style="color:#ae81ff">26</span>];
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>fill(nxt,nxt<span style="color:#f92672">+</span><span style="color:#ae81ff">26</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> str.size();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>            nxt[str[i]<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>] <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>;<span style="color:#75715e">//1号节点是起始空节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> ch<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;ch<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">26</span>;ch<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                st[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].next[ch] <span style="color:#f92672">=</span> nxt[ch];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">query</span>(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> str){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//查询str是否是子序列（可以不连续）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, n<span style="color:#f92672">=</span>str.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> st[p].next[str[i]<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SQA sqa;
</span></span></code></pre></div><h1 id="数论">数论</h1>
<h2 id="欧几里得算法">欧几里得算法</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu B3736
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//gcd是可重复贡献的，gcd(x,x)=x，可以用st表维护区间gcd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//x*y=gcd(x,y)*lcm(x,y)，lcm是最小公倍数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">gcd</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> b<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> a : gcd(b, a<span style="color:#f92672">%</span>b);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x,y,z;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>x<span style="color:#f92672">&gt;&gt;</span>y<span style="color:#f92672">&gt;&gt;</span>z;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>gcd(gcd(x,y),z)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="扩展欧几里得">扩展欧几里得</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//求解ax+by=c的一组解，c不是gcd(a,b)的倍数则无解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//扩展欧几里得
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P5656
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">exgcd</span>(LL a,LL b,LL<span style="color:#f92672">&amp;</span> x,LL<span style="color:#f92672">&amp;</span> y){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//求出的是ax+by=gcd(a,b)的一组解，等于c的需要转换一下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//此时ax+by=gcd(a,b)中b=0，任何数与0的最大公约数是他本身，所以ax+0y=a，x=1 y=0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    LL d <span style="color:#f92672">=</span> exgcd(b,a<span style="color:#f92672">%</span>b,y,x);
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">-=</span> (a<span style="color:#f92672">/</span>b)<span style="color:#f92672">*</span>x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> d;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> T;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>T;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(T<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>        LL a,b,c;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>b<span style="color:#f92672">&gt;&gt;</span>c;
</span></span><span style="display:flex;"><span>        LL x0<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, y0<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        LL d <span style="color:#f92672">=</span> exgcd(a,b,x0,y0);<span style="color:#75715e">//d=gcd(a,b)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(c<span style="color:#f92672">%</span>d<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>){<span style="color:#75715e">//c不是gcd(a,b)的倍数则无解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;-1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        LL x1 <span style="color:#f92672">=</span> x0<span style="color:#f92672">*</span>c<span style="color:#f92672">/</span>d, y1 <span style="color:#f92672">=</span> y0<span style="color:#f92672">*</span>c<span style="color:#f92672">/</span>d;<span style="color:#75715e">//ax+by=gcd(a,b)的一组解转化为ax+by=c的一组解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//通解的形式为x=x1+s*dx, y=y1-s*dy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//其中s为任意整数，dx=b/d, dy = a/d;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        LL dx <span style="color:#f92672">=</span> b<span style="color:#f92672">/</span>d, dy <span style="color:#f92672">=</span> a<span style="color:#f92672">/</span>d;
</span></span><span style="display:flex;"><span>        LL l <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>ceil((<span style="color:#f92672">-</span>x1<span style="color:#f92672">+</span><span style="color:#ae81ff">1.0</span>)<span style="color:#f92672">/</span>dx);
</span></span><span style="display:flex;"><span>        LL r <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>floor((y1<span style="color:#f92672">-</span><span style="color:#ae81ff">1.0</span>)<span style="color:#f92672">/</span>dy);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//x&gt;0,y&gt;0时，s的取值为[l,r]中的整数，若l&gt;r，则说明不存在正整数解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&gt;</span>r){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>x1<span style="color:#f92672">+</span>l<span style="color:#f92672">*</span>dx<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;<span style="color:#75715e">//所有解中x的最小正整数值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>y1<span style="color:#f92672">-</span>r<span style="color:#f92672">*</span>dy<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;<span style="color:#75715e">//所有解中y的最小正整数值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>r<span style="color:#f92672">-</span>l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;<span style="color:#75715e">//正整数解的个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>x1<span style="color:#f92672">+</span>l<span style="color:#f92672">*</span>dx<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;<span style="color:#75715e">//正整数解中x的最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>y1<span style="color:#f92672">-</span>r<span style="color:#f92672">*</span>dy<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;<span style="color:#75715e">//正整数解中y的最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>x1<span style="color:#f92672">+</span>r<span style="color:#f92672">*</span>dx<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;<span style="color:#75715e">//正整数解中x的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>y1<span style="color:#f92672">-</span>l<span style="color:#f92672">*</span>dy<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;<span style="color:#75715e">//正整数解中y的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="欧拉筛">欧拉筛</h2>
<p>TODO: 用模板元编程实现编译期算素数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//欧拉筛, luogu p3383
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e8</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> prime;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> isnp[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sieve</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    isnp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    isnp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>isnp[i]) prime.push_back(i);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> p:prime){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">*</span>p<span style="color:#f92672">&gt;</span>n) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            isnp[i<span style="color:#f92672">*</span>p] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">%</span>p<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="miller-rabin素数测试">Miller-Rabin素数测试</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//对数 n 进行 k 轮测试的时间复杂度是 klog^3(n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//miller-rabin
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//loj 143
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//通过测试的有可能是素数，不通过的一定不是素数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ctime&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdint&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> __int128;<span style="color:#75715e">//本题数据范围过大，防止运算中爆掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>LL <span style="color:#66d9ef">const</span> test_time <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">qPowMod</span>(LL n, LL p, LL m){
</span></span><span style="display:flex;"><span>    LL res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> (res <span style="color:#f92672">*</span> n)<span style="color:#f92672">%</span>m;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> (n<span style="color:#f92672">*</span>n)<span style="color:#f92672">%</span>m;
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">&gt;&gt;=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">millerRabin</span>(LL n) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">||</span> n <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    LL a <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, b <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (a <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) a <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span>, <span style="color:#f92672">++</span>b;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// test_time 为测试次数,建议设为不小于 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 的整数以保证正确率,但也不宜过大,否则会影响效率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (LL i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, j; i <span style="color:#f92672">&lt;=</span> test_time; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>        LL x <span style="color:#f92672">=</span> rand() <span style="color:#f92672">%</span> (n <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        LL v <span style="color:#f92672">=</span> qPowMod(x, a, n);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (v <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> b; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (v <span style="color:#f92672">==</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            v <span style="color:#f92672">=</span> v <span style="color:#f92672">*</span> v <span style="color:#f92672">%</span> n;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> b) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    srand(time(NULL));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(millerRabin(n)){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;Y</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;N</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="乘法逆元">乘法逆元</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 扩展欧几里得法和费马小定理法都是logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//乘法逆元
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//ax≡1(mod b)，x为a在乘法意义上的逆元，记作a^(-1)，或者inv(a)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//用扩展欧几里得法的角度看，就是求ax+by=1的整数解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//快速幂法利用费马小定理，需要b为素数，并且疑似比exgcd常数大
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P3811，会TLE，需要线性求逆元
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//但loj 110不会TLE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">exgcd</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b,<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> x,<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> y){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> d <span style="color:#f92672">=</span> exgcd(b,a<span style="color:#f92672">%</span>b,y,x);
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">-=</span> (a<span style="color:#f92672">/</span>b)<span style="color:#f92672">*</span>x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> d;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">exgcd_inv</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//a在模b意义下的逆元
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> x,y;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> d <span style="color:#f92672">=</span> exgcd(a,b,x,y);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(d<span style="color:#f92672">!=</span><span style="color:#ae81ff">1</span>){<span style="color:#75715e">//显然a，b要互质才会有逆元
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (x<span style="color:#f92672">+</span>b)<span style="color:#f92672">%</span>b;<span style="color:#75715e">//实际上是为了防止出现x为负数的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">qPowMod</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> mod){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//x^p % m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">=</span> (ans<span style="color:#f92672">*</span>x)<span style="color:#f92672">%</span>mod;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> (x<span style="color:#f92672">*</span>x)<span style="color:#f92672">%</span>mod;
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">&gt;&gt;=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">fermat_inv</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b){<span style="color:#75715e">//a在模b意义下的逆元
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> qPowMod(a,b<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,b);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="线性求逆元">线性求逆元</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//线性求逆元，对于1~n这些数，复杂度总共n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p3381, loj 110
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">3000005</span>;
</span></span><span style="display:flex;"><span>LL inv[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">getinv</span>(LL n, LL m){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//求1~n中，每个数在模m意义下的乘法逆元
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    inv[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(LL i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//inv[i] = -(b/i)*inv[b%i]; //这样写会出现负数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        inv[i] <span style="color:#f92672">=</span> (LL)(m<span style="color:#f92672">-</span>m<span style="color:#f92672">/</span>i)<span style="color:#f92672">*</span>inv[m<span style="color:#f92672">%</span>i]<span style="color:#f92672">%</span>m;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="线性同余方程">线性同余方程</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//ax≡c (mod b)求解x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//和ax+by=c等价
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p1082
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">exgcd</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b,<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> x,<span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> y){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> d <span style="color:#f92672">=</span> exgcd(b,a<span style="color:#f92672">%</span>b,y,x);
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">-=</span> (a<span style="color:#f92672">/</span>b)<span style="color:#f92672">*</span>x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> d;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">linearEquation</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> c, <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x, <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>y){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> d <span style="color:#f92672">=</span> exgcd(a,b,x,y);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(c<span style="color:#f92672">%</span>d<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> x<span style="color:#f92672">*</span>c<span style="color:#f92672">/</span>d;
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> y<span style="color:#f92672">*</span>c<span style="color:#f92672">/</span>d;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> d;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a,b,c,x,y;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    cin<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>b;
</span></span><span style="display:flex;"><span>    c<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> d <span style="color:#f92672">=</span> linearEquation(a,b,c,x,y);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//d是a,b的最大公约数，如果无解d==-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//下面输出的是最小整数解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> b<span style="color:#f92672">/</span>d;
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> (x<span style="color:#f92672">%</span>t<span style="color:#f92672">+</span>t)<span style="color:#f92672">%</span>t;
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>x<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="中国剩余定理">中国剩余定理</h2>
<p>求解如下方程中的<span class="math inline">\(x\)</span></p>
<p><span class="math display">\[\left\{\begin{matrix}
x \equiv a_1(mod\quad r_1) \\
x \equiv a_2(mod\quad r_2) \\
\vdots \\
x \equiv a_k(mod\quad r_k)
\end{matrix}\right.
\]</span></p>
<p>其中<span class="math inline">\(r_i\)</span>两两互质，如果不满足则需要扩展CRT。</p>
<p>设<span class="math inline">\(n=r_1r_2\cdots r_k\)</span>，计算<span class="math inline">\(m_i=n/r_i\)</span>，计算<span class="math inline">\(m_i\)</span>在模<span class="math inline">\(r_i\)</span>意义下的逆元，计算<span class="math inline">\(c_i=m_im_i^{-1}\)</span>（不要对<span class="math inline">\(r_i\)</span>取模）。方程组在模<span class="math inline">\(n\)</span>意义下有唯一解<span class="math inline">\(x=\sum^k_i a_ic_i\)</span>（也就意味着<span class="math inline">\(x\)</span>在<span class="math inline">\(1\sim n\)</span>中必有一解）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//中国剩余定理 复杂度 klogk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p1495
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ll;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">10005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ll <span style="color:#a6e22e">exgcd</span>(ll a, ll b, ll <span style="color:#f92672">&amp;</span>x, ll <span style="color:#f92672">&amp;</span>y){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>b){
</span></span><span style="display:flex;"><span>        x<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        y<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ll d <span style="color:#f92672">=</span> exgcd(b,a<span style="color:#f92672">%</span>b,x,y);
</span></span><span style="display:flex;"><span>    ll tmp <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> y;
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> tmp <span style="color:#f92672">-</span> (a<span style="color:#f92672">/</span>b)<span style="color:#f92672">*</span>y;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> d;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ll <span style="color:#a6e22e">exgcd_inv</span>(ll a, ll b){
</span></span><span style="display:flex;"><span>    ll x,y;
</span></span><span style="display:flex;"><span>    ll d <span style="color:#f92672">=</span> exgcd(a,b,x,y);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (x<span style="color:#f92672">+</span>b)<span style="color:#f92672">%</span>b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CRT</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    ll ax[MAXN],rx[MAXN];<span style="color:#75715e">//每个方程的形式为x≡ai(mod ri)，要求ri互质
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//k个方程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(ll a, ll r){
</span></span><span style="display:flex;"><span>        ax[<span style="color:#f92672">++</span>k] <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>        rx[k] <span style="color:#f92672">=</span> r;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ll <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>        ll n<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, ans<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>k;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            n <span style="color:#f92672">=</span> n <span style="color:#f92672">*</span> rx[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>k;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            ll m <span style="color:#f92672">=</span> n<span style="color:#f92672">/</span>rx[i];
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">=</span> (ans<span style="color:#f92672">+</span>ax[i]<span style="color:#f92672">*</span>m<span style="color:#f92672">*</span>exgcd_inv(m,rx[i]))<span style="color:#f92672">%</span>n;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CRT crt;
</span></span></code></pre></div><h2 id="积性函数">积性函数</h2>
<p>积性函数是数论函数的一种。数论函数则是定义域为正整数的函数。</p>
<p>若函数<span class="math inline">\(f(n)\)</span>满足<span class="math inline">\(f(1)=1\)</span>且<span class="math inline">\(\forall x,y\in N^*,gcd(x,y)=1\)</span>都有<span class="math inline">\(f(xy)=f(x)f(y)\)</span>，则<span class="math inline">\(f(n)\)</span>为积性函数</p>
<p>如果不要求<span class="math inline">\(gcd(x,y)=1\)</span>也有这个性质的函数叫完全积性函数。同理可知加性函数的定义。</p>
<p><strong>性质</strong></p>
<ol>
<li>若<span class="math inline">\(f(x),g(x)\)</span>均为积性函数，则以下函数也是积性函数
<ol>
<li><span class="math inline">\(h(x)=f(x^p)\)</span></li>
<li><span class="math inline">\(h(x)=f^p(x)\)</span></li>
<li><span class="math inline">\(h(x)=f(x)g(x)\)</span></li>
<li><span class="math inline">\(h(x)=\sum_{d|x}f(d)g(x/d)\)</span>（即狄利克雷卷积）</li>
<li>其逆元</li>
</ol>
</li>
<li>若<span class="math inline">\(f\)</span>是积性函数，且在算术基本定理中<span class="math inline">\(n=\prod^{m}_{i=1}p_i^{c_i}\)</span>，则<span class="math inline">\(f(n)=\prod^{m}_{i=1}f(p_i^{c_i})\)</span>。如果<span class="math inline">\(f\)</span>是完全积性函数，则<span class="math inline">\(f(n)=\prod^{m}_{i=1}f(p_i)^{c_i}\)</span></li>
</ol>
<p><strong>例子</strong></p>
<ol>
<li><span class="math inline">\(\varepsilon(n)=[n=1]\)</span>，单位函数，括号是艾弗森括号，是完全积性。</li>
<li><span class="math inline">\(id_k(n)=n^k\)</span>，幂函数，是完全积性。<span class="math inline">\(k=1\)</span>是恒等函数<span class="math inline">\(id(n)=n\)</span>，<span class="math inline">\(k=0\)</span>是常数函数<span class="math inline">\(1(n)=1\)</span></li>
<li><span class="math inline">\(\sigma_k(n)=\sum_{d/n}d^k\)</span>，除数函数。当<span class="math inline">\(k=1\)</span>时，为因数和函数<span class="math inline">\(\sigma(n)\)</span>，当<span class="math inline">\(k=0\)</span>时为因数个数函数<span class="math inline">\(\sigma_0(n)\)</span></li>
<li>欧拉函数</li>
<li>莫比乌斯函数</li>
</ol>
<h2 id="欧拉函数-todo习题">欧拉函数 TODO：习题</h2>
<p><span class="math inline">\(1\sim N\)</span>中与<span class="math inline">\(N\)</span>互质的数的个数被称为欧拉函数，记为<span class="math inline">\(\varphi(N)\)</span></p>
<p>若在算数基本定理中，<span class="math inline">\(N=p_1^{c_1}p_2^{c_2}\cdots p_m^{c_m}\)</span>，则</p>
<p><span class="math display">\[\varphi(N)=N\times\dfrac{p_1-1}{p_1}\times\dfrac{p_2-1}{p_2}\times\cdots\times\dfrac{p_m-1}{p_m}
\]</span></p>
<p>欧拉函数也可以写成艾弗森括号的形式为</p>
<p><span class="math display">\[\sum^n_{i=1}[\gcd(i,n)=1]
\]</span></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 根号n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">phi</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">*</span>i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">%</span>i<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">=</span> ans<span style="color:#f92672">/</span>i<span style="color:#f92672">*</span>(i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(n<span style="color:#f92672">%</span>i<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) n<span style="color:#f92672">/=</span>i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>) ans <span style="color:#f92672">=</span> ans<span style="color:#f92672">/</span>n<span style="color:#f92672">*</span>(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>欧拉函数有以下性质</p>
<ol>
<li><span class="math inline">\(\forall n>1\)</span>，<span class="math inline">\(1\sim n\)</span>中与<span class="math inline">\(n\)</span>互质的数的和为<span class="math inline">\(n\times\varphi(n)/2\)</span></li>
<li>若<span class="math inline">\(a,b\)</span>互质，则<span class="math inline">\(\varphi(ab)=\varphi(a)\varphi(b)\)</span>。也就是说欧拉函数是积性函数</li>
<li>设<span class="math inline">\(p\)</span>为质数，若<span class="math inline">\(p|n\)</span>且<span class="math inline">\(p^2|n\)</span>，则<span class="math inline">\(\varphi(n)=\varphi(n/p)\times p\)</span></li>
<li>设<span class="math inline">\(p\)</span>为质数，若<span class="math inline">\(p|n\)</span>但不满足<span class="math inline">\(p^2|n\)</span>，则<span class="math inline">\(\varphi(n)=\varphi(n/p)\times (p-1)\)</span></li>
<li><span class="math inline">\(\sum_{d|n}\varphi(d)=n\)</span></li>
<li>若<span class="math inline">\(p\)</span>是质数，则<span class="math inline">\(\varphi(p^n)=p^{n-1}(p-1)\)</span></li>
<li>若<span class="math inline">\(a|x\)</span>，则<span class="math inline">\(\varphi(ax)=a\varphi(x)\)</span></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//求1-N的所有欧拉函数值，使用筛法，埃氏筛复杂度NloglogN，线性筛复杂度N，这里是线性筛
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> prime;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> isnp[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> phi[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">euler</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    phi[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>isnp[i]){
</span></span><span style="display:flex;"><span>            prime.push_back(i);
</span></span><span style="display:flex;"><span>            phi[i] <span style="color:#f92672">=</span> i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> p:prime){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">*</span>p<span style="color:#f92672">&gt;</span>n) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            isnp[i<span style="color:#f92672">*</span>p] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">%</span>p<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>                phi[i<span style="color:#f92672">*</span>p] <span style="color:#f92672">=</span> phi[i] <span style="color:#f92672">*</span> p;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>                phi[i<span style="color:#f92672">*</span>p] <span style="color:#f92672">=</span> phi[i] <span style="color:#f92672">*</span> phi[p];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="狄利克雷卷积">狄利克雷卷积</h2>
<p>两个数论函数<span class="math inline">\(f(n),g(n)\)</span>的狄利克雷卷积定义为</p>
<p><span class="math display">\[(f\ast g)(n) = \sum_{xy=n}f(x)g(y)
\]</span></p>
<p>也可以写作</p>
<p><span class="math display">\[(f\ast g)(n) = \sum_{d|n}f(d)g(n/d)
\]</span></p>
<p><strong>性质</strong></p>
<ol>
<li>两个积性函数的卷积还是积性函数</li>
<li><span class="math inline">\((f\ast 1)(n) = \sum_{d|n}f(d)\)</span></li>
<li><span class="math inline">\((id_k\ast 1)(n)=\sum_{d|n}d^k=\sigma_k\)</span></li>
<li><span class="math inline">\(\varphi\ast 1=id\)</span></li>
<li>满足交换率、结合律、对加法的分配律</li>
<li>等式性质，<span class="math inline">\(f=g\)</span>的充要条件是<span class="math inline">\(f\ast h = g\ast h\)</span>，其中数论函数<span class="math inline">\(h(1)\neq 0\)</span></li>
<li>幺元是<span class="math inline">\(\varepsilon\)</span>，即<span class="math inline">\(f\ast \varepsilon=f\)</span></li>
<li>逆元，即满足<span class="math inline">\(f\ast g=\varepsilon\)</span>的函数<span class="math inline">\(g\)</span>为（显然<span class="math inline">\(f(1)\neq 0\)</span>才有逆元）</li>
</ol>
<p><span class="math display">\[g(x)=\dfrac{\varepsilon(x)-\sum_{d|x,d\neq 1}f(d)g(x/d)}{f(1)}
\]</span></p>
<ol start="9">
<li>积性函数一定有逆元，且逆元也是积性函数。</li>
</ol>
<h2 id="莫比乌斯反演-todo习题">莫比乌斯反演 TODO：习题</h2>
<p>莫比乌斯函数是常数函数<span class="math inline">\(1\)</span>的逆元。即</p>
<p><span class="math display">\[\mu(n) = \left\{\begin{matrix}
1, & n=1 \\
(-1)^m  & n=p_1p_2\cdots p_m\\
0  & \text{otherwise}
\end{matrix}\right.
\]</span></p>
<p>其中第二个条件就是<span class="math inline">\(n\)</span>质因数分解后每个因子的次数是<span class="math inline">\(1\)</span></p>
<p>莫比乌斯反演公式即为</p>
<p><span class="math display">\[g(n)=\sum_{d|n}f(d)\Leftrightarrow f(n) = \sum_{d|n}\mu(d)g(n/d)
\]</span></p>
<p>用狄利克雷卷积来写就是</p>
<p><span class="math display">\[f\ast 1=g\Leftrightarrow f=g\ast \mu
\]</span></p>
<p>还有一种形式（倍数形式，之前的叫因数形式）是</p>
<p><span class="math display">\[g(n) = \sum_{n|N}f(N)\Leftrightarrow f(n) = \sum_{n|N}\mu(N/n)g(N)
\]</span></p>
<p><strong>性质</strong></p>
<ol>
<li>是积性函数</li>
<li><span class="math inline">\(\sum_{d|n}\mu(d)=\varepsilon(n),\mu\ast 1=\varepsilon\)</span></li>
<li><span class="math inline">\(\sum_{d|\gcd(i,j)}\mu(d)=[\gcd(i,j)=1]\)</span></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//线性筛求莫比乌斯函数，复杂度n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> mu[MAXN];
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> prime;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> isnp[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mobius</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    mu[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>isnp[i]){
</span></span><span style="display:flex;"><span>            prime.push_back(i);
</span></span><span style="display:flex;"><span>            mu[i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> p:prime){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">*</span>p<span style="color:#f92672">&gt;</span>n) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            isnp[i<span style="color:#f92672">*</span>p] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">%</span>p<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>                mu[i<span style="color:#f92672">*</span>p] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>                mu[i<span style="color:#f92672">*</span>p] <span style="color:#f92672">=</span> mu[i] <span style="color:#f92672">*</span> mu[p];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="数论分块">数论分块</h2>
<p>在计算形如</p>
<p><span class="math display">\[\sum^n_{i=1}f(i)g(\left \lfloor \dfrac{n}{i} \right \rfloor )
\]</span></p>
<p>的式子时，注意到<span class="math inline">\(\left \lfloor \dfrac{n}{i} \right \rfloor\)</span>的取值个数会比<span class="math inline">\(n\)</span>小很多，我们可以将取值相同的合在一起计算。如果可以在<span class="math inline">\(O(1)\)</span>内计算<span class="math inline">\(f(l)+\cdots+f(r)\)</span>（比如等差数列求和公式）或者有<span class="math inline">\(f\)</span>的前缀和时，数论分块可以在<span class="math inline">\(O(\sqrt{n})\)</span>计算和式的值。</p>
<p><strong>定理1</strong></p>
<p><span class="math display">\[\forall a,b,c\in Z, \left \lfloor \dfrac{a}{bc} \right \rfloor=\left \lfloor \dfrac{\left \lfloor \dfrac{a}{b} \right \rfloor}{c} \right \rfloor
\]</span></p>
<p><strong>定理2</strong></p>
<p>当<span class="math inline">\(i\)</span>取正整数且<span class="math inline">\(i\leq n\)</span>时，<span class="math inline">\(\left \lfloor \dfrac{n}{i} \right \rfloor\)</span>的不同取值的数量不超过<span class="math inline">\(\left \lfloor 2\sqrt n \right \rfloor\)</span></p>
<p><strong>定理3</strong></p>
<p>使得式子</p>
<p><span class="math display">\[\left \lfloor \dfrac{n}{i} \right \rfloor = \left \lfloor \dfrac{n}{j} \right \rfloor
\]</span></p>
<p>成立的最大的满足<span class="math inline">\(i\leq j\leq n\)</span>的<span class="math inline">\(j\)</span>值是<span class="math inline">\(\left \lfloor \dfrac{n}{\left \lfloor \dfrac{n}{i} \right \rfloor} \right \rfloor\)</span>。也就是这个分块的右端点。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//UVA 11526
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//数论分块模板 复杂度sqrt n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//要求计算i=1~n, ans = ans+n/i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    LL n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>    LL ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    LL l <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(l<span style="color:#f92672">&lt;=</span>n){
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> n<span style="color:#f92672">/</span>(n<span style="color:#f92672">/</span>l);
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">+=</span> (r<span style="color:#f92672">-</span>l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> (n<span style="color:#f92672">/</span>l);
</span></span><span style="display:flex;"><span>        l <span style="color:#f92672">=</span> r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;  
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意如果不是<span class="math inline">\(\left \lfloor \dfrac{n}{i} \right \rfloor\)</span>而是某个<span class="math inline">\(\left \lfloor \dfrac{k}{i} \right \rfloor\)</span>，要注意特判判<span class="math inline">\(k/l\)</span>等于<span class="math inline">\(0\)</span>，以及<span class="math inline">\(r\)</span>要特判不能超过<span class="math inline">\(n\)</span>。</p>
<p>当有多个取整<span class="math inline">\(\left \lfloor \dfrac{a_1}{i} \right \rfloor,\left \lfloor \dfrac{a_2}{i} \right \rfloor,\cdots\)</span> 时，我们取的右端点就变成每一个块的右端点的最小值。</p>
<h2 id="杜教筛">杜教筛</h2>
<p>杜教筛可以在<span class="math inline">\(O(n^{2/3})\)</span>的时间复杂度下求得一类数论函数（不一定需要积性）<span class="math inline">\(f(n)\)</span>的前缀和。</p>
<p>我们需要找到一个数论函数<span class="math inline">\(g(n)\)</span>，使得<span class="math inline">\(g(n)\)</span>和<span class="math inline">\(f\ast g(n)\)</span>的前缀和都很容易求出（最好在<span class="math inline">\(O(1)\)</span>），那我们就能以低于线性复杂度的算法求出<span class="math inline">\(f(n)\)</span>的前缀和<span class="math inline">\(S(n)\)</span>。证明略，结论为：</p>
<p><span class="math display">\[g(1)S(n) = \sum^n_{i=1}(f\ast g)(i)-\sum^n_{i=2}g(i)S(\left \lfloor \dfrac{n}{i} \right \rfloor)
\]</span></p>
<p><strong>筛莫比乌斯函数</strong></p>
<p>之前我们学到<span class="math inline">\(\mu\ast 1=\varepsilon\)</span>，所以我们自然的令<span class="math inline">\(g(n)=1\)</span>，得到</p>
<p><span class="math display">\[S(n)=\sum^n_{i=1}\varepsilon(i)-\sum^n_{i=2}S(\left \lfloor \dfrac{n}{i} \right \rfloor) = 1-\sum^n_{i=2}S(\left \lfloor \dfrac{n}{i} \right \rfloor)
\]</span></p>
<p>此时如果我们直接用数论分块去算<span class="math inline">\(S(n)\)</span>，我们的算法复杂度是<span class="math inline">\(O(n^{3/4})\)</span>，但是如果我们用线性筛预处理前<span class="math inline">\(n^{2/3}\)</span>的<span class="math inline">\(S(n)\)</span>的值，就可以优化复杂度到<span class="math inline">\(O(n^{2/3})\)</span>，通常我们还会开一个哈希表去维护大于<span class="math inline">\(n^{2/3}\)</span>的值来优化。</p>
<p><strong>筛欧拉函数</strong></p>
<p>同样取<span class="math inline">\(g(n)=1\)</span>，有<span class="math inline">\(\varphi(n)\ast 1=id\)</span></p>
<p><span class="math display">\[S(n) = \sum^n_{i=1}id-\sum^n_{i=2}S(\left \lfloor \dfrac{n}{i} \right \rfloor) = \dfrac{n(1+n)}{2}-\sum^n_{i=2}S(\left \lfloor \dfrac{n}{i} \right \rfloor)
\]</span></p>
<p>跟之前可以说没什么区别。</p>
<p>给出求欧拉函数和莫比乌斯函数前缀和的例子代码。这里筛法一次把两个函数都筛了，其他不难理解。注意要用unordered_map以及数论分块的时候<span class="math inline">\(l\)</span>从<span class="math inline">\(2\)</span>开始。以及洛谷上这题数据范围为2^31，要筛出大概前170w个数。我筛了200w也过了，分类讨论，前200w直接返回，大于200w的如果在map里就返回，否则递归计算后放入map里。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//杜教筛 复杂度n^(2/3)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p4213
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">2000005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> mu[MAXN];
</span></span><span style="display:flex;"><span>LL phi[MAXN];
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> prime;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> isnp[MAXN];
</span></span><span style="display:flex;"><span>LL sum_mu[MAXN],sum_phi[MAXN];
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span>LL,LL<span style="color:#f92672">&gt;</span> mp_mu,mp_phi;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sieve</span>(<span style="color:#66d9ef">int</span> n<span style="color:#f92672">=</span>MAXN<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    mu[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    phi[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>isnp[i]){
</span></span><span style="display:flex;"><span>            prime.push_back(i);
</span></span><span style="display:flex;"><span>            mu[i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            phi[i] <span style="color:#f92672">=</span> i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> p:prime){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">*</span>p<span style="color:#f92672">&gt;</span>n) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            isnp[i<span style="color:#f92672">*</span>p] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">%</span>p<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>                mu[i<span style="color:#f92672">*</span>p] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                phi[i<span style="color:#f92672">*</span>p] <span style="color:#f92672">=</span> phi[i] <span style="color:#f92672">*</span> p;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>                mu[i<span style="color:#f92672">*</span>p] <span style="color:#f92672">=</span> mu[i] <span style="color:#f92672">*</span> mu[p];
</span></span><span style="display:flex;"><span>                phi[i<span style="color:#f92672">*</span>p] <span style="color:#f92672">=</span> phi[i] <span style="color:#f92672">*</span> phi[p];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        sum_mu[i] <span style="color:#f92672">=</span> sum_mu[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>mu[i];
</span></span><span style="display:flex;"><span>        sum_phi[i] <span style="color:#f92672">=</span> sum_phi[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>phi[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">sum1</span>(LL n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">&lt;</span>MAXN){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sum_phi[n];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(mp_phi.count(n)){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> mp_phi[n];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    LL l<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, r<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    LL ret <span style="color:#f92672">=</span> n<span style="color:#f92672">*</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>n)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(l<span style="color:#f92672">&lt;=</span>n){
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> n<span style="color:#f92672">/</span>(n<span style="color:#f92672">/</span>l);
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">-=</span> (r<span style="color:#f92672">-</span>l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>sum1(n<span style="color:#f92672">/</span>l);
</span></span><span style="display:flex;"><span>        l <span style="color:#f92672">=</span> r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    mp_phi[n] <span style="color:#f92672">=</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">sum2</span>(LL n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">&lt;</span>MAXN){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sum_mu[n];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(mp_mu.count(n)){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> mp_mu[n];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    LL l<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, r<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    LL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(l<span style="color:#f92672">&lt;=</span>n){
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> n<span style="color:#f92672">/</span>(n<span style="color:#f92672">/</span>l);
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">-=</span> (r<span style="color:#f92672">-</span>l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>sum2(n<span style="color:#f92672">/</span>l);
</span></span><span style="display:flex;"><span>        l <span style="color:#f92672">=</span> r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    mp_mu[n] <span style="color:#f92672">=</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    LL n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>sum1(n)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">&lt;&lt;</span>sum2(n)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sieve();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> T;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>T;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//T=1;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span>(T<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>	    solve();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="图论">图论</h1>
<h2 id="存图">存图</h2>
<h3 id="邻接矩阵">邻接矩阵</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> graph[MAXN][MAXN];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//加边删边、访问很方便，a-&gt;b，权值为w，则graph[a][b]=w
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//空间占用大，并且不能存重边
</span></span></span></code></pre></div><h3 id="邻接表vector版">邻接表（vector版）</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v,w;<span style="color:#75715e">//下一点，权
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> edges[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//加边u-&gt;v,权值w
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>edges[u].push_back(w);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//访问只能遍历u所连的出边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> x:edges[u]){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>x.v<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">&lt;&lt;</span>x.w<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//缺点是，删边难，以及清空边复杂度过高。快速清边见链式前向星传统数组版
</span></span></span></code></pre></div><h3 id="链式前向星vector版">链式前向星（vector版）</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v;LL w;<span style="color:#75715e">//指向的点，容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Edge(<span style="color:#66d9ef">int</span> v_, LL w_)<span style="color:#f92672">:</span>v(v_),w(w_){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> edges;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> graph(MAXN);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//常用于网络流，例如加u-&gt;v，权值为w，及其反向边v-&gt;w，权值为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>graph[u].push_back(edges.size());
</span></span><span style="display:flex;"><span>edges.push_back(Edge(v,w));
</span></span><span style="display:flex;"><span>graph[v].push_back(edges.size());
</span></span><span style="display:flex;"><span>edges.push_back(Edge(u,<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span><span style="color:#75715e">//遍历u的边时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> x:graph[u]){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> e<span style="color:#f92672">=</span>edges[x];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> v<span style="color:#f92672">=</span>e.v, w<span style="color:#f92672">=</span>e.w;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//e的反向边就是edges[x^1]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//清空某个点连出的所有边时，graph[u].clear()，不需要管edges的size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//清除整个图时edges.clear()，graph要对每个下标clear
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//这种清除方式复杂度比传统数组版高很多，需要反复建图时不推荐使用。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//好处是不需要让边编号从2开始，从0开始即可存反向边
</span></span></span></code></pre></div><h3 id="链式前向星传统数组版">链式前向星（传统数组版）</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v,w,next;<span style="color:#75715e">//指向的点，边权，下一条边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Edge edges[MAXM];<span style="color:#75715e">//存无向图记得开两倍
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> head[MAXN],cnt;<span style="color:#75715e">//如果要存反向边，并且用^1取反向边，应初始化cnt=1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//不应把后面add的逻辑改成最后再cnt++，因为我们遍历边的时候是判断e是否等于0，所以不应该有边的编号等于0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> v, <span style="color:#66d9ef">int</span> w){
</span></span><span style="display:flex;"><span>    edges[<span style="color:#f92672">++</span>cnt].w <span style="color:#f92672">=</span> w;
</span></span><span style="display:flex;"><span>    edges[cnt].v <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>    edges[cnt].next <span style="color:#f92672">=</span> head[u];<span style="color:#75715e">//把下一条边设置为当前起点的第一条边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    head[u] <span style="color:#f92672">=</span> cnt;<span style="color:#75715e">//该边称为当前起点的第一条边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//遍历，与vector版不同，vector版按加入先后顺序遍历，而这里是反向顺序遍历。绝大多数情况不影响
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//例如遍历1号节点所连的边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> e<span style="color:#f92672">=</span>head[<span style="color:#ae81ff">1</span>];e;e<span style="color:#f92672">=</span>edges[e].next){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>edges[e].v<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">&lt;&lt;</span>edges[e].w<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//当需要清空某个点的所有连出边时, head[u] = 0，不需要管cnt
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//清空全图时，cnt = 0, 对于所有点head = 0， 由于还可以用memset，比vector版更是快了不少
</span></span></span></code></pre></div><h2 id="最短路">最短路</h2>
<h3 id="dijkstra">Dijkstra</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 优先队列实现为mlogm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//dijkstra，单源最短路
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p4779
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAXN 500005
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAXINT 0x7fffffff
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v,w;<span style="color:#75715e">//下一点，权
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Edge(<span style="color:#66d9ef">int</span> v_, <span style="color:#66d9ef">int</span> w_)<span style="color:#f92672">:</span>v(v_),w(w_){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> dis, u;<span style="color:#75715e">//存储起点到u点的距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Node(<span style="color:#66d9ef">int</span> dis_, <span style="color:#66d9ef">int</span> u_)<span style="color:#f92672">:</span>dis(dis_),u(u_){};
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&gt;</span>(Node <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> a) <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> dis <span style="color:#f92672">&gt;</span> a.dis; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> graph[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dis[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> tag[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>priority_queue<span style="color:#f92672">&lt;</span>Node, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span>, std<span style="color:#f92672">::</span>greater<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> pq;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        dis[i] <span style="color:#f92672">=</span> MAXINT;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//初始化为无限远
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        tag[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        graph[i].clear();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>pq.empty()) pq.pop();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dijk</span>(<span style="color:#66d9ef">int</span> s){
</span></span><span style="display:flex;"><span>    dis[s]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    pq.push(Node(<span style="color:#ae81ff">0</span>,s));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>pq.empty())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> pq.top().u;
</span></span><span style="display:flex;"><span>        pq.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(tag[u]) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        tag[u]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> g : graph[u]){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> g.v, w <span style="color:#f92672">=</span> g.w;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(dis[v]<span style="color:#f92672">&gt;</span>dis[u]<span style="color:#f92672">+</span>w){
</span></span><span style="display:flex;"><span>                dis[v] <span style="color:#f92672">=</span> dis[u]<span style="color:#f92672">+</span>w;
</span></span><span style="display:flex;"><span>                pq.push(Node(dis[v],v));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m,s;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>s;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//点数，边数，起点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    init(n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u,v,w;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w;<span style="color:#75715e">//起点，终点，边权
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        graph[u].push_back(Edge(v,w));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    dijk(s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>dis[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="bellman-ford">Bellman-Ford</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 nm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//bellman-ford, 单源最短路
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p4779，有一个点TLE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x6fffffff</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v,w;<span style="color:#75715e">//下一点,权
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Edge(<span style="color:#66d9ef">int</span> v_, <span style="color:#66d9ef">int</span> w_)<span style="color:#f92672">:</span>v(v_),w(w_){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dis[MAXN];
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> graph[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        dis[i]<span style="color:#f92672">=</span>INF;
</span></span><span style="display:flex;"><span>        graph[i].clear();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">BF</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> s){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果不存在最短路就返回0，否则返回1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    dis[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){<span style="color:#75715e">//松弛n-1轮，若第n轮还能松弛，就说明有负环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> u<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;u<span style="color:#f92672">&lt;=</span>n;u<span style="color:#f92672">++</span>){<span style="color:#75715e">//这里看似是两层循环，实际上总数是边数，整个算法的复杂度是mn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> e : graph[u]){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> w<span style="color:#f92672">=</span>e.w,v<span style="color:#f92672">=</span>e.v;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(dis[v]<span style="color:#f92672">&gt;</span>dis[u]<span style="color:#f92672">+</span>w){
</span></span><span style="display:flex;"><span>                    dis[v]<span style="color:#f92672">=</span>dis[u]<span style="color:#f92672">+</span>w;
</span></span><span style="display:flex;"><span>                    flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(flag){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> flag;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m,s;<span style="color:#75715e">//点数，边数，起点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>s;
</span></span><span style="display:flex;"><span>    init(n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u,v,w;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//起点，终点，边权
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        graph[u].push_back(Edge(v,w));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    BF(n,s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>dis[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="spfa">SPFA</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 nm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    bellman-ford的优化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    只有上一次被松弛的结点，所连接的边，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    才有可能引起下一次的松弛操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//spfa 单源最短路
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P3371
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x5fffffff</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v,w;
</span></span><span style="display:flex;"><span>    Edge(<span style="color:#66d9ef">int</span> v_, <span style="color:#66d9ef">int</span> w_)<span style="color:#f92672">:</span>v(v_),w(w_){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dis[MAXN];<span style="color:#75715e">//距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> cnt[MAXN];<span style="color:#75715e">//算到达本节点所要经过的边数，若cnt&gt;=n，则说明有负权环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> tag[MAXN];<span style="color:#75715e">//用于判断是否为上次松弛过的节点的边所连的点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> qu;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> graph[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>qu.empty()) qu.pop();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        dis[i] <span style="color:#f92672">=</span> INF;
</span></span><span style="display:flex;"><span>        cnt[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        tag[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        graph[i].clear();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">SPFA</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> s){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果不存在最短路就返回0，否则返回1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    dis[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    tag[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    qu.push(s);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>qu.empty()){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>flag) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> qu.front();
</span></span><span style="display:flex;"><span>        qu.pop();
</span></span><span style="display:flex;"><span>        tag[u]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> e : graph[u]){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> e.v, w <span style="color:#f92672">=</span> e.w;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(dis[v]<span style="color:#f92672">&gt;</span>dis[u]<span style="color:#f92672">+</span>w){
</span></span><span style="display:flex;"><span>                dis[v]<span style="color:#f92672">=</span>dis[u]<span style="color:#f92672">+</span>w;
</span></span><span style="display:flex;"><span>                cnt[v]<span style="color:#f92672">=</span>cnt[u]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(cnt[v]<span style="color:#f92672">&gt;=</span>n) {
</span></span><span style="display:flex;"><span>                    flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>tag[v]){
</span></span><span style="display:flex;"><span>                    qu.push(v);
</span></span><span style="display:flex;"><span>                    tag[v]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> flag;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m,s;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>s;
</span></span><span style="display:flex;"><span>    init(n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u,v,w;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//起点，终点，边权
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        graph[u].push_back(Edge(v,w));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    SPFA(n,s);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(dis[i]<span style="color:#f92672">!=</span>INF){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>dis[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;2147483647 &#34;</span>;<span style="color:#75715e">//根据luogu P3371要输出这个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="floyd">Floyd</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 n^3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//floyd全源最短路
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p5905，由于不能判断负环和速度慢，会wa和tle一些
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//floyd虽然不能处理负环但是可以接受负边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">3005</span>;
</span></span><span style="display:flex;"><span>LL <span style="color:#66d9ef">const</span> INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e17</span>; <span style="color:#75715e">//不能设置为int的最大值，否则后面加法可能导致溢出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL graph[MAXN][MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;<span style="color:#75715e">//点数，边数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>n;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            graph[i][j] <span style="color:#f92672">=</span> INF;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u,v;LL w;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w;<span style="color:#75715e">//起点，终点，边权
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        graph[u][v] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(graph[u][v], w);<span style="color:#75715e">//处理重边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        graph[i][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;k<span style="color:#f92672">&lt;=</span>n;k<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>n;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                graph[i][j] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(graph[i][j],graph[i][k]<span style="color:#f92672">+</span>graph[k][j]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        LL res<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(LL j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>n;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(graph[i][j]<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1e9</span>) graph[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e9</span>;
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">+=</span> j<span style="color:#f92672">*</span>graph[i][j];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>res<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="johnson-todo">Johnson TODO</h3>
<h2 id="差分约束">差分约束</h2>
<p>给出一组不等式</p>
<p><span class="math display">\[\left\{\begin{matrix}
x_{c_1}-x_{c_1'}\leq y_1 \\
x_{c_2}-x_{c_2'}\leq y_2 \\
\vdots \\
x_{c_m}-x_{c_m'}\leq y_m
\end{matrix}\right.
\]</span></p>
<p>其中一共有<span class="math inline">\(n\)</span>个未知数<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>，<span class="math inline">\(m\)</span>个不等式，求一组可行解。</p>
<p>我们连边，连一条<span class="math inline">\(x_{c_i'}\)</span>到<span class="math inline">\(x_{c_i}\)</span>，权值为<span class="math inline">\(y_i\)</span>的边。然后增加<span class="math inline">\(n+1\)</span>号节点，从它到所有点连一条权值为<span class="math inline">\(0\)</span>的边。然后以<span class="math inline">\(n+1\)</span>为源点求到各点的最短路，这个最短距离dis[i]就是<span class="math inline">\(x_i\)</span>的一个解。</p>
<p>当然，出现负环就无解。</p>
<p>不难理解，<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>全部加上或减去同一个数，仍然是可行解。</p>
<p>之前我们假设dis[n+1]=0，如果我们设置dis[n+1] = w，那么我们求得的就是<span class="math inline">\(x_1,x_2,\cdots,x_n\leq w\)</span>的一组解。实际上，可以证明这个解是满足<span class="math inline">\(x_1,x_2,\cdots,x_n\leq w\)</span>的最大解（每个变量能取得的最大值）。</p>
<p>如果题目上的约束条件全部变为<span class="math inline">\(\geq\)</span>型，我们要求满足<span class="math inline">\(x_1,x_2,\cdots,x_n\geq w\)</span>的最小解，则只需要求最长路即可。对于Bellman-Ford和SPFA来说，初始化dis为-INF，然后颠倒比较符号即可。</p>
<p>题目中不总是给出<span class="math inline">\(x_1-x_2\leq y\)</span>，但我们可以转化</p>
<ul>
<li><span class="math inline">\(x_1-x_2\geq y\Rightarrow x_2-x_1\leq -y\)</span></li>
<li><span class="math inline">\(x_1-x_2=y\Rightarrow x_1-x_2\leq y \wedge x_2-x_1\leq -y\)</span></li>
<li><span class="math inline">\(x_1-x_2< y\Rightarrow x_1-x_2\leq y-1\)</span>（要求取值只能是整数）</li>
<li><span class="math inline">\(x_1-x_2>y\Rightarrow x_2-x_1\leq -y-1\)</span>（要求取值只能是整数）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//差分约束，复杂度同SPFA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p5960
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//使用介绍见markdown
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">5005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x5fffffff</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v,w;
</span></span><span style="display:flex;"><span>    Edge(<span style="color:#66d9ef">int</span> v_, <span style="color:#66d9ef">int</span> w_)<span style="color:#f92672">:</span>v(v_),w(w_){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dis[MAXN];<span style="color:#75715e">//距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> cnt[MAXN];<span style="color:#75715e">//算到达本节点所要经过的边数，若cnt&gt;=n，则说明有负权环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> tag[MAXN];<span style="color:#75715e">//用于判断是否为上次松弛过的节点的边所连的点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> qu;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> graph[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>qu.empty()) qu.pop();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        dis[i] <span style="color:#f92672">=</span> INF;
</span></span><span style="display:flex;"><span>        cnt[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        tag[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        graph[i].clear();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">SPFA</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> s){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果不存在最短路就返回0，否则返回1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    dis[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    tag[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    qu.push(s);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>qu.empty()){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>flag) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> qu.front();
</span></span><span style="display:flex;"><span>        qu.pop();
</span></span><span style="display:flex;"><span>        tag[u]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> e : graph[u]){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> e.v, w <span style="color:#f92672">=</span> e.w;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(dis[v]<span style="color:#f92672">&gt;</span>dis[u]<span style="color:#f92672">+</span>w){
</span></span><span style="display:flex;"><span>                dis[v]<span style="color:#f92672">=</span>dis[u]<span style="color:#f92672">+</span>w;
</span></span><span style="display:flex;"><span>                cnt[v]<span style="color:#f92672">=</span>cnt[u]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(cnt[v]<span style="color:#f92672">&gt;=</span>n) {
</span></span><span style="display:flex;"><span>                    flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>tag[v]){
</span></span><span style="display:flex;"><span>                    qu.push(v);
</span></span><span style="display:flex;"><span>                    tag[v]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> flag;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    init(n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v,u,w;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>w;
</span></span><span style="display:flex;"><span>        graph[u].push_back(Edge(v,w));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        graph[n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].push_back(Edge(i,<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    n<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>SPFA(n,n)){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;NO</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>dis[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="拓扑排序">拓扑排序</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//拓扑排序, luogu B3644
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">105</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> graph[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> in[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> v;
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>v;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(v<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            graph[i].push_back(v);
</span></span><span style="display:flex;"><span>            in[v]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> qu;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(in[i]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) qu.push(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>qu.empty()){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> qu.front();
</span></span><span style="display:flex;"><span>        qu.pop();
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>u<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> v:graph[u]){
</span></span><span style="display:flex;"><span>            in[v]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(in[v]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) qu.push(v);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="最小生成树">最小生成树</h2>
<h3 id="kruskal">Kruskal</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 mlogm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//最小生成树Kruskal，luogu p3366
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXM <span style="color:#f92672">=</span> <span style="color:#ae81ff">200005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">5005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> u,v,w;<span style="color:#75715e">//最小生成树是在无向图上跑的，由于要排序，所以记录uvw
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(Edge <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> x) <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> w<span style="color:#f92672">&lt;</span>x.w;
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Edge edges[MAXM];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> find_sets[MAXN];<span style="color:#75715e">//并查集
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> find_sets[x]<span style="color:#f92672">==</span>x <span style="color:#f92672">?</span> x : find_sets[x] <span style="color:#f92672">=</span> find(find_sets[x]);}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;<span style="color:#75715e">//点数和边数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>edges[i].u<span style="color:#f92672">&gt;&gt;</span>edges[i].v<span style="color:#f92672">&gt;&gt;</span>edges[i].w;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(edges<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,edges<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>m);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        find_sets[i]<span style="color:#f92672">=</span>i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> cnt<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> edges[i].u, v <span style="color:#f92672">=</span> edges[i].v;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> find(u);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> find(v);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(x<span style="color:#f92672">!=</span>y){
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">+=</span> edges[i].w;
</span></span><span style="display:flex;"><span>            find_sets[x] <span style="color:#f92672">=</span> y;
</span></span><span style="display:flex;"><span>            cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//计数，如果小于n-1则不连通
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(cnt<span style="color:#f92672">&lt;</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;orz</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="prim算法">Prim算法</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 (m+n)logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//最小生成树prim，luogu p3366
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">5005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXM <span style="color:#f92672">=</span> <span style="color:#ae81ff">200005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x5fffffff</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v,w;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    edge(){};
</span></span><span style="display:flex;"><span>    edge(<span style="color:#66d9ef">int</span> v,<span style="color:#66d9ef">int</span> w)<span style="color:#f92672">:</span>v(v),w(w){}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">const</span> edge<span style="color:#f92672">&amp;</span> x) <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> w<span style="color:#f92672">&gt;</span>x.w;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>edge<span style="color:#f92672">&gt;</span> graph[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> vis[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>priority_queue<span style="color:#f92672">&lt;</span>edge, std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>edge<span style="color:#f92672">&gt;</span>, std<span style="color:#f92672">::</span>greater<span style="color:#f92672">&lt;</span>edge<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> pq;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;<span style="color:#75715e">//点数，边数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u,v,w;<span style="color:#75715e">//起点，终点，边权
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w;
</span></span><span style="display:flex;"><span>        graph[u].push_back(edge(v,w));
</span></span><span style="display:flex;"><span>        graph[v].push_back(edge(u,w));
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//无向图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>graph[<span style="color:#ae81ff">1</span>].size();i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        pq.push(graph[<span style="color:#ae81ff">1</span>][i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    vis[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(cnt<span style="color:#f92672">!=</span>n<span style="color:#f92672">&amp;&amp;!</span>pq.empty()){
</span></span><span style="display:flex;"><span>        edge minx<span style="color:#f92672">=</span>pq.top();
</span></span><span style="display:flex;"><span>        pq.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(vis[minx.v]){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(pq.empty()){
</span></span><span style="display:flex;"><span>                std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;orz</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;<span style="color:#75715e">//不连通
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            minx<span style="color:#f92672">=</span>pq.top();
</span></span><span style="display:flex;"><span>            pq.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        vis[minx.v] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        ans<span style="color:#f92672">+=</span>minx.w;
</span></span><span style="display:flex;"><span>        cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>graph[minx.v].size();i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>vis[graph[minx.v][i].v])
</span></span><span style="display:flex;"><span>                pq.push(graph[minx.v][i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(cnt<span style="color:#f92672">&lt;</span>n){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;orz</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="最小树形图朱刘算法">最小树形图（朱刘算法）</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 nm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//最小树形图，朱刘算法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//从根节点能到达其他所有点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu4716
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">105</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXM <span style="color:#f92672">=</span> <span style="color:#ae81ff">10005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7fffffff</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> u,v,w;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Edge edge[MAXM]; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> vis[MAXN],id[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> in[MAXN],pre[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">zhuliu</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> m, <span style="color:#66d9ef">int</span> root){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//返回最小树形图的边权和，如果不存在则返回-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(;;){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) in[i]<span style="color:#f92672">=</span>INF;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> edge[i].u;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> edge[i].v;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(u<span style="color:#f92672">!=</span>v <span style="color:#f92672">&amp;&amp;</span> edge[i].w<span style="color:#f92672">&lt;</span>in[v]){<span style="color:#75715e">//遍历所有边，找到对每个点的最短入边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                in[v] <span style="color:#f92672">=</span> edge[i].w;
</span></span><span style="display:flex;"><span>                pre[v] <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">!=</span>root <span style="color:#f92672">&amp;&amp;</span> in[i]<span style="color:#f92672">==</span>INF){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//无解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//记录环数以及下一次循环的点数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            vis[i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            id[i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        in[root] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">==</span>root) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">+=</span> in[i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> v<span style="color:#f92672">=</span>i;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(vis[v]<span style="color:#f92672">!=</span>i<span style="color:#f92672">&amp;&amp;</span>id[v]<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&amp;&amp;</span>v<span style="color:#f92672">!=</span>root){
</span></span><span style="display:flex;"><span>                vis[v] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                v <span style="color:#f92672">=</span> pre[v];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(v<span style="color:#f92672">!=</span>root <span style="color:#f92672">&amp;&amp;</span> id[v]<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>                id[v] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>cnt;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> u<span style="color:#f92672">=</span>pre[v];u<span style="color:#f92672">!=</span>v;u<span style="color:#f92672">=</span>pre[u]) id[u] <span style="color:#f92672">=</span> cnt;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(cnt<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){<span style="color:#75715e">//无环，得到解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(id[i]<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>) id[i]<span style="color:#f92672">=++</span>cnt;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> edge[i].u;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> edge[i].v;
</span></span><span style="display:flex;"><span>            edge[i].u <span style="color:#f92672">=</span> id[u];
</span></span><span style="display:flex;"><span>            edge[i].v <span style="color:#f92672">=</span> id[v];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(edge[i].u<span style="color:#f92672">!=</span>edge[i].v) edge[i].w <span style="color:#f92672">-=</span> in[v];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> cnt;
</span></span><span style="display:flex;"><span>        root <span style="color:#f92672">=</span> id[root];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m,root;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>root;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//点数，边数，根节点序号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>edge[i].u<span style="color:#f92672">&gt;&gt;</span>edge[i].v<span style="color:#f92672">&gt;&gt;</span>edge[i].w;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//起点，终点，边权
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>zhuliu(n,m,root)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="二分图判定">二分图判定</h2>
<p>一张无向图是二分图，当且仅当图中不存在长度为奇数的环。</p>
<p>我们可以用染色法来判定。假设染成两种颜色，一个节点被染色后，所有相连节点都应该染成另一种颜色，如果有冲突，则说明不是二分图。</p>
<h2 id="二分图匹配">二分图匹配</h2>
<h3 id="最大匹配匈牙利算法">最大匹配（匈牙利算法）</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 nm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p3386
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//求二分图最大匹配，根据定理，最大匹配=最小点覆盖，以及最小边覆盖=点数-最大匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//二分图是&#34;可以将点集分为两个不相交的部分，所有边连接的两个顶点在不同的部分中&#34;的图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//二分图的匹配：边集的任意子集的任意两条边都没有公共顶点，则这个子集是一个匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//二分图的最大匹配：所有匹配中边数最多的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//最小点覆盖：选最少的点，满足每条边至少有一个端点被选
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//最大独立集：选最多的点，满足两两之间没有边相连
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//这里的二分图是无向图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//如果最大匹配中所有点都被匹配，那么叫做完美匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">505</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> graph[MAXN][MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> vis[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> toLeft[MAXN];<span style="color:#75715e">//标记右边节点i连到了哪个左边界点，即toLeft[i]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">match</span>(<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> i, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> rightNum){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>rightNum;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(graph[i][j]<span style="color:#f92672">&amp;&amp;!</span>vis[j]){
</span></span><span style="display:flex;"><span>            vis[j] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(toLeft[j]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> match(toLeft[j], rightNum)){
</span></span><span style="display:flex;"><span>                toLeft[j] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hungarian</span>(<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> leftNum, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> rightNum){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//返回最大的边数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>leftNum;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>memset(vis,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(vis));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(match(i,rightNum)) cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> cnt;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m,e;<span style="color:#75715e">//左边点数，右边点数，边数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>e;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>e;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x,y;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>x<span style="color:#f92672">&gt;&gt;</span>y;
</span></span><span style="display:flex;"><span>        graph[x][y] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>hungarian(n,m)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="二分图的相关定理">二分图的相关定理</h3>
<p>Konig定理：一个二分图中的最大匹配数等于这个图中的最小点覆盖数。</p>
<p>最大独立集=点数-最小点覆盖。</p>
<h3 id="最大匹配转换为网络流模型">最大匹配转换为网络流模型</h3>
<p>将源点连上左边所有点，右边所有点连上汇点，容量都为1。原来的每条边从左往右连边（转成了有向有容量图），容量也为1，最大流即最大匹配。用Dinic算法求复杂度为<span class="math inline">\(O(\sqrt nm)\)</span></p>
<h3 id="二分图最大权完美匹配km算法-todo-bfs版">二分图最大权完美匹配（KM算法） TODO: BFS版</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//luogu p6577
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//二分图的最大权匹配，必须是完美匹配才能正确运行，即左右各n个点，最大匹配有n条边。虽然KM算法必须是完美匹配才可以运行而转化为费用流则不需要，但是KM算法在稠密图上的效率会高于费用流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//随机数据O(n^3)，最坏O(n^4)，所以luogu p6577上会超时一些数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//这主要是他卡dfs版的，bfs版的可以通过。但luogu p3967不卡dfs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//最大权匹配指二分图中边权和最大的匹配，最大权匹配不一定是最大匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//如果要跑多次KM算法记得把toLeft数组初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> LL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">505</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> LL INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e17</span>;
</span></span><span style="display:flex;"><span>LL graph[MAXN][MAXN];
</span></span><span style="display:flex;"><span>LL labelL[MAXN], labelR[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> visL[MAXN],visR[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> toLeft[MAXN];
</span></span><span style="display:flex;"><span>LL upd[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">match</span>(<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> i, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> pointNum){
</span></span><span style="display:flex;"><span>    visL[i] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>pointNum;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>visR[j]){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(labelL[i]<span style="color:#f92672">+</span>labelR[j]<span style="color:#f92672">-</span>graph[i][j]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>                visR[j] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>toLeft[j]<span style="color:#f92672">||</span>match(toLeft[j],pointNum)){
</span></span><span style="display:flex;"><span>                    toLeft[j] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>                upd[j] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(upd[j],labelL[i]<span style="color:#f92672">+</span>labelR[j]<span style="color:#f92672">-</span>graph[i][j]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">KM</span>(<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> pointNum){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>pointNum;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        labelL[i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>INF;
</span></span><span style="display:flex;"><span>        labelR[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>pointNum;j<span style="color:#f92672">++</span>) labelL[i] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(labelL[i], graph[i][j]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>pointNum;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>memset(visL,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(visL));
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>memset(visR,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(visR));
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>pointNum;j<span style="color:#f92672">++</span>) upd[j] <span style="color:#f92672">=</span> INF;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(match(i,pointNum)) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            LL delta <span style="color:#f92672">=</span> INF;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>pointNum;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>visR[j]) delta <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(delta,upd[j]);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>pointNum;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(visL[j]) labelL[j] <span style="color:#f92672">-=</span> delta;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(visR[j]) labelR[j] <span style="color:#f92672">+=</span> delta;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    LL ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>pointNum;i<span style="color:#f92672">++</span>) ans <span style="color:#f92672">+=</span> graph[toLeft[i]][i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans;<span style="color:#75715e">//输出最大权匹配的权值和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,e;<span style="color:#75715e">//一边的点数；边数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>e;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>n;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            graph[i][j] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>INF;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>e;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x,y;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>x<span style="color:#f92672">&gt;&gt;</span>y;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>graph[x][y];<span style="color:#75715e">//这里是左边有n个点，右边有n个点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//左边第x个点到右边第y个点的边权，并不是双向边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>KM(n)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>toLeft[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="最大权匹配转化为费用流">最大权匹配转化为费用流</h3>
<p>新增一个源点和一个汇点，从源点向二分图的每个左部点连一条流量为1，费用为0的边；从每个右部点向汇点连一条流量为1，费用为0的边；从左部点i向右部点j连一条流量为1，费用为c的边。然后这些边的反向边也要注意连上。然后求这个网络的最大费用最大流即可。</p>
<p>具体而言，最大费用的求法最好不要去该内部算法实现。把费用取相反数，然后最后答案再取相反数即可。</p>
<p>如果要输出方案，就遍历右边点到左边点的反向边，如果实际流量w变为1了，则说明走了这条边，也就是这两个点配对。</p>
<p>目前为止还只能处理完美匹配的情况。因为最大费用最大流是在最大流的前提下采取计算最大费用，也就是说它会去计算最大匹配再去计算其中的最大权。而最大权匹配是只要求权最大而不用一定是最大匹配。</p>
<p>解决方法是把左部点连一条边到汇点，容量为1，费用为0，再去求最大费用最大流。这样如果这条边有实际流量通过（即w变成0），他是失配的。</p>
<h2 id="动态维护二分图判定-todo-例题">动态维护二分图判定 TODO: 例题</h2>
<p>只判定一次可以用涂色法。动态加边可以用扩展域并查集（可撤销）来实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>stack<span style="color:#f92672">&lt;</span>pii<span style="color:#f92672">&gt;</span> stk;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DSU</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fa[MAXN<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>], rk[MAXN<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) fa[i] <span style="color:#f92672">=</span> i, rk[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> fa[x]<span style="color:#f92672">==</span>x <span style="color:#f92672">?</span> x : find(fa[x]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y){
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> find(x), y <span style="color:#f92672">=</span> find(y);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(x<span style="color:#f92672">==</span>y) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(rk[x]<span style="color:#f92672">&gt;</span>rk[y]) std<span style="color:#f92672">::</span>swap(x,y);
</span></span><span style="display:flex;"><span>        fa[x] <span style="color:#f92672">=</span> y;
</span></span><span style="display:flex;"><span>        stk.push({x,rk[x]<span style="color:#f92672">==</span>rk[y]});<span style="color:#75715e">//保存操作记录，也可以用stack以外的数据结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(rk[x]<span style="color:#f92672">==</span>rk[y]) rk[y]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">erase</span>(pii p){
</span></span><span style="display:flex;"><span>        rk[find(p.first)]<span style="color:#f92672">-=</span>p.second;
</span></span><span style="display:flex;"><span>        fa[p.first] <span style="color:#f92672">=</span> p.first;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//设总共n个点，每次添加一条边&lt;x,y&gt;，注意没有边也算二分图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    dsu.merge(x,y<span style="color:#f92672">+</span>n);
</span></span><span style="display:flex;"><span>    dsu.merge(y,x<span style="color:#f92672">+</span>n);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(dsu.find(x)<span style="color:#f92672">==</span>dsu.find(x<span style="color:#f92672">+</span>n) <span style="color:#f92672">||</span> dsu.find(y)<span style="color:#f92672">==</span>dsu.find(y<span style="color:#f92672">+</span>n)){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//说明不是二分图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//说明是二分图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//删边的时候，需要注意用一个pii删（调用erase函数），first保存了&lt;x,y&gt;这条边的x（y可以用find函数找出来），second保存了秩的数据，在删边时有用。至于删完是不是二分图，我没有找到办法。我做过的题目都是，添加了这条边后不再是二分图，输出某个结果，然后撤销这条边（之后显然是二分图）。要不就是只有加边的。直接删去任意一条边的题目并没有遇到过。
</span></span></span></code></pre></div><h2 id="网络流">网络流</h2>
<h3 id="最大流">最大流</h3>
<h4 id="dfs实现的ford-fulkerson">DFS实现的Ford-Fulkerson</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//luogu 3376
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//复杂度O(ef)，边数乘以最大流，所以在luogu上这题超时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> LL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">205</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> LL INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffff</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v;LL w;<span style="color:#75715e">//指向的点，容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Edge(<span style="color:#66d9ef">int</span> v_, LL w_)<span style="color:#f92672">:</span>v(v_),w(w_){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> edges;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> graph(MAXN);<span style="color:#75715e">//vector版的链式前向星
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> vis[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> p, LL <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> flow, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> t){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">==</span>t) <span style="color:#66d9ef">return</span> flow;
</span></span><span style="display:flex;"><span>    vis[p] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> graph[p].size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> ; i<span style="color:#f92672">&lt;</span>size ; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> eg <span style="color:#f92672">=</span> graph[p][i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edges[eg].v;
</span></span><span style="display:flex;"><span>        LL vol <span style="color:#f92672">=</span> edges[eg].w, c;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(vol<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>vis[to] <span style="color:#f92672">&amp;&amp;</span> (c<span style="color:#f92672">=</span>DFS(to,std<span style="color:#f92672">::</span>min(flow,vol),s,t))<span style="color:#f92672">!=-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>            edges[eg].w <span style="color:#f92672">-=</span> c;
</span></span><span style="display:flex;"><span>            edges[eg<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>].w <span style="color:#f92672">+=</span> c;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> c;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">FF</span>(<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> p, LL <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> flow, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> t){
</span></span><span style="display:flex;"><span>    LL ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, c;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>((c<span style="color:#f92672">=</span>DFS(p,flow,s,t))<span style="color:#f92672">!=-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>memset(vis,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(vis));
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">+=</span> c;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m,s,t;<span style="color:#75715e">//点数，边数，源点，汇点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>s<span style="color:#f92672">&gt;&gt;</span>t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u,v;LL w;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w;<span style="color:#75715e">//起点，终点，边容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        graph[u].push_back(edges.size());
</span></span><span style="display:flex;"><span>        edges.push_back(Edge(v,w));
</span></span><span style="display:flex;"><span>        graph[v].push_back(edges.size());
</span></span><span style="display:flex;"><span>        edges.push_back(Edge(u,<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>FF(s,INF,s,t)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;<span style="color:#75715e">//输出最大流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="edmondskarp">EdmondsKarp</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//luogu P3376
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//EK算法的时间复杂度为O(nm^2)，这题不会超时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> LL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">205</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> LL INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffff</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v;LL w;<span style="color:#75715e">//指向的点，容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Edge(<span style="color:#66d9ef">int</span> v_, LL w_)<span style="color:#f92672">:</span>v(v_),w(w_){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> edges;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> graph(MAXN);<span style="color:#75715e">//vector版的链式前向星
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> last[MAXN];
</span></span><span style="display:flex;"><span>LL flow[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">BFS</span>(<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> t){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>memset(last,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">sizeof</span>(last));
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> qu;
</span></span><span style="display:flex;"><span>    qu.push(s);
</span></span><span style="display:flex;"><span>    flow[s] <span style="color:#f92672">=</span> INF;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>qu.empty()){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> qu.front();
</span></span><span style="display:flex;"><span>        qu.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p <span style="color:#f92672">==</span> t) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> graph[p].size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>size;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> eg <span style="color:#f92672">=</span> graph[p][i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edges[eg].v;
</span></span><span style="display:flex;"><span>            LL vol <span style="color:#f92672">=</span> edges[eg].w;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(vol<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> last[to] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>                last[to] <span style="color:#f92672">=</span> eg;
</span></span><span style="display:flex;"><span>                flow[to] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(flow[p], vol);
</span></span><span style="display:flex;"><span>                qu.push(to);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> last[t] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">EK</span>(<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> t){
</span></span><span style="display:flex;"><span>    LL ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(BFS(s,t)){
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">+=</span> flow[t];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>t;i<span style="color:#f92672">!=</span>s;i<span style="color:#f92672">=</span>edges[last[i]<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>].v){
</span></span><span style="display:flex;"><span>            edges[last[i]].w <span style="color:#f92672">-=</span> flow[t];
</span></span><span style="display:flex;"><span>            edges[last[i]<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>].w <span style="color:#f92672">+=</span> flow[t];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m,s,t;<span style="color:#75715e">//点数，边数，源点，汇点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>s<span style="color:#f92672">&gt;&gt;</span>t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u,v;LL w;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w;
</span></span><span style="display:flex;"><span>        graph[u].push_back(edges.size());
</span></span><span style="display:flex;"><span>        edges.push_back(Edge(v,w));
</span></span><span style="display:flex;"><span>        graph[v].push_back(edges.size());
</span></span><span style="display:flex;"><span>        edges.push_back(Edge(u,<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>EK(s,t)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="dinic-todo-如果可能换成链式前向星">Dinic TODO: 如果可能换成链式前向星</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//luogu P3376
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Dinic算法的时间复杂度为O(n^2m)，这题不会超时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> LL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">205</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> LL INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffff</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v;LL w;<span style="color:#75715e">//指向的点，容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Edge(<span style="color:#66d9ef">int</span> v_, LL w_)<span style="color:#f92672">:</span>v(v_),w(w_){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> edges;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> graph(MAXN);<span style="color:#75715e">//vector版的链式前向星
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> cur(MAXN);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> level[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">BFS</span>(<span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> t){<span style="color:#75715e">//BFS分层
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>memset(level, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span>(level));
</span></span><span style="display:flex;"><span>    level[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    cur.assign(MAXN,<span style="color:#ae81ff">0</span>);<span style="color:#75715e">//初始化当前弧
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> qu;
</span></span><span style="display:flex;"><span>    qu.push(s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>qu.empty()){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> qu.front();
</span></span><span style="display:flex;"><span>        qu.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> graph[p].size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>size;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> eg <span style="color:#f92672">=</span> graph[p][i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edges[eg].v;
</span></span><span style="display:flex;"><span>            LL vol <span style="color:#f92672">=</span> edges[eg].w;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(vol<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> level[to] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>                level[to] <span style="color:#f92672">=</span> level[p] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                qu.push(to);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> level[t] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> p, LL <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> flow, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> t){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">==</span>t) <span style="color:#66d9ef">return</span> flow;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    LL surplus <span style="color:#f92672">=</span> flow;<span style="color:#75715e">//剩余流量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> graph[p].size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>cur[p];i<span style="color:#f92672">&lt;</span>size <span style="color:#f92672">&amp;&amp;</span> surplus;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> eg <span style="color:#f92672">=</span> graph[p][i];
</span></span><span style="display:flex;"><span>        cur[p] <span style="color:#f92672">=</span> i;<span style="color:#75715e">//更新当前弧
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edges[eg].v;
</span></span><span style="display:flex;"><span>        LL vol <span style="color:#f92672">=</span> edges[eg].w;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(vol<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> level[to]<span style="color:#f92672">==</span>level[p]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>            LL c <span style="color:#f92672">=</span> DFS(to, std<span style="color:#f92672">::</span>min(vol, surplus), s, t);
</span></span><span style="display:flex;"><span>            surplus <span style="color:#f92672">-=</span> c;
</span></span><span style="display:flex;"><span>            edges[eg].w <span style="color:#f92672">-=</span> c;
</span></span><span style="display:flex;"><span>            edges[eg<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>].w <span style="color:#f92672">+=</span> c;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> flow <span style="color:#f92672">-</span> surplus;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">Dinic</span>(<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> p, LL <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> flow, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> t){
</span></span><span style="display:flex;"><span>    LL ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(BFS(s,t)){
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">+=</span> DFS(p,flow,s,t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m,s,t;<span style="color:#75715e">//点数，边数，源点，汇点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>s<span style="color:#f92672">&gt;&gt;</span>t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u,v;LL w;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w;
</span></span><span style="display:flex;"><span>        graph[u].push_back(edges.size());
</span></span><span style="display:flex;"><span>        edges.push_back(Edge(v,w));
</span></span><span style="display:flex;"><span>        graph[v].push_back(edges.size());
</span></span><span style="display:flex;"><span>        edges.push_back(Edge(u,<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>Dinic(s,INF,s,t)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="isap算法-todo">ISAP算法 TODO</h3>
<h3 id="最大流最小割定理">最大流最小割定理</h3>
<p>网络流的最大流等于其所有割的最小容量。</p>
<p>割：从网络中选择一些边，去掉这些边后，剩下恰好两个互相不连通的分别包含源点和汇点的点集（当然其他边不去掉）。去掉的这些边就是一个割。</p>
<p>割的大小就是去掉的这些边的容量之和。</p>
<h3 id="最小费用最大流">最小费用最大流</h3>
<p>即在使流最大的前提下，最小化费用。费用是一条边的属性，一条边的总费用等于它的单位费用<span class="math inline">\(\times\)</span>流过的流量。</p>
<p>建边的时候，反向边的容量为0，费用为相反数。</p>
<h4 id="ekspfa">EK+SPFA</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//luogu P3381
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//EK+SPFA的实现，复杂度为O(nmf)，即点数、边数、最大流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> LL;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>LL,LL<span style="color:#f92672">&gt;</span> pll;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">5005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> LL INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffff</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v;LL w;LL c;<span style="color:#75715e">//指向的点，容量，费用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Edge(<span style="color:#66d9ef">int</span> v_, LL w_, LL c_)<span style="color:#f92672">:</span>v(v_),w(w_),c(c_){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> edges;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> graph(MAXN);<span style="color:#75715e">//vector版的链式前向星
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> last[MAXN];
</span></span><span style="display:flex;"><span>LL flow[MAXN];
</span></span><span style="display:flex;"><span>LL dis[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> inq[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">SPFA</span>(<span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> t){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> qu;
</span></span><span style="display:flex;"><span>    qu.push(s);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>memset(last,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">sizeof</span>(last));
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>memset(dis,<span style="color:#ae81ff">127</span>,<span style="color:#66d9ef">sizeof</span>(dis));
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>memset(inq,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(inq));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    flow[s] <span style="color:#f92672">=</span> INF;
</span></span><span style="display:flex;"><span>    dis[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    inq[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>qu.empty()){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> qu.front();
</span></span><span style="display:flex;"><span>        qu.pop();
</span></span><span style="display:flex;"><span>        inq[p] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> graph[p].size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>size;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> eg <span style="color:#f92672">=</span> graph[p][i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edges[eg].v;
</span></span><span style="display:flex;"><span>            LL vol <span style="color:#f92672">=</span> edges[eg].w;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(vol<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> dis[to]<span style="color:#f92672">&gt;</span>dis[p]<span style="color:#f92672">+</span>edges[eg].c){
</span></span><span style="display:flex;"><span>                last[to] <span style="color:#f92672">=</span> eg;
</span></span><span style="display:flex;"><span>                flow[to] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(flow[p], vol);
</span></span><span style="display:flex;"><span>                dis[to] <span style="color:#f92672">=</span> dis[p]<span style="color:#f92672">+</span>edges[eg].c;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>inq[to]){
</span></span><span style="display:flex;"><span>                    qu.push(to);
</span></span><span style="display:flex;"><span>                    inq[to] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> last[t] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pll <span style="color:#a6e22e">MCMF</span>(<span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> t){
</span></span><span style="display:flex;"><span>    LL maxflow <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, mincost <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(SPFA(s,t)){
</span></span><span style="display:flex;"><span>        maxflow <span style="color:#f92672">+=</span> flow[t];
</span></span><span style="display:flex;"><span>        mincost <span style="color:#f92672">+=</span> dis[t] <span style="color:#f92672">*</span> flow[t];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>t;i<span style="color:#f92672">!=</span>s;i<span style="color:#f92672">=</span>edges[last[i]<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>].v){
</span></span><span style="display:flex;"><span>            edges[last[i]].w <span style="color:#f92672">-=</span> flow[t];
</span></span><span style="display:flex;"><span>            edges[last[i]<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>].w <span style="color:#f92672">+=</span> flow[t];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {maxflow,mincost};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m,s,t;<span style="color:#75715e">//点数，边数，源点，汇点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>s<span style="color:#f92672">&gt;&gt;</span>t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u,v;LL w,c;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w<span style="color:#f92672">&gt;&gt;</span>c;
</span></span><span style="display:flex;"><span>        graph[u].push_back(edges.size());
</span></span><span style="display:flex;"><span>        edges.push_back(Edge(v,w,c));
</span></span><span style="display:flex;"><span>        graph[v].push_back(edges.size());
</span></span><span style="display:flex;"><span>        edges.push_back(Edge(u,<span style="color:#ae81ff">0</span>,<span style="color:#f92672">-</span>c));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pll ans <span style="color:#f92672">=</span> MCMF(s,t);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans.first<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">&lt;&lt;</span>ans.second<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="dinicspfa">Dinic+SPFA</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//luogu P3381
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Dinic+SPFA的实现，复杂度为O(nmf)，即点数、边数、最大流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> LL;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span>LL,LL<span style="color:#f92672">&gt;</span> pll;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">5005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> LL INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xffffffff</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v;LL w,c;<span style="color:#75715e">//指向的点，容量，费用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Edge(<span style="color:#66d9ef">int</span> v_, LL w_, LL c_)<span style="color:#f92672">:</span>v(v_),w(w_),c(c_){}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Edge<span style="color:#f92672">&gt;</span> edges;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> graph(MAXN);<span style="color:#75715e">//vector版的链式前向星
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> cur(MAXN);
</span></span><span style="display:flex;"><span>LL dis[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> inq[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">SPFA</span>(<span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> t){<span style="color:#75715e">//BFS分层
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>fill(dis,dis<span style="color:#f92672">+</span>MAXN,INF);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>memset(inq, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(inq));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    dis[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    inq[s] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    cur.assign(MAXN,<span style="color:#ae81ff">0</span>);<span style="color:#75715e">//初始化当前弧
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> qu;
</span></span><span style="display:flex;"><span>    qu.push(s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>qu.empty()){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> qu.front();
</span></span><span style="display:flex;"><span>        qu.pop();
</span></span><span style="display:flex;"><span>        inq[p] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> graph[p].size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>size;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> eg <span style="color:#f92672">=</span> graph[p][i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edges[eg].v;
</span></span><span style="display:flex;"><span>            LL vol <span style="color:#f92672">=</span> edges[eg].w;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(vol<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> dis[to] <span style="color:#f92672">&gt;</span> dis[p]<span style="color:#f92672">+</span>edges[eg].c){
</span></span><span style="display:flex;"><span>                dis[to] <span style="color:#f92672">=</span> dis[p]<span style="color:#f92672">+</span>edges[eg].c;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>inq[to]){
</span></span><span style="display:flex;"><span>                    qu.push(to);
</span></span><span style="display:flex;"><span>                    inq[to] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> dis[t] <span style="color:#f92672">!=</span> INF;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> p, LL <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> flow, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> t){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">==</span>t) <span style="color:#66d9ef">return</span> flow;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    LL surplus <span style="color:#f92672">=</span> flow;<span style="color:#75715e">//剩余流量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    inq[p] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//由于在SPFA中都会清零，可以复用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> graph[p].size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>cur[p];i<span style="color:#f92672">&lt;</span>size <span style="color:#f92672">&amp;&amp;</span> surplus;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> eg <span style="color:#f92672">=</span> graph[p][i];
</span></span><span style="display:flex;"><span>        cur[p] <span style="color:#f92672">=</span> i;<span style="color:#75715e">//更新当前弧
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> to <span style="color:#f92672">=</span> edges[eg].v;
</span></span><span style="display:flex;"><span>        LL vol <span style="color:#f92672">=</span> edges[eg].w;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>inq[to] <span style="color:#f92672">&amp;&amp;</span> vol<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> dis[to]<span style="color:#f92672">==</span>dis[p]<span style="color:#f92672">+</span>edges[eg].c){
</span></span><span style="display:flex;"><span>            LL cx <span style="color:#f92672">=</span> DFS(to, std<span style="color:#f92672">::</span>min(vol, surplus), s, t);
</span></span><span style="display:flex;"><span>            surplus <span style="color:#f92672">-=</span> cx;
</span></span><span style="display:flex;"><span>            edges[eg].w <span style="color:#f92672">-=</span> cx;
</span></span><span style="display:flex;"><span>            edges[eg<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>].w <span style="color:#f92672">+=</span> cx;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    inq[p] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> flow <span style="color:#f92672">-</span> surplus;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pll <span style="color:#a6e22e">MCMF</span>(<span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> p, LL <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> flow, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> t){
</span></span><span style="display:flex;"><span>    LL maxflow <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, mincost <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(SPFA(s,t)){
</span></span><span style="display:flex;"><span>        LL ret <span style="color:#f92672">=</span> DFS(p,flow,s,t);
</span></span><span style="display:flex;"><span>        maxflow <span style="color:#f92672">+=</span> ret;
</span></span><span style="display:flex;"><span>        mincost <span style="color:#f92672">+=</span> ret <span style="color:#f92672">*</span> dis[t];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> {maxflow,mincost};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m,s,t;<span style="color:#75715e">//点数，边数，源点，汇点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>s<span style="color:#f92672">&gt;&gt;</span>t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u,v;LL w,c;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w<span style="color:#f92672">&gt;&gt;</span>c;
</span></span><span style="display:flex;"><span>        graph[u].push_back(edges.size());
</span></span><span style="display:flex;"><span>        edges.push_back(Edge(v,w,c));
</span></span><span style="display:flex;"><span>        graph[v].push_back(edges.size());
</span></span><span style="display:flex;"><span>        edges.push_back(Edge(u,<span style="color:#ae81ff">0</span>,<span style="color:#f92672">-</span>c));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    pll ans <span style="color:#f92672">=</span> MCMF(s,INF,s,t);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans.first<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">&lt;&lt;</span>ans.second<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="上下界流">上下界流</h3>
<h4 id="无源汇上下界可行流">无源汇上下界可行流</h4>
<p>给定一个没有源点和汇点的网络，每条边的容量都有一个上界和下界，问是否有一个可行流使得流量平衡（即每个点的流入等于流出）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//loj 115
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//前面的Dinic算法省略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL in[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n, m, s, t; <span style="color:#75715e">//点数，边数，源点，汇点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m;
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">=</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//虚拟源点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    t <span style="color:#f92672">=</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;<span style="color:#75715e">//虚拟汇点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>LL<span style="color:#f92672">&gt;</span> ans;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> m; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u, v;
</span></span><span style="display:flex;"><span>        LL w1, w2;<span style="color:#75715e">//下界，上界
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v <span style="color:#f92672">&gt;&gt;</span> w1 <span style="color:#f92672">&gt;&gt;</span> w2;
</span></span><span style="display:flex;"><span>        ans.push_back(w1);
</span></span><span style="display:flex;"><span>        graph[u].push_back(edges.size());
</span></span><span style="display:flex;"><span>        edges.push_back(Edge(v, w2 <span style="color:#f92672">-</span> w1));<span style="color:#75715e">//只用建立差网络即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        graph[v].push_back(edges.size());
</span></span><span style="display:flex;"><span>        edges.push_back(Edge(u, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        in[u] <span style="color:#f92672">-=</span> w1;
</span></span><span style="display:flex;"><span>        in[v] <span style="color:#f92672">+=</span> w1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (in[i] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {<span style="color:#75715e">//在下界网络中，有净流入的节点，要从源点连一条边，大小等于净流入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            graph[s].push_back(edges.size());
</span></span><span style="display:flex;"><span>            edges.push_back(Edge(i, in[i]));
</span></span><span style="display:flex;"><span>            graph[i].push_back(edges.size());
</span></span><span style="display:flex;"><span>            edges.push_back(Edge(s, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {<span style="color:#75715e">//有净流出的节点，要向汇点连一条边，大小等于净流出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            graph[i].push_back(edges.size());
</span></span><span style="display:flex;"><span>            edges.push_back(Edge(t, <span style="color:#f92672">-</span>in[i]));
</span></span><span style="display:flex;"><span>            graph[t].push_back(edges.size());
</span></span><span style="display:flex;"><span>            edges.push_back(Edge(i, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Dinic(s, INF, s, t);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> x : graph[s]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (edges[x].w <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果源点的附加边没有满流，说明不存在可行流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//也可以换成判断汇点没有满流，二者等价
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;NO</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;YES</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> m; i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//反向边就是这条边的流量，再加之前输入的下界得到每条边的流量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ans[i <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">+=</span> edges[i].w;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> x : ans) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="有源汇上下界可行流">有源汇上下界可行流</h4>
<p>比起无源汇的情况，我们可以把图中的汇点向源点连一条下界0，上界无限大的边。然后就变成无源汇图了。处理的时候，新建附加源点汇点<span class="math inline">\(S',T'\)</span>，原来的<span class="math inline">\(S,T\)</span>就变成了普通点，思路一致。</p>
<p>若有解，则<span class="math inline">\(S\)</span>到<span class="math inline">\(T\)</span>的可行流流量等于<span class="math inline">\(T\)</span>到<span class="math inline">\(S\)</span>的附加边的流量。</p>
<h4 id="有源汇上下界最大流">有源汇上下界最大流</h4>
<p>在有源汇上下界可行流有解的时候，<span class="math inline">\(S\)</span>到<span class="math inline">\(T\)</span>的可行流量就是<span class="math inline">\(T\)</span>到<span class="math inline">\(S\)</span>的附加边的流量。然后我们删去所有添加的附加边，包括<span class="math inline">\(S',T'\)</span>连的以及<span class="math inline">\(T-S\)</span>附加边，再在跑完的网络上再跑一次Dinic，得到的流加上可行流就是最后的答案。</p>
<p>具体实践上，我们不需要真的把边删了，<span class="math inline">\(S',T'\)</span>所连的边根本不会影响结果，可以不用管，至于<span class="math inline">\(T-S\)</span>这条边，我们获取了流量之后，直接把正向、反向边置零即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//loj 116
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//前面的Dinic算法省略
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL in[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n, m, s, t; <span style="color:#75715e">//点数，边数，源点，汇点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> n <span style="color:#f92672">&gt;&gt;</span> m <span style="color:#f92672">&gt;&gt;</span> s <span style="color:#f92672">&gt;&gt;</span> t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> m; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u, v;
</span></span><span style="display:flex;"><span>        LL w1, w2;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> u <span style="color:#f92672">&gt;&gt;</span> v <span style="color:#f92672">&gt;&gt;</span> w1 <span style="color:#f92672">&gt;&gt;</span> w2;
</span></span><span style="display:flex;"><span>        graph[u].push_back(edges.size());
</span></span><span style="display:flex;"><span>        edges.push_back(Edge(v, w2 <span style="color:#f92672">-</span> w1));
</span></span><span style="display:flex;"><span>        graph[v].push_back(edges.size());
</span></span><span style="display:flex;"><span>        edges.push_back(Edge(u, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        in[u] <span style="color:#f92672">-=</span> w1;
</span></span><span style="display:flex;"><span>        in[v] <span style="color:#f92672">+=</span> w1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    graph[t].push_back(edges.size());
</span></span><span style="display:flex;"><span>    edges.push_back(Edge(s, INF <span style="color:#f92672">*</span> <span style="color:#ae81ff">4ll</span>));
</span></span><span style="display:flex;"><span>    graph[s].push_back(edges.size());
</span></span><span style="display:flex;"><span>    edges.push_back(Edge(t, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//T-S的边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> s2 <span style="color:#f92672">=</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, t2 <span style="color:#f92672">=</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (in[i] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            graph[s2].push_back(edges.size());
</span></span><span style="display:flex;"><span>            edges.push_back(Edge(i, in[i]));
</span></span><span style="display:flex;"><span>            graph[i].push_back(edges.size());
</span></span><span style="display:flex;"><span>            edges.push_back(Edge(s2, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            graph[i].push_back(edges.size());
</span></span><span style="display:flex;"><span>            edges.push_back(Edge(t2, <span style="color:#f92672">-</span>in[i]));
</span></span><span style="display:flex;"><span>            graph[t2].push_back(edges.size());
</span></span><span style="display:flex;"><span>            edges.push_back(Edge(i, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Dinic(s2, INF, s2, t2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> x : graph[s2]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (edges[x].w <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;please go home to sleep</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    LL flow <span style="color:#f92672">=</span> edges[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> m <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>].w;
</span></span><span style="display:flex;"><span>    edges[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> m].w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, edges[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> m <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>].w <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> Dinic(s, INF, s, t) <span style="color:#f92672">+</span> flow <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="有源汇上下界最小流">有源汇上下界最小流</h4>
<p>和上面几乎一模一样，只需在拆掉附加边后，从汇点到源点跑一次Dinic，然后flow删去这个结果就得到最小流。Loj 117。</p>
<h2 id="割边tarjan算法">割边（Tarjan算法）</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 n+m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//tarjan求割边，可以正确处理重边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//如果无向图中删掉某条边会使无向图的连通分量数增多，那么这条边叫割边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p1656
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">20005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXM <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dfn[MAXN], low[MAXN], cnt<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//dfn为对一个图进行dfs时，dfs的顺序序号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//low[x]为以下所有符合要求的节点的dfn中的最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//1.以x为根的子树的所有节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//2.通过非dfs生成树上的边能够到达该子树的所有节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v,next;<span style="color:#75715e">//指向的点，边权，下一条边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Edge edges[MAXM<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>];<span style="color:#75715e">//存无向图记得开两倍
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> head[MAXN],ecnt<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//注意这个ecnt=1，这是用来方便in_edge判断的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> bridges[MAXM<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>];<span style="color:#75715e">//判断一条边是不是割边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> v){
</span></span><span style="display:flex;"><span>    edges[<span style="color:#f92672">++</span>ecnt].v <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>    edges[ecnt].next <span style="color:#f92672">=</span> head[u];
</span></span><span style="display:flex;"><span>    head[u] <span style="color:#f92672">=</span> ecnt;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tarjan</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> in_edge){
</span></span><span style="display:flex;"><span>    low[u] <span style="color:#f92672">=</span> dfn[u] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>cnt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>head[u];i;i<span style="color:#f92672">=</span>edges[i].next){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> edges[i].v;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>dfn[v]){
</span></span><span style="display:flex;"><span>            tarjan(v,i);
</span></span><span style="display:flex;"><span>            low[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(low[u],low[v]);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(low[v]<span style="color:#f92672">&gt;</span>dfn[u])<span style="color:#75715e">//边u-v是割边的充要条件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                bridges[i] <span style="color:#f92672">=</span> bridges[i<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> true;          
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">!=</span> (in_edge <span style="color:#f92672">^</span> <span style="color:#ae81ff">1</span>)){
</span></span><span style="display:flex;"><span>            low[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(low[u], dfn[v]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//点数，边数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>b;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//起点，终点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        add(a,b);
</span></span><span style="display:flex;"><span>        add(b,a);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//无向图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>dfn[i])
</span></span><span style="display:flex;"><span>            tarjan(i,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> ans;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&lt;</span>ecnt;i<span style="color:#f92672">+=</span><span style="color:#ae81ff">2</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(bridges[i]){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> edges[i].v;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> edges[i<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>].v;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(u<span style="color:#f92672">&gt;</span>v) std<span style="color:#f92672">::</span>swap(u,v);
</span></span><span style="display:flex;"><span>            ans.push_back({u,v});
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(ans.begin(),ans.end());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> x:ans) std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>x.first<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">&lt;&lt;</span>x.second<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="割点tarjan算法">割点（Tarjan算法）</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 n+m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//tarjan求割点,luogu P3388
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//如果无向图中删掉某个点和其所有相连的边边会使无向图的连通分量数增多，那么这个点叫割点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">20005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXM <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dfn[MAXN], low[MAXN], cnt<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//含义见割边模板
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v,next;<span style="color:#75715e">//指向的点，边权，下一条边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Edge edges[MAXM<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>];<span style="color:#75715e">//存无向图记得开两倍
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> head[MAXN],ecnt;<span style="color:#75715e">//这个ecnt和割边那里不一样，但也可以等于1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> cut[MAXN];<span style="color:#75715e">//判断割点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> v){
</span></span><span style="display:flex;"><span>    edges[<span style="color:#f92672">++</span>ecnt].v <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>    edges[ecnt].next <span style="color:#f92672">=</span> head[u];
</span></span><span style="display:flex;"><span>    head[u] <span style="color:#f92672">=</span> ecnt;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tarjan</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> root){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tot <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    low[u] <span style="color:#f92672">=</span> dfn[u] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>cnt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>head[u];i;i<span style="color:#f92672">=</span>edges[i].next){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> edges[i].v;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>dfn[v]){
</span></span><span style="display:flex;"><span>            tarjan(v,root);
</span></span><span style="display:flex;"><span>            low[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(low[u],low[v]);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//一个点x是割点的充要条件是，它至少一个子节点y满足dfn[x]&lt;=low[y]，特别的，对于根节点，需要至少两个这样的子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(low[v]<span style="color:#f92672">&gt;=</span>dfn[u]){
</span></span><span style="display:flex;"><span>                tot<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(u<span style="color:#f92672">!=</span>root <span style="color:#f92672">||</span> tot<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>) cut[u] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            low[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(low[u], dfn[v]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//点数，边数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>b;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//起点，终点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        add(a,b);
</span></span><span style="display:flex;"><span>        add(b,a);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//无向图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>dfn[i])
</span></span><span style="display:flex;"><span>            tarjan(i,i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ans;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) <span style="color:#66d9ef">if</span>(cut[i]) ans.push_back(i);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(ans.begin(),ans.end());
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans.size()<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> x:ans) std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>x<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="强连通分量tarjan算法">强连通分量（Tarjan算法）</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//强连通分量，复杂度 n+m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P2863
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//一个有向图是强连通的当且仅当其中任意两个顶点相互可达
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//强连通分量是有向图中的极大的强连通子图。极大意味着把一个图分为若干个强连通分量，分量之间互相不可达。或者，不存在包含该子图的更大的子图也是强连通分量。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">10005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXM <span style="color:#f92672">=</span> <span style="color:#ae81ff">50005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dfn[MAXN], low[MAXN], instk[MAXN], scci[MAXN], cnt<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, cscc<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> edges[MAXN];
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stk;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> scc[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//dfn是dfs时的顺序的序号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//stk中存入两类点，访问到节点x时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//1.搜索树上x的祖先节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//2.已经访问过，并且存在一条路径到达x祖先的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//low[x]定义为满足以下两个条件的节点的最小dfn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//1.该点在stk中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//2.存在一条从subtree(x)出发的有向边，以该点为终点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//scci[x]代表，x这个结点在第几个分量中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//cscc代表有几个分量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//scc[j]中表示，第j个分量的所有节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tarjan</span>(<span style="color:#66d9ef">int</span> u){
</span></span><span style="display:flex;"><span>    low[u] <span style="color:#f92672">=</span> dfn[u] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>cnt;
</span></span><span style="display:flex;"><span>    instk[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    stk.push(u);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>edges[u].size();i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> edges[u][i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>dfn[v]){
</span></span><span style="display:flex;"><span>            tarjan(v);
</span></span><span style="display:flex;"><span>            low[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(low[u],low[v]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(instk[v]){
</span></span><span style="display:flex;"><span>            low[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(low[u], dfn[v]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(low[u]<span style="color:#f92672">==</span>dfn[u]){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> top;
</span></span><span style="display:flex;"><span>        cscc<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span>{
</span></span><span style="display:flex;"><span>            top <span style="color:#f92672">=</span> stk.top();
</span></span><span style="display:flex;"><span>            stk.pop();
</span></span><span style="display:flex;"><span>            instk[top] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            scci[top] <span style="color:#f92672">=</span> cscc;
</span></span><span style="display:flex;"><span>            scc[cscc].push_back(top);
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">while</span>(top<span style="color:#f92672">!=</span>u);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>b;
</span></span><span style="display:flex;"><span>        edges[a].push_back(b);<span style="color:#75715e">//有向边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>dfn[i]) tarjan(i);<span style="color:#75715e">//注意遍历所有dfn为零的点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>cscc;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(scc[i].size()<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>) ans<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="2-sat问题">2-SAT问题</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//2-SAT算法，复杂度n+m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P4782
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//2-SAT是用来解决一些条件是否能够满足的算法。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//每个条件都能转化为形如&#34;若x赋值为a，则y必须赋值为b&#34;的形式。其中a,b的取值只能有两个，通常是true和false。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//例如总共有m个这样的条件，我们要判断是否存在一种赋值情况满足所有的条件。如果有还要输出一种可行方案
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">2e6</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dfn[MAXN], low[MAXN], instk[MAXN], scci[MAXN], cnt<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, cscc<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> edges[MAXN];
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stk;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> scc[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//含义见强连通分量tarjan算法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> ans[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tarjan</span>(<span style="color:#66d9ef">int</span> u){
</span></span><span style="display:flex;"><span>    low[u] <span style="color:#f92672">=</span> dfn[u] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>cnt;
</span></span><span style="display:flex;"><span>    instk[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    stk.push(u);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>edges[u].size();i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> edges[u][i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>dfn[v]){
</span></span><span style="display:flex;"><span>            tarjan(v);
</span></span><span style="display:flex;"><span>            low[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(low[u],low[v]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(instk[v]){
</span></span><span style="display:flex;"><span>            low[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(low[u], dfn[v]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(low[u]<span style="color:#f92672">==</span>dfn[u]){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> top;
</span></span><span style="display:flex;"><span>        cscc<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span>{
</span></span><span style="display:flex;"><span>            top <span style="color:#f92672">=</span> stk.top();
</span></span><span style="display:flex;"><span>            stk.pop();
</span></span><span style="display:flex;"><span>            instk[top] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            scci[top] <span style="color:#f92672">=</span> cscc;
</span></span><span style="display:flex;"><span>            scc[cscc].push_back(top);
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">while</span>(top<span style="color:#f92672">!=</span>u);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//n个点，m个条件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(m<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i,j;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> a,b;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>i<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>j<span style="color:#f92672">&gt;&gt;</span>b;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//本题的条件为，i为a或（不是异或）j为b，其他题按情况处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//每个点x拆为两个点y和y+n,y代表x为0，y+n代表x为1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//每条边x-&gt;y代表着，如果x，那么一定有y
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//本题如“i为假或j为真”可以拆为两个条件，这个条件满足（为真）时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//i为真则j一定为真
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//j为假则i一定为假
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        edges[i<span style="color:#f92672">+</span>(<span style="color:#f92672">!</span>a)<span style="color:#f92672">*</span>n].push_back(j<span style="color:#f92672">+</span>b<span style="color:#f92672">*</span>n);
</span></span><span style="display:flex;"><span>        edges[j<span style="color:#f92672">+</span>(<span style="color:#f92672">!</span>b)<span style="color:#f92672">*</span>n].push_back(i<span style="color:#f92672">+</span>a<span style="color:#f92672">*</span>n);<span style="color:#75715e">//逆否命题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//逆否命题是一定要插入的，不能只插入原命题，但是本题拆出来的两个条件正好互为逆否命题，所以只插入了两条边。其他题并不一定总会给出逆否命题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//这里的逻辑运算可能有些不容易理解，怕错可以写成很长的if else判断a和b的具体取值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>dfn[i]) tarjan(i);<span style="color:#75715e">//注意遍历所有dfn为零的点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(scci[i]<span style="color:#f92672">==</span>scci[i<span style="color:#f92672">+</span>n]){<span style="color:#75715e">//如果i和i+n在一个强连通分量，则不可满足
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;IMPOSSIBLE</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(scci[i]<span style="color:#f92672">&gt;</span>scci[i<span style="color:#f92672">+</span>n])
</span></span><span style="display:flex;"><span>            ans[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            ans[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;POSSIBLE</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="边双联通分量">边双联通分量</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 n+m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//tarjan求边双联通分量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p8436
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//如果一张无向连通图不存在割边，则称之为边双联通图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//双连通分量是图的极大双联通子图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//若u-v边双联通，v-w边双联通，则u-w边双联通
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//一张图是边双联通，当且仅当每条边都在至少一个简单环中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//无向连通图中，对于任意两个点，如果无论删去哪条边（只能一条），都不能使它们不连通，则为边双联通
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//同时这也意味着，把割边删去后的图，就是若干个双联通分量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*这一段是求割边的核心代码，省略*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dcci[MAXN], cdcc;<span style="color:#75715e">//记录点i属于双联通分量dcci[i]，以及总的dcc个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> dcc(MAXN);<span style="color:#75715e">//存储双联通分量dcc[i]中有哪些点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">getDCC</span>(<span style="color:#66d9ef">int</span> u){
</span></span><span style="display:flex;"><span>    dcci[u] <span style="color:#f92672">=</span> cdcc;
</span></span><span style="display:flex;"><span>    dcc[cdcc].push_back(u);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>head[u];i;i<span style="color:#f92672">=</span>edges[i].next){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> edges[i].v;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(dcci[v] <span style="color:#f92672">||</span> bridges[i]) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        getDCC(v);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//点数，边数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>b;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//起点，终点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        add(a,b);
</span></span><span style="display:flex;"><span>        add(b,a);
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//无向图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>dfn[i])
</span></span><span style="display:flex;"><span>            tarjan(i,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//以上求完了割边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>dcci[i]){
</span></span><span style="display:flex;"><span>            cdcc<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            getDCC(i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>cdcc<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>cdcc;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>dcc[i].size()<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> x:dcc[i]){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>x<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="边双联通缩点todo">边双联通缩点TODO</h2>
<h2 id="点双联通分量">点双联通分量</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 n+m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//tarjan求点双联通分量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p8435
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//如果一张无向连通图不存在割点，则称之为点双联通图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//双连通分量是图的极大双联通子图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//极大指的是，不存在包含这个子图的更大的子图也是边双联通图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//若u-v点双联通，v-w点双联通，则u-w[并不一定]点双联通
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//一张图是点双联通，当且仅当以下两个条件之一成立
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//1. 图的顶点数不超过2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//2. 图中任意两点都同时包含在至少一个简单环中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//无向连通图中，对于任意两个点，如果无论删去哪个点（只能一个，且不能删除这两个点自己），都不能使它们不连通，则为点双联通
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//但是，虽然边双联通中的割边不属于任何连通分量，但割点却可以属于多个点双联通分量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">500005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXM <span style="color:#f92672">=</span> <span style="color:#ae81ff">2000005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dfn[MAXN], low[MAXN], cnt<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">//含义见割边模板
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v,next;<span style="color:#75715e">//指向的点，边权，下一条边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Edge edges[MAXM<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>];<span style="color:#75715e">//存无向图记得开两倍
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> head[MAXN],ecnt;<span style="color:#75715e">//这个ecnt和割边那里不一样，但也可以等于1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> cut[MAXN];<span style="color:#75715e">//判断割点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> v){
</span></span><span style="display:flex;"><span>    edges[<span style="color:#f92672">++</span>ecnt].v <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>    edges[ecnt].next <span style="color:#f92672">=</span> head[u];
</span></span><span style="display:flex;"><span>    head[u] <span style="color:#f92672">=</span> ecnt;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stk;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> cdcc;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> dcc(MAXN);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tarjan</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> root){
</span></span><span style="display:flex;"><span>    low[u] <span style="color:#f92672">=</span> dfn[u] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>cnt;
</span></span><span style="display:flex;"><span>    stk.push(u);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(u<span style="color:#f92672">==</span>root <span style="color:#f92672">&amp;&amp;</span> head[u]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        dcc[<span style="color:#f92672">++</span>cdcc].push_back(u);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tot<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>head[u];i;i<span style="color:#f92672">=</span>edges[i].next){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> edges[i].v;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>dfn[v]){
</span></span><span style="display:flex;"><span>            tarjan(v,root);
</span></span><span style="display:flex;"><span>            low[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(low[u],low[v]);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(low[v]<span style="color:#f92672">&gt;=</span>dfn[u]){
</span></span><span style="display:flex;"><span>                tot<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(u<span style="color:#f92672">!=</span>root <span style="color:#f92672">||</span> tot<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>) cut[u] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                cdcc<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> z;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">do</span>{
</span></span><span style="display:flex;"><span>                    z <span style="color:#f92672">=</span> stk.top();
</span></span><span style="display:flex;"><span>                    stk.pop();
</span></span><span style="display:flex;"><span>                    dcc[cdcc].push_back(z);
</span></span><span style="display:flex;"><span>                }<span style="color:#66d9ef">while</span>(z<span style="color:#f92672">!=</span>v);
</span></span><span style="display:flex;"><span>                dcc[cdcc].push_back(u);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            low[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(low[u], dfn[v]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//点数，边数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>b;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//起点，终点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(a<span style="color:#f92672">==</span>b) <span style="color:#66d9ef">continue</span>;<span style="color:#75715e">//点双联通需要注意排除自环才能处理孤立点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        add(a,b);
</span></span><span style="display:flex;"><span>        add(b,a);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//无向图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>dfn[i])
</span></span><span style="display:flex;"><span>            tarjan(i,i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>cdcc<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>cdcc;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>dcc[i].size()<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> x:dcc[i]) std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>x<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="点双联通缩点todo">点双联通缩点TODO</h2>
<h2 id="树的直径">树的直径</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//树的直径，复杂度n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//poj1985，输出树上最长路径的长度，即树的直径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//两遍dfs版可以求出路径上的点，但树形dp的可以处理负边权问题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>pii<span style="color:#f92672">&gt;</span> edges[MAXN];<span style="color:#75715e">//first是v，second是w
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dis[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> far;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> fa){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> edges[u].size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>size;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        pii e <span style="color:#f92672">=</span> edges[u][i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> e.first, w <span style="color:#f92672">=</span> e.second;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(v<span style="color:#f92672">==</span>fa) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        dis[v] <span style="color:#f92672">=</span> dis[u]<span style="color:#f92672">+</span>w;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(dis[v]<span style="color:#f92672">&gt;</span>dis[far]) far<span style="color:#f92672">=</span>v;
</span></span><span style="display:flex;"><span>        dfs(v,u);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u,v,w;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> trash;<span style="color:#75715e">//poj 1985的输入数据问题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w<span style="color:#f92672">&gt;&gt;</span>trash;
</span></span><span style="display:flex;"><span>        edges[u].push_back(std<span style="color:#f92672">::</span>make_pair(v,w));
</span></span><span style="display:flex;"><span>        edges[v].push_back(std<span style="color:#f92672">::</span>make_pair(u,w));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    dfs(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    dis[far] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    dfs(far,<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>dis[far]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//树的直径，复杂度n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//poj1985，输出树上最长路径的长度，即树的直径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//两遍dfs版可以求出路径上的点，但树形dp的可以处理负边权问题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>pii<span style="color:#f92672">&gt;</span> edges[MAXN];<span style="color:#75715e">//first是v，second是w
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dis[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> vis[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> ans;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dp</span>(<span style="color:#66d9ef">int</span> u){
</span></span><span style="display:flex;"><span>    vis[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> edges[u].size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>size;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        pii e <span style="color:#f92672">=</span> edges[u][i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> e.first, w <span style="color:#f92672">=</span> e.second;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(vis[v]) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        dp(v);
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(ans,dis[u]<span style="color:#f92672">+</span>dis[v]<span style="color:#f92672">+</span>w);
</span></span><span style="display:flex;"><span>        dis[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(dis[u],dis[v]<span style="color:#f92672">+</span>w);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u,v,w;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> trash;<span style="color:#75715e">//poj 1985的输入数据问题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w<span style="color:#f92672">&gt;&gt;</span>trash;
</span></span><span style="display:flex;"><span>        edges[u].push_back(std<span style="color:#f92672">::</span>make_pair(v,w));
</span></span><span style="display:flex;"><span>        edges[v].push_back(std<span style="color:#f92672">::</span>make_pair(u,w));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    dp(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>若树上所有边边权均为正，则树的所有直径中点重合。</p>
<h2 id="树的重心">树的重心</h2>
<p>计算无根树的每一个节点作为根时，其最大子树的大小。最大子树的大小最小的节点叫做树的重心。</p>
<p><strong>性质如下</strong></p>
<ol>
<li>重心如果不唯一，则最多只有两个，且它们相邻。并且此时树有偶数个节点，可以被划分为两个大小相等的连通块，每个块各自包含一个重心。</li>
<li>以树的重心为根时，所有子树的大小都不超过整棵树的一半</li>
<li>树中所有点到某个点的距离之和中，到重心的距离之和是最小的。如果有两个重心，它们是并列最小的。反过来距离之和最小的点一定是重心。</li>
<li>两棵树通过一条边连成一棵树，则新树的重心在连接原来两颗树的重心的路径上。如果两棵树大小一样，那么重心就是两个连接点。</li>
<li>在一棵树上添加或删除一个叶节点，它的重心最多只移动一条边的距离。如果原树有奇数个节点，那么重心可能会增加一个，原重心仍然是重心。如果有偶数个节点，那么重心可能减少一个，另一个重心仍然是重心。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//poj 1655
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> edges[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> sz[MAXN], mss[MAXN];<span style="color:#75715e">//树的大小（含自己），最大子树大小（不含自己）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ctr;<span style="color:#75715e">//存重心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> fa, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> n){<span style="color:#75715e">//需要传入点的个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sz[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, mss[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> edges[u].size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> e<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;e<span style="color:#f92672">&lt;</span>size;e<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> edges[u][e];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(v<span style="color:#f92672">==</span>fa) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        dfs(v,u,n);
</span></span><span style="display:flex;"><span>        mss[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(mss[u],sz[v]);
</span></span><span style="display:flex;"><span>        sz[u] <span style="color:#f92672">+=</span> sz[v];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    mss[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(mss[u],n<span style="color:#f92672">-</span>sz[u]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(mss[u]<span style="color:#f92672">&lt;=</span>n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>) ctr.push_back(u);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="倍增求最近公共祖先">倍增求最近公共祖先</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 单次查询 logn 预处理 nlogn，常数小点的可以用重链剖分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P3379
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//倍增求最近公共祖先
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">500005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> LOGN <span style="color:#f92672">=</span> <span style="color:#ae81ff">31</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> edge[MAXN];<span style="color:#75715e">//邻接表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> logn[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> fa[MAXN][LOGN],deep[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//fa[a][b]代表a的第2^b个祖先，deep是深度，根节点深度为1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build</span>(<span style="color:#66d9ef">int</span> u,<span style="color:#66d9ef">int</span> father){
</span></span><span style="display:flex;"><span>    fa[u][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> father;
</span></span><span style="display:flex;"><span>    deep[u] <span style="color:#f92672">=</span> deep[father]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>logn[deep[u]];i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        fa[u][i] <span style="color:#f92672">=</span> fa[fa[u][i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]][i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> v:edge[u]){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(v<span style="color:#f92672">==</span>father) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        build(v,u);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lca</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> y){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(deep[x]<span style="color:#f92672">&gt;</span>deep[y]) std<span style="color:#f92672">::</span>swap(x,y);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//保证y比x深
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(deep[x]<span style="color:#f92672">!=</span>deep[y]){
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> fa[y][logn[deep[y]<span style="color:#f92672">-</span>deep[x]]];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(x<span style="color:#f92672">==</span>y) <span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span>logn[deep[x]];k<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;k<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(fa[x][k]<span style="color:#f92672">!=</span>fa[y][k]){
</span></span><span style="display:flex;"><span>            x <span style="color:#f92672">=</span> fa[x][k], y <span style="color:#f92672">=</span> fa[y][k];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> fa[x][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m,s;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>s;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//点数，询问数，根节点序号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        logn[i] <span style="color:#f92672">=</span> logn[i<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//必须的初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>b;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//读入树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        edge[a].push_back(b);
</span></span><span style="display:flex;"><span>        edge[b].push_back(a);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    build(s,<span style="color:#ae81ff">0</span>);<span style="color:#75715e">//必须build才能用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x,y;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>x<span style="color:#f92672">&gt;&gt;</span>y;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//查询x,y的最近公共祖先
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>lca(x,y)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="虚树-todo">虚树 TODO</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"></code></pre></div><h2 id="点分治">点分治</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//点分治 复杂度nlog^2n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//poj 1741
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//查询树上长度小于等于k的路径的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;set&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">10007</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v,w,next;<span style="color:#75715e">//指向的点，边权，下一条边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Edge edges[MAXN<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> head[MAXN],cnt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> v, <span style="color:#66d9ef">int</span> w){
</span></span><span style="display:flex;"><span>    edges[<span style="color:#f92672">++</span>cnt].w <span style="color:#f92672">=</span> w;
</span></span><span style="display:flex;"><span>    edges[cnt].v <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>    edges[cnt].next <span style="color:#f92672">=</span> head[u];
</span></span><span style="display:flex;"><span>    head[u] <span style="color:#f92672">=</span> cnt;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> sz[MAXN], mss[MAXN];<span style="color:#75715e">//树的大小（含自己），最大子树大小（不含自己）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> ctr<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//重心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> del[MAXN];<span style="color:#75715e">//这个点是否在分治的时候被删除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfsCtr</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> fa, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> n){<span style="color:#75715e">//需要传入树的点的个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//执行完后ctr为本子树的重心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sz[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, mss[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> e<span style="color:#f92672">=</span>head[u];e;e<span style="color:#f92672">=</span>edges[e].next){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> edges[e].v;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(v<span style="color:#f92672">==</span>fa <span style="color:#f92672">||</span> del[v]) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        dfsCtr(v,u,n);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(ctr<span style="color:#f92672">!=-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        mss[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(mss[u],sz[v]);
</span></span><span style="display:flex;"><span>        sz[u] <span style="color:#f92672">+=</span> sz[v];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    mss[u] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(mss[u],n<span style="color:#f92672">-</span>sz[u]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(mss[u]<span style="color:#f92672">&lt;=</span>n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>) ctr <span style="color:#f92672">=</span> u, sz[fa] <span style="color:#f92672">=</span> n<span style="color:#f92672">-</span>sz[u];<span style="color:#75715e">//注意要改编sz以保证复杂度正确
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dis[MAXN];<span style="color:#75715e">//dis[x]存储点x到根root的距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> indexx[MAXN];<span style="color:#75715e">//要对节点编号按照dis进行排序，indexx[0]代表元素个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> belong[MAXN];<span style="color:#75715e">//判断子树节点属于哪一个子子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> cntsame[MAXN];<span style="color:#75715e">//查询[l,r]时，维护[l+1,r]中belong与l的belong相同的个数，见calc函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> y){<span style="color:#66d9ef">return</span> dis[x]<span style="color:#f92672">&lt;</span>dis[y];}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfsDis</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> fa, <span style="color:#66d9ef">int</span> from){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//获得子树到根节点的距离，from用于计算belong
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    indexx[<span style="color:#f92672">++</span>indexx[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>    belong[u] <span style="color:#f92672">=</span> from;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> e<span style="color:#f92672">=</span>head[u];e;e<span style="color:#f92672">=</span>edges[e].next){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> edges[e].v, w <span style="color:#f92672">=</span> edges[e].w;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(v<span style="color:#f92672">==</span>fa <span style="color:#f92672">||</span> del[v]) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        dis[v] <span style="color:#f92672">=</span> dis[u] <span style="color:#f92672">+</span> w;
</span></span><span style="display:flex;"><span>        cntsame[from]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        dfsDis(v,u,from);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">calc</span>(<span style="color:#66d9ef">int</span> u,<span style="color:#66d9ef">int</span> k){
</span></span><span style="display:flex;"><span>    indexx[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    indexx[<span style="color:#f92672">++</span>indexx[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>    belong[u] <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>    dis[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    cntsame[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> e<span style="color:#f92672">=</span>head[u];e;e<span style="color:#f92672">=</span>edges[e].next){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> edges[e].v, w <span style="color:#f92672">=</span>edges[e].w;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(del[v]) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        dis[v] <span style="color:#f92672">=</span> dis[u] <span style="color:#f92672">+</span> w;
</span></span><span style="display:flex;"><span>        cntsame[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        dfsDis(v,u,v);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(indexx<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,indexx<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>indexx[<span style="color:#ae81ff">0</span>],cmp);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> l<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, r<span style="color:#f92672">=</span>indexx[<span style="color:#ae81ff">0</span>],ans<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(l<span style="color:#f92672">&lt;</span>r){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> indexx[l], y <span style="color:#f92672">=</span> indexx[r];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(dis[x]<span style="color:#f92672">+</span>dis[y]<span style="color:#f92672">&gt;</span>k){
</span></span><span style="display:flex;"><span>            cntsame[belong[y]]<span style="color:#f92672">--</span>;<span style="color:#75715e">//把cntsame由[l,r]转移,r-1]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            r<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//显然，如果不考虑两个点在同一个子子树内，则l和l+1~r的每个点都满足dis[x]+dis[y]&lt;=k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//减去同子子树的情况，即减去[l+1,r]中和l拥有相同belong的点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            cntsame[belong[x]]<span style="color:#f92672">--</span>;<span style="color:#75715e">//把cntsame由[l,r]转移到[l+1,r]，一定要注意顺序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ans <span style="color:#f92672">+=</span> r<span style="color:#f92672">-</span>l<span style="color:#f92672">-</span>cntsame[belong[x]];
</span></span><span style="display:flex;"><span>            l<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">divide</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> k){
</span></span><span style="display:flex;"><span>    del[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">+=</span> calc(u,k);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> e<span style="color:#f92672">=</span>head[u];e;e<span style="color:#f92672">=</span>edges[e].next){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> edges[e].v, w <span style="color:#f92672">=</span> edges[e].w;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(del[v]) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        ctr <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        dfsCtr(v,<span style="color:#ae81ff">0</span>,sz[v]);
</span></span><span style="display:flex;"><span>        divide(ctr,k);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> k){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u,v,w;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>u<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>w;
</span></span><span style="display:flex;"><span>        add(u,v,w);
</span></span><span style="display:flex;"><span>        add(v,u,w);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    dfsCtr(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,n);
</span></span><span style="display:flex;"><span>    divide(ctr,k);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>res<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ctr <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) head[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,del[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> n,k;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span>(std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>k){
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&amp;&amp;</span>k<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	    solve(n,k);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="重链剖分">重链剖分</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//树根节点的子节点中子树最大的为它的重子节点，其他的为轻子节点（整棵树的根节点是轻点，其他子树的根节点可轻可重）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//节点连向其轻子节点的边叫轻边，否则叫重边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//节点数为n，则从任意节点向上到根节点，经过的轻边数不超过logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fa, sz, dep, hson;<span style="color:#75715e">//父节点、子树大小（包含自己）、深度、重子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> top;<span style="color:#75715e">//链头，即所在的重链中深度最小的那个节点 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}node[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> edges[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs1</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> d<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//在dfs2之前先用dfs1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, ma <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    node[u].dep <span style="color:#f92672">=</span> d;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> v:edges[u]){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>node[v].dep){
</span></span><span style="display:flex;"><span>            dfs1(v,d<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            node[v].fa <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>            size <span style="color:#f92672">+=</span> node[v].sz;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(node[v].sz <span style="color:#f92672">&gt;</span> ma){
</span></span><span style="display:flex;"><span>                node[u].hson <span style="color:#f92672">=</span> v, ma <span style="color:#f92672">=</span> node[v].sz;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    node[u].sz <span style="color:#f92672">=</span> size;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs2</span>(<span style="color:#66d9ef">int</span> u){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//需要先把根节点的top设置为自己
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> v:edges[u]){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>node[v].top){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(v<span style="color:#f92672">==</span>node[u].hson) node[v].top <span style="color:#f92672">=</span> node[u].top;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> node[v].top <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>            dfs2(v);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cut</span>(<span style="color:#66d9ef">int</span> r<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//进行树剖预处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    dfs1(r);
</span></span><span style="display:flex;"><span>    node[r].top <span style="color:#f92672">=</span> r;
</span></span><span style="display:flex;"><span>    dfs2(r);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="重链剖分求lca">重链剖分求LCA</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//树剖求LCA，每次查询复杂度 logn，常数很小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p3379
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lca</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(node[a].top<span style="color:#f92672">!=</span>node[b].top){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(node[node[a].top].dep<span style="color:#f92672">&gt;</span>node[node[b].top].dep)
</span></span><span style="display:flex;"><span>            a <span style="color:#f92672">=</span> node[node[a].top].fa;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            b <span style="color:#f92672">=</span> node[node[b].top].fa;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(node[a].dep <span style="color:#f92672">&gt;</span> node[b].dep) <span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="重链剖分线段树维护树上路径点权和">重链剖分+线段树维护树上路径点权和</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//树剖维护树上路径的点权和，维护和查询一次复杂度 logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p3384
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//树根节点的子节点中子树最大的为它的重子节点，其他的为轻子节点（整棵树的根节点是轻点，其他子树的根节点可轻可重）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//节点连向其轻子节点的边叫轻边，否则叫重边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//节点数为n，则从任意节点向上到根节点，经过的轻边数不超过logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define pb push_back
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define mkp std::make_pair
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define fi first
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define se second
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> INF <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x7fffffff</span>;
</span></span><span style="display:flex;"><span>LL MOD <span style="color:#f92672">=</span> <span style="color:#ae81ff">998244353</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fa, sz, dep, hson;<span style="color:#75715e">//父节点、子树大小（包含自己）、深度、重子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> top;<span style="color:#75715e">//链头，即所在的重链中深度最小的那个节点 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> dfn, mdfn;<span style="color:#75715e">//该节点的dfs序，该节点子树的最大dfs序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL v;<span style="color:#75715e">//点上的权
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}node[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dfnmap[MAXN];<span style="color:#75715e">//映射dfn对应的点编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> edges[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs1</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> d<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//在dfs2之前先用dfs1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, ma <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    node[u].dep <span style="color:#f92672">=</span> d;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> v:edges[u]){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>node[v].dep){
</span></span><span style="display:flex;"><span>            dfs1(v,d<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            node[v].fa <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>            size <span style="color:#f92672">+=</span> node[v].sz;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(node[v].sz <span style="color:#f92672">&gt;</span> ma){
</span></span><span style="display:flex;"><span>                node[u].hson <span style="color:#f92672">=</span> v, ma <span style="color:#f92672">=</span> node[v].sz;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    node[u].sz <span style="color:#f92672">=</span> size;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> cnt<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs2</span>(<span style="color:#66d9ef">int</span> u){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//需要先把根节点的top设置为自己
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    node[u].dfn <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>cnt;
</span></span><span style="display:flex;"><span>    dfnmap[cnt] <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(node[u].hson<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        node[node[u].hson].top <span style="color:#f92672">=</span> node[u].top;
</span></span><span style="display:flex;"><span>        dfs2(node[u].hson);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//采取这个改变的原因是，每棵子树的dfs序是连续的，根节点dfs序最小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//而如果我们强制先遍历重子节点，那么重链上的dfs序是连续的，并且链头dfs序最小。这样就能用线段树维护链上的信息了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> v:edges[u]){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>node[v].top){
</span></span><span style="display:flex;"><span>            node[v].top <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>            dfs2(v);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    node[u].mdfn <span style="color:#f92672">=</span> cnt;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cut</span>(<span style="color:#66d9ef">int</span> r){
</span></span><span style="display:flex;"><span>    dfs1(r);
</span></span><span style="display:flex;"><span>    node[r].top <span style="color:#f92672">=</span> r;
</span></span><span style="display:flex;"><span>    dfs2(r);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Nodest</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> s,t;<span style="color:#75715e">//该端点的起点和终点下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL tag, v;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Nodest st[MAXN<span style="color:#f92672">*</span><span style="color:#ae81ff">4</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build</span>(<span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> t, <span style="color:#66d9ef">int</span> p){
</span></span><span style="display:flex;"><span>    st[p].s <span style="color:#f92672">=</span> s;
</span></span><span style="display:flex;"><span>    st[p].t <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==</span>t) {
</span></span><span style="display:flex;"><span>        st[p].v <span style="color:#f92672">=</span> node[dfnmap[s]].v<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>        st[p].tag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> s<span style="color:#f92672">+</span>((t<span style="color:#f92672">-</span>s)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    build(s,m,p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    build(m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,t,p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    st[p].v <span style="color:#f92672">=</span> (st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>].v <span style="color:#f92672">+</span> st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].v)<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>    st[p].tag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spreadTag</span>(<span style="color:#66d9ef">int</span> p){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(st[p].tag){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> st[p].s, t <span style="color:#f92672">=</span> st[p].t;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> s<span style="color:#f92672">+</span>((t<span style="color:#f92672">-</span>s)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>].v     <span style="color:#f92672">=</span> (st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>].v <span style="color:#f92672">+</span> (m<span style="color:#f92672">-</span>s<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>st[p].tag)<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>        st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].v   <span style="color:#f92672">=</span> (st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].v <span style="color:#f92672">+</span> (t<span style="color:#f92672">-</span>m)<span style="color:#f92672">*</span>st[p].tag)<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>        st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>].tag   <span style="color:#f92672">=</span> (st[p].tag <span style="color:#f92672">+</span> st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>].tag)<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>        st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].tag <span style="color:#f92672">=</span> (st[p].tag <span style="color:#f92672">+</span> st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].tag)<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>        st[p].tag<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> p, LL k){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> st[p].s, t <span style="color:#f92672">=</span> st[p].t;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>s <span style="color:#f92672">&amp;&amp;</span> t<span style="color:#f92672">&lt;=</span>r){
</span></span><span style="display:flex;"><span>        st[p].v   <span style="color:#f92672">=</span> (st[p].v <span style="color:#f92672">+</span> (t<span style="color:#f92672">-</span>s<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> k)<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>        st[p].tag <span style="color:#f92672">=</span> (st[p].tag <span style="color:#f92672">+</span> k)<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    spreadTag(p);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> s<span style="color:#f92672">+</span>((t<span style="color:#f92672">-</span>s)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>m) update(l, r, p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>, k);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(r<span style="color:#f92672">&gt;</span>m)  update(l, r, p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, k);
</span></span><span style="display:flex;"><span>    st[p].v <span style="color:#f92672">=</span> (st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>].v <span style="color:#f92672">+</span> st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].v)<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> p){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> st[p].s, t <span style="color:#f92672">=</span> st[p].t;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>s <span style="color:#f92672">&amp;&amp;</span> t<span style="color:#f92672">&lt;=</span>r) <span style="color:#66d9ef">return</span> st[p].v<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    spreadTag(p);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> s<span style="color:#f92672">+</span>((t<span style="color:#f92672">-</span>s)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    LL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>m) ret <span style="color:#f92672">=</span> (ret <span style="color:#f92672">+</span> query(l,r,p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>))<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(r<span style="color:#f92672">&gt;</span>m)  ret <span style="color:#f92672">=</span> (ret <span style="color:#f92672">+</span> query(l,r,p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>))<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update_path</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y, LL k){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(node[x].top <span style="color:#f92672">!=</span> node[y].top){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(node[node[x].top].dep <span style="color:#f92672">&gt;</span> node[node[y].top].dep){
</span></span><span style="display:flex;"><span>            update(node[node[x].top].dfn, node[x].dfn, <span style="color:#ae81ff">1</span>, k);
</span></span><span style="display:flex;"><span>            x <span style="color:#f92672">=</span> node[node[x].top].fa;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            update(node[node[y].top].dfn, node[y].dfn, <span style="color:#ae81ff">1</span>, k);
</span></span><span style="display:flex;"><span>            y <span style="color:#f92672">=</span> node[node[y].top].fa;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(node[x].dep<span style="color:#f92672">&gt;</span>node[y].dep){
</span></span><span style="display:flex;"><span>        update(node[y].dfn, node[x].dfn, <span style="color:#ae81ff">1</span>, k);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        update(node[x].dfn, node[y].dfn, <span style="color:#ae81ff">1</span>, k);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">query_path</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y){
</span></span><span style="display:flex;"><span>    LL ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(node[x].top <span style="color:#f92672">!=</span> node[y].top){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(node[node[x].top].dep <span style="color:#f92672">&gt;</span> node[node[y].top].dep){
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">+=</span> query(node[node[x].top].dfn, node[x].dfn, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            x <span style="color:#f92672">=</span> node[node[x].top].fa;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">+=</span> query(node[node[y].top].dfn, node[y].dfn, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            y <span style="color:#f92672">=</span> node[node[y].top].fa;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(node[x].dep<span style="color:#f92672">&gt;</span>node[y].dep){
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">+=</span> query(node[y].dfn, node[x].dfn, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">+=</span> query(node[x].dfn, node[y].dfn, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update_subtree</span>(<span style="color:#66d9ef">int</span> x, LL k){
</span></span><span style="display:flex;"><span>    update(node[x].dfn, node[x].mdfn, <span style="color:#ae81ff">1</span>, k);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">query_subtree</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> query(node[x].dfn, node[x].mdfn, <span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m,r;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>r<span style="color:#f92672">&gt;&gt;</span>MOD;<span style="color:#75715e">//节点个数，操作个数，根节点序号，取模数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>node[i].v;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x,y;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>x<span style="color:#f92672">&gt;&gt;</span>y;
</span></span><span style="display:flex;"><span>        edges[x].pb(y);
</span></span><span style="display:flex;"><span>        edges[y].pb(x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    cut(r);
</span></span><span style="display:flex;"><span>    build(<span style="color:#ae81ff">1</span>,n,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(m<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ope,x,y;
</span></span><span style="display:flex;"><span>        LL z;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>ope;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(ope<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>x<span style="color:#f92672">&gt;&gt;</span>y<span style="color:#f92672">&gt;&gt;</span>z;
</span></span><span style="display:flex;"><span>            update_path(x,y,z);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(ope<span style="color:#f92672">==</span><span style="color:#ae81ff">2</span>){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>x<span style="color:#f92672">&gt;&gt;</span>y;
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>query_path(x,y)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(ope<span style="color:#f92672">==</span><span style="color:#ae81ff">3</span>){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>x<span style="color:#f92672">&gt;&gt;</span>z;
</span></span><span style="display:flex;"><span>            update_subtree(x,z);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(ope<span style="color:#f92672">==</span><span style="color:#ae81ff">4</span>){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>x;
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>query_subtree(x)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> T;
</span></span><span style="display:flex;"><span>	T<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span>(T<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>	    solve();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="长链剖分">长链剖分</h2>
<h3 id="求k级祖先">求K级祖先</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//长链剖分定义子树最深深度最深的节点为重子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//任意节点p的k级祖先q所在的链长度一定大于k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//任意节点p到根节点最多经过sqrt n级别的轻边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p5903
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//求任意节点的第k级祖先，预处理nlogn，查询常数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define pb push_back
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">500005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fa, dep, hson;<span style="color:#75715e">//父节点、深度、重子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> top;<span style="color:#75715e">//链头，即所在的长链中深度最小的那个节点 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> len,dfn,mdfn;<span style="color:#75715e">//部分链长，dfs序，子树最大dfs序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}node[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dfnmap[MAXN];<span style="color:#75715e">//dfs序对应节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> edges[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs1</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> d<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    node[u].len <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, node[u].dep <span style="color:#f92672">=</span> d;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> v:edges[u]){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>node[v].dep){
</span></span><span style="display:flex;"><span>            dfs1(v,d<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            node[v].fa <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(node[v].len<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>node[u].len)
</span></span><span style="display:flex;"><span>                node[u].hson <span style="color:#f92672">=</span> v, node[u].len <span style="color:#f92672">=</span> node[v].len<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs2</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> tp){
</span></span><span style="display:flex;"><span>    node[u].dfn <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>cnt;
</span></span><span style="display:flex;"><span>    node[u].top <span style="color:#f92672">=</span> tp;
</span></span><span style="display:flex;"><span>    dfnmap[cnt] <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(node[u].hson) dfs2(node[u].hson, tp);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> v:edges[u]){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>node[v].top) dfs2(v,v);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    node[u].mdfn <span style="color:#f92672">=</span> cnt;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cut</span>(<span style="color:#66d9ef">int</span> r<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    dfs1(r);
</span></span><span style="display:flex;"><span>    dfs2(r,r);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> anc[MAXN], des[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//分别存储（链头）节点p的1,2,...,node[p].len-1级祖先节点和子孙节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> LOGN <span style="color:#f92672">=</span> <span style="color:#ae81ff">21</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> fa[MAXN][LOGN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> logn[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    cut(r);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    logn[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    logn[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>;i<span style="color:#f92672">&lt;</span>MAXN;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        logn[i] <span style="color:#f92672">=</span> logn[i<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//预先计算logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) fa[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> node[i].fa;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;</span>LOGN;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            fa[i][j] <span style="color:#f92672">=</span> fa[fa[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(node[i].top<span style="color:#f92672">==</span>i){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,p<span style="color:#f92672">=</span>i;j<span style="color:#f92672">&lt;</span>node[i].len;j<span style="color:#f92672">++</span>,p<span style="color:#f92672">=</span>fa[p][<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>                anc[i].pb(p);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span>node[i].len;j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                des[i].pb(dfnmap[node[i].dfn<span style="color:#f92672">+</span>j]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> k){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//查询节点u的k级祖先
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(k<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> u;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> logn[k];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> fa[u][i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tp <span style="color:#f92672">=</span> node[v].top;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> d <span style="color:#f92672">=</span> k <span style="color:#f92672">-</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span>i) <span style="color:#f92672">+</span> node[tp].dep <span style="color:#f92672">-</span> node[v].dep;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(d<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> anc[tp][d];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> des[tp][<span style="color:#f92672">-</span>d];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="计算几何-todo">计算几何 TODO</h1>
<h2 id="基础板子">基础板子</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//数据类型定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">double</span> db;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">double</span> LD;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span>{db x,y;};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> Point Vec;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Line</span>{Point p; Vec v;};<span style="color:#75715e">//点向式直线，不保证方向向量为单位向量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Seg</span>{Point a,b;};<span style="color:#75715e">//线段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Circle</span>{Point o;db r;};<span style="color:#75715e">//圆心和半径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//常数定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Point <span style="color:#66d9ef">const</span> o{<span style="color:#ae81ff">0.0</span>,<span style="color:#ae81ff">0.0</span>};<span style="color:#75715e">//原点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Line <span style="color:#66d9ef">const</span> ox{o,{<span style="color:#ae81ff">1.0</span>,<span style="color:#ae81ff">0.0</span>}}, oy{o,{<span style="color:#ae81ff">0.0</span>,<span style="color:#ae81ff">1.0</span>}};<span style="color:#75715e">//横轴纵轴
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>db <span style="color:#66d9ef">const</span> PI <span style="color:#f92672">=</span> acos(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>db <span style="color:#66d9ef">const</span> EPS <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e-9</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//可调整精度的比较
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">eq</span>(db a, db b)  {<span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>abs(a <span style="color:#f92672">-</span> b)<span style="color:#f92672">&lt;</span> EPS;}<span style="color:#75715e">//等于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">ge</span>(db a, db b)  {<span style="color:#66d9ef">return</span> a <span style="color:#f92672">-</span> b          <span style="color:#f92672">&gt;</span> EPS;}<span style="color:#75715e">//大于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">le</span>(db a, db b)  {<span style="color:#66d9ef">return</span> a <span style="color:#f92672">-</span> b          <span style="color:#f92672">&lt;</span> <span style="color:#f92672">-</span>EPS;}<span style="color:#75715e">//小于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">geq</span>(db a, db b) {<span style="color:#66d9ef">return</span> a <span style="color:#f92672">-</span> b          <span style="color:#f92672">&gt;</span> <span style="color:#f92672">-</span>EPS;}<span style="color:#75715e">//大于等于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">leq</span>(db a, db b) {<span style="color:#66d9ef">return</span> a <span style="color:#f92672">-</span> b          <span style="color:#f92672">&lt;</span> EPS;}<span style="color:#75715e">//小于等于
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sgn</span>(db x) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (std<span style="color:#f92672">::</span>abs(x) <span style="color:#f92672">&lt;</span> EPS) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">// 符号，等于零返回0，大于零返回1，小于零返回-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//基础运算
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Vec <span style="color:#a6e22e">r90a</span>(Vec v){<span style="color:#66d9ef">return</span> {<span style="color:#f92672">-</span>v.y, v.x};}<span style="color:#75715e">//向量逆时针90度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Vec <span style="color:#a6e22e">r90c</span>(Vec v){<span style="color:#66d9ef">return</span> {v.y, <span style="color:#f92672">-</span>v.x};}<span style="color:#75715e">//向量顺时针90度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Vec <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(Vec a, Vec b){<span style="color:#66d9ef">return</span> {a.x<span style="color:#f92672">+</span>b.x, a.y<span style="color:#f92672">+</span>b.y};}
</span></span><span style="display:flex;"><span>Vec <span style="color:#66d9ef">operator</span><span style="color:#f92672">-</span>(Vec a, Vec b){<span style="color:#66d9ef">return</span> {a.x<span style="color:#f92672">-</span>b.x, a.y<span style="color:#f92672">-</span>b.y};}
</span></span><span style="display:flex;"><span>Vec <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>(db k, Vec v){<span style="color:#66d9ef">return</span> {k<span style="color:#f92672">*</span>v.x, k<span style="color:#f92672">*</span>v.y};}
</span></span><span style="display:flex;"><span>Vec <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>(Vec v, db k){<span style="color:#66d9ef">return</span> {v.x<span style="color:#f92672">*</span>k, v.y<span style="color:#f92672">*</span>k};}
</span></span><span style="display:flex;"><span>db <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>(Vec a, Vec b){<span style="color:#66d9ef">return</span> a.x<span style="color:#f92672">*</span>b.x<span style="color:#f92672">+</span>a.y<span style="color:#f92672">*</span>b.y;}
</span></span><span style="display:flex;"><span>db <span style="color:#66d9ef">operator</span><span style="color:#f92672">^</span>(Vec a, Vec b){<span style="color:#66d9ef">return</span> a.x<span style="color:#f92672">*</span>b.y<span style="color:#f92672">-</span>a.y<span style="color:#f92672">*</span>b.x;}<span style="color:#75715e">//叉积
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>db <span style="color:#a6e22e">len2</span>(Vec v){<span style="color:#66d9ef">return</span> v.x<span style="color:#f92672">*</span>v.x<span style="color:#f92672">+</span>v.y<span style="color:#f92672">*</span>v.y;}<span style="color:#75715e">//长度平方
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>db <span style="color:#a6e22e">len</span>(Vec v){<span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>sqrt(len2(v));}<span style="color:#75715e">//向量长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>db <span style="color:#a6e22e">slope</span>(Vec v){<span style="color:#66d9ef">return</span> v.y<span style="color:#f92672">/</span>v.x;}<span style="color:#75715e">//斜率，不存在时，用后面的paral_y函数，不要判断是否是无穷
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//向量操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>db <span style="color:#a6e22e">sin_v</span>(Vec a, Vec b){<span style="color:#66d9ef">return</span> (a<span style="color:#f92672">^</span>b)<span style="color:#f92672">/</span>len(a)<span style="color:#f92672">/</span>len(b);}<span style="color:#75715e">//向量内积，右手定则
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>db <span style="color:#a6e22e">cos_v</span>(Vec a, Vec b){<span style="color:#66d9ef">return</span> a<span style="color:#f92672">*</span>b<span style="color:#f92672">/</span>len(a)<span style="color:#f92672">/</span>len(b);}<span style="color:#75715e">//向量夹角余弦
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Vec <span style="color:#a6e22e">norm</span>(Vec v){<span style="color:#66d9ef">return</span> {v.x<span style="color:#f92672">/</span>len(v), v.y<span style="color:#f92672">/</span>len(v)};}<span style="color:#75715e">//求其单位向量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Vec <span style="color:#a6e22e">pnorm</span>(Vec v){<span style="color:#66d9ef">return</span> (v.x<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">?-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span>len(v)<span style="color:#f92672">*</span>v;}<span style="color:#75715e">//与原向量平行且横坐标大于零的单位向量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Vec <span style="color:#a6e22e">dvec</span>(Seg l){<span style="color:#66d9ef">return</span> l.b<span style="color:#f92672">-</span>l.a;}<span style="color:#75715e">//线段转化为向量（没有归一化）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Vec <span style="color:#a6e22e">trunc</span>(Vec v, db r){ <span style="color:#75715e">// v转化为长度为l的向量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    db l <span style="color:#f92672">=</span> len(v);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>sgn(l)) <span style="color:#66d9ef">return</span> v;
</span></span><span style="display:flex;"><span>    r <span style="color:#f92672">/=</span> l;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> v<span style="color:#f92672">*</span>r;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//直线操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Line <span style="color:#a6e22e">line</span>(Point a, Point b){<span style="color:#66d9ef">return</span> {a,b<span style="color:#f92672">-</span>a};}<span style="color:#75715e">//两点式直线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Line <span style="color:#a6e22e">line</span>(db k, db b){<span style="color:#66d9ef">return</span> {{<span style="color:#ae81ff">0</span>,b},{<span style="color:#ae81ff">1</span>,k}};}<span style="color:#75715e">//斜截式直线y=kx+b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Line <span style="color:#a6e22e">line</span>(Point p, db k){<span style="color:#66d9ef">return</span> {p,{<span style="color:#ae81ff">1</span>,k}};}<span style="color:#75715e">//点斜式直线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Line <span style="color:#a6e22e">line</span>(Seg l){<span style="color:#66d9ef">return</span> {l.a, l.b<span style="color:#f92672">-</span>l.a};}<span style="color:#75715e">//线段所在直线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>db <span style="color:#a6e22e">at_x</span>(Line l, db x){<span style="color:#66d9ef">return</span> l.p.y<span style="color:#f92672">+</span>(x<span style="color:#f92672">-</span>l.p.x)<span style="color:#f92672">*</span>l.v.y<span style="color:#f92672">/</span>l.v.x;}<span style="color:#75715e">//给定直线上的横坐标求纵坐标，要确保直线不与y轴平行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>db <span style="color:#a6e22e">at_y</span>(Line l, db y){<span style="color:#66d9ef">return</span> l.p.x<span style="color:#f92672">+</span>(y<span style="color:#f92672">+</span>l.p.y)<span style="color:#f92672">*</span>l.v.x<span style="color:#f92672">/</span>l.v.y;}<span style="color:#75715e">//与上相反
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Point <span style="color:#a6e22e">pedal</span>(Point p, Line l){<span style="color:#66d9ef">return</span> l.p<span style="color:#f92672">-</span>(l.p<span style="color:#f92672">-</span>p)<span style="color:#f92672">*</span>l.v<span style="color:#f92672">/</span>(l.v<span style="color:#f92672">*</span>l.v)<span style="color:#f92672">*</span>l.v;}<span style="color:#75715e">//求点到直线的垂足
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Line <span style="color:#a6e22e">perp</span>(Line l, Point p){<span style="color:#66d9ef">return</span> {p,r90c(l.v)};}<span style="color:#75715e">//过某点作直线的垂线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Line <span style="color:#a6e22e">bisec</span>(Point p, Vec a, Vec b){<span style="color:#66d9ef">return</span> {p,norm(a)<span style="color:#f92672">+</span>norm(b)};}<span style="color:#75715e">//角平分线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//线段操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Point <span style="color:#a6e22e">midp</span>(Seg l){<span style="color:#66d9ef">return</span> {(l.a.x<span style="color:#f92672">+</span>l.b.x)<span style="color:#f92672">/</span><span style="color:#ae81ff">2.0</span>,(l.a.y<span style="color:#f92672">+</span>l.b.y)<span style="color:#f92672">/</span><span style="color:#ae81ff">2.0</span>};}<span style="color:#75715e">//线段中点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Line <span style="color:#a6e22e">perp</span>(Seg l){<span style="color:#66d9ef">return</span> {midp(l), r90c(l.b<span style="color:#f92672">-</span>l.a)};}<span style="color:#75715e">//线段中垂线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//几何关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">verti</span>(Vec a, Vec b){<span style="color:#66d9ef">return</span> eq(a<span style="color:#f92672">*</span>b,<span style="color:#ae81ff">0.0</span>);}<span style="color:#75715e">//向量是否垂直
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">paral</span>(Vec a, Vec b){<span style="color:#66d9ef">return</span> eq(a<span style="color:#f92672">^</span>b,<span style="color:#ae81ff">0.0</span>);}<span style="color:#75715e">//向量是否平行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">paral_x</span>(Vec v){<span style="color:#66d9ef">return</span> eq(v.y,<span style="color:#ae81ff">0.0</span>);}<span style="color:#75715e">//是否平行x轴
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">paral_y</span>(Vec v){<span style="color:#66d9ef">return</span> eq(v.x,<span style="color:#ae81ff">0.0</span>);}<span style="color:#75715e">//是否平行y轴
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">on</span>(Point p, Line l){<span style="color:#66d9ef">return</span> eq((p.x<span style="color:#f92672">-</span>l.p.x)<span style="color:#f92672">*</span>l.v.y, (p.y<span style="color:#f92672">-</span>l.p.y)<span style="color:#f92672">*</span>l.v.x);}<span style="color:#75715e">//点是否在直线上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">on</span>(Point p, Seg l){<span style="color:#66d9ef">return</span> eq(len(p<span style="color:#f92672">-</span>l.a)<span style="color:#f92672">+</span>len(p<span style="color:#f92672">-</span>l.b),len(l.a<span style="color:#f92672">-</span>l.b));}<span style="color:#75715e">//点是否在线段上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//bool on(Point p, Seg l){return sgn((p-l.a)^(l.b-l.a))==0 &amp;&amp; sgn((p-l.a)*(p-l.b))&lt;=0 ;}//点是否在线段上，无须len的判断法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">on</span>(Point p, Circle c){<span style="color:#75715e">//0圆外，1圆上，2圆内
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    db dst <span style="color:#f92672">=</span> len(p<span style="color:#f92672">-</span>c.o);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(sgn(dst<span style="color:#f92672">-</span>c.r)<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(sgn(dst<span style="color:#f92672">-</span>c.r)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(Point a, Point b){<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">eq</span>(a.x,b.x)<span style="color:#f92672">&amp;&amp;</span>eq(a.y,b.y);}<span style="color:#75715e">//点重合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(Line a, Line b){<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">on</span>(a.p,b)<span style="color:#f92672">&amp;&amp;</span>on(a.p<span style="color:#f92672">+</span>a.v,b);}<span style="color:#75715e">//直线重合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(Seg a, Seg b){<span style="color:#66d9ef">return</span> ((a.a<span style="color:#f92672">==</span>b.a<span style="color:#f92672">&amp;&amp;</span>a.b<span style="color:#f92672">==</span>b.b)<span style="color:#f92672">||</span>(a.a<span style="color:#f92672">==</span>b.b<span style="color:#f92672">&amp;&amp;</span>a.b<span style="color:#f92672">==</span>b.a));}<span style="color:#75715e">//线段（完全）重合
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(Point a, Point b){<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">le</span>(a.x,b.x)<span style="color:#f92672">||</span>(eq(a.x,b.x)<span style="color:#f92672">&amp;&amp;</span>le(a.y,b.y));}<span style="color:#75715e">//横坐标第一关键字，纵坐标第二关键字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">tangency</span>(Line l, Circle c){<span style="color:#66d9ef">return</span> eq(std<span style="color:#f92672">::</span>abs((c.o<span style="color:#f92672">^</span>l.v)<span style="color:#f92672">-</span>(l.p<span style="color:#f92672">^</span>l.v)),c.r<span style="color:#f92672">*</span>len(l.v));}<span style="color:#75715e">//直线和圆是否相切
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">tangency</span>(Circle c1, Circle c2){<span style="color:#66d9ef">return</span> eq(len(c1.o<span style="color:#f92672">-</span>c2.o),c1.r<span style="color:#f92672">+</span>c2.r);}<span style="color:#75715e">//两个圆是否相切
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>db <span style="color:#a6e22e">dis</span>(Point a, Point b){<span style="color:#66d9ef">return</span> len(a<span style="color:#f92672">-</span>b);}<span style="color:#75715e">//两点距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>db <span style="color:#a6e22e">dis</span>(Point p, Line l){<span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>abs((p<span style="color:#f92672">^</span>l.v)<span style="color:#f92672">-</span>(l.p<span style="color:#f92672">^</span>l.v))<span style="color:#f92672">/</span>len(l.v);}<span style="color:#75715e">//点到直线的距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>db <span style="color:#a6e22e">dis</span>(Line a, Line b){<span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>abs((a.p<span style="color:#f92672">^</span>pnorm(a.v))<span style="color:#f92672">-</span>(b.p<span style="color:#f92672">^</span>pnorm(b.v)));}<span style="color:#75715e">//两直线距离，需要确保平行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>db <span style="color:#a6e22e">dis</span>(Point p, Seg s){ <span style="color:#75715e">// 点到线段的距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(sgn(cos_v(p<span style="color:#f92672">-</span>s.a, s.b<span style="color:#f92672">-</span>s.a))<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> sgn(cos_v(p<span style="color:#f92672">-</span>s.b, s.a<span style="color:#f92672">-</span>s.b))<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>min(dis(p, s.a), dis(p, s.b));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> dis(p, line(s));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>db <span style="color:#a6e22e">dis</span>(Seg s1, Seg s2){ <span style="color:#75715e">// 线段之间的距离，前提是不相交。相交时为0，需要自己判断
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>min(std<span style="color:#f92672">::</span>min(dis(s1.a, s2), dis(s1.b, s2)), std<span style="color:#f92672">::</span>min(dis(s2.a, s1), dis(s2.b, s1)));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//平移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Line <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(Line l, Vec v){<span style="color:#66d9ef">return</span> {l.p<span style="color:#f92672">+</span>v, l.v};}<span style="color:#75715e">//直线平移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Seg <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(Seg l, Vec v){<span style="color:#66d9ef">return</span> {l.a<span style="color:#f92672">+</span>v,l.b<span style="color:#f92672">+</span>v};}<span style="color:#75715e">//线段平移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//旋转
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Point <span style="color:#a6e22e">rotate</span>(Point p, db rad){<span style="color:#66d9ef">return</span> {cos(rad)<span style="color:#f92672">*</span>p.x<span style="color:#f92672">-</span>sin(rad)<span style="color:#f92672">*</span>p.y,sin(rad)<span style="color:#f92672">*</span>p.x<span style="color:#f92672">+</span>cos(rad)<span style="color:#f92672">*</span>p.y};}<span style="color:#75715e">//绕原点旋转rad弧度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Point <span style="color:#a6e22e">rotate</span>(Point p, db rad, Point c){<span style="color:#66d9ef">return</span> c<span style="color:#f92672">+</span>rotate(p<span style="color:#f92672">-</span>c,rad);}<span style="color:#75715e">//绕c旋转rad弧度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Line <span style="color:#a6e22e">rotate</span>(Line l, db rad, Point c<span style="color:#f92672">=</span>o){<span style="color:#66d9ef">return</span> {rotate(l.p,rad,c),rotate(l.v,rad)};}<span style="color:#75715e">//直线绕c点旋转rad弧度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Seg <span style="color:#a6e22e">rotate</span>(Seg l, db rad, Point c<span style="color:#f92672">=</span>o){<span style="color:#66d9ef">return</span> {rotate(l.a,rad,c), rotate(l.b,rad,c)};};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//对称
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Point <span style="color:#a6e22e">reflect</span>(Point a, Point p){<span style="color:#66d9ef">return</span> {p.x<span style="color:#f92672">*</span><span style="color:#ae81ff">2.0</span><span style="color:#f92672">-</span>a.x, p.y<span style="color:#f92672">*</span><span style="color:#ae81ff">2.0</span><span style="color:#f92672">-</span>a.y};}<span style="color:#75715e">//a关于p的对称点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Line <span style="color:#a6e22e">reflect</span>(Line l, Point p){<span style="color:#66d9ef">return</span> {reflect(l.p,p),l.v};}<span style="color:#75715e">//直线l关于p的对称直线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Seg <span style="color:#a6e22e">reflect</span>(Seg l, Point p){<span style="color:#66d9ef">return</span> {reflect(l.a,p),reflect(l.b,p)};}<span style="color:#75715e">//线段l关于p的对称线段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Point <span style="color:#a6e22e">reflect</span>(Point a, Line ax){<span style="color:#66d9ef">return</span> reflect(a, pedal(a,ax));}<span style="color:#75715e">//点a关于直线ax的对称点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Point <span style="color:#a6e22e">reflect_v</span>(Vec v, Line ax){<span style="color:#66d9ef">return</span> reflect(v,ax)<span style="color:#f92672">-</span>reflect(o,ax);}<span style="color:#75715e">//向量v关于直线ax的对称向量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Line <span style="color:#a6e22e">reflect</span>(Line l, Line ax){<span style="color:#66d9ef">return</span> {reflect(l.p, ax),reflect_v(l.v, ax)};}<span style="color:#75715e">//直线l关于直线ax的对称直线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Seg <span style="color:#a6e22e">reflect</span>(Seg l, Line ax){<span style="color:#66d9ef">return</span> {reflect(l.a, ax), reflect(l.b, ax)};}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//交点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> inter(Line a, Line b){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//两直线的交点，没有交点返回空vector，否则返回一个大小为1的vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 不能重叠
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    db c <span style="color:#f92672">=</span> a.v<span style="color:#f92672">^</span>b.v;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(eq(c,<span style="color:#ae81ff">0.0</span>)) <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>    Vec v <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>c<span style="color:#f92672">*</span>Vec{a.p<span style="color:#f92672">^</span>(a.p<span style="color:#f92672">+</span>a.v), b.p<span style="color:#f92672">^</span>(b.p<span style="color:#f92672">+</span>b.v)};
</span></span><span style="display:flex;"><span>    ret.push_back({v<span style="color:#f92672">*</span>Vec{<span style="color:#f92672">-</span>b.v.x, a.v.x},v<span style="color:#f92672">*</span>Vec{<span style="color:#f92672">-</span>b.v.y, a.v.y}});
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> inter(Seg s1, Seg s2) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 两线段的交点，没有交点返回空vector，否则返回一个大小为1的vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这里特别规定，如果两条线段有重叠线段，会返回第一条线段的两个端点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>max;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>min;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> check <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    check <span style="color:#f92672">=</span> check <span style="color:#f92672">&amp;&amp;</span> geq(max(s1.a.x, s1.b.x), min(s2.a.x, s2.b.x));
</span></span><span style="display:flex;"><span>    check <span style="color:#f92672">=</span> check <span style="color:#f92672">&amp;&amp;</span> geq(max(s2.a.x, s2.b.x), min(s1.a.x, s1.b.x));
</span></span><span style="display:flex;"><span>    check <span style="color:#f92672">=</span> check <span style="color:#f92672">&amp;&amp;</span> geq(max(s1.a.y, s1.b.y), min(s2.a.y, s2.b.y));
</span></span><span style="display:flex;"><span>    check <span style="color:#f92672">=</span> check <span style="color:#f92672">&amp;&amp;</span> geq(max(s2.a.y, s2.b.y), min(s1.a.y, s1.b.y));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>check) <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    db pd1 <span style="color:#f92672">=</span> (s2.a <span style="color:#f92672">-</span> s1.a) <span style="color:#f92672">^</span> (s1.b <span style="color:#f92672">-</span> s1.a);
</span></span><span style="display:flex;"><span>    db pd2 <span style="color:#f92672">=</span> (s2.b <span style="color:#f92672">-</span> s1.a) <span style="color:#f92672">^</span> (s1.b <span style="color:#f92672">-</span> s1.a);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (sgn(pd1 <span style="color:#f92672">*</span> pd2) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>swap(s1, s2);  <span style="color:#75715e">// 双方都要跨立实验
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    pd1 <span style="color:#f92672">=</span> (s2.a <span style="color:#f92672">-</span> s1.a) <span style="color:#f92672">^</span> (s1.b <span style="color:#f92672">-</span> s1.a);
</span></span><span style="display:flex;"><span>    pd2 <span style="color:#f92672">=</span> (s2.b <span style="color:#f92672">-</span> s1.a) <span style="color:#f92672">^</span> (s1.b <span style="color:#f92672">-</span> s1.a);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (sgn(pd1 <span style="color:#f92672">*</span> pd2) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (sgn(pd1) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> sgn(pd2) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        ret.push_back(s2.a);
</span></span><span style="display:flex;"><span>        ret.push_back(s2.a);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">inter</span>(line(s2), line(s1));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> inter(Line l, Circle c){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//直线与圆的交点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Point p <span style="color:#f92672">=</span> pedal(c.o, l);
</span></span><span style="display:flex;"><span>    db h <span style="color:#f92672">=</span> len(p<span style="color:#f92672">-</span>c.o);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(ge(h,c.r)) <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(eq(h,c.r)) {ret.push_back(p);<span style="color:#66d9ef">return</span> ret;};
</span></span><span style="display:flex;"><span>    db d <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>sqrt(c.r<span style="color:#f92672">*</span>c.r <span style="color:#f92672">-</span> h<span style="color:#f92672">*</span>h);
</span></span><span style="display:flex;"><span>    Vec v <span style="color:#f92672">=</span> d<span style="color:#f92672">/</span>len(l.v)<span style="color:#f92672">*</span>l.v;
</span></span><span style="display:flex;"><span>    ret.push_back(p<span style="color:#f92672">-</span>v);ret.push_back(p<span style="color:#f92672">+</span>v);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> inter(Circle c1, Circle c2){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//两个圆的交点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Vec v1 <span style="color:#f92672">=</span> c2.o <span style="color:#f92672">-</span> c1.o, v2 <span style="color:#f92672">=</span> r90c(v1);
</span></span><span style="display:flex;"><span>    db d <span style="color:#f92672">=</span> len(v1);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(ge(d, c1.r<span style="color:#f92672">+</span>c2.r)<span style="color:#f92672">||</span>ge(std<span style="color:#f92672">::</span>abs(c1.r<span style="color:#f92672">-</span>c2.r),d)) <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(eq(d, c1.r<span style="color:#f92672">+</span>c2.r)<span style="color:#f92672">||</span>eq(std<span style="color:#f92672">::</span>abs(c1.r<span style="color:#f92672">-</span>c2.r),d)){ret.push_back(c1.o<span style="color:#f92672">+</span>c1.r<span style="color:#f92672">/</span>d<span style="color:#f92672">*</span>v1);<span style="color:#66d9ef">return</span> ret;}
</span></span><span style="display:flex;"><span>    db a <span style="color:#f92672">=</span> ((c1.r<span style="color:#f92672">*</span>c1.r<span style="color:#f92672">-</span>c2.r<span style="color:#f92672">*</span>c2.r)<span style="color:#f92672">/</span>d<span style="color:#f92672">+</span>d)<span style="color:#f92672">/</span><span style="color:#ae81ff">2.0</span>;
</span></span><span style="display:flex;"><span>    db h <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>sqrt(c1.r<span style="color:#f92672">*</span>c1.r<span style="color:#f92672">-</span>a<span style="color:#f92672">*</span>a);
</span></span><span style="display:flex;"><span>    Vec av <span style="color:#f92672">=</span> a<span style="color:#f92672">/</span>len(v1)<span style="color:#f92672">*</span>v1, hv <span style="color:#f92672">=</span> h<span style="color:#f92672">/</span>len(v2)<span style="color:#f92672">*</span>v2;
</span></span><span style="display:flex;"><span>    ret.push_back(c1.o<span style="color:#f92672">+</span>av<span style="color:#f92672">+</span>hv);ret.push_back(c1.o<span style="color:#f92672">+</span>av<span style="color:#f92672">-</span>hv);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//多边形相关
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>db <span style="color:#a6e22e">area</span>(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> ps){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 逆时针排序的多边形的顶点，计算面积
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    db ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, sz<span style="color:#f92672">=</span>ps.size();i<span style="color:#f92672">&lt;</span>sz;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">+=</span> (ps[i]<span style="color:#f92672">^</span>ps[(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>sz])<span style="color:#f92672">/</span><span style="color:#ae81ff">2.0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isconvex</span>(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> poly){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 多边形是否为凸
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> s(<span style="color:#ae81ff">3</span>, false);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, n<span style="color:#f92672">=</span>poly.size();i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> (i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>n;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> (j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>n;
</span></span><span style="display:flex;"><span>        s[sgn((poly[j]<span style="color:#f92672">-</span>poly[i])<span style="color:#f92672">^</span>(poly[k]<span style="color:#f92672">-</span>poly[i]))<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(s[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&amp;&amp;</span> s[<span style="color:#ae81ff">2</span>]) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">inpoly</span>(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> poly, Point p){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 一个点是否在多边形内？
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 0外部，1内部，2边上，3顶点上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> n<span style="color:#f92672">=</span>poly.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(poly[i]<span style="color:#f92672">==</span>p) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(on(p, Seg{poly[(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>n],poly[i]})) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> (i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>n;
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> sgn((p<span style="color:#f92672">-</span>poly[j])<span style="color:#f92672">^</span>(poly[i]<span style="color:#f92672">-</span>poly[j]));
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> sgn(poly[i].y<span style="color:#f92672">-</span>p.y);
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> sgn(poly[j].y<span style="color:#f92672">-</span>p.y);
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">if</span>(k<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> u<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> v<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>) cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">if</span>(k<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> v<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> u<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>) cnt<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> cnt <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> convexCut(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> ps, Point p1, Point p2){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// p1p2连成的直线，切开凸多边形，获得左半边的凸多边形
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 多边形逆时针，左半边指(p2-p1)向量的左半边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> ps.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        Point q1 <span style="color:#f92672">=</span> ps[i], q2 <span style="color:#f92672">=</span> ps[(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>n];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> d1 <span style="color:#f92672">=</span> sgn((p2<span style="color:#f92672">-</span>p1)<span style="color:#f92672">^</span>(q1<span style="color:#f92672">-</span>p1)), d2 <span style="color:#f92672">=</span> sgn((p2<span style="color:#f92672">-</span>p1)<span style="color:#f92672">^</span>(q2<span style="color:#f92672">-</span>p1));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(d1<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>) ret.push_back(q1);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(d1<span style="color:#f92672">*</span>d2<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>) ret.push_back(inter(line(q1,q2), line(p1,p2))[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//三角形四心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//可能都需要判断三点共线的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Point <span style="color:#a6e22e">barycenter</span>(Point a, Point b, Point c){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//重心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> {(a.x<span style="color:#f92672">+</span>b.x<span style="color:#f92672">+</span>c.x)<span style="color:#f92672">/</span><span style="color:#ae81ff">3.0</span>, (a.y<span style="color:#f92672">+</span>b.y<span style="color:#f92672">+</span>c.y)<span style="color:#f92672">/</span><span style="color:#ae81ff">3.0</span>};
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Point <span style="color:#a6e22e">circumcenter</span>(Point a, Point b, Point c){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//外心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    db a2 <span style="color:#f92672">=</span> a<span style="color:#f92672">*</span>a, b2 <span style="color:#f92672">=</span> b<span style="color:#f92672">*</span>b, c2 <span style="color:#f92672">=</span> c<span style="color:#f92672">*</span>c;
</span></span><span style="display:flex;"><span>    db d <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.0</span><span style="color:#f92672">*</span>(a.x<span style="color:#f92672">*</span>(b.y<span style="color:#f92672">-</span>c.y)<span style="color:#f92672">+</span>b.x<span style="color:#f92672">*</span>(c.y<span style="color:#f92672">-</span>a.y)<span style="color:#f92672">+</span>c.x<span style="color:#f92672">*</span>(a.y<span style="color:#f92672">-</span>b.y));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>d <span style="color:#f92672">*</span> r90c(a2<span style="color:#f92672">*</span>(b<span style="color:#f92672">-</span>c)<span style="color:#f92672">+</span>b2<span style="color:#f92672">*</span>(c<span style="color:#f92672">-</span>a)<span style="color:#f92672">+</span>c2<span style="color:#f92672">*</span>(a<span style="color:#f92672">-</span>b));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Point <span style="color:#a6e22e">incenter</span>(Point a, Point b, Point c){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//内心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    db a1 <span style="color:#f92672">=</span> len(b<span style="color:#f92672">-</span>c), b1 <span style="color:#f92672">=</span> len(a<span style="color:#f92672">-</span>c), c1 <span style="color:#f92672">=</span> len(a<span style="color:#f92672">-</span>b);
</span></span><span style="display:flex;"><span>    db d <span style="color:#f92672">=</span> a1<span style="color:#f92672">+</span>b1<span style="color:#f92672">+</span>c1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>d <span style="color:#f92672">*</span> (a1<span style="color:#f92672">*</span>a<span style="color:#f92672">+</span>b1<span style="color:#f92672">*</span>b<span style="color:#f92672">+</span>c1<span style="color:#f92672">*</span>c);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Point <span style="color:#a6e22e">orthocenter</span>(Point a, Point b, Point c){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//垂心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    db n <span style="color:#f92672">=</span> b<span style="color:#f92672">*</span>(a<span style="color:#f92672">-</span>c), m <span style="color:#f92672">=</span> a<span style="color:#f92672">*</span>(b<span style="color:#f92672">-</span>c);
</span></span><span style="display:flex;"><span>    db d <span style="color:#f92672">=</span> (b<span style="color:#f92672">-</span>c)<span style="color:#f92672">^</span>(a<span style="color:#f92672">-</span>c);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>d <span style="color:#f92672">*</span> r90c(n<span style="color:#f92672">*</span>(c<span style="color:#f92672">-</span>b)<span style="color:#f92672">-</span>m<span style="color:#f92672">*</span>(c<span style="color:#f92672">-</span>a));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/////////////////////////////////////////////////
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 圆切线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Line<span style="color:#f92672">&gt;</span> tangentLine(Point p, Circle c){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 过一点做圆的切线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Line<span style="color:#f92672">&gt;</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> on(p, c);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(x<span style="color:#f92672">==</span><span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(x<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        ret.push_back(line(p, p<span style="color:#f92672">+</span>r90a(p<span style="color:#f92672">-</span>c.o)));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    db d <span style="color:#f92672">=</span> dis(p, c.o);
</span></span><span style="display:flex;"><span>    db l <span style="color:#f92672">=</span> c.r<span style="color:#f92672">*</span>c.r<span style="color:#f92672">/</span>d;
</span></span><span style="display:flex;"><span>    db h <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>sqrt(c.r<span style="color:#f92672">*</span>c.r<span style="color:#f92672">-</span>l<span style="color:#f92672">*</span>l);
</span></span><span style="display:flex;"><span>    ret.push_back(line(p, c.o<span style="color:#f92672">+</span>(trunc(p<span style="color:#f92672">-</span>c.o,l)<span style="color:#f92672">+</span>trunc(r90a(p<span style="color:#f92672">-</span>c.o),h))));
</span></span><span style="display:flex;"><span>    ret.push_back(line(p, c.o<span style="color:#f92672">+</span>(trunc(p<span style="color:#f92672">-</span>c.o,l)<span style="color:#f92672">+</span>trunc(r90c(p<span style="color:#f92672">-</span>c.o),h))));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Seg<span style="color:#f92672">&gt;</span> getTangent(Circle a, Circle b){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 求两圆的公共切线，这里用切点的线段表示了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 其中线段的a点代表圆a的切点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Seg<span style="color:#f92672">&gt;</span> ret;
</span></span><span style="display:flex;"><span>    db dist<span style="color:#f92672">=</span>len(a.o<span style="color:#f92672">-</span>b.o);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> mul <span style="color:#f92672">=</span> [](Point a, Point b)<span style="color:#f92672">-&gt;</span>Point{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> {a.x<span style="color:#f92672">*</span>b.x<span style="color:#f92672">-</span>a.y<span style="color:#f92672">*</span>b.y, a.x<span style="color:#f92672">*</span>b.y<span style="color:#f92672">+</span>a.y<span style="color:#f92672">*</span>b.x};
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> getInTangent <span style="color:#f92672">=</span> [<span style="color:#f92672">&amp;</span>mul](Circle a,Circle b,db flg<span style="color:#f92672">=</span><span style="color:#ae81ff">1.0</span>)<span style="color:#f92672">-&gt;</span>Seg{
</span></span><span style="display:flex;"><span>        Point base<span style="color:#f92672">=</span>b.o<span style="color:#f92672">-</span>a.o;
</span></span><span style="display:flex;"><span>        db w<span style="color:#f92672">=</span>a.r<span style="color:#f92672">+</span>b.r;
</span></span><span style="display:flex;"><span>        db h<span style="color:#f92672">=</span>std<span style="color:#f92672">::</span>sqrt(len2(base)<span style="color:#f92672">-</span>w<span style="color:#f92672">*</span>w);
</span></span><span style="display:flex;"><span>        Point k <span style="color:#f92672">=</span> mul(base, Point{w, h<span style="color:#f92672">*</span>flg})<span style="color:#f92672">*</span>(<span style="color:#ae81ff">1.0</span><span style="color:#f92672">/</span>len2(base));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Seg{a.o<span style="color:#f92672">+</span>k<span style="color:#f92672">*</span>a.r,b.o<span style="color:#f92672">-</span>k<span style="color:#f92672">*</span>b.r};
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> getOutTangent <span style="color:#f92672">=</span> [<span style="color:#f92672">&amp;</span>mul](Circle a,Circle b,db flg<span style="color:#f92672">=</span><span style="color:#ae81ff">1.0</span>)<span style="color:#f92672">-&gt;</span>Seg{
</span></span><span style="display:flex;"><span>        Point base<span style="color:#f92672">=</span>b.o<span style="color:#f92672">-</span>a.o;
</span></span><span style="display:flex;"><span>        db h<span style="color:#f92672">=</span>b.r<span style="color:#f92672">-</span>a.r;
</span></span><span style="display:flex;"><span>        db w<span style="color:#f92672">=</span>std<span style="color:#f92672">::</span>sqrt(len2(base)<span style="color:#f92672">-</span>h<span style="color:#f92672">*</span>h);
</span></span><span style="display:flex;"><span>        Point k <span style="color:#f92672">=</span> mul(mul(base, Point{w, h<span style="color:#f92672">*</span>flg})<span style="color:#f92672">*</span>(<span style="color:#ae81ff">1.0</span><span style="color:#f92672">/</span>len2(base)), Point{<span style="color:#ae81ff">0</span>,flg});
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Seg{a.o<span style="color:#f92672">+</span>k<span style="color:#f92672">*</span>a.r,b.o<span style="color:#f92672">-</span>k<span style="color:#f92672">*</span>b.r};
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(dist<span style="color:#f92672">&gt;</span>a.r<span style="color:#f92672">+</span>b.r<span style="color:#f92672">+</span>EPS)
</span></span><span style="display:flex;"><span>        ret.push_back(getInTangent(a,b,<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(dist<span style="color:#f92672">&gt;</span>a.r<span style="color:#f92672">+</span>b.r<span style="color:#f92672">-</span>EPS)
</span></span><span style="display:flex;"><span>        ret.push_back(getInTangent(a,b,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(dist<span style="color:#f92672">&gt;</span>std<span style="color:#f92672">::</span>abs(a.r<span style="color:#f92672">-</span>b.r)<span style="color:#f92672">+</span>EPS)
</span></span><span style="display:flex;"><span>        ret.push_back(getOutTangent(a,b,<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(dist<span style="color:#f92672">&gt;</span>std<span style="color:#f92672">::</span>abs(a.r<span style="color:#f92672">-</span>b.r)<span style="color:#f92672">-</span>EPS)
</span></span><span style="display:flex;"><span>        ret.push_back(getOutTangent(a,b,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="基本公式">基本公式</h2>
<h3 id="正弦定理">正弦定理</h3>
<p>在<span class="math inline">\(\triangle ABC\)</span>中，设角<span class="math inline">\(A,B,C\)</span>对应的边为<span class="math inline">\(a,b,c\)</span>，则</p>
<p><span class="math display">\[\dfrac{a}{\sin A} = \dfrac{b}{\sin B} = \dfrac{c}{\sin C} = 2R
\]</span></p>
<p>其中<span class="math inline">\(R\)</span>是外接圆半径</p>
<h3 id="余弦定理">余弦定理</h3>
<p><span class="math display">\[a^2 = b^2+c^2-2bc\cos A
\]</span></p>
<p><span class="math display">\[b^2 = a^2+c^2-2ac\cos B
\]</span></p>
<p><span class="math display">\[c^2 = a^2+b^2-2ab\cos C
\]</span></p>
<h3 id="向量积">向量积</h3>
<p><span class="math display">\[\vec{a}\cdot\vec{b} = a_1b_1+a_2b_2+\cdots+a_nb_n =|\vec{a}||\vec{b}|\cos\theta
\]</span></p>
<p><span class="math display">\[\vec{a}\times\vec{b} = |\vec{a}||\vec{b}|\sin\theta
\]</span></p>
<p>实际上外积只在三维中有定义。用在二维向量上时，只能算出这个标量值，用右手定则判断正负。其也代表两个向量构成的平行四边形的面积。三维中的定义为</p>
<p><span class="math display">\[\vec{s} = \vec{u}\times\vec{v} = (u_2v_3-u_3v_2, u_3v_1-u_1v_3,u_1v_2-u_2v_1)
\]</span></p>
<p>其中<span class="math inline">\(\vec{s}\)</span>垂直于<span class="math inline">\(\vec{u},\vec{v}\)</span>构成的屏幕。</p>
<h3 id="求任意多边形的周长">求任意多边形的周长</h3>
<p>使用我们提供的<code>len</code>函数计算所有边即可。</p>
<h3 id="求任意多边形的面积">求任意多边形的面积</h3>
<p>将多边形上的点逆时针标记为<span class="math inline">\(p_1, p_2,\cdots,p_n\)</span>，再选一个辅助点<span class="math inline">\(O\)</span>，记<span class="math inline">\(v_i=p_i-O\)</span>，那么</p>
<p><span class="math display">\[S = \dfrac{1}{2}\sum^n_{i=1}v_i\times v_{i\%n+1}
\]</span></p>
<h2 id="二维凸包">二维凸包</h2>
<h3 id="andrew扫描法">Andrew扫描法</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 nlogn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P2742，求凸包周长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//凸包即能包围住所有给定顶点的最小凸多边形
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//注意题给条件，如果是整数坐标，务必切换到long long来避免误差
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> convexHull(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> poly){
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 返回凸包上的点，逆时针顺序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 如果要判断一个多边形是不是凸包，也可以用其生成一个凸包，判断点数是否相同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 此时要将下面的sgn(...)&lt;=0改成sgn(...)&lt;0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 另外要特判所有点共线的情况，否则得不到正确的点数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> poly.size();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> qs;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(k<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&amp;&amp;</span>sgn((qs[k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-</span>qs[k<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>])<span style="color:#f92672">^</span>(poly[i]<span style="color:#f92672">-</span>qs[k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]))<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>            qs.pop_back();
</span></span><span style="display:flex;"><span>            k<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        qs.push_back(poly[i]);
</span></span><span style="display:flex;"><span>        k<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,t<span style="color:#f92672">=</span>k;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(k<span style="color:#f92672">&gt;</span>t<span style="color:#f92672">&amp;&amp;</span>sgn((qs[k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-</span>qs[k<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>])<span style="color:#f92672">^</span>(poly[i]<span style="color:#f92672">-</span>qs[k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]))<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            qs.pop_back();
</span></span><span style="display:flex;"><span>            k<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        qs.push_back(poly[i]);
</span></span><span style="display:flex;"><span>        k<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    qs.pop_back();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> qs;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> po(n);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>po[i].x<span style="color:#f92672">&gt;&gt;</span>po[i].y;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//输入点的横纵坐标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(po.begin(), po.end());
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> ch <span style="color:#f92672">=</span> convexHull(po);
</span></span><span style="display:flex;"><span>    db ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,sz<span style="color:#f92672">=</span>ch.size();i<span style="color:#f92672">&lt;</span>sz;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">+=</span> len(ch[(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>sz]<span style="color:#f92672">-</span>ch[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>fixed;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout.precision(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="旋转卡壳求最远点对">旋转卡壳求最远点对</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 nlogn，其中求凸包nlogn，旋转卡壳本身为n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Luogu P1452
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//旋转卡壳和凸包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//注意题给条件，如果是整数坐标，务必切换到long long来避免误差
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>db <span style="color:#a6e22e">rc</span>(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> ch){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回凸包直径的平方
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> tn <span style="color:#f92672">=</span> ch.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> cnt<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(tn<span style="color:#f92672">==</span><span style="color:#ae81ff">2</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> len2(ch[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-</span>ch[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;k<span style="color:#f92672">&lt;</span>tn;k<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>(ch[i]<span style="color:#f92672">&lt;</span>ch[k])) i<span style="color:#f92672">=</span>k;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(ch[j]<span style="color:#f92672">&lt;</span>ch[k]) j<span style="color:#f92672">=</span>k;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    db res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> si<span style="color:#f92672">=</span>i,sj<span style="color:#f92672">=</span>j;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">!=</span>sj<span style="color:#f92672">||</span>j<span style="color:#f92672">!=</span>si){
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(res, len2(ch[i]<span style="color:#f92672">-</span>ch[j]));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(sgn((ch[(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>tn]<span style="color:#f92672">-</span>ch[i])<span style="color:#f92672">^</span>(ch[(j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>tn]<span style="color:#f92672">-</span>ch[j]))<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>            i <span style="color:#f92672">=</span> (i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>tn;
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            j <span style="color:#f92672">=</span> (j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>tn;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> po(n);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>po[i].x<span style="color:#f92672">&gt;&gt;</span>po[i].y;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//输入点的横纵坐标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(po.begin(), po.end());
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Point<span style="color:#f92672">&gt;</span> ch <span style="color:#f92672">=</span> convexHull(po);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>rc(ch)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="平面最近点对">平面最近点对</h2>
<p>输入<span class="math inline">\(n\)</span>个点的平面坐标，使用分治法计算最近点对，复杂度<span class="math inline">\(O(nlogn)\)</span></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度nlogn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Luogu P1257
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span>{db x,y;<span style="color:#66d9ef">int</span> id;}; <span style="color:#75715e">// id为了记录最近点对是哪两个点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp</span>(Point <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> a, Point <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> b){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> le(a.y, b.y);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 除了这两个部分其他同基础板子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>db minDist;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> ansA, ansB;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Point po[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">updAns</span>(Point <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> a, Point <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> b){
</span></span><span style="display:flex;"><span>    db dist <span style="color:#f92672">=</span> len(b<span style="color:#f92672">-</span>a);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(dist<span style="color:#f92672">&lt;</span>minDist){
</span></span><span style="display:flex;"><span>        minDist <span style="color:#f92672">=</span> dist;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果要记录节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ansA <span style="color:#f92672">=</span> a.id;
</span></span><span style="display:flex;"><span>        ansB <span style="color:#f92672">=</span> b.id;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">calcMin</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(r<span style="color:#f92672">-</span>l<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">3</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>l;i<span style="color:#f92672">&lt;=</span>r;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>r;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                updAns(po[i],po[j]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>sort(po<span style="color:#f92672">+</span>l, po<span style="color:#f92672">+</span>r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, cmp); <span style="color:#75715e">// 只排序y
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> (l<span style="color:#f92672">+</span>r)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    db midx <span style="color:#f92672">=</span> po[m].x;
</span></span><span style="display:flex;"><span>    calcMin(l,m);
</span></span><span style="display:flex;"><span>    calcMin(m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,r);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//归并排序的合并，两个有序数组合并，合并之后仍然有序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>inplace_merge(po<span style="color:#f92672">+</span>l, po<span style="color:#f92672">+</span>m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, po<span style="color:#f92672">+</span>r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, cmp); <span style="color:#75715e">// 只排序y
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> Point t[MAXN];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tsz <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> l; i <span style="color:#f92672">&lt;=</span> r; <span style="color:#f92672">++</span>i){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (le(std<span style="color:#f92672">::</span>abs(po[i].x <span style="color:#f92672">-</span> midx),minDist)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> tsz <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> le(po[i].y <span style="color:#f92672">-</span> t[j].y,minDist); <span style="color:#f92672">--</span>j)
</span></span><span style="display:flex;"><span>                updAns(po[i], t[j]);
</span></span><span style="display:flex;"><span>            t[tsz<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> po[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>po[i].x<span style="color:#f92672">&gt;&gt;</span>po[i].y;
</span></span><span style="display:flex;"><span>        po[i].id <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(po<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,po<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>n); <span style="color:#75715e">// 按照x第一，y第二排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    minDist <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e20</span>;
</span></span><span style="display:flex;"><span>    calcMin(<span style="color:#ae81ff">1</span>,n);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>fixed;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout.precision(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>minDist<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="扫描线算法">扫描线算法</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//Luogu P5490
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//复杂度 nlogn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//求平面所有平行于坐标轴的矩形的面积重叠和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> ll <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">2000005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Line</span>{
</span></span><span style="display:flex;"><span>    ll l,r,h;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tag;
</span></span><span style="display:flex;"><span>    Line(){}
</span></span><span style="display:flex;"><span>    Line(ll l, ll r, ll h, <span style="color:#66d9ef">int</span> tag)<span style="color:#f92672">:</span>l(l),r(r),h(h),tag(tag){}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(Line <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> h<span style="color:#f92672">&lt;</span>rhs.h;
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}line[MAXN<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ll st[MAXN<span style="color:#f92672">*</span><span style="color:#ae81ff">4</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>];<span style="color:#75715e">//对于一颗线段树，n个数所组成的树最多有4n-5个节点，开大了一点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ll posX[MAXN<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>ll len[MAXN<span style="color:#f92672">*</span><span style="color:#ae81ff">4</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> t, <span style="color:#66d9ef">int</span> p, ll c){<span style="color:#75715e">//c表示加减的数值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(posX[t<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">&lt;=</span>l <span style="color:#f92672">||</span> r<span style="color:#f92672">&lt;=</span>posX[s]) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>posX[s] <span style="color:#f92672">&amp;&amp;</span> posX[t<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">&lt;=</span>r){
</span></span><span style="display:flex;"><span>        st[p] <span style="color:#f92672">+=</span> c;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(st[p]){
</span></span><span style="display:flex;"><span>            len[p] <span style="color:#f92672">=</span> posX[t<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> posX[s];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            len[p] <span style="color:#f92672">=</span> len[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> len[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> s <span style="color:#f92672">+</span> ((t<span style="color:#f92672">-</span>s)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>posX[m]) update(l, r, s, m, p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>, c);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(r<span style="color:#f92672">&gt;</span>posX[m])  update(l, r, m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, t, p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, c);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(st[p]){
</span></span><span style="display:flex;"><span>        len[p] <span style="color:#f92672">=</span> posX[t<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> posX[s];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        len[p] <span style="color:#f92672">=</span> len[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> len[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;<span style="color:#75715e">//矩形个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	ll x1,x2,y1,y2;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>	    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>x1<span style="color:#f92672">&gt;&gt;</span>y1<span style="color:#f92672">&gt;&gt;</span>x2<span style="color:#f92672">&gt;&gt;</span>y2;<span style="color:#75715e">//输入每个矩形的左下角和右上角
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    posX[<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> x1, posX[<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>i] <span style="color:#f92672">=</span> x2;
</span></span><span style="display:flex;"><span>	    line[<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> Line(x1,x2,y1,<span style="color:#ae81ff">1</span>), line[<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>i] <span style="color:#f92672">=</span> Line(x1,x2,y2,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	n<span style="color:#f92672">*=</span><span style="color:#ae81ff">2</span>;<span style="color:#75715e">//方便起见
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>sort(line<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,line<span style="color:#f92672">+</span>n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>sort(posX<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,posX<span style="color:#f92672">+</span>n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> sumSeg <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>unique(posX<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, posX<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>n) <span style="color:#f92672">-</span> posX <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//去重求出线段总数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ll ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){<span style="color:#75715e">//最后一条边不用管
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        update(line[i].l, line[i].r, <span style="color:#ae81ff">1</span>, sumSeg, <span style="color:#ae81ff">1</span>, line[i].tag);
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">+=</span> len[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> (line[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].h <span style="color:#f92672">-</span> line[i].h);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;<span style="color:#75715e">//输出矩形的并集的总面积
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="二维数点">二维数点</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//Luogu P2163
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//时间复杂度 nlogn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//给定平面上n个点，m次查询，查询一个矩阵内有多少点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//由于坐标范围很大，不能直接用前缀和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">500005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> x,y;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tag;<span style="color:#75715e">//用于区分实际的点和查询时的虚点  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(Point <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> p){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(x<span style="color:#f92672">!=</span>p.x) <span style="color:#66d9ef">return</span> x<span style="color:#f92672">&lt;</span>p.x;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(y<span style="color:#f92672">!=</span>p.y) <span style="color:#66d9ef">return</span> y<span style="color:#f92672">&lt;</span>p.y;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> tag<span style="color:#f92672">&lt;</span>p.tag;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}pts[MAXN<span style="color:#f92672">*</span><span style="color:#ae81ff">5</span>];<span style="color:#75715e">//实点和查询矩阵的点都放在这里面
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> b[MAXN<span style="color:#f92672">*</span><span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> bit[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> ans[MAXN][<span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> tot[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lowbit</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> n<span style="color:#f92672">&amp;</span>(<span style="color:#f92672">-</span>n);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> k, <span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(;p<span style="color:#f92672">&lt;=</span>n;p<span style="color:#f92672">+=</span>lowbit(p)){
</span></span><span style="display:flex;"><span>        bit[p]<span style="color:#f92672">+=</span>k;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> p){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ret<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(;p;p<span style="color:#f92672">-=</span>lowbit(p)){
</span></span><span style="display:flex;"><span>        ret<span style="color:#f92672">+=</span>bit[p];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lsh</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> cnt){<span style="color:#75715e">//离散化函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>lower_bound(b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,b<span style="color:#f92672">+</span>cnt<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,x)<span style="color:#f92672">-</span>b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;<span style="color:#75715e">//点数，查询数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>pts[i].x<span style="color:#f92672">&gt;&gt;</span>pts[i].y;<span style="color:#75715e">//所有实点的坐标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pts[i].tag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x1,x2,y1,y2;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>x1<span style="color:#f92672">&gt;&gt;</span>y1<span style="color:#f92672">&gt;&gt;</span>x2<span style="color:#f92672">&gt;&gt;</span>y2;<span style="color:#75715e">//查询的长方形的左下角和右上角
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        
</span></span><span style="display:flex;"><span>        pts[<span style="color:#f92672">++</span>n].x <span style="color:#f92672">=</span> x1<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, pts[n].y <span style="color:#f92672">=</span> y1<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, pts[n].tag <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        pts[<span style="color:#f92672">++</span>n].x <span style="color:#f92672">=</span> x2, pts[n].y <span style="color:#f92672">=</span> y2, pts[n].tag <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        pts[<span style="color:#f92672">++</span>n].x <span style="color:#f92672">=</span> x2, pts[n].y <span style="color:#f92672">=</span> y1<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, pts[n].tag <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        pts[<span style="color:#f92672">++</span>n].x <span style="color:#f92672">=</span> x1<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, pts[n].y <span style="color:#f92672">=</span> y2, pts[n].tag <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(pts<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,pts<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>n);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) b[i] <span style="color:#f92672">=</span> pts[i].y;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>n);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>unique(b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,b<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>n) <span style="color:#f92672">-</span> b <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//把所有y离散化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(pts[i].tag){
</span></span><span style="display:flex;"><span>            ans[pts[i].tag][<span style="color:#f92672">++</span>tot[pts[i].tag]] <span style="color:#f92672">=</span> query(lsh(pts[i].y, cnt));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            update(lsh(pts[i].y, cnt), <span style="color:#ae81ff">1</span>, cnt);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans[i][<span style="color:#ae81ff">4</span>]<span style="color:#f92672">-</span>ans[i][<span style="color:#ae81ff">3</span>]<span style="color:#f92672">-</span>ans[i][<span style="color:#ae81ff">2</span>]<span style="color:#f92672">+</span>ans[i][<span style="color:#ae81ff">1</span>]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="pick定理">Pick定理</h2>
<p>给定顶点均为整点的简单多边形，其面积<span class="math inline">\(A\)</span>和内部格点数目<span class="math inline">\(i\)</span>，边上格点数目<span class="math inline">\(b\)</span>的关系为</p>
<p><span class="math display">\[A = i+\dfrac{b}{2}-1
\]</span></p>
<h1 id="组合数学">组合数学</h1>
<h2 id="用乘法逆元计算组合数">用乘法逆元计算组合数</h2>
<p>TODO: 用模板元编程实现编译期算阶乘</p>
<p>根据</p>
<p><span class="math display">\[(a/b)\%p=(a\times b^{-1})\%p=[(a\%p)\times(b^{-1}\%p)]\%p
\]</span></p>
<p>（如果加载不全，见<a class="link" href="https://kegalas.top/p/%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97%E7%9A%84%E5%88%86%E9%85%8D%E5%BE%8B/"  target="_blank" rel="noopener"
    >取余运算的分配律</a>）</p>
<p>可以不用除法求出组合数。其中<span class="math inline">\(b^{-1}\)</span>是<span class="math inline">\(b\)</span>在模<span class="math inline">\(p\)</span>意义下的逆元。</p>
<p>注意阶乘和其逆元的预处理。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 初始化为nlogn 后续查询为O(1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P3414，只能过50%（因为这道题考的不是这个）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">200005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> LL MOD <span style="color:#f92672">=</span> <span style="color:#ae81ff">6662333</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL fac[MAXN];
</span></span><span style="display:flex;"><span>LL invFac[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">qPowMod</span>(LL x, LL p, LL m){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//x^p % m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">=</span> (ans<span style="color:#f92672">*</span>x)<span style="color:#f92672">%</span>m;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> (x<span style="color:#f92672">*</span>x)<span style="color:#f92672">%</span>m;
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">&gt;&gt;=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">fermat_inv</span>(LL a, LL b){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> qPowMod(a,b<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,b);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    fac[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    invFac[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        fac[i] <span style="color:#f92672">=</span> (fac[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span>i)<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>        invFac[i] <span style="color:#f92672">=</span> fermat_inv(fac[i],MOD);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">comb</span>(LL n, LL m){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//n里面选m个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">||</span>m<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">||</span>m<span style="color:#f92672">&gt;</span>n) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (((fac[n]<span style="color:#f92672">*</span>invFac[m])<span style="color:#f92672">%</span>MOD)<span style="color:#f92672">*</span>invFac[n<span style="color:#f92672">-</span>m])<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="组合数的性质">组合数的性质</h2>
<p><strong>二项式定理</strong></p>
<p><span class="math display">\[(a+b)^n = \sum^n_{i=0}\binom{n}{i}a^{n-i}b^i
\]</span></p>
<p><strong>对称性</strong></p>
<p><span class="math display">\[\binom{n}{m} = \binom{n}{n-m}
\]</span></p>
<p><strong>递推式1</strong></p>
<p><span class="math display">\[\binom{n}{k}=\dfrac{n}{k}\binom{n-1}{k-1}
\]</span></p>
<p><strong>递推式2</strong></p>
<p><span class="math display">\[\binom{n}{m} = \binom{n-1}{m}+\binom{n-1}{m-1}
\]</span></p>
<p><strong>二项式定理的特例1</strong></p>
<p><span class="math display">\[\binom{n}{0}+\binom{n}{1}+\cdots+\binom{n}{n} = 2^n
\]</span></p>
<p><strong>二项式定理的特例2</strong></p>
<p><span class="math display">\[\sum^n_{i=0}(-1)^i\binom{n}{i} = [n=0]
\]</span></p>
<p><strong>组合数拆分</strong></p>
<p><span class="math display">\[\sum^m_{i=0}\binom{n}{i}\binom{m}{m-i} = \binom{m+n}{m} (n\geq m)
\]</span></p>
<p><strong>组合数拆分的特例</strong></p>
<p><span class="math display">\[\sum^m_{i=0}\binom{n}{i}^2= \binom{2n}{n}
\]</span></p>
<p><strong>带权和1</strong></p>
<p><span class="math display">\[\sum^n_{i=0}i\binom{n}{i} = n2^{n-1}
\]</span></p>
<p><strong>带权和2</strong></p>
<p><span class="math display">\[\sum^n_{i=0}i^2\binom{n}{i} = n(n+1)2^{n-2}
\]</span></p>
<p><strong>性质1</strong></p>
<p><span class="math display">\[\sum^n_{l=0}\binom{l}{k} = \binom{n+1}{k+1}
\]</span></p>
<p><strong>性质2</strong></p>
<p><span class="math display">\[\binom{n}{r}\binom{r}{k} = \binom{n}{k}\binom{n-k}{r-k}
\]</span></p>
<p><strong>斐波那契数列性质</strong></p>
<p><span class="math display">\[\sum^n_{i=0}\binom{n-i}{i} = F_{n+1}
\]</span></p>
<h2 id="圆排列">圆排列</h2>
<p><span class="math inline">\(n\)</span>个人全部来围成一圈，所有的排列数记为<span class="math inline">\(Q^n_n\)</span>。考虑其中已经拍好的一圈，从不同位置断开可以变成不同的队列，则有</p>
<p><span class="math display">\[Q^n_n\times n = A^n_n
\]</span></p>
<p>由此可知</p>
<p><span class="math display">\[Q^r_n = \dfrac{A^r_n}{r}
\]</span></p>
<h2 id="二项式反演">二项式反演</h2>
<p>记<span class="math inline">\(f_n\)</span>表示恰好使用<span class="math inline">\(n\)</span>个不同元素形成特定结构的方案数，<span class="math inline">\(g_n\)</span>表示从<span class="math inline">\(n\)</span>个不同元素中选出<span class="math inline">\(i\geq 0\)</span>个元素形成特定结构的总方案数。有</p>
<p><span class="math display">\[g_n = \sum^n_{i=0}\binom{n}{i}f_i
\]</span></p>
<p>二项式反演就是已知<span class="math inline">\(g_n\)</span>求<span class="math inline">\(f_n\)</span></p>
<p><span class="math display">\[f_n = \sum^n_{i=0}\binom{n}{i}(-1)^{n-i}g_i
\]</span></p>
<h2 id="斐波那契数列的性质">斐波那契数列的性质</h2>
<p><strong>通项公式</strong></p>
<p><span class="math display">\[F_n = \dfrac{\left(\dfrac{1+\sqrt{5}}{2}\right)^n-\left(\dfrac{1-\sqrt{5}}{2}\right)^n}{\sqrt{5}}
\]</span></p>
<p><span class="math display">\[F_n = \left[\dfrac{\left(\dfrac{1+\sqrt{5}}{2}\right)^n}{\sqrt{5}}\right]
\]</span></p>
<p>中括号表示取离他最近的整数。</p>
<p><strong>性质1</strong></p>
<p><span class="math display">\[F_{n-1}F_{n+1}-F_n^2=(-1)^n
\]</span></p>
<p><strong>性质2</strong></p>
<p><span class="math display">\[F_{n+k}=F_kF_{n+1}+F_{k-1}F_n
\]</span></p>
<p><strong>性质3</strong></p>
<p><span class="math display">\[F_{2n}=F_{n}(F_{n+1}+F_{n-1}),\quad F_{2n+1}=F^2_{k+1}+F^2_k
\]</span></p>
<p><strong>性质4</strong></p>
<p><span class="math display">\[\forall k\in N,F_n|F_{nk}
\]</span></p>
<p><strong>性质5</strong></p>
<p><span class="math display">\[\forall F_a|F_b,a|b
\]</span></p>
<p><strong>性质6</strong></p>
<p><span class="math display">\[\gcd(F_m,F_n)=F_{\gcd(m,n)}
\]</span></p>
<p><strong>性质7</strong></p>
<p><span class="math display">\[F_{n+1}=\sum_{0\leq i\leq n}\binom{n-i}{i}
\]</span></p>
<h2 id="和式性质">和式性质</h2>
<h3 id="基本性质">基本性质</h3>
<p><span class="math display">\[\sum_{k\in K}ca_k=c\sum_{k\in K}a_k
\]</span></p>
<p><span class="math display">\[\sum_{k\in K}(a_k+b_k)=\sum_{k\in K}a_k+\sum_{k\in K}b_k
\]</span></p>
<p><span class="math display">\[\sum_{k\in K}a_k = \sum_{p(k)\in K}a_{p(k)}
\]</span></p>
<p>此处<span class="math inline">\(p(k)\)</span>是<span class="math inline">\(k\)</span>的任意排列。</p>
<h3 id="多重和式分配律">多重和式分配律</h3>
<p><span class="math display">\[\sum_{j\in J,k\in K}a_jb_k = (\sum_{j\in J}a_j)(\sum_{k\in K}b_k)
\]</span></p>
<h3 id="多重和式次序交换">多重和式次序交换</h3>
<p><span class="math display">\[\sum_{j\in J}\sum_{k\in K}a_{j,k} = \sum_{j\in J,k\in K}a_{j,k} = \sum_{k\in K}\sum_{j\in J}a_{j,k}
\]</span></p>
<p>当<span class="math inline">\(J,K\)</span>相互独立时成立。</p>
<p><span class="math display">\[\sum_{j\in J}\sum_{k\in K(j)}a_{j,k} = \sum_{k\in K'}\sum_{j\in J'(k)}a_{j,k}
\]</span></p>
<p>这里<span class="math inline">\(J,K\)</span>不独立，并且要满足</p>
<p><span class="math display">\[[j\in J][k\in K(j)]=[k\in K'][j\in J'(k)]
\]</span></p>
<p>例如</p>
<p><span class="math display">\[\sum_{j=1}^n\sum_{k=j}^na_{j,k}=\sum_{i\leq j\leq k\leq n}a_{j,k}=\sum_{k=1}^n\sum_{j=1}^ka_{j,k}
\]</span></p>
<h2 id="卡特兰数">卡特兰数</h2>
<p>TODO: 用模板元编程实现编译期算卡特兰数</p>
<p>第<span class="math inline">\(n\)</span>个记作<span class="math inline">\(C_n\)</span></p>
<p><span class="math inline">\(n\)</span>对括号形成的字符串，合法的情况数是<span class="math inline">\(C_n\)</span></p>
<p><span class="math inline">\(n\)</span>个节点的二叉树，总共有<span class="math inline">\(C_n\)</span>种</p>
<p><span class="math inline">\(2n+1\)</span>个节点组成的满二叉树，有<span class="math inline">\(C_n\)</span>种</p>
<p><span class="math inline">\(n\times n\)</span>的格点网中，从左下角格点出发，到达右上角格点，不穿过对角线（但可以碰到）的单调路径个数有<span class="math inline">\(C_n\)</span>个。</p>
<p>在圆上有<span class="math inline">\(2n\)</span>个点，将这些点成对连接起来使得所得到的<span class="math inline">\(n\)</span>条线段不相交的方法数为<span class="math inline">\(C_n\)</span>种</p>
<p>一个栈（无穷大）的进栈序列为<span class="math inline">\(1,2,3,\cdots,n\)</span>，合法的出栈序列有<span class="math inline">\(C_n\)</span>个</p>
<p>其计算公式为</p>
<p><span class="math display">\[C_n = \frac{1}{n+1}\binom{2n}{n}
\]</span></p>
<p><span class="math display">\[C_n=\binom{2n}{n} - \binom{2n}{n-1}
\]</span></p>
<p><span class="math display">\[C_0=1,C_{n+1}=\sum^n_{i=0}C_iC_{n-i}
\]</span></p>
<p><span class="math display">\[C_0=1,C_{n+1}=\frac{2(2n+1)}{n+2}C_n
\]</span></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">//前几项：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p1044
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ll;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">3005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ll h[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ll <span style="color:#a6e22e">comb</span>(ll a,ll b){
</span></span><span style="display:flex;"><span>    ll ans<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(ll i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>b;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        ans<span style="color:#f92672">*=</span>a;<span style="color:#75715e">//数字太大会爆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        a<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(ll i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>b;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        ans<span style="color:#f92672">/=</span>i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    ll n;
</span></span><span style="display:flex;"><span>    cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(ll i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        cout<span style="color:#f92672">&lt;&lt;</span>comb(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>i,i)<span style="color:#f92672">/</span>(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">&lt;&lt;</span>endl;<span style="color:#75715e">//n&gt;=15的时候ll都能爆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;###&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//下面是递推求法，不容易爆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    h[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>h[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(ll i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        h[i] <span style="color:#f92672">=</span> h[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span>(<span style="color:#ae81ff">4</span><span style="color:#f92672">*</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">/</span>(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        cout<span style="color:#f92672">&lt;&lt;</span>h[i]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="生成函数">生成函数</h2>
<p>生成函数是一种形式幂级数</p>
<p><span class="math display">\[F(x) = \sum_na_nx^n
\]</span></p>
<p><span class="math inline">\(\{a_i\}\)</span>序列可以是有限的，也可以是无限的。<span class="math inline">\(a_i\)</span>下标以<span class="math inline">\(0\)</span>为起点。生成函数例如</p>
<ol>
<li><span class="math inline">\(a=<1,2,3>\)</span>的普通生成函数为<span class="math inline">\(1+2x+3x^2\)</span></li>
<li><span class="math inline">\(a=<1,1,1,\cdots>\)</span>的普通生成函数为<span class="math inline">\(\sum_{n\geq 0}x^n\)</span></li>
<li><span class="math inline">\(a=<2,4,6,8,\cdots>\)</span>的普通生成函数为<span class="math inline">\(\sum_{n\geq 0}(2n+2)x^n\)</span></li>
</ol>
<p><strong>加减运算</strong></p>
<p>设序列<span class="math inline">\(a,b\)</span>的普通生成函数分别为<span class="math inline">\(F(x),G(x)\)</span>，则</p>
<p><span class="math display">\[F(x)\pm G(x) = \sum_n(a_n\pm b_n)x^n
\]</span></p>
<p><strong>乘/卷积运算</strong></p>
<p><span class="math display">\[F(x)G(x) = \sum_n x^n\sum^n_{i=0}a_i b_{n-i}
\]</span></p>
<p>给出一些常见封闭形式，这其实和幂级数收敛时的求和公式差不多（目前只会普通生成函数来应对组合问题，之后更新指数生成函数应对排列问题TODO）：</p>
<p><span class="math display">\[\sum_{n\geq 0}x^n = \dfrac{1}{1-x}
\]</span></p>
<p><span class="math display">\[\sum_{n\geq 0}p^nx^n=\dfrac{1}{1-px}
\]</span></p>
<p><span class="math display">\[\sum_{n\geq 1}x^n = \dfrac{x}{1-x}
\]</span></p>
<p><span class="math display">\[\sum_{n\geq 0}x^{cn} = \dfrac{1}{1-x^c}
\]</span></p>
<p><span class="math display">\[1+2x+3x^2+\cdots = \sum_{n\geq 0}(n-1)x^n = \dfrac{1}{(1-x)^2} 
\]</span></p>
<p><span class="math display">\[\sum_{n\geq 0}\binom{m}{n}x^n = (1+x)^m
\]</span></p>
<p><span class="math display">\[\sum_{n\geq 0}\binom{m+n-1}{n}x^n = \dfrac{1}{(1-x)^{m}}
\]</span></p>
<p>其他有限项生成函数应该用等比数列求和公式，转化成分式形式。之后再来进行生成函数的计算。</p>
<p><strong>例题</strong></p>
<p>在许多不同种类的食物中选出<span class="math inline">\(n\)</span>个，每种食物的限制如下（每种食物选出来的个数必须满足该限制）</p>
<ol>
<li>汉堡：偶数个</li>
<li>可乐：0或1个</li>
<li>鸡腿：0或1或2个</li>
<li>蜜桃多：奇数个（注：0个不满足条件）</li>
<li>鸡块：4的倍数个</li>
<li>包子，0、1、2、3个</li>
<li>土豆炒肉：不超过1个</li>
<li>面包：3的倍数个</li>
</ol>
<p>所有食物选出来的总数加起来等于<span class="math inline">\(n\)</span>就可以算作一种方案。计算方案总数模<span class="math inline">\(10007\)</span></p>
<p>我们设<span class="math inline">\(a_n\)</span>表示这种食物选<span class="math inline">\(n\)</span>个的方案数，并求出其生成函数。显然，假设只选两个食品，如果食品1选了<span class="math inline">\(i\)</span>个，那么食品2就只能选<span class="math inline">\(n-i\)</span>个。这和我们之前的卷积形式是一样的。所以我们应该把各种食品的生成函数的封闭形式乘起来得到答案。生成函数构造如下</p>
<ol>
<li><span class="math inline">\(\sum_{n\geq 0}x^{2n}=\dfrac{1}{1-x^2}\)</span></li>
<li><span class="math inline">\(1+x\)</span></li>
<li><span class="math inline">\(1+x+x^2=\dfrac{1-x^3}{1-x}\)</span>（这里食品都是相同的，所以选1个只有1种方案。求法是等比数列求和。有些题的物品是不同的，这里就要变成其他序列）</li>
<li><span class="math inline">\(\dfrac{x}{1-x^2}\)</span></li>
<li><span class="math inline">\(\dfrac{1}{1-x^4}\)</span></li>
<li><span class="math inline">\(\dfrac{1-x^4}{1-x}\)</span></li>
<li><span class="math inline">\(1+x\)</span></li>
<li><span class="math inline">\(\dfrac{1}{1-x^3}\)</span></li>
</ol>
<p>全部乘起来得到的生成函数为</p>
<p><span class="math display">\[F(x) = \dfrac{(1+x)(1-x^3)x(1-x^4)(1+x)}{(1-x^2)(1-x)(1-x^2)(1-x^4)(1-x)(1-x^3)} = \dfrac{x}{(1-x)^4}
\]</span></p>
<p>再转化为展开形式</p>
<p><span class="math display">\[F(x) = \sum_{n\geq 0}\binom{n+3}{n}x^{n+1}=\sum_{n\geq 1}\binom{n+2}{n-1}x^n
\]</span></p>
<p>可得答案就是<span class="math inline">\(\binom{n+2}{n-1}=\binom{n+2}{3}\)</span></p>
<h2 id="稳定婚姻问题gale-shapley算法-todo">稳定婚姻问题(Gale-Shapley算法) TODO</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//POJ 3487
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> N   <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> inf <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">29</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MOD <span style="color:#f92672">=</span> <span style="color:#ae81ff">2007</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ll;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> couple;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> maleLike[N][N], femaleLike[N][N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> maleChoice[N],  femaleChoice[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> maleName[N],    femaleName[N];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> str[N];
</span></span><span style="display:flex;"><span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>freemale;<span style="color:#75715e">//目前单身的男人
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> t;
</span></span><span style="display:flex;"><span>    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>t);<span style="color:#75715e">//数据组数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(t<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>couple);<span style="color:#75715e">//男女对数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>freemale.empty()){
</span></span><span style="display:flex;"><span>            freemale.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>couple;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            scanf(<span style="color:#e6db74">&#34;%s&#34;</span>,str);
</span></span><span style="display:flex;"><span>            maleName[i]<span style="color:#f92672">=</span>str[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>;<span style="color:#75715e">//题目中是以小写字母给男人名字，转化为数字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            freemale.push(maleName[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        sort(maleName, maleName<span style="color:#f92672">+</span>couple);<span style="color:#75715e">//名字排序，便于字典序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>couple;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            scanf(<span style="color:#e6db74">&#34;%s&#34;</span>,str);
</span></span><span style="display:flex;"><span>            femaleName[i]<span style="color:#f92672">=</span>str[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;A&#39;</span>;<span style="color:#75715e">//女人名字是大写字母
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>couple;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            scanf(<span style="color:#e6db74">&#34;%s&#34;</span>,str);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span>couple;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                maleLike[i][j]<span style="color:#f92672">=</span>str[j<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>]<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;A&#39;</span>;<span style="color:#75715e">//男人喜好顺序由男人名字:女人名字列表给出;降序排列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//女士对男士的打分，添加虚拟人物，编号couple，为女士的初始对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>couple;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            scanf(<span style="color:#e6db74">&#34;%s&#34;</span>,str);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span>couple;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                femaleLike[i][str[j<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>]<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>]<span style="color:#f92672">=</span>couple<span style="color:#f92672">-</span>j;<span style="color:#75715e">//排名越前打分越高
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>            femaleLike[i][couple]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        memset(maleChoice,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(maleChoice));
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//一开始男士的期望都是最喜欢的女士
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>couple;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            femaleChoice[i]<span style="color:#f92672">=</span>couple;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>freemale.empty()){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> male<span style="color:#f92672">=</span>freemale.front();
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//找出未配对的男士
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> female<span style="color:#f92672">=</span>maleLike[male][maleChoice[male]];
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//找出心意的女士
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(femaleLike[female][male]<span style="color:#f92672">&gt;</span>femaleLike[female][femaleChoice[female]]){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//比现男友好
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                freemale.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(femaleChoice[female]<span style="color:#f92672">!=</span>couple){
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//前男友再次单身，并且不能将虚拟人物加入队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    freemale.push(femaleChoice[female]);
</span></span><span style="display:flex;"><span>                    maleChoice[femaleChoice[female]]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                femaleChoice[female]<span style="color:#f92672">=</span>male;
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">//更换男友
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                maleChoice[male]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//如果被拒绝，则选择下一位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>couple;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">&#34;%c %c</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,maleName[i]<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;a&#39;</span>, maleLike[maleName[i]][maleChoice[maleName[i]]]<span style="color:#f92672">+</span><span style="color:#e6db74">&#39;A&#39;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(t) puts(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="数据结构">数据结构</h1>
<h2 id="树状数组">树状数组</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 单次查询 logn 单次修改 logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//树状数组，维护的是数组的前缀和，有大量的应用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P3374
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//普通的树状数组要维护的信息，其运算要满足结合律和可差分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//结合律不难理解，可差分指的是若已知x op y和x，则可以求出y
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//这样的运算例如加，乘，异或。乘如果在模意义下可差分，需要保证每个数都有逆元，如果模数为质数则肯定有
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//gcd,max这种是不可差分的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fenwick</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    LL data[MAXN];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">int</span> size_){size<span style="color:#f92672">=</span>size_;}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lowbit</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> x<span style="color:#f92672">&amp;</span>(<span style="color:#f92672">-</span>x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">int</span> p, LL k){<span style="color:#75715e">//位置p的元素加k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(;p<span style="color:#f92672">&lt;=</span>size;p<span style="color:#f92672">+=</span>lowbit(p)){
</span></span><span style="display:flex;"><span>            data[p]<span style="color:#f92672">+=</span>k;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    LL <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> p){<span style="color:#75715e">//查询[1,p]的和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        LL ret<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(;p;p<span style="color:#f92672">-=</span>lowbit(p)){
</span></span><span style="display:flex;"><span>            ret <span style="color:#f92672">+=</span> data[p];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fenwick fenwick;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//数组长度，查询数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fenwick.init(n);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        LL tmp;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>tmp;
</span></span><span style="display:flex;"><span>        fenwick.update(i,tmp);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> op;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x,y;
</span></span><span style="display:flex;"><span>        LL k;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>op<span style="color:#f92672">&gt;&gt;</span>x;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(op<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>k;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//将单点增加k，如果想要改成修改，则可以update(x,k-查询x位置上的数)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            fenwick.update(x,k);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>y;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//输出[x,y]的数组和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>fenwick.query(y)<span style="color:#f92672">-</span>fenwick.query(x<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="树状数组求逆序对">树状数组求逆序对</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 nlogn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//Luogu P1908
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//逆序对&lt;i,j&gt;即，符合i&lt;j且ai&gt;aj的&lt;i,j&gt;的个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define LL long long
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">500005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL arr[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Par</span>{
</span></span><span style="display:flex;"><span>    LL value,id;
</span></span><span style="display:flex;"><span>}par[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">const</span> Par<span style="color:#f92672">&amp;</span> a,<span style="color:#66d9ef">const</span> Par<span style="color:#f92672">&amp;</span> b){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(a.value<span style="color:#f92672">!=</span>b.value) <span style="color:#66d9ef">return</span> a.value<span style="color:#f92672">&lt;</span>b.value;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a.id<span style="color:#f92672">&lt;</span>b.id;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL bit[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> LL <span style="color:#a6e22e">lowbit</span>(LL n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> n<span style="color:#f92672">&amp;</span>(<span style="color:#f92672">-</span>n);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(LL p, LL k, LL n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(;p<span style="color:#f92672">&lt;=</span>n;p<span style="color:#f92672">+=</span>lowbit(p)){
</span></span><span style="display:flex;"><span>        bit[p]<span style="color:#f92672">+=</span>k;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">query</span>(LL p){
</span></span><span style="display:flex;"><span>    LL ans<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(;p;p<span style="color:#f92672">-=</span>lowbit(p)){
</span></span><span style="display:flex;"><span>        ans<span style="color:#f92672">+=</span>bit[p];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    LL n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>par[i].value;
</span></span><span style="display:flex;"><span>        par[i].id <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(par<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,par<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>n,cmp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        arr[par[i].id] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    }<span style="color:#75715e">//这一步其实是离散化，但与stl实现的离散化不同的是，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//出现同样的数字时，例如6,-4,3,7,3会离散化为4,1,2,5,3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    LL ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">+=</span> query(arr[i]);
</span></span><span style="display:flex;"><span>        update(arr[i],<span style="color:#ae81ff">1</span>,n);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ans <span style="color:#f92672">=</span> n<span style="color:#f92672">*</span>(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span><span style="color:#f92672">-</span>ans;<span style="color:#75715e">//本来统计的是等于或顺序对，现在反过来计算逆序对
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="二维树状数组">二维树状数组</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//二维树状数组 支持单点修改和区间查询
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//loj 133
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">5005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BIT2D</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> N,M;
</span></span><span style="display:flex;"><span>    LL data[MAXN][MAXN];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">int</span> n,<span style="color:#66d9ef">int</span> m){
</span></span><span style="display:flex;"><span>        N <span style="color:#f92672">=</span> n, M <span style="color:#f92672">=</span> m;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lowbit</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> x<span style="color:#f92672">&amp;</span>(<span style="color:#f92672">-</span>x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y, LL v){<span style="color:#75715e">//把(x,y)这个点加上v
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>x;i<span style="color:#f92672">&lt;=</span>N;i<span style="color:#f92672">+=</span>lowbit(i)){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>y;j<span style="color:#f92672">&lt;=</span>M;j<span style="color:#f92672">+=</span>lowbit(j)){
</span></span><span style="display:flex;"><span>                data[i][j] <span style="color:#f92672">+=</span> v;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    LL <span style="color:#a6e22e">sum</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y){
</span></span><span style="display:flex;"><span>        LL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>x;i<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">-=</span>lowbit(i)){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>y;j<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">-=</span>lowbit(j)){
</span></span><span style="display:flex;"><span>                ret <span style="color:#f92672">+=</span> data[i][j];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    LL <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> x1, <span style="color:#66d9ef">int</span> y1, <span style="color:#66d9ef">int</span> x2, <span style="color:#66d9ef">int</span> y2){<span style="color:#75715e">//查询(x1,y1)-(x2,y2)这个矩形的区间和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> sum(x2,y2) <span style="color:#f92672">-</span> sum(x2,y1<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">-</span> sum(x1<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, y2) <span style="color:#f92672">+</span> sum(x1<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, y1<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BIT2D bit2d;
</span></span></code></pre></div><h2 id="并查集">并查集</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 很小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//并查集 Luogu3367
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">10005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DSU</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fa[MAXN], rk[MAXN];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) fa[i] <span style="color:#f92672">=</span> i, rk[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//没有路径压缩的find，在需要删除操作时，不能使用路径压缩，只能按秩合并保证复杂度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> fa[x]<span style="color:#f92672">==</span>x <span style="color:#f92672">?</span> x : find(fa[x]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">findc</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//带路径压缩的find
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> fa[x]<span style="color:#f92672">==</span>x <span style="color:#f92672">?</span> x : (fa[x] <span style="color:#f92672">=</span> findc(fa[x]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//按秩合并，如果不需要则直接 fa[find(x)] = find(y);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        x <span style="color:#f92672">=</span> find(x), y <span style="color:#f92672">=</span> find(y);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(x<span style="color:#f92672">==</span>y) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(rk[x]<span style="color:#f92672">&gt;</span>rk[y]) std<span style="color:#f92672">::</span>swap(x,y);
</span></span><span style="display:flex;"><span>        fa[x] <span style="color:#f92672">=</span> y;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(rk[x]<span style="color:#f92672">==</span>rk[y]) rk[y]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mergec</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//按秩合并+路径压缩，如果不需要则直接 fa[findc(x)] = findc(y);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        x <span style="color:#f92672">=</span> findc(x), y <span style="color:#f92672">=</span> findc(y);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(x<span style="color:#f92672">==</span>y) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(rk[x]<span style="color:#f92672">&gt;</span>rk[y]) std<span style="color:#f92672">::</span>swap(x,y);
</span></span><span style="display:flex;"><span>        fa[y] <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(rk[x]<span style="color:#f92672">==</span>rk[y]) rk[y]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">erase</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">--</span>rk[find(x)];
</span></span><span style="display:flex;"><span>        fa[x] <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="线段树">线段树</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 单次查询 logn 单次修改 logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p3372
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//线段树维护的数据要求满足结合律，比如区间和，区间最大区间最小，区间gcd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//区间修改一般支持加、乘、赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> s,t;<span style="color:#75715e">//该端点的起点和终点下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL tag, v;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Node st[MAXN<span style="color:#f92672">*</span><span style="color:#ae81ff">4</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>LL arr[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build</span>(<span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> t, <span style="color:#66d9ef">int</span> p<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    st[p].s <span style="color:#f92672">=</span> s;
</span></span><span style="display:flex;"><span>    st[p].t <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==</span>t) {
</span></span><span style="display:flex;"><span>        st[p].v <span style="color:#f92672">=</span> arr[s];
</span></span><span style="display:flex;"><span>        st[p].tag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> s<span style="color:#f92672">+</span>((t<span style="color:#f92672">-</span>s)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    build(s,m,p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    build(m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,t,p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    st[p].v <span style="color:#f92672">=</span> st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>].v <span style="color:#f92672">+</span> st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].v;
</span></span><span style="display:flex;"><span>    st[p].tag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spreadTag</span>(<span style="color:#66d9ef">int</span> p){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(st[p].tag){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> st[p].s, t <span style="color:#f92672">=</span> st[p].t;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> s<span style="color:#f92672">+</span>((t<span style="color:#f92672">-</span>s)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>].v     <span style="color:#f92672">+=</span> (m<span style="color:#f92672">-</span>s<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>st[p].tag;
</span></span><span style="display:flex;"><span>        st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].v   <span style="color:#f92672">+=</span> (t<span style="color:#f92672">-</span>m)<span style="color:#f92672">*</span>st[p].tag;
</span></span><span style="display:flex;"><span>        st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>].tag   <span style="color:#f92672">+=</span> st[p].tag;
</span></span><span style="display:flex;"><span>        st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].tag <span style="color:#f92672">+=</span> st[p].tag;
</span></span><span style="display:flex;"><span>        st[p].tag<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, LL k, <span style="color:#66d9ef">int</span> p<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> st[p].s, t <span style="color:#f92672">=</span> st[p].t;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>s <span style="color:#f92672">&amp;&amp;</span> t<span style="color:#f92672">&lt;=</span>r){
</span></span><span style="display:flex;"><span>        st[p].v   <span style="color:#f92672">+=</span> (t<span style="color:#f92672">-</span>s<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> k;
</span></span><span style="display:flex;"><span>        st[p].tag <span style="color:#f92672">+=</span> k;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    spreadTag(p);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> s<span style="color:#f92672">+</span>((t<span style="color:#f92672">-</span>s)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>m) update(l, r, k, p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(r<span style="color:#f92672">&gt;</span>m)  update(l, r, k, p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    st[p].v <span style="color:#f92672">=</span> st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>].v <span style="color:#f92672">+</span> st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].v;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> p<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> st[p].s, t <span style="color:#f92672">=</span> st[p].t;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>s <span style="color:#f92672">&amp;&amp;</span> t<span style="color:#f92672">&lt;=</span>r) <span style="color:#66d9ef">return</span> st[p].v;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    spreadTag(p);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> s<span style="color:#f92672">+</span>((t<span style="color:#f92672">-</span>s)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    LL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>m) ret<span style="color:#f92672">+=</span>query(l,r,p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(r<span style="color:#f92672">&gt;</span>m)  ret<span style="color:#f92672">+=</span>query(l,r,p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="动态开点线段树">动态开点线段树</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//动态开点线段树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p3372，由于并没有找到合适的习题，我把题中的查询范围全部加了一个偏移值-5e4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//动态开点线段树并不是动态分配内存，只是在范围很大，但查询不多的时候，可以用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//普通线段树的空间复杂度是O(n)，单次操作的时间复杂度是O(logn)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//动态开点，设查询为m次，时间复杂度仍然为O(logn)，但是空间复杂度变成O(mlogn)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//动态开点还可以处理查询范围为负数的情况，比如查询[-5,6]这一段上的和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//动态开点假设初始数组全部为0，输入一个数组时直接add修改线段树即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">8e6</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;<span style="color:#75715e">//能开多大开多大，128M可以开到800万
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    LL val, tag;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ls,  rs;
</span></span><span style="display:flex;"><span>}st[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> ls(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> st[x].ls;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> rs(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> st[x].rs;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> LL<span style="color:#f92672">&amp;</span> val(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> st[x].val;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> LL<span style="color:#f92672">&amp;</span> tag(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> st[x].tag;}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getMid</span>(<span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> t){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//处理负数边界时，需要强行向下取整，而不是向零取整
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">+</span>t<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">+</span>t<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> (s<span style="color:#f92672">+</span>t)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>((<span style="color:#f92672">-</span>s<span style="color:#f92672">-</span>t<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> stcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> L <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>(<span style="color:#ae81ff">1e6</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>), R <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e6</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;<span style="color:#75715e">//这里根据题目信息选择区间范围
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">upd</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>p, LL k, <span style="color:#66d9ef">int</span> len){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p) p <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt;
</span></span><span style="display:flex;"><span>    val(p) <span style="color:#f92672">+=</span> k <span style="color:#f92672">*</span> len;
</span></span><span style="display:flex;"><span>    tag(p) <span style="color:#f92672">+=</span> k;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">spreadTag</span>(<span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> len){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(len<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    upd(ls(p), tag(p), len<span style="color:#f92672">-</span>len<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    upd(rs(p), tag(p), len<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    tag(p) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> L, <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> R){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">&gt;=</span>l <span style="color:#f92672">&amp;&amp;</span> t<span style="color:#f92672">&lt;=</span>r) <span style="color:#66d9ef">return</span> val(p);
</span></span><span style="display:flex;"><span>    spreadTag(p, t<span style="color:#f92672">-</span>s<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> getMid(s,t);
</span></span><span style="display:flex;"><span>    LL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(mid <span style="color:#f92672">&gt;=</span> l) ret <span style="color:#f92672">+=</span> query(l, r, ls(p), s, mid);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(mid <span style="color:#f92672">&lt;</span> r)  ret <span style="color:#f92672">+=</span> query(l, r, rs(p), mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, t);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, LL k, <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> L, <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> R){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">&gt;=</span>l <span style="color:#f92672">&amp;&amp;</span> t<span style="color:#f92672">&lt;=</span>r){
</span></span><span style="display:flex;"><span>        val(p) <span style="color:#f92672">+=</span> k <span style="color:#f92672">*</span> (t<span style="color:#f92672">-</span>s<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        tag(p) <span style="color:#f92672">+=</span> k;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    spreadTag(p, t<span style="color:#f92672">-</span>s<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> getMid(s,t);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(mid <span style="color:#f92672">&gt;=</span> l) add(l, r, k, ls(p), s, mid);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(mid <span style="color:#f92672">&lt;</span> r)  add(l, r, k, rs(p), mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, t);
</span></span><span style="display:flex;"><span>    val(p) <span style="color:#f92672">=</span> val(ls(p)) <span style="color:#f92672">+</span> val(rs(p));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> offset <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">5e4</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>a;
</span></span><span style="display:flex;"><span>        add(i<span style="color:#f92672">+</span>offset,i<span style="color:#f92672">+</span>offset,a);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(m<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ope, l, r, x;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>ope<span style="color:#f92672">&gt;&gt;</span>l<span style="color:#f92672">&gt;&gt;</span>r;
</span></span><span style="display:flex;"><span>        l <span style="color:#f92672">+=</span> offset;
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">+=</span> offset;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(ope<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>x;
</span></span><span style="display:flex;"><span>            add(l,r,x);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>query(l,r)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="权值线段树">权值线段树</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//权值线段树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//loj 104
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//权值线段树大部分时候是用来代替平衡树使用的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//和树状数组求逆序对很像，他把每一个[x,x]范围上的节点视作一个桶，插入数据时，add(x,x,1)，删除一个时add(x,x,-1)。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//查询复杂度为O(logv)，v为值域
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*这里是动态开点线段树的核心代码*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> v){<span style="color:#75715e">//插入一个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    add(v,v,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove</span>(<span style="color:#66d9ef">int</span> v){<span style="color:#75715e">//删除一个数，相同的只删一个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    add(v,v,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">countL</span>(<span style="color:#66d9ef">int</span> v){<span style="color:#75715e">//计算小于v的数的个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> query(L, v<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">countG</span>(<span style="color:#66d9ef">int</span> v){<span style="color:#75715e">//计算大于v的数的个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> query(v<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, R);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rank</span>(<span style="color:#66d9ef">int</span> v){<span style="color:#75715e">//求v的排名，即小于v的数的个数+1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> countL(v)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kth</span>(<span style="color:#66d9ef">int</span> k, <span style="color:#66d9ef">int</span> p<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span>L, <span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span>R){<span style="color:#75715e">//查询排名第k的数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==</span>t) <span style="color:#66d9ef">return</span> s;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> getMid(s,t);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(val(ls(p)) <span style="color:#f92672">&gt;=</span> k)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> kth(k, ls(p), s, mid);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> kth(k<span style="color:#f92672">-</span>val(ls(p)), rs(p), mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, t);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pre</span>(<span style="color:#66d9ef">int</span> v){<span style="color:#75715e">//查询v的前驱，即第一个比v小的数，可能需要保证一定存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> countL(v);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> kth(r);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">suc</span>(<span style="color:#66d9ef">int</span> v){<span style="color:#75715e">//查询v的后继
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> val(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">-</span> countG(v) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> kth(r);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="可持久化线段树">可持久化线段树</h2>
<h3 id="单点修改">单点修改</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//可持久化线段树，单点修改、区间查询，操作复杂度logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p3919
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//可持久化线段树是完全可持久化的，意味着可以查询历史修改，以及对每一个历史状态都可以再修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXV <span style="color:#f92672">=</span> <span style="color:#ae81ff">3e7</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e6</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    LL val;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ls,  rs;
</span></span><span style="display:flex;"><span>}st[MAXV];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> ls(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> st[x].ls;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> rs(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> st[x].rs;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> LL<span style="color:#f92672">&amp;</span> val(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> st[x].val;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getMid</span>(<span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> t){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">+</span>t<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">+</span>t<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> (s<span style="color:#f92672">+</span>t)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>((<span style="color:#f92672">-</span>s<span style="color:#f92672">-</span>t<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> stcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> L <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, R <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e6</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;<span style="color:#75715e">//这里根据题目信息选择区间范围
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL arr[MAXN], roots[MAXN];<span style="color:#75715e">//arr存初始数组，roots[i]表示第i次操作的根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build</span>(<span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span>L, <span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span>R, <span style="color:#66d9ef">int</span> p<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//一般不会完全动态开点，会把初始状态建树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==</span>t) val(p) <span style="color:#f92672">=</span> arr[s];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        ls(p) <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt, rs(p) <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> getMid(s,t);
</span></span><span style="display:flex;"><span>        build(s,mid,ls(p));
</span></span><span style="display:flex;"><span>        build(mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,t,rs(p));
</span></span><span style="display:flex;"><span>        val(p) <span style="color:#f92672">=</span> val(ls(p)) <span style="color:#f92672">+</span> val(rs(p));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">assign</span>(<span style="color:#66d9ef">int</span> i, LL k, <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> q, <span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span>L, <span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span>R){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//这里是单点修改操作，如果改成区间加，则下一行改成val(q)=val(p)+k
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//修改第i位为k，对版本x的根节点p进行修改，修改完为版本y的根节点q
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==</span>t) val(q) <span style="color:#f92672">=</span> k;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        ls(q) <span style="color:#f92672">=</span> ls(p), rs(q) <span style="color:#f92672">=</span> rs(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> getMid(s,t);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;=</span>mid) ls(q) <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt, assign(i,k,ls(p),ls(q),s,mid);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> rs(q) <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt, assign(i,k,rs(p),rs(q),mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,t);
</span></span><span style="display:flex;"><span>        val(q) <span style="color:#f92672">=</span> val(ls(q)) <span style="color:#f92672">+</span> val(rs(q));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span>L, <span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span>R){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//查询区间和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//对版本p查询
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">&gt;</span>r <span style="color:#f92672">||</span> t<span style="color:#f92672">&lt;</span>l) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">&gt;=</span>l <span style="color:#f92672">&amp;&amp;</span> t<span style="color:#f92672">&lt;=</span>r) <span style="color:#66d9ef">return</span> val(p);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> getMid(s,t);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> query(l,r,ls(p),s,mid) <span style="color:#f92672">+</span> query(l,r,rs(p),mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>R<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>L;i<span style="color:#f92672">&lt;=</span>R;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>arr[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    build();
</span></span><span style="display:flex;"><span>    roots[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//别忘了初始化初始区间的根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;t<span style="color:#f92672">&lt;=</span>m;t<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> v, o;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>o;<span style="color:#75715e">//v是对第v个版本操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(o<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> i;LL k;
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>i<span style="color:#f92672">&gt;&gt;</span>k;
</span></span><span style="display:flex;"><span>            roots[t] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt;<span style="color:#75715e">//本题的修改和查询都算一个版本
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            assign(i,k,roots[v],roots[t]);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//注意你把第1个版本修改为第5个，不会对2、3、4版本产生影响
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>i;
</span></span><span style="display:flex;"><span>            roots[t] <span style="color:#f92672">=</span> roots[v];<span style="color:#75715e">//虽然修改也算一个版本，但是可以和之前的合并
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>query(i,i,roots[v])<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="区间修改">区间修改</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//可持久化线段树，区间修改、区间查询，操作复杂度logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//hdu 4348
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXV <span style="color:#f92672">=</span> <span style="color:#ae81ff">3e6</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    LL val, tag;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ls,  rs;
</span></span><span style="display:flex;"><span>}st[MAXV];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> ls(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> st[x].ls;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> rs(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> st[x].rs;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> LL<span style="color:#f92672">&amp;</span> val(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> st[x].val;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> LL<span style="color:#f92672">&amp;</span> tag(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> st[x].tag;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getMid</span>(<span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> t){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">+</span>t<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">+</span>t<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> (s<span style="color:#f92672">+</span>t)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>((<span style="color:#f92672">-</span>s<span style="color:#f92672">-</span>t<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> stcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> L <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, R <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e6</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;<span style="color:#75715e">//这里根据题目信息选择区间范围
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL arr[MAXN], roots[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build</span>(<span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span>L, <span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span>R, <span style="color:#66d9ef">int</span> p<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==</span>t) val(p) <span style="color:#f92672">=</span> arr[s], tag(p) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        ls(p) <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt, rs(p) <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> getMid(s,t);
</span></span><span style="display:flex;"><span>        build(s,mid,ls(p));
</span></span><span style="display:flex;"><span>        build(mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,t,rs(p));
</span></span><span style="display:flex;"><span>        val(p) <span style="color:#f92672">=</span> val(ls(p)) <span style="color:#f92672">+</span> val(rs(p));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, LL k, <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> q, <span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span>L, <span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span>R){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//l,r是修改范围，其他同单点修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ls(q) <span style="color:#f92672">=</span> ls(p), rs(q) <span style="color:#f92672">=</span> rs(p), tag(q) <span style="color:#f92672">=</span> tag(p);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>s <span style="color:#f92672">&amp;&amp;</span> t<span style="color:#f92672">&lt;=</span>r){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(t<span style="color:#f92672">&gt;</span>s) tag(q) <span style="color:#f92672">+=</span> k;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> getMid(s,t);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">&lt;=</span>r <span style="color:#f92672">&amp;&amp;</span> mid<span style="color:#f92672">&gt;=</span>l) ls(q) <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt, add(l,r,k,ls(p),ls(q),s,mid);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;=</span>r <span style="color:#f92672">&amp;&amp;</span> t<span style="color:#f92672">&gt;=</span>l) rs(q) <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt, add(l,r,k,rs(p),rs(q),mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    val(q) <span style="color:#f92672">=</span> val(p) <span style="color:#f92672">+</span> (std<span style="color:#f92672">::</span>min(r,t)<span style="color:#f92672">-</span>std<span style="color:#f92672">::</span>max(l,s)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>k;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> p, LL tg<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span>L, <span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span>R){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//l,r是修改范围，tg是一种标记永久化的技术，其他同单点修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">&gt;</span>r <span style="color:#f92672">||</span> t<span style="color:#f92672">&lt;</span>l) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">&gt;=</span>l <span style="color:#f92672">&amp;&amp;</span> t<span style="color:#f92672">&lt;=</span>r) <span style="color:#66d9ef">return</span> val(p) <span style="color:#f92672">+</span> tg<span style="color:#f92672">*</span>(t<span style="color:#f92672">-</span>s<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> getMid(s,t);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> query(l,r,ls(p),tg<span style="color:#f92672">+</span>tag(p),s,mid) <span style="color:#f92672">+</span> query(l,r,rs(p),tg<span style="color:#f92672">+</span>tag(p),mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>L;i<span style="color:#f92672">&lt;=</span>R;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>arr[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    stcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    build();
</span></span><span style="display:flex;"><span>    roots[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> time <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//本题只有加数才算进行一次版本修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(m<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span> o;<span style="color:#66d9ef">int</span> l,r;LL d;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>o;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(o<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;C&#39;</span>){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>l<span style="color:#f92672">&gt;&gt;</span>r<span style="color:#f92672">&gt;&gt;</span>d;<span style="color:#75715e">//[l,r]上每个数+d
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            time<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            roots[time] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt;
</span></span><span style="display:flex;"><span>            add(l,r,d,roots[time<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],roots[time]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(o<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;Q&#39;</span>){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>l<span style="color:#f92672">&gt;&gt;</span>r;<span style="color:#75715e">//查询当前版本[l,r]和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>query(l,r,roots[time])<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(o<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;H&#39;</span>){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>l<span style="color:#f92672">&gt;&gt;</span>r<span style="color:#f92672">&gt;&gt;</span>d;<span style="color:#75715e">//查询版本d的[l,r]和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>query(l,r,roots[d])<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(o<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;B&#39;</span>){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>d;<span style="color:#75715e">//把版本倒回d，中间的版本失效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            time <span style="color:#f92672">=</span> d;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">signed</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span>(std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>R){<span style="color:#75715e">//本题多组数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    solve();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="主席树可持久化权值线段树">主席树（可持久化权值线段树）</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//主席树，查询静态区间第k小，复杂度logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p3834
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXV <span style="color:#f92672">=</span> <span style="color:#ae81ff">8e6</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">2e5</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    LL val;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ls,  rs;
</span></span><span style="display:flex;"><span>}st[MAXV];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> ls(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> st[x].ls;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> rs(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> st[x].rs;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> LL<span style="color:#f92672">&amp;</span> val(<span style="color:#66d9ef">int</span> x){<span style="color:#66d9ef">return</span> st[x].val;}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getMid</span>(<span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> t){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//处理负数边界时，需要强行向下取整，而不是向零取整
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">+</span>t<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">+</span>t<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> (s<span style="color:#f92672">+</span>t)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>((<span style="color:#f92672">-</span>s<span style="color:#f92672">-</span>t<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> stcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> L <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, R <span style="color:#f92672">=</span> <span style="color:#ae81ff">2e5</span><span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build</span>(<span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span>L, <span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span>R, <span style="color:#66d9ef">int</span> p<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//初始化建成全0的，因为主席树是权值线段树的可持久化版
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    val(p) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">!=</span>t){
</span></span><span style="display:flex;"><span>        ls(p) <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt, rs(p) <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> getMid(s,t);
</span></span><span style="display:flex;"><span>        build(s,mid,ls(p));
</span></span><span style="display:flex;"><span>        build(mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,t,rs(p));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> i, LL k, <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> q, <span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span>L, <span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span>R){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//参数同单点修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==</span>t) val(q) <span style="color:#f92672">=</span> val(p) <span style="color:#f92672">+</span> k;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        ls(q) <span style="color:#f92672">=</span> ls(p), rs(q) <span style="color:#f92672">=</span> rs(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> getMid(s,t);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;=</span>mid) ls(q) <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt, add(i,k,ls(p),ls(q),s,mid);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> rs(q) <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt, add(i,k,rs(p),rs(q),mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,t);
</span></span><span style="display:flex;"><span>        val(q) <span style="color:#f92672">=</span> val(ls(q)) <span style="color:#f92672">+</span> val(rs(q));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[MAXN], disc[MAXN], assi[MAXN],ori[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//arr是输入的原数组，disc是离散化后的，assi是临时的辅助数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//ori[i]代表着在arr里排名为i的数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> roots[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kth</span>(<span style="color:#66d9ef">int</span> k, <span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> q, <span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span>L, <span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span>R){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==</span>t) <span style="color:#66d9ef">return</span> ori[s];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> getMid(s,t);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(val(ls(q)) <span style="color:#f92672">-</span> val(ls(p))<span style="color:#f92672">&gt;=</span>k){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> kth(k, ls(p), ls(q), s, mid);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> kth(k<span style="color:#f92672">-</span>(val(ls(q))<span style="color:#f92672">-</span>val(ls(p))), rs(p), rs(q), mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lrkth</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> k){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//查询数组arr的[l,r]区间中第k小的数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> kth(k,roots[l<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],roots[r]);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>R<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>L;i<span style="color:#f92672">&lt;=</span>R;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>arr[i];
</span></span><span style="display:flex;"><span>        disc[i] <span style="color:#f92672">=</span> assi[i] <span style="color:#f92672">=</span> arr[i]; 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(assi<span style="color:#f92672">+</span>L,assi<span style="color:#f92672">+</span>R<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> last <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>unique(assi<span style="color:#f92672">+</span>L,assi<span style="color:#f92672">+</span>R<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">-</span> (assi<span style="color:#f92672">+</span>L);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>L;i<span style="color:#f92672">&lt;=</span>R;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        disc[i] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>lower_bound(assi<span style="color:#f92672">+</span>L,assi<span style="color:#f92672">+</span>last,disc[i]) <span style="color:#f92672">-</span> (assi<span style="color:#f92672">+</span>L)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        ori[disc[i]] <span style="color:#f92672">=</span> arr[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//这上面都是离散化和数据输入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    build();
</span></span><span style="display:flex;"><span>    roots[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>L;i<span style="color:#f92672">&lt;=</span>R;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        roots[i] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt;
</span></span><span style="display:flex;"><span>        add(disc[i],<span style="color:#ae81ff">1</span>,roots[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],roots[i]);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//和权值线段树的思路一致
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(m<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> l,r,k;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>l<span style="color:#f92672">&gt;&gt;</span>r<span style="color:#f92672">&gt;&gt;</span>k;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>lrkth(l,r,k)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="线段树合并">线段树合并</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//线段树合并，合并复杂度大概是O(klogN)，N是值域，k是若干线段树一共进行过k次插入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p3224
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//动态开点线段树，之前的各种操作中都有p=1这一参数默认值，这其实是根节点的意思。也就是如果我们设置不同的p，可以开多颗线段树。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//线段树合并就是把重合位置的节点的值加起来，对于没有重合位置的节点则原地保留，常常用于权值线段树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">merge</span>(<span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> q, <span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span>L, <span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span>R){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//不新开空间的合并方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//把q为根的树合并到p为根的树上，返回p，即新根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//由于各题不一样，所以要在合并后手动把roots[j]指定为p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p<span style="color:#f92672">||!</span>q) <span style="color:#66d9ef">return</span> p<span style="color:#f92672">+</span>q;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==</span>t) <span style="color:#66d9ef">return</span> val(p)<span style="color:#f92672">+=</span>val(q), p;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> getMid(s,t);
</span></span><span style="display:flex;"><span>    ls(p) <span style="color:#f92672">=</span> merge(ls(p), ls(q), s, mid);
</span></span><span style="display:flex;"><span>    rs(p) <span style="color:#f92672">=</span> merge(rs(p), rs(q), mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, t);
</span></span><span style="display:flex;"><span>    val(p) <span style="color:#f92672">=</span> val(ls(p)) <span style="color:#f92672">+</span> val(rs(p));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">merge</span>(<span style="color:#66d9ef">int</span> p, <span style="color:#66d9ef">int</span> q, <span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span>L, <span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span>R){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//新开空间的合并方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//把p,q为根的两棵树合并到r为根的树上，返回r，即新根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//由于各题不一样，所以要在合并后手动把roots[i]和[j]指定为r
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>p<span style="color:#f92672">||!</span>q) <span style="color:#66d9ef">return</span> p<span style="color:#f92672">+</span>q;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>stcnt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==</span>t) <span style="color:#66d9ef">return</span> val(r) <span style="color:#f92672">=</span> val(p)<span style="color:#f92672">+</span>val(q), r;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> getMid(s,t);
</span></span><span style="display:flex;"><span>    ls(r) <span style="color:#f92672">=</span> merge(ls(p), ls(q), s, mid);
</span></span><span style="display:flex;"><span>    rs(r) <span style="color:#f92672">=</span> merge(rs(p), rs(q), mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, t);
</span></span><span style="display:flex;"><span>    val(r) <span style="color:#f92672">=</span> val(ls(r)) <span style="color:#f92672">+</span> val(rs(r));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> r;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="珂朵莉树">珂朵莉树</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span><span style="color:#75715e">//珂朵莉树，区间推平问题
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//方便给某个区间赋值，区间加数，维护区间第k大值，区间和等等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//数据随机的情况下，复杂度为nloglogn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//珂朵莉树的每一个节点都是一个区间，这个区间内的值相同。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//cf896c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> l,r;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">mutable</span> LL v;<span style="color:#75715e">//这里修改成自己需要的数据类型，在[l,r]内都等于这个值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Node(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, LL v)<span style="color:#f92672">:</span>l(l),r(r),v(v){}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(Node <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> x) <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> l<span style="color:#f92672">&lt;</span>x.l;}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ODT</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span> tree;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> <span style="color:#a6e22e">split</span>(<span style="color:#66d9ef">int</span> pos){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> tree.lower_bound(Node(pos,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(it<span style="color:#f92672">!=</span>tree.end() <span style="color:#f92672">&amp;&amp;</span> it<span style="color:#f92672">-&gt;</span>l<span style="color:#f92672">==</span>pos)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> it;
</span></span><span style="display:flex;"><span>        it<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>l, r <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>r;
</span></span><span style="display:flex;"><span>        LL v <span style="color:#f92672">=</span> it<span style="color:#f92672">-&gt;</span>v;
</span></span><span style="display:flex;"><span>        tree.erase(it);
</span></span><span style="display:flex;"><span>        tree.insert(Node(l,pos<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,v));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> tree.insert(Node(pos,r,v)).first;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">assign</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> v){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//给区间赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">auto</span> end <span style="color:#f92672">=</span> split(r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>), begin <span style="color:#f92672">=</span> split(l);<span style="color:#75715e">//必须要注意顺序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        tree.erase(begin,end);
</span></span><span style="display:flex;"><span>        tree.insert(Node(l,r,v));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">perf</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r){<span style="color:#75715e">//其他操作的模板函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">auto</span> end <span style="color:#f92672">=</span> split(r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>), begin <span style="color:#f92672">=</span> split(l);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> it<span style="color:#f92672">=</span>begin;it<span style="color:#f92672">!=</span>end;it<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//这里是操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//这些操作都很暴力，例如k大值，就把区间全部枚举排序一遍去找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//例如区间和，就枚举区间加起来，注意是加it-&gt;v * (it-&gt;r-it-&gt;l+1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//例如区间加数，就枚举区间给所有的it-&gt;v都加一个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//珂朵莉树的初始化不能用assign，设范围为[1,w]，初值全部为0，则
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ODT odt;
</span></span><span style="display:flex;"><span>odt.tree.insert(Node(<span style="color:#ae81ff">1</span>,w,<span style="color:#ae81ff">0</span>));
</span></span></code></pre></div><h2 id="分块">分块</h2>
<p>分块是根号算法，比线段树略差，但是不需要满足结合律，也不需要传递tag。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//luogu p3372 和线段树区间加，维护区间和一样
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//复杂度n sqrt(n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//在块内时对块操作，跨块时中间对块操作，两边多余部分暴力处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL arr[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BA</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> st[MAXN],ed[MAXN],size[MAXN],bel[MAXN];<span style="color:#75715e">//每一段的开始下标、结束下标、段大小；每个元素属于哪个段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> sq;
</span></span><span style="display:flex;"><span>    LL sum[MAXN];<span style="color:#75715e">//保存第i个块的和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL tag[MAXN];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>        sq <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>sqrt(n);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>sq;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            st[i] <span style="color:#f92672">=</span> n <span style="color:#f92672">/</span> sq <span style="color:#f92672">*</span> (i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            ed[i] <span style="color:#f92672">=</span> n <span style="color:#f92672">/</span> sq <span style="color:#f92672">*</span> i;
</span></span><span style="display:flex;"><span>            size[i] <span style="color:#f92672">=</span> ed[i] <span style="color:#f92672">-</span> st[i] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        ed[sq] <span style="color:#f92672">=</span> n;<span style="color:#75715e">//最后一段可能长度不够n/sq
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        size[sq] <span style="color:#f92672">=</span> ed[sq] <span style="color:#f92672">-</span> st[sq] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>sq;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>st[i];j<span style="color:#f92672">&lt;=</span>ed[i];j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                bel[j] <span style="color:#f92672">=</span> i, sum[i] <span style="color:#f92672">+=</span> arr[j];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, LL k){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(bel[l]<span style="color:#f92672">==</span>bel[r]){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>l;i<span style="color:#f92672">&lt;=</span>r;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                arr[i]<span style="color:#f92672">+=</span>k;
</span></span><span style="display:flex;"><span>                sum[bel[i]] <span style="color:#f92672">+=</span> k;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>l;i<span style="color:#f92672">&lt;=</span>ed[bel[l]];i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            arr[i]<span style="color:#f92672">+=</span>k;
</span></span><span style="display:flex;"><span>            sum[bel[i]]<span style="color:#f92672">+=</span>k;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>st[bel[r]];i<span style="color:#f92672">&lt;=</span>r;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            arr[i]<span style="color:#f92672">+=</span>k;
</span></span><span style="display:flex;"><span>            sum[bel[i]]<span style="color:#f92672">+=</span>k;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>bel[l]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>bel[r];i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            tag[i] <span style="color:#f92672">+=</span> k;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    LL <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r){
</span></span><span style="display:flex;"><span>        LL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(bel[l]<span style="color:#f92672">==</span>bel[r]){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>l;i<span style="color:#f92672">&lt;=</span>r;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                ret <span style="color:#f92672">+=</span> arr[i] <span style="color:#f92672">+</span> tag[bel[i]];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>l;i<span style="color:#f92672">&lt;=</span>ed[bel[l]];i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            ret <span style="color:#f92672">+=</span> arr[i] <span style="color:#f92672">+</span> tag[bel[i]];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>st[bel[r]];i<span style="color:#f92672">&lt;=</span>r;i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            ret <span style="color:#f92672">+=</span> arr[i] <span style="color:#f92672">+</span> tag[bel[i]]; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>bel[l]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>bel[r];i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>            ret <span style="color:#f92672">+=</span> sum[i] <span style="color:#f92672">+</span> tag[i] <span style="color:#f92672">*</span> size[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>BA ba;<span style="color:#75715e">//注意，开了大数组，要声明在main函数外面，或者可以去用动态分配内存
</span></span></span></code></pre></div><h2 id="平衡树pbds实现">平衡树（pbds实现）</h2>
<p>平衡树在ACM中用的极少，就不手搓了，大部分情况下都可以用set和pbds搞定。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;ext/pb_ds/assoc_container.hpp&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;ext/pb_ds/tree_policy.hpp&gt; //仅限g++可以使用</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> pbds <span style="color:#f92672">=</span> __gnu_pbds;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pbds<span style="color:#f92672">::</span>tree<span style="color:#f92672">&lt;</span>LL, pbds<span style="color:#f92672">::</span>null_type, std<span style="color:#f92672">::</span>less<span style="color:#f92672">&lt;</span>LL<span style="color:#f92672">&gt;</span>, 
</span></span><span style="display:flex;"><span>           pbds<span style="color:#f92672">::</span>rb_tree_tag, pbds<span style="color:#f92672">::</span>tree_order_statistics_node_update<span style="color:#f92672">&gt;</span> tr;
</span></span></code></pre></div><p>声明如上，还是挺复杂的，但是ACM可以带资料所以不成问题。需要注意只能在g++上用，ACM赛场大多都有g++所以不是问题。</p>
<p><strong>模板参数解释</strong></p>
<p>LL是存储数据的类型；</p>
<p>pbds::null_type是映射规则（低版本g++为pbds::null_mapped_type，如果存入类型为std::map&lt;Key,Value&gt;则要填入Value）；</p>
<p>std::less&lt;LL&gt;则是我们选择大根还是小根；可选参数，默认为less</p>
<p>pbds::rb_tree_tag 则是我们选择的树的类型。总共有三种平衡树在pbds里，红黑树、splay、ov，但是后两个容易超时，一般不用。可选参数，默认为红黑树</p>
<p>pbds::tree_order_statistics_node_update是节点更新方法，如果使用order_of_key和find_by_key方法，则要用它。可选参数，但默认是null_node_update。</p>
<p><strong>方法</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>tr.insert(x); <span style="color:#75715e">//插入一个元素x，返回std::pair&lt;point_iterator, bool&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//若成功，则是插入之后的迭代器和true，否则是x的迭代器和false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>tr.erase(x);  <span style="color:#75715e">//成功返回true，也可以把迭代器作为参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>tr.order_of_key(x);  <span style="color:#75715e">//返回x的排名，0为第一名，x不一定要在树里
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>tr.find_by_order(k); <span style="color:#75715e">//返回排名为k的元素的迭代器，0为第一名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>tr.lower_bound(x);   <span style="color:#75715e">//返回迭代器，这个函数不用多说了吧，和经常见到的一样
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>tr.upper_bound(x);   <span style="color:#75715e">//返回迭代器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>tr.join(b);          <span style="color:#75715e">//将b树并入当前树，两棵树的类型要一样，不能有重复元素，b树将会被删除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>tr.split(x,b);       <span style="color:#75715e">//小于等于x的保留在当前树，其他分给b树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>tr.empty();
</span></span><span style="display:flex;"><span>tr.size();
</span></span></code></pre></div><p>以上操作均为O(logn)复杂度，除了最后两个是O(1)</p>
<p><strong>注意事项</strong></p>
<p>tree里面的元素是唯一的，有点类似与set。但我们并没有multi-tree去使用，做例如洛谷上的平衡树模板题，他要求元素可重复。此时我们有以下奇技淫巧</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>LL n;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> ope;
</span></span><span style="display:flex;"><span>	LL x;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>ope<span style="color:#f92672">&gt;&gt;</span>x;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span>(ope<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>) tr.insert((x<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">20</span>)<span style="color:#f92672">+</span>i);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(ope<span style="color:#f92672">==</span><span style="color:#ae81ff">2</span>) tr.erase(tr.lower_bound(x<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">20</span>));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(ope<span style="color:#f92672">==</span><span style="color:#ae81ff">3</span>) std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>tr.order_of_key(x<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">20</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(ope<span style="color:#f92672">==</span><span style="color:#ae81ff">4</span>) std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>((<span style="color:#f92672">*</span>tr.find_by_order(x<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">20</span>)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(ope<span style="color:#f92672">==</span><span style="color:#ae81ff">5</span>){
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> tr.lower_bound(x<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">20</span>);
</span></span><span style="display:flex;"><span>	    it<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>	    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>((<span style="color:#f92672">*</span>it)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">20</span>)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> tr.upper_bound((x<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">20</span>)<span style="color:#f92672">+</span>n);
</span></span><span style="display:flex;"><span>    	std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>((<span style="color:#f92672">*</span>it)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">20</span>)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>假设有<span class="math inline">\(n\)</span>个操作，共<span class="math inline">\(6\)</span>种</p>
<ol>
<li>插入<span class="math inline">\(x\)</span></li>
<li>删除<span class="math inline">\(x\)</span></li>
<li>查询<span class="math inline">\(x\)</span>的排名（比<span class="math inline">\(x\)</span>小的数的个数<span class="math inline">\(+1\)</span>）</li>
<li>查询排名为<span class="math inline">\(x\)</span>的数</li>
<li>求小于<span class="math inline">\(x\)</span>的最大的数</li>
<li>求大于<span class="math inline">\(x\)</span>的最小的数</li>
</ol>
<p>看代码，我们将<span class="math inline">\(x\)</span>左移20位，加上了操作序号，这样我们就可以实现可重复插入。只需要我们再最后把数字右移20位回来即可。erase注意是加入迭代器去erase，因为我们并没有等于x&lt;&lt;20的数字。最后一个操作，要<span class="math inline">\(+n\)</span>，来处理所有的相等的<span class="math inline">\(x\)</span></p>
<h2 id="01字典树">01字典树</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//01字典树，复杂度线性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//HDU4825
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">3500005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXBIT <span style="color:#f92672">=</span> <span style="color:#ae81ff">35</span>;<span style="color:#75715e">//注意题目给的数据范围，这里2^32以下可以处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Trie</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nxt[MAXN][<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> cnt;
</span></span><span style="display:flex;"><span>    LL num[MAXN];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;=</span>cnt;i<span style="color:#f92672">++</span>) <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span>;j<span style="color:#f92672">++</span>) nxt[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;=</span>cnt;i<span style="color:#f92672">++</span>) num[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(LL n){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//插入一个自然数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(LL i<span style="color:#f92672">=</span>MAXBIT;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>            LL bit <span style="color:#f92672">=</span> (n<span style="color:#f92672">&gt;&gt;</span>i)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>nxt[cur][bit]){
</span></span><span style="display:flex;"><span>                nxt[cur][bit] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>cnt;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">=</span> nxt[cur][bit];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        num[cur] <span style="color:#f92672">=</span> n;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    LL <span style="color:#a6e22e">find_max</span>(LL x){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//查询x与数组内的所有数的异或的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> cur<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>MAXBIT;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>            LL bit <span style="color:#f92672">=</span> (x<span style="color:#f92672">&gt;&gt;</span>i)<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(nxt[cur][bit<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>])<span style="color:#75715e">//尽量走与当前位不同的路径，最小值应改为走相同的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                cur <span style="color:#f92672">=</span> nxt[cur][bit<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                cur <span style="color:#f92672">=</span> nxt[cur][bit];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> x<span style="color:#f92672">^</span>num[cur];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Trie trie;
</span></span></code></pre></div><p>可以通过01Trie来计算连续区间的异或最大值。要用到一个性质：</p>
<p><span class="math display">\[a\oplus b\oplus b = a
\]</span></p>
<p>也就是说，我们可以把异或前缀全部插入到Trie里，然后以第i个数为结尾的区间的最大异或值就是find_max(pre[i])。注意特殊处理长度为1的区间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>LL ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>arr[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>arr[i];
</span></span><span style="display:flex;"><span>	ans <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(ans,arr[i]);
</span></span><span style="display:flex;"><span>	arr[i] <span style="color:#f92672">^=</span> arr[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]; 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>trie.insert(<span style="color:#ae81ff">0</span>);<span style="color:#75715e">//注意要先插入一个0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>	ans <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(ans,trie.find_max(arr[i]));
</span></span><span style="display:flex;"><span>	trie.insert(arr[i]);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span></code></pre></div><h2 id="对顶堆">对顶堆</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//动态维护一个集合的第k大数，每次操作logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//spoj RMID2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//维护第k小只要维护第n-k大即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//另外这个k是可以变化的，不需要固定，复杂度确实是logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">KthLargest</span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>priority_queue<span style="color:#f92672">&lt;</span>T,std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>,std<span style="color:#f92672">::</span>less<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> big{};
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>priority_queue<span style="color:#f92672">&lt;</span>T,std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>,std<span style="color:#f92672">::</span>greater<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> small{};
</span></span><span style="display:flex;"><span>    size_t kth{};
</span></span><span style="display:flex;"><span>    size_t size{};
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(){
</span></span><span style="display:flex;"><span>        kth <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(kth,size);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(kth<span style="color:#f92672">&lt;</span>small.size()){
</span></span><span style="display:flex;"><span>            big.push(small.top());
</span></span><span style="display:flex;"><span>            small.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(kth<span style="color:#f92672">&gt;</span>small.size()){
</span></span><span style="display:flex;"><span>            small.push(big.top());
</span></span><span style="display:flex;"><span>            big.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    KthLargest()<span style="color:#f92672">:</span>kth(<span style="color:#ae81ff">1</span>),size(<span style="color:#ae81ff">0</span>){}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    T <span style="color:#a6e22e">findK</span>(size_t k){
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//找到第k大的数字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        kth <span style="color:#f92672">=</span> k;
</span></span><span style="display:flex;"><span>        update();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> small.top();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">eraseK</span>(size_t k){
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//移除第k大的数字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        kth <span style="color:#f92672">=</span> k;
</span></span><span style="display:flex;"><span>        update();
</span></span><span style="display:flex;"><span>        small.pop();
</span></span><span style="display:flex;"><span>        size<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        update();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(T x){
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//插入一个数字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        size<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(small.empty() <span style="color:#f92672">||</span> x<span style="color:#f92672">&gt;=</span>small.top()){
</span></span><span style="display:flex;"><span>            small.push(x);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            big.push(x);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        update();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    size_t <span style="color:#a6e22e">getSize</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> size;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>KthLargest<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ddd;
</span></span></code></pre></div><h2 id="单调栈">单调栈</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//单调栈 luogu p5788
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//本题定义f[i]为数列中第i个元素之后第一个大于a[i]的元素的下标（不存在则为0）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//很显然我们可以维护一个单调不增的栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//当push的元素x大于栈顶t时，第一个大于t的元素就是x。反复出栈直到栈顶t小于等于x或栈空，入栈。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//复杂度 n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> arr[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> ans[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> stk[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>arr[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> top <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(top<span style="color:#f92672">&amp;&amp;</span>arr[stk[top]]<span style="color:#f92672">&lt;</span>arr[i]){
</span></span><span style="display:flex;"><span>            ans[stk[top]] <span style="color:#f92672">=</span> i;<span style="color:#75715e">//这一行是具体的操作，因题而异；而其他行在这个for循环里都是固定的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            top<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        stk[<span style="color:#f92672">++</span>top] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="单调队列">单调队列</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//单调队列，luogu1886
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//本题是滑动窗口，即在长度为n的数组中，给出一个长度为k的连续区间，从左向右滑动，求每个区间中的最大值和最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//求最小值时，我们可以维护一个单增的双端队列。x加入队尾时，如果队尾元素b&gt;=x，则把队尾弹出，直到b&lt;x或者栈空时把x入队。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//因为我们的区间长度有限，每次我们的区间左端点向右枚举+1时，判断队首元素的下标，如果小于区间左端点，就出队。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//之后留在队首的元素就是区间最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//具体可见代码。最大值维护同理。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//复杂度n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> arr[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,k;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>arr[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>deque<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dq;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>k;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>dq.empty()<span style="color:#f92672">&amp;&amp;</span>arr[dq.back()]<span style="color:#f92672">&gt;=</span>arr[i]) dq.pop_back();
</span></span><span style="display:flex;"><span>        dq.push_back(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>k;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>dq.empty()<span style="color:#f92672">&amp;&amp;</span>arr[dq.back()]<span style="color:#f92672">&gt;=</span>arr[i]) dq.pop_back();
</span></span><span style="display:flex;"><span>        dq.push_back(i);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(dq.front()<span style="color:#f92672">&lt;=</span>i<span style="color:#f92672">-</span>k) dq.pop_front();
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>arr[dq.front()]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;<span style="color:#75715e">//输出最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    dq.clear();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>k;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>dq.empty()<span style="color:#f92672">&amp;&amp;</span>arr[dq.back()]<span style="color:#f92672">&lt;=</span>arr[i]) dq.pop_back();
</span></span><span style="display:flex;"><span>        dq.push_back(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>k;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>dq.empty()<span style="color:#f92672">&amp;&amp;</span>arr[dq.back()]<span style="color:#f92672">&lt;=</span>arr[i]) dq.pop_back();
</span></span><span style="display:flex;"><span>        dq.push_back(i);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(dq.front()<span style="color:#f92672">&lt;=</span>i<span style="color:#f92672">-</span>k) dq.pop_front();
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>arr[dq.front()]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;<span style="color:#75715e">//输出最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="st表">ST表</h2>
<p>对于经典的RMQ（即给定一个数组，求区间内的最大值）问题，有如下代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 单次查询 logn 预处理 nlogn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P3865
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//查询区间最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//也可以查询其他可重复贡献问题的信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//可重复贡献指对于运算op，满足x op x = x。这样的运算有最大最小、gcd等。但显然求和不是。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//另外op还必须满足结合律。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> LOGN <span style="color:#f92672">=</span> <span style="color:#ae81ff">21</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> fmax[MAXN][LOGN<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//fmax[a][b]表示[a,a+2^b-1]中的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> logn[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//预先计算logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//数组大小以及查询次数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>n,<span style="color:#f92672">&amp;</span>m);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>fmax[i][<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    logn[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    logn[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>;i<span style="color:#f92672">&lt;</span>MAXN;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        logn[i] <span style="color:#f92672">=</span> logn[i<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//预先计算logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>LOGN;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">+</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span>j)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            fmax[i][j] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(fmax[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],fmax[i<span style="color:#f92672">+</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span>(j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b;
</span></span><span style="display:flex;"><span>        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>a,<span style="color:#f92672">&amp;</span>b);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//查询[a,b]分为两部分，即[a,a+2^s-1]与[b-2^s+1,b]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//完全不用担心这两个范围重叠，因为是求max
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> logn[b<span style="color:#f92672">-</span>a<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,std<span style="color:#f92672">::</span>max(fmax[a][s],fmax[b<span style="color:#f92672">-</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span>s)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][s]));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="二分">二分</h1>
<h2 id="二分答案">二分答案</h2>
<p>给出一个通用代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> MAXR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;</span>r){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> (l<span style="color:#f92672">+</span>r)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(judge(mid)) l<span style="color:#f92672">=</span>mid;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> r <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(judge(l)) std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>l<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span> std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>r<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span></code></pre></div><p>当验证一个情况是否能满足题目的复杂度小于等于<span class="math inline">\(O(n)\)</span>，而且这些情况具有单调性（即例如若x&gt;y，x不能满足，则y一定不能满足）时，就可以通过二分去得到最符合题意的答案。二分这些情况的复杂度为<span class="math inline">\(O(\log n)\)</span>，再乘上验证情况的复杂度得到总的复杂度。</p>
<p>judge函数应该根据题意写出。</p>
<p>如果是浮点数的二分，则不推荐使用EPS进行精度判断（有可能会丢精度）。而是使用计数器，一般迭代100次就能保证符合题目要求。</p>
<h2 id="二分查找">二分查找</h2>
<p>通常是在排好序上的数组中，查找第一个大于（或大于等于）x的元素。见STL用法中的lower_bound和upper_bound。每次查找的复杂度是logn</p>
<h2 id="二分求单调函数零点">二分求单调函数零点</h2>
<p>设函数<span class="math inline">\(f\)</span>在<span class="math inline">\([l,r]\)</span>上严格单调，<span class="math inline">\(mid=(l+r)/2\)</span>，显然有<span class="math inline">\(f(l)f(r)<0\)</span>。迭代中，若<span class="math inline">\(f(l)f(mid)<0\)</span>，则<span class="math inline">\(r=mid\)</span>，否则<span class="math inline">\(l=mid\)</span>。直到<span class="math inline">\(f(mid)=0\)</span>或者<span class="math inline">\(r-l< EPS\)</span>或者迭代次数达到要求。收敛速度是线性收敛。</p>
<h1 id="三分法">三分法</h1>
<h2 id="三分法求单峰函数的极值点">三分法求单峰函数的极值点</h2>
<p>用二分求函数的导数的零点也可以，但是并不是每次都可以方便的求出导数。三分法可以不用求出导数。</p>
<p>设函数<span class="math inline">\(f\)</span>在<span class="math inline">\([l,r]\)</span>上单峰，意味着有且只有一个极大值<span class="math inline">\(x\)</span>，<span class="math inline">\(f\)</span>在<span class="math inline">\([l,x]\)</span>上严格单增，在<span class="math inline">\([x,r]\)</span>上严格单减。单谷函数则为极小值<span class="math inline">\(x\)</span>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//三分法求单峰函数的极值点 luogu p3382
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//收敛速度是线性收敛
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//用二分求函数的导数的零点也可以，但是并不是每次都可以方便的求出导数。三分法可以不用求出导数。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//设函数f在[l,r]上单峰，意味着有且只有一个极大值x，f在[l,x]上严格单增，在[x,r]上严格单减。单谷函数则为极小值x。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//在[l,r]上取两个不等的点，设靠近l的是l1，靠近r的是r1。如果f(l1)&lt;f(r1)，说明极大值一定在[l1,r]，令l=l1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//如果f(l1)&gt;f(r1)，极大值一定在[l,r1]，令r=r1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//持续下去直到r-l&lt;EPS或者迭代次数足够
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//取l1和r1时，可以直接取三等分点，也可以取黄金分割点(l1=l+(r-l)(1-0.618),r1=r-(r-l)*(1-0.618))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//还可以让l1=mid-EPS, r1=mid-EPS，但是要令l=mid而不是l=l1，防止死循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> DB <span style="color:#f92672">=</span> <span style="color:#66d9ef">double</span>;
</span></span><span style="display:flex;"><span>DB <span style="color:#66d9ef">const</span> EPS <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e-8</span>;
</span></span><span style="display:flex;"><span>DB l,r;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>l<span style="color:#f92672">&gt;&gt;</span>r;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(r<span style="color:#f92672">-</span>l<span style="color:#f92672">&gt;</span>EPS){
</span></span><span style="display:flex;"><span>    DB mid <span style="color:#f92672">=</span> (l<span style="color:#f92672">+</span>r)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    DB f1 <span style="color:#f92672">=</span> func(mid<span style="color:#f92672">-</span>EPS), f2 <span style="color:#f92672">=</span> func(mid<span style="color:#f92672">+</span>EPS);<span style="color:#75715e">//func根据题目要求定义，是一元函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(f1<span style="color:#f92672">&lt;</span>f2)
</span></span><span style="display:flex;"><span>        l <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="三分套三分">三分套三分</h2>
<p>例如Luogu P2571，这是一个二元函数要求最小值。我们发现这个函数在固定<span class="math inline">\(x\)</span>的时候<span class="math inline">\(y\)</span>是单谷的，固定<span class="math inline">\(y\)</span>的时候<span class="math inline">\(x\)</span>是单谷的。所以我们可以先三分一个变量，再固定这个变量三分另一个变量，最后得出答案。</p>
<p>注意，三分套三分是指不能先假设一个<span class="math inline">\(y\)</span>的定值，再三分<span class="math inline">\(x\)</span>，然后拿着计算出的<span class="math inline">\(x\)</span>再去三分<span class="math inline">\(y\)</span>。应当在三分<span class="math inline">\(x\)</span>的过程中，把<span class="math inline">\(x\)</span>当作参数，传入三分<span class="math inline">\(y\)</span>的函数中。它们不是先后关系，而是嵌套关系。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> func <span style="color:#f92672">=</span> [<span style="color:#f92672">&amp;</span>](DB x, DB y){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//这里是函数定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> sfy <span style="color:#f92672">=</span> [<span style="color:#f92672">&amp;</span>](DB x){<span style="color:#75715e">//固定x，三分y
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    DB ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>    DB l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>, r <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(r<span style="color:#f92672">-</span>l<span style="color:#f92672">&gt;</span>EPS){
</span></span><span style="display:flex;"><span>        DB delta <span style="color:#f92672">=</span> (r<span style="color:#f92672">-</span>l)<span style="color:#f92672">/</span><span style="color:#ae81ff">3.0</span>;
</span></span><span style="display:flex;"><span>        DB f1 <span style="color:#f92672">=</span> func(x,l<span style="color:#f92672">+</span>delta), f2 <span style="color:#f92672">=</span> func(x,r<span style="color:#f92672">-</span>delta);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(f1<span style="color:#f92672">&gt;</span>f2)
</span></span><span style="display:flex;"><span>            l <span style="color:#f92672">=</span> l<span style="color:#f92672">+</span>delta;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            r <span style="color:#f92672">=</span> r<span style="color:#f92672">-</span>delta;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">func</span>(x,l);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>DB l<span style="color:#f92672">=</span><span style="color:#ae81ff">0.0</span>,r<span style="color:#f92672">=</span><span style="color:#ae81ff">1.0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(r<span style="color:#f92672">-</span>l<span style="color:#f92672">&gt;</span>EPS){<span style="color:#75715e">//三分x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    DB delta <span style="color:#f92672">=</span> (r<span style="color:#f92672">-</span>l)<span style="color:#f92672">/</span><span style="color:#ae81ff">3.0</span>;
</span></span><span style="display:flex;"><span>    DB f1 <span style="color:#f92672">=</span> sfy(l<span style="color:#f92672">+</span>delta), f2 <span style="color:#f92672">=</span> sfy(r<span style="color:#f92672">-</span>delta);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(f1<span style="color:#f92672">&gt;</span>f2)
</span></span><span style="display:flex;"><span>        l <span style="color:#f92672">=</span> l<span style="color:#f92672">+</span>delta;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> r<span style="color:#f92672">-</span>delta;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//最后的答案是sfy(l)
</span></span></span></code></pre></div><h2 id="三分答案-todo">三分答案 TODO</h2>
<h1 id="动态规划">动态规划</h1>
<h2 id="01背包">01背包</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 nW
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P1048
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">1005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dp[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> w[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> v[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,W;<span style="color:#75715e">//物品数，背包大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cin<span style="color:#f92672">&gt;&gt;</span>W<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        cin<span style="color:#f92672">&gt;&gt;</span>w[i]<span style="color:#f92672">&gt;&gt;</span>v[i];<span style="color:#75715e">//物品体积，物品价值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>W;j<span style="color:#f92672">&gt;=</span>w[i];j<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>			dp[j] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(dp[j],dp[j<span style="color:#f92672">-</span>w[i]]<span style="color:#f92672">+</span>v[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>dp[W]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="完全背包">完全背包</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 nW
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P1616
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">10007</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXW <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000007</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> LL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL dp[MAXW];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> w[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> v[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,W;<span style="color:#75715e">//物品数，背包大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cin<span style="color:#f92672">&gt;&gt;</span>W<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        cin<span style="color:#f92672">&gt;&gt;</span>w[i]<span style="color:#f92672">&gt;&gt;</span>v[i];<span style="color:#75715e">//物品体积，物品价值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>w[i];j<span style="color:#f92672">&lt;=</span>W;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>			dp[j] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(dp[j],dp[j<span style="color:#f92672">-</span>w[i]]<span style="color:#f92672">+</span>v[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>dp[W]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="多重背包">多重背包</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度 Wsum(logk_i) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P1776
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//即每种物品有ki个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//我们可以简单转化为01背包，但是复杂度太高；采用二进制分组的思想
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">100007</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXW <span style="color:#f92672">=</span> <span style="color:#ae81ff">40007</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> LL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL dp[MAXW];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> w[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> v[MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m,W;<span style="color:#75715e">//物品种类数，背包大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    cin<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>W;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>m;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> p,h,k;<span style="color:#75715e">//物品价值，物品体积，物品数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        cin<span style="color:#f92672">&gt;&gt;</span>p<span style="color:#f92672">&gt;&gt;</span>h<span style="color:#f92672">&gt;&gt;</span>k;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(k<span style="color:#f92672">&gt;</span>c){
</span></span><span style="display:flex;"><span>            k <span style="color:#f92672">-=</span> c;
</span></span><span style="display:flex;"><span>            v[<span style="color:#f92672">++</span>n] <span style="color:#f92672">=</span> c<span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>            w[n] <span style="color:#f92672">=</span> c<span style="color:#f92672">*</span>h;
</span></span><span style="display:flex;"><span>            c <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        v[<span style="color:#f92672">++</span>n] <span style="color:#f92672">=</span> p<span style="color:#f92672">*</span>k;
</span></span><span style="display:flex;"><span>        w[n] <span style="color:#f92672">=</span> h<span style="color:#f92672">*</span>k;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>W;j<span style="color:#f92672">&gt;=</span>w[i];j<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>	        dp[j] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(dp[j],dp[j<span style="color:#f92672">-</span>w[i]]<span style="color:#f92672">+</span>v[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>dp[W]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="分组背包">分组背包</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//分组背包 复杂度=组数*背包容量*组内个数最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p1757
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//有g个组，每组物品有group[i].size()个，每个物品有价值v和体积w，总共n个物品，背包体积为m。每个组最多只能拿一个物品出来，求最大价值。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">1005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dp[MAXN];
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> group[MAXN];<span style="color:#75715e">//存储每一组的物品序号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> v[MAXN],w[MAXN];<span style="color:#75715e">//物品价值和体积
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>n;<span style="color:#75715e">//背包容量;n件物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a,b,c;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>b<span style="color:#f92672">&gt;&gt;</span>c;
</span></span><span style="display:flex;"><span>        w[i] <span style="color:#f92672">=</span> a, v[i] <span style="color:#f92672">=</span> b,group[c].push_back(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> g <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;<span style="color:#75715e">//本题中只说了有g个组，没有给出具体有多少个以及是否连续，采取遍历的方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>g;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(group[i].size()<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>m;j<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> k:group[i]){<span style="color:#75715e">//注意这三个循环的顺序不能改变
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">&gt;=</span>w[k]) dp[j] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(dp[j], dp[j<span style="color:#f92672">-</span>w[k]]<span style="color:#f92672">+</span>v[k]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>dp[m]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> T;
</span></span><span style="display:flex;"><span>	T<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span>(T<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>	    solve();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="最长上升子序列">最长上升子序列</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//最长上升子序列 复杂度nlogn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu B3637
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">100005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dp[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//dp[i]表示长度为i的上升子序列的最后一个元素的最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//例如1 2 5 3 4 1。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//最开始dp[1]=1，arr[2]=2&gt;dp[1]，所以插入dp[2]=2;arr[3]同理，得到dp={1,2,5};到arr[4]=3时，我们找到第一个大于等于3的元素，即dp[3]，替换他，得到dp={1,2,3};接下来到arr[5]=4，现在4&gt;3，可以插入末尾得到dp={1,2,3,4}，显然我们刚刚的操作把5换成3，让后面的数更有可能直接加入到数组末尾了。最后arr[6]=1，由于我们求的是最长上升子序列，而不是最长不下降，所以替换不影响。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//注意dp里面的数字并不是最长的序列，例如我们加一个0进去，dp={0,2,3,4}，但是0是在最后的，不存在0,2,3,4这个序列。我们只能计算长度。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>arr[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>memset(dp,<span style="color:#ae81ff">0x3f</span>,<span style="color:#66d9ef">sizeof</span>(dp));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxv <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>std<span style="color:#f92672">::</span>lower_bound(dp,dp<span style="color:#f92672">+</span>n,arr[i]) <span style="color:#f92672">=</span> arr[i];
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//换成最长不下降子序列时，用upper_bound
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(dp[ans]<span style="color:#f92672">!=</span>maxv) ans<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="dilworth定理">Dilworth定理</h2>
<p>把一个序列分为若干不上升子序列，其序列总数的最小值等于最长上升子序列的长度</p>
<h2 id="最长公共子序列">最长公共子序列</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//最长公共子序列，复杂度nm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//hdu 1159
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu p1439因为是排列，可以转化为LIS问题，复杂度是nlogn。但hdu1159没有这种性质，复杂度到不了nlogn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAXN 505
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dp[MAXN][MAXN];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lcs</span>(std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s1, std<span style="color:#f92672">::</span>string <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> s2){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n1<span style="color:#f92672">=</span>s1.size(),n2<span style="color:#f92672">=</span>s2.size();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>memset(dp,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(dp));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n1;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>n2;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(s1[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">==</span>s2[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>                dp[i][j] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                dp[i][j] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> dp[n1][n2];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string s1,s2;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>s1<span style="color:#f92672">&gt;&gt;</span>s2){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>lcs(s1,s2)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="最大子段和">最大子段和</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//luogu P1115
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//复杂度 n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//求一个数组里面最大连续子段的和，可以为空，此时和为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//如果要保证非空，则可以在外部加一条
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//ans = std::max(ans, arr[i]);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//并且如果每个数都是负数，则直接输出最大的负数。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL <span style="color:#a6e22e">calc</span>(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>LL<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> vec){
</span></span><span style="display:flex;"><span>    LL ret<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    LL cur<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>vec.size();i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        cur <span style="color:#f92672">+=</span> vec[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(cur<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>) cur <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(ret, cur);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="斜率优化todo">斜率优化TODO</h2>
<h2 id="四边形不等式todo">四边形不等式TODO</h2>
<h2 id="悬线法">悬线法</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//luogu p1387
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//悬线法求符合条件的最大矩形/正方形，复杂度 nm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> grid[MAXN][MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> l[MAXN][MAXN], r[MAXN][MAXN], u[MAXN][MAXN];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//l,r分别表示从当前格向上的悬线最多能向左向右扩展多少格（含自己）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//u表示当前格向上能扩展多少格（含自己），即悬线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dp</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> m){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>m;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(grid[i][j]) l[i][j] <span style="color:#f92672">=</span> l[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//若(i,j-1)可选，当然首先要(i,j)可选，(i,j-1)不可选时l[i][j-1]会等于0，l[i][j]就会等于1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">//这里的if条件看情况选择，下面同理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>m;j<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(grid[i][j]) r[i][j] <span style="color:#f92672">=</span> r[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//若(i,j+1)可选
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>m;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(grid[i][j]){
</span></span><span style="display:flex;"><span>                u[i][j] <span style="color:#f92672">=</span> u[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(grid[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]){<span style="color:#75715e">//若(i-1,j)可选
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    l[i][j] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(l[i][j], l[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]);
</span></span><span style="display:flex;"><span>                    r[i][j] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(r[i][j], r[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//然后在这里对ans进行该有的操作，因题而异
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">//对于(i,j)这一格来说，它对应的悬线向左右拓展能得到的最大矩形面积为
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">//u[i][j]*(l[i][j]+r[i][j]-1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">//最大正方形为
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">//min(u[i][j],l[i][j]+r[i][j]-1)的平方
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="数位dp">数位DP</h2>
<p>数位DP是对有多少数符合特性的计数问题。通常他的题目数据范围会很大，比如<span class="math inline">\(10^{18}\)</span>。题目通常也会要求我们的数字要在某个范围内，还有可能会要求符合题意的一对、一组数。</p>
<p>我们通常会用记忆化搜索来实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//数位dp模板题，常用记忆化搜索实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//hdu 2089
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//本题要求，[n,m]之间的所有整数，不含4，不含62（连续的）的数字有多少个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define pb push_back
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> digit;<span style="color:#75715e">//用于存储getSum中x的每一位，最高位从0下标开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dp[<span style="color:#ae81ff">8</span>][<span style="color:#ae81ff">12</span>][<span style="color:#ae81ff">2</span>];<span style="color:#75715e">//dp[pos][last][limit]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//pos代表搜索到第几位，如五位数，pos==0说明搜索到高位第一位，pos==4说明搜索到个位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//last代表上一位搜索的数字是多少，如果last==11，10这样的数字则代表目前在搜索pos==0。设置为11还是10还是别的什么要看题目对只有一位数时的要求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//limit代表本位数字的取值有没有限制，例如上限是12345，现在搜到了12???，要搜第三位，显然第三位只能取0,1,2,3，limit==true。又如搜到了11???，第三位就可以取0-9，limit==false。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//limit==true当且仅当上一位limit也为true且取得最大值（第一位特判）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> pos, <span style="color:#66d9ef">int</span> last, <span style="color:#66d9ef">bool</span> limit){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(pos<span style="color:#f92672">==</span>digit.size()) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//搜索终点，由于不是非法状态所以返回1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(dp[pos][last][limit] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> dp[pos][last][limit];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> v<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;v<span style="color:#f92672">&lt;=</span>(limit <span style="color:#f92672">?</span> digit[pos] <span style="color:#f92672">:</span> <span style="color:#ae81ff">9</span>);v<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>((last<span style="color:#f92672">==</span><span style="color:#ae81ff">6</span> <span style="color:#f92672">&amp;&amp;</span> v<span style="color:#f92672">==</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">||</span> v<span style="color:#f92672">==</span><span style="color:#ae81ff">4</span>) <span style="color:#66d9ef">continue</span>;<span style="color:#75715e">//非法状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        ret <span style="color:#f92672">+=</span> dfs(pos<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, v, limit <span style="color:#f92672">&amp;&amp;</span> v<span style="color:#f92672">==</span>digit[pos]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    dp[pos][last][limit] <span style="color:#f92672">=</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getSum</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>    digit.clear();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>memset(dp,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">sizeof</span>(dp));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(x){<span style="color:#75715e">//注意如果某些题0也在范围内要特判
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        digit.pb(x<span style="color:#f92672">%</span><span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>        x<span style="color:#f92672">/=</span><span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>reverse(digit.begin(),digit.end());<span style="color:#75715e">//高位到低位存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> dfs(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">10</span>,true);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> m){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>getSum(m)<span style="color:#f92672">-</span>getSum(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> n,m;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span>(std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m){
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> m<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>	    solve(n,m);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面再给出一例，求一对数字的、与位运算有关的，拆分成二进制的题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//数位dp另一例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//atcoder abc317_f
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//本题给定n,a1,a2,a3。要求求三元组&lt;x1,x2,x3&gt;的个数，满足
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//1. 1&lt;=xi&lt;=n，对所有i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//2. xi是ai的任意倍数，对所有i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//3. x1^x2^x3=0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//其中n取值[1,1e18]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//ai取值[1,10]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define pb push_back
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span>LL <span style="color:#66d9ef">const</span> MOD <span style="color:#f92672">=</span> <span style="color:#ae81ff">998244353</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> digit;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> dp[<span style="color:#ae81ff">80</span>][<span style="color:#ae81ff">12</span>][<span style="color:#ae81ff">12</span>][<span style="color:#ae81ff">12</span>][<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a1,a2,a3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> pos, <span style="color:#66d9ef">int</span> r1, <span style="color:#66d9ef">int</span> r2, <span style="color:#66d9ef">int</span> r3,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> l1, <span style="color:#66d9ef">bool</span> l2, <span style="color:#66d9ef">bool</span> l3,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> z1, <span style="color:#66d9ef">bool</span> z2, <span style="color:#66d9ef">bool</span> z3){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//分布代表着，pos位数字，上一位搜索到的x1除以a1的余数,...,x1的limit,...,x1是否前面全是前导0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(pos<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>z1 <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>z2 <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>z3 <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>r1 <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>r2 <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>r3;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//每个数都没有前导零（即填入了至少一个数字），以及余数都是0（即xi已经是ai的倍数了）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(dp[pos][r1][r2][r3][l1][l2][l3][z1][z2][z3] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> dp[pos][r1][r2][r3][l1][l2][l3][z1][z2][z3];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m1 <span style="color:#f92672">=</span> l1 <span style="color:#f92672">?</span> digit[pos] <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m2 <span style="color:#f92672">=</span> l2 <span style="color:#f92672">?</span> digit[pos] <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m3 <span style="color:#f92672">=</span> l3 <span style="color:#f92672">?</span> digit[pos] <span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(LL i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;=</span>m1;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(LL j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;=</span>m2;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(LL k<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;k<span style="color:#f92672">&lt;=</span>m3;k<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>((i<span style="color:#f92672">^</span>j<span style="color:#f92672">^</span>k)<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> newr1 <span style="color:#f92672">=</span> ((LL)r1<span style="color:#f92672">+</span>(i<span style="color:#f92672">&lt;&lt;</span>pos))<span style="color:#f92672">%</span>a1;<span style="color:#75715e">//计算新的余数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">int</span> newr2 <span style="color:#f92672">=</span> ((LL)r2<span style="color:#f92672">+</span>(j<span style="color:#f92672">&lt;&lt;</span>pos))<span style="color:#f92672">%</span>a2;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> newr3 <span style="color:#f92672">=</span> ((LL)r3<span style="color:#f92672">+</span>(k<span style="color:#f92672">&lt;&lt;</span>pos))<span style="color:#f92672">%</span>a3;
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                ret <span style="color:#f92672">=</span> (ret <span style="color:#f92672">+</span> dfs(pos<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,newr1,newr2,newr3,
</span></span><span style="display:flex;"><span>                l1<span style="color:#f92672">&amp;&amp;</span>i<span style="color:#f92672">==</span>digit[pos], l2<span style="color:#f92672">&amp;&amp;</span>j<span style="color:#f92672">==</span>digit[pos],l3<span style="color:#f92672">&amp;&amp;</span>k<span style="color:#f92672">==</span>digit[pos],
</span></span><span style="display:flex;"><span>                z1<span style="color:#f92672">&amp;&amp;</span>i<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>,z2<span style="color:#f92672">&amp;&amp;</span>j<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>,z3<span style="color:#f92672">&amp;&amp;</span>k<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>))<span style="color:#f92672">%</span>MOD;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    dp[pos][r1][r2][r3][l1][l2][l3][z1][z2][z3] <span style="color:#f92672">=</span> ret;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getSum</span>(LL x){
</span></span><span style="display:flex;"><span>    digit.clear();
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>memset(dp,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#66d9ef">sizeof</span>(dp));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(x){
</span></span><span style="display:flex;"><span>        digit.pb(x<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>        x<span style="color:#f92672">/=</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }<span style="color:#75715e">//本题低位到高位存更方便，方便移位运算
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> dfs(digit.size()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    LL n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>a1<span style="color:#f92672">&gt;&gt;</span>a2<span style="color:#f92672">&gt;&gt;</span>a3;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>getSum(n)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>选择低位到高位还是高位到低位应该根据题目的不同来选择。</p>
<p>另外如果满足limit为真的情况出现的概率远低于为假的，那么可以把limit这一维省略掉，dp数组里面只记录limit为假的情况。</p>
<p>低位到高位存还有一个好处。我们知道高位到低位存时，由于数字长度不一样，比如a有5位，b有10位，把a的dp数组求完后，求b时就必须再次清空成-1。原因是，对于a的pos为1，也就是从高到低第二位，其实对应这b的pos为6，我们就不能用a中求出的dp带进去b里面计算了。</p>
<p>而低位到高位就没有这个问题，大家的最低位都是平等的从0下标开始的，可以进行复用。清零为-1只需要程序最开始的时候清零一次即可。有时候程序有多个case会避免TLE。</p>
<h1 id="概率论">概率论</h1>
<h2 id="处理分数期望概率">处理分数期望、概率</h2>
<p>有时候，题目中的期望是一个分数<span class="math inline">\(\frac{P}{Q}\)</span>，而为了防止精度问题，往往会要求输出一个<span class="math inline">\(R\)</span>，满足</p>
<p><span class="math display">\[R\times Q\equiv P(mod\ 998244353)
\]</span></p>
<p>此时</p>
<p><span class="math display">\[R = (P\times Q^{-1})\%998244353
\]</span></p>
<p><span class="math inline">\(Q^{-1}\)</span>是<span class="math inline">\(Q\)</span>在模<span class="math inline">\(998244353\)</span>意义下的乘法逆元</p>
<h1 id="杂项">杂项</h1>
<h2 id="快速幂">快速幂</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度logn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//快速幂
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu P1226
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">qPow</span>(LL x, LL p){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//x^p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> x;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">*=</span> x;
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">&gt;&gt;=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">qPowMod</span>(LL x, LL p, LL m){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//x^p % m
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> (res <span style="color:#f92672">*</span> x)<span style="color:#f92672">%</span>m;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> (x<span style="color:#f92672">*</span>x)<span style="color:#f92672">%</span>m;
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">&gt;&gt;=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="离散化">离散化</h2>
<p>有两种，一种是unique函数版，一种是树状数组求逆序对里使用的，都可以，区别是，那个对于相同的数字根据先后顺序确定大小，这个则是一样大</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//复杂度nlogn
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//离散化 例如将1,500,40,1000保持相对大小不变，离散化为1,3,2,4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//出现同样的数字时，例如6,-4,3,7,3会离散化为3,1,2,4,2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//luogu B3694
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> arr,assi;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>    arr.clear();
</span></span><span style="display:flex;"><span>    assi.clear();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>a;
</span></span><span style="display:flex;"><span>        arr.push_back(a);
</span></span><span style="display:flex;"><span>        assi.push_back(a);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(assi.begin(),assi.end());
</span></span><span style="display:flex;"><span>    assi.erase(std<span style="color:#f92672">::</span>unique(assi.begin(),assi.end()),assi.end());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        arr[i] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>upper_bound(assi.begin(),assi.end(),arr[i])<span style="color:#f92672">-</span>assi.begin();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>arr[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="莫队算法">莫队算法</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//对于序列上的区域离线询问问题，如果[l,r]的答案能够O(1)拓展得到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//[l-1,r],[l+1,r],[l,r-1],[l,r+1]的答案，那么就可以在O(n sqrt(n))中解决所有询问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//SPOJ DQUERY
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//本题是给定若干个区间[l,r]，查询这个范围内有多少个不同的数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> arr[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> sq;<span style="color:#75715e">//分块数sq = sqrt(n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Query</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> l,r,id;<span style="color:#75715e">//询问区间和询问下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(Query <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> x)<span style="color:#66d9ef">const</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">/</span>sq <span style="color:#f92672">!=</span> x.l<span style="color:#f92672">/</span>sq)<span style="color:#75715e">//根据归属于哪个块排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> l<span style="color:#f92672">&lt;</span>x.l;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">/</span>sq <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>)      <span style="color:#75715e">//玄学奇偶排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> r<span style="color:#f92672">&lt;</span>x.r;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> r<span style="color:#f92672">&gt;</span>x.r;
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}Q[MAXQ];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> ans[MAXQ], cnt[MAXA], cur;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> l<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,r<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//初始化询问区间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> p){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(cnt[arr[p]]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)<span style="color:#75715e">//新增一种数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        cur<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    cnt[arr[p]]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">del</span>(<span style="color:#66d9ef">int</span> p){
</span></span><span style="display:flex;"><span>    cnt[arr[p]]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(cnt[arr[p]]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)<span style="color:#75715e">//把一种数全部删完
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        cur<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n;
</span></span><span style="display:flex;"><span>	sq <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>sqrt(n);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>) std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>arr[i];
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> q;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>q;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>q;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>	    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>Q[i].l<span style="color:#f92672">&gt;&gt;</span>Q[i].r;
</span></span><span style="display:flex;"><span>	    Q[i].id <span style="color:#f92672">=</span> i;<span style="color:#75715e">//把询问离线
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>sort(Q,Q<span style="color:#f92672">+</span>q);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>q;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">while</span>(l<span style="color:#f92672">&gt;</span>Q[i].l)
</span></span><span style="display:flex;"><span>	        add(<span style="color:#f92672">--</span>l);<span style="color:#75715e">//当前区间l大于查询的l，要把左边的数加进来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    <span style="color:#66d9ef">while</span>(r<span style="color:#f92672">&lt;</span>Q[i].r)
</span></span><span style="display:flex;"><span>	        add(<span style="color:#f92672">++</span>r);<span style="color:#75715e">//当前区间r小于查询的r，要把右边的数加进来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    <span style="color:#66d9ef">while</span>(l<span style="color:#f92672">&lt;</span>Q[i].l)
</span></span><span style="display:flex;"><span>	        del(l<span style="color:#f92672">++</span>);<span style="color:#75715e">//当前区间l小于查询的l，要把左边的数删掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    <span style="color:#66d9ef">while</span>(r<span style="color:#f92672">&gt;</span>Q[i].r)
</span></span><span style="display:flex;"><span>	        del(r<span style="color:#f92672">--</span>);<span style="color:#75715e">//当前区间r大于查询的r，要把右边的数删掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    <span style="color:#75715e">//注意上述顺序，扩张区间是先移动再更新，缩减区间是先更新再移动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    <span style="color:#75715e">//四个操作的具体实现可能会有不一样，具体题目具体讨论
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    ans[Q[i].id] <span style="color:#f92672">=</span> cur;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>q;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>	    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="01分数规划">0/1分数规划</h2>
<p>0/1分数规划的目的是如下列式子取值最大化</p>
<p><span class="math display">\[\dfrac{\sum^n_{i=1}a_ix_i}{\sum^n_{i=1}b_ix_i}
\]</span></p>
<p>其中<span class="math inline">\(\{a_i\}\)</span>和<span class="math inline">\(\{b_i\}\)</span>是给定的数列，而<span class="math inline">\(\{x_i\}\)</span>是要求的一组解，其取值只能是<span class="math inline">\(0\)</span>或<span class="math inline">\(1\)</span>。或者说，给定<span class="math inline">\(n\)</span>对数<span class="math inline">\(a_i,b_i\)</span>，从中选出若干对（通常题目要求恰好选<span class="math inline">\(k\)</span>对），使选出的数对的<span class="math inline">\(a\)</span>之和和<span class="math inline">\(b\)</span>之和的商最大。</p>
<p>我们转化成二分答案，验证一个值<span class="math inline">\(m\)</span>，上式的取值能否大于等于<span class="math inline">\(m\)</span>。转化一下就可以得到，是否存在一组解<span class="math inline">\(x_1,\cdots,x_n\)</span>，满足</p>
<p><span class="math display">\[\sum^n_{i=1}(a_i-m\times b_i)\times x_i\geq 0
\]</span></p>
<p>如果存在则说明<span class="math inline">\(m\)</span>比最大值要小，否则<span class="math inline">\(m\)</span>比最大值要大，满足二分性。</p>
<p>我们可以计算每一个<span class="math inline">\((a_i-m\times b_i)\)</span>，如果题目说可以任意选择若干对，则只要有一个非负数，就能满足条件。如果要求恰好选<span class="math inline">\(k\)</span>对，那么我们全部算出来然后排序，选择最大的<span class="math inline">\(k\)</span>个，其和非负就能满足条件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//0/1分数规划，复杂度n log^2 n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//nowcoder NC14662
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//介绍见markdown
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL a[MAXN],b[MAXN];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n,k;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">judge</span>(DB mid){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>DB<span style="color:#f92672">&gt;</span> vec;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        vec.pb(a[i]<span style="color:#f92672">-</span>mid<span style="color:#f92672">*</span>b[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>sort(vec.begin(),vec.end());
</span></span><span style="display:flex;"><span>    DB sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;=</span>k;i<span style="color:#f92672">--</span>) sum<span style="color:#f92672">+=</span>vec[i];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(sum<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>k;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>b[i]<span style="color:#f92672">&gt;&gt;</span>a[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    DB l<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, r<span style="color:#f92672">=</span><span style="color:#ae81ff">1e13</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">100</span>;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        DB mid <span style="color:#f92672">=</span> (l<span style="color:#f92672">+</span>r)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(judge(mid)) l <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> r <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>(LL)r<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="表达式求值-可能需要进一步完善todo">表达式求值 可能需要进一步完善TODO</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isOper</span>(<span style="color:#66d9ef">char</span> c){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> c<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;+&#39;</span><span style="color:#f92672">||</span>c<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;-&#39;</span><span style="color:#f92672">||</span>c<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;*&#39;</span><span style="color:#f92672">||</span>c<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;/&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isDigit</span>(<span style="color:#66d9ef">char</span> c){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> c<span style="color:#f92672">&gt;=</span><span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">&amp;&amp;</span> c<span style="color:#f92672">&lt;=</span><span style="color:#e6db74">&#39;9&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">priority</span>(<span style="color:#66d9ef">char</span> oper){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(oper<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#f92672">||</span> oper<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;-&#39;</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(oper<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#f92672">||</span> oper<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;/&#39;</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string toRPN(std<span style="color:#f92672">::</span>string expr){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string ret;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> oper;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> esize <span style="color:#f92672">=</span> expr.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>esize;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">&amp;</span> c <span style="color:#f92672">=</span> expr[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(c<span style="color:#f92672">==</span><span style="color:#e6db74">&#39; &#39;</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(isOper(c)){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(c<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">&amp;&amp;</span> (i<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> expr[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;(&#39;</span>)){
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//判断一元运算符负号，这里采用了加个0-前缀的方法，如果题目要求输出RPN其实是做不到的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">//TODO: 把toRPN返回一个vector，实现真正的RPN
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                ret.push_back(<span style="color:#e6db74">&#39;0&#39;</span>);
</span></span><span style="display:flex;"><span>                ret.push_back(<span style="color:#e6db74">&#39; &#39;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>oper.empty() <span style="color:#f92672">&amp;&amp;</span> priority(oper.top())<span style="color:#f92672">&gt;=</span>priority(c)){
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//如果是右结合运算符，则要改成大于，如果只有一部分是右结合运算符，分类讨论
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                ret.push_back(oper.top());
</span></span><span style="display:flex;"><span>                ret.push_back(<span style="color:#e6db74">&#39; &#39;</span>);
</span></span><span style="display:flex;"><span>                oper.pop();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            oper.push(c);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(c<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;(&#39;</span>){
</span></span><span style="display:flex;"><span>            oper.push(c);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(c<span style="color:#f92672">==</span><span style="color:#960050;background-color:#1e0010">&#39;</span>)<span style="color:#960050;background-color:#1e0010">&#39;</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(oper.top()<span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;(&#39;</span>){
</span></span><span style="display:flex;"><span>                ret.push_back(oper.top());
</span></span><span style="display:flex;"><span>                ret.push_back(<span style="color:#e6db74">&#39; &#39;</span>);
</span></span><span style="display:flex;"><span>                oper.pop();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            oper.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>esize <span style="color:#f92672">&amp;&amp;</span> isDigit(expr[i])){
</span></span><span style="display:flex;"><span>                ret.push_back(expr[i<span style="color:#f92672">++</span>]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            ret.push_back(<span style="color:#e6db74">&#39; &#39;</span>);
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>oper.empty()){
</span></span><span style="display:flex;"><span>        ret.push_back(oper.top());
</span></span><span style="display:flex;"><span>        ret.push_back(<span style="color:#e6db74">&#39; &#39;</span>);
</span></span><span style="display:flex;"><span>        oper.pop();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processOper</span>(std<span style="color:#f92672">::</span>stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span> st, <span style="color:#66d9ef">char</span> oper){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> st.top();
</span></span><span style="display:flex;"><span>    st.pop();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> st.top();
</span></span><span style="display:flex;"><span>    st.pop();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span>(oper){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;+&#39;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            st.push(l<span style="color:#f92672">+</span>r);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;-&#39;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            st.push(l<span style="color:#f92672">-</span>r);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;*&#39;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            st.push(l<span style="color:#f92672">*</span>r);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#39;/&#39;</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>            st.push(l<span style="color:#f92672">/</span>r);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">RPNCalc</span>(std<span style="color:#f92672">::</span>string expr){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> number;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> esize <span style="color:#f92672">=</span> expr.size();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>esize;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">char</span><span style="color:#f92672">&amp;</span> c <span style="color:#f92672">=</span> expr[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(c<span style="color:#f92672">==</span><span style="color:#e6db74">&#39; &#39;</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(isOper(c)){
</span></span><span style="display:flex;"><span>            processOper(number, c);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>esize <span style="color:#f92672">&amp;&amp;</span> isDigit(expr[i])){
</span></span><span style="display:flex;"><span>                res <span style="color:#f92672">=</span> res<span style="color:#f92672">*</span><span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> expr[i<span style="color:#f92672">++</span>] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;0&#39;</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            number.push(res);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ret <span style="color:#f92672">=</span> number.top();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">exprCalc</span>(std<span style="color:#f92672">::</span>string expr){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> RPNCalc(toRPN(expr));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>string str;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>str;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>toRPN(str)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>	std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>exprCalc(str)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="艾弗森括号">艾弗森括号</h2>
<p>艾弗森括号常表示为<span class="math inline">\([A]\)</span>，其中<span class="math inline">\(A\)</span>是一个二值表达式。用三元运算符可以等价为<span class="math inline">\([A]\leftrightarrow A?1:0\)</span>。</p>
<p>例如<span class="math inline">\([\gcd(a,b)==1]\)</span>，就意味着，如果<span class="math inline">\(a,b\)</span>互质，式子的值为<span class="math inline">\(1\)</span>，否则为<span class="math inline">\(0\)</span>。</p>
<h2 id="向上向下取整">向上、向下取整</h2>
<p>在C++中，如果我们对一个double或者float用强制类型转换</p>
<pre tabindex="0"><code>double x = 1.1;
std::cout&lt;&lt;(int)x&lt;&lt;&#34;\n&#34;;
</code></pre><p>这其实看起来像是向下取整，实际上却不是。它是省略小数部分，实为向<span class="math inline">\(0\)</span>取整。C++的整数除法也是向零取整的，而Python则是向下取整。具体表现为C++中<span class="math inline">\(-7/2\)</span>为<span class="math inline">\(-3\)</span>，Python中<span class="math inline">\(-7//2\)</span>为<span class="math inline">\(-4\)</span>。</p>
<p>C++本身也有std::floor()和std::ceil()，但是只能针对浮点数使用。</p>
<p>我们一般会在结果非负的时候，用以下方式计算向上向下取整</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> a<span style="color:#f92672">/</span>b;<span style="color:#75715e">//a/b向下取整
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> (a<span style="color:#f92672">+</span>b<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span>b;<span style="color:#75715e">//a/b向上取整
</span></span></span></code></pre></div><p>而对于负数结果，我们有一个性质</p>
<p><span class="math display">\[-\lfloor x\rfloor= \lceil -x\rceil
\]</span></p>
<p><span class="math display">\[-\lceil x\rceil= \lfloor -x\rfloor
\]</span></p>
<p>转换即可。</p>
<h2 id="滚动哈希">滚动哈希</h2>
<p>（总觉得和之前的字符串哈希其实一模一样）</p>
<p>滚动哈希用来以线性复杂度求一个序列的哈希，这个序列可以是一个字符串，可以是一个数组。或者也可以退化成单个元素。假设序列是<span class="math inline">\(A=(A_1,A_2,\cdots,A_N)\)</span>，定义滚动哈希函数为<span class="math inline">\(R\)</span>，为</p>
<p><span class="math display">\[R(A) = \bigg(\sum^N_{i=1}A_ix^{N-i}\bigg)\mod{p}
\]</span></p>
<p>其中，<span class="math inline">\(P\)</span>是一个足够大的质数，而<span class="math inline">\(x\)</span>是从<span class="math inline">\([0,p)\)</span>中等可能选出的一个整数。假设<span class="math inline">\(A(a,b)\)</span>为<span class="math inline">\(A\)</span>的下标从<span class="math inline">\(a\)</span>到<span class="math inline">\(b\)</span>的子序列，我们可以立即得到它的递推式：</p>
<p><span class="math display">\[R(A(1,1)) = A_1, R(A(1,n))=R(A(1,n-1))\times x+A_n(n>1)
\]</span></p>
<p>并且如果已经与处理过所有的<span class="math inline">\(R(A(1, i))\)</span>，那么我们可以在<span class="math inline">\(O(1)\)</span>内求出<span class="math inline">\(R(A(a,b))\)</span>，即</p>
<p><span class="math display">\[R(A(a,b)) = R(A(1,b)) - R(A(1, a-1))\times x^{b-(a-1)}
\]</span></p>
<p>有一个有用的性质，如果记<span class="math inline">\(A+B=(A_1+B_1, A_2+B_2, \cdots, A_N+B_N)\)</span>，那么有</p>
<p><span class="math display">\[R(A+B) = R(A)+R(B)
\]</span></p>
<p>对于字符串<span class="math inline">\(S\)</span>和<span class="math inline">\(T\)</span>，它们的<strong>拼接</strong>，即<span class="math inline">\(S+T\)</span>，可以由之前的递推式得出哈希为</p>
<p><span class="math display">\[R(S+T) = R(S)\times x^{|T|}+R(T)
\]</span></p>
<p>这样的序列上的哈希可以方便我们判断任意两个区间的内容是否相等。另外，结合线段树，我们可以实现<span class="math inline">\(O(logn)\)</span>的单点修改和<span class="math inline">\(O(logn)\)</span>的区间哈希查询。只要每个节点存这段区间的哈希即可。两个区间合并的时候相当于<strong>拼接</strong>。支持区间修改可能有些麻烦，因为lazy tag有些难写。</p>
<p>另外，对于字符串，滚动哈希还可以用来<span class="math inline">\(O(1)\)</span>地判断一个区间是否是回文串。我们只需要正着求一遍哈希，再倒着求一遍哈希，响应的区间的哈希值相等，那么意味着是回文串。如果要避免下标的转换，则可以换一下哈希函数（注意与之前正着的哈希区分）：</p>
<p><span class="math display">\[R'(A) = \bigg(\sum^N_{i=1}A_ix^{i-1}\bigg)\mod{p}
\]</span></p>
<p>此时，<span class="math inline">\(R'(S+T)=R'(S)+R'(T)\times x^{|S|}\)</span>。</p>
<p>另外，单哈希可能不能使得碰撞的概率足够低，那么我们就重复使用多个<span class="math inline">\(p\)</span>来算多个哈希即可。</p>
<p>下面给出一个，支持单点修改，维护字符串子串哈希的线段树代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">//atcoder abc331_f
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//滚动哈希+线段树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;random&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;ctime&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;array&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> LL <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000005</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> B <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>LL mod[B] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">998244353</span>, <span style="color:#ae81ff">1000000007</span>, <span style="color:#ae81ff">1000000009</span>, <span style="color:#ae81ff">1000000021</span>, <span style="color:#ae81ff">1000000033</span>};
</span></span><span style="display:flex;"><span>LL base[B];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Hash</span>{
</span></span><span style="display:flex;"><span>    LL h1, h2, pw;  
</span></span><span style="display:flex;"><span>    Hash()<span style="color:#f92672">:</span>h1(<span style="color:#ae81ff">0</span>),h2(<span style="color:#ae81ff">0</span>),pw(<span style="color:#ae81ff">1</span>){} <span style="color:#75715e">// 字符串拼接哈希时，拼接操作的幺元
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> T <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>array<span style="color:#f92672">&lt;</span>Hash, B<span style="color:#f92672">&gt;</span>; <span style="color:#75715e">// 存多个哈希，以减小碰撞概率
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>T <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(T lhs, T rhs){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 区间拼接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    T res;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>B;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        res[i].h1 <span style="color:#f92672">=</span> (lhs[i].h1<span style="color:#f92672">*</span>rhs[i].pw <span style="color:#f92672">+</span> rhs[i].h1)<span style="color:#f92672">%</span>mod[i];
</span></span><span style="display:flex;"><span>        res[i].h2 <span style="color:#f92672">=</span> (lhs[i].h2 <span style="color:#f92672">+</span> lhs[i].pw<span style="color:#f92672">*</span>rhs[i].h2)<span style="color:#f92672">%</span>mod[i];
</span></span><span style="display:flex;"><span>        res[i].pw <span style="color:#f92672">=</span> (lhs[i].pw<span style="color:#f92672">*</span>rhs[i].pw)<span style="color:#f92672">%</span>mod[i];
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 见字符串拼接的哈希
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>T <span style="color:#a6e22e">gen</span>(<span style="color:#66d9ef">char</span> c){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 单个字符的哈希
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    T res;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>B;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        res[i].h1 <span style="color:#f92672">=</span> c;
</span></span><span style="display:flex;"><span>        res[i].h2 <span style="color:#f92672">=</span> c;
</span></span><span style="display:flex;"><span>        res[i].pw <span style="color:#f92672">=</span> base[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> s,t;<span style="color:#75715e">//该端点的起点和终点下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    T v;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Node st[MAXN<span style="color:#f92672">*</span><span style="color:#ae81ff">4</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string arr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">build</span>(<span style="color:#66d9ef">int</span> s, <span style="color:#66d9ef">int</span> t, <span style="color:#66d9ef">int</span> p<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    st[p].s <span style="color:#f92672">=</span> s;
</span></span><span style="display:flex;"><span>    st[p].t <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==</span>t) {
</span></span><span style="display:flex;"><span>        st[p].v <span style="color:#f92672">=</span> gen(arr[s]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> s<span style="color:#f92672">+</span>((t<span style="color:#f92672">-</span>s)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    build(s,m,p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    build(m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,t,p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    st[p].v <span style="color:#f92672">=</span> st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>].v <span style="color:#f92672">+</span> st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].v;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(<span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">char</span> ch, <span style="color:#66d9ef">int</span> p<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> st[p].s, t <span style="color:#f92672">=</span> st[p].t;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==</span>t){
</span></span><span style="display:flex;"><span>        st[p].v <span style="color:#f92672">=</span> gen(ch);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> s<span style="color:#f92672">+</span>((t<span style="color:#f92672">-</span>s)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;=</span>m) update(i, ch, p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&gt;</span>m)  update(i, ch, p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    st[p].v <span style="color:#f92672">=</span> st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>].v <span style="color:#f92672">+</span> st[p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].v;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>T <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> p<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> st[p].s, t <span style="color:#f92672">=</span> st[p].t;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>s <span style="color:#f92672">&amp;&amp;</span> t<span style="color:#f92672">&lt;=</span>r) <span style="color:#66d9ef">return</span> st[p].v;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> s<span style="color:#f92672">+</span>((t<span style="color:#f92672">-</span>s)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    T ret;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>m) ret <span style="color:#f92672">=</span> ret<span style="color:#f92672">+</span>query(l,r,p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(r<span style="color:#f92672">&gt;</span>m)  ret <span style="color:#f92672">=</span> ret<span style="color:#f92672">+</span>query(l,r,p<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>mt19937_64 rng(time(<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>B;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        base[i] <span style="color:#f92672">=</span> rng() <span style="color:#f92672">%</span> mod[i]; <span style="color:#75715e">// 即随机生成的x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n,q;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>q;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>arr;
</span></span><span style="display:flex;"><span>    arr <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;#&#39;</span><span style="color:#f92672">+</span>arr;
</span></span><span style="display:flex;"><span>    build(<span style="color:#ae81ff">1</span>, n);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(q<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> op;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>op;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(op<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> c;
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>x<span style="color:#f92672">&gt;&gt;</span>c;
</span></span><span style="display:flex;"><span>            update(x,c);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 判断[l,r]是否为回文串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> l, r;
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>l<span style="color:#f92672">&gt;&gt;</span>r;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> h <span style="color:#f92672">=</span> query(l, r);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">bool</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>B;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                ans <span style="color:#f92672">&amp;=</span> (h[i].h1<span style="color:#f92672">==</span>h[i].h2);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>(ans<span style="color:#f92672">?</span><span style="color:#e6db74">&#34;Yes&#34;</span><span style="color:#f92672">:</span><span style="color:#e6db74">&#34;No&#34;</span>)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="线性规划">线性规划</h2>
<p>有<span class="math inline">\(n\)</span>个变量，<span class="math inline">\(m\)</span>条约束，其中第<span class="math inline">\(i\)</span>条约束为<span class="math inline">\(\sum^n_{j=1}a_{ij}x_j\leq b_i\)</span></p>
<p>另外，所有变量都满足<span class="math inline">\(x_j\geq 0\)</span>。此时要求求出<span class="math inline">\(\sum^n_{j=1}c_jx_j\)</span>的最大值，以及对应的变量值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// UOJ179 线性规划
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#66d9ef">const</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">31</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> DB <span style="color:#f92672">=</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">double</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define double DB
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LP</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> n, m;  <span style="color:#75715e">// 变量个数，约束个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">double</span> cons
</span></span><span style="display:flex;"><span>        [MAXN]
</span></span><span style="display:flex;"><span>        [MAXN];  <span style="color:#75715e">// 0维为c_i,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                 <span style="color:#75715e">// 1~m维为约束条件，共m个，每个长度为n+1，第0维为b，1~n维为a_ij
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">double</span> <span style="color:#66d9ef">const</span> EPS <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e-8</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> idx[MAXN <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">solve</span>() {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>memset(idx, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(idx));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>) idx[i] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, e <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// 换入、换出变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> m; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (cons[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> <span style="color:#f92672">-</span>EPS <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">!</span>l <span style="color:#f92672">||</span> (rand() <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>)))
</span></span><span style="display:flex;"><span>                    l <span style="color:#f92672">=</span> i;  <span style="color:#75715e">// rand可以提升运行效率，避免TLE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>l) <span style="color:#66d9ef">return</span> Simplex();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (cons[l][j] <span style="color:#f92672">&lt;</span> <span style="color:#f92672">-</span>EPS <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">!</span>e <span style="color:#f92672">||</span> (rand() <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>))) e <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>e) {
</span></span><span style="display:flex;"><span>                std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Infeasible</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;  <span style="color:#75715e">// 无解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Pivot(l, e);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Simplex</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, e <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (cons[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">&gt;</span> EPS) {
</span></span><span style="display:flex;"><span>                    e <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>e) <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">double</span> minv <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e18</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> m; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (cons[i][e] <span style="color:#f92672">&gt;</span> EPS <span style="color:#f92672">&amp;&amp;</span> cons[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">/</span> cons[i][e] <span style="color:#f92672">&lt;</span> minv) {
</span></span><span style="display:flex;"><span>                    minv <span style="color:#f92672">=</span> cons[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">/</span> cons[i][e];
</span></span><span style="display:flex;"><span>                    l <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>l) {
</span></span><span style="display:flex;"><span>                std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Unbounded</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Pivot(l, e);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Pivot</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> e) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>swap(idx[n <span style="color:#f92672">+</span> l], idx[e]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">double</span> t <span style="color:#f92672">=</span> cons[l][e];
</span></span><span style="display:flex;"><span>        cons[l][e] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) cons[l][j] <span style="color:#f92672">/=</span> t;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> m; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> l <span style="color:#f92672">&amp;&amp;</span> std<span style="color:#f92672">::</span>abs(cons[i][e]) <span style="color:#f92672">&gt;</span> EPS) {
</span></span><span style="display:flex;"><span>                t <span style="color:#f92672">=</span> cons[i][e];
</span></span><span style="display:flex;"><span>                cons[i][e] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;=</span> n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                    cons[i][j] <span style="color:#f92672">-=</span> t <span style="color:#f92672">*</span> cons[l][j];
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">double</span> ans[<span style="color:#ae81ff">31</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    LP lp;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> lp.n <span style="color:#f92672">&gt;&gt;</span> lp.m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> type;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> type;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> lp.n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> lp.cons[<span style="color:#ae81ff">0</span>][i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> lp.m; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> lp.n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> lp.cons[i][j];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> lp.cons[i][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>fixed;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout.precision(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (lp.solve()) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">-</span>lp.cons[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (type) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> lp.m; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>                ans[lp.idx[i <span style="color:#f92672">+</span> lp.n]] <span style="color:#f92672">=</span> lp.cons[i][<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> lp.n; i<span style="color:#f92672">++</span>) std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> ans[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="c-stl用法">C++ STL用法</h1>
<h2 id="stdswap">std::swap</h2>
<p>交换两个元素的内容（也可以交换数组，不重要不介绍）。复杂度：常数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a,b;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>swap(a,b);
</span></span></code></pre></div><p>注意其中的两个参数，类型要相同。不能一个是LL一个是int。</p>
<h2 id="stdsort">std::sort</h2>
<p>对数组、vector等进行排序。复杂度nlogn。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>sort(a,a<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>sort(vec.begin(),vec.end());
</span></span></code></pre></div><p>注意排序范围是左闭右开区间。</p>
<p>通常会按照类型的&lt;操作符来进行比较。如果对结构体进行排序，可以重载运算符或者设定cmp函数。注意这两种方法一定不能是小于等于或者大于等于的运算，必须只使用小于号或者大于号（严格弱序）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">const</span> Type1<span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">const</span> Type2<span style="color:#f92672">&amp;</span> b);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//然后在sort中加入第三个参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>sort(a,a<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>,cmp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">const</span> node<span style="color:#f92672">&amp;</span> a);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">//不用添加cmp参数
</span></span></span></code></pre></div><h2 id="stdmerge">std::merge</h2>
<p>对两个有序数组进行合并。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a(<span style="color:#ae81ff">5</span>), b(<span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> c(<span style="color:#ae81ff">5</span><span style="color:#f92672">+</span><span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>merge(a.begin(), a.end(), b.begin(), b.end(), c.begin(), std<span style="color:#f92672">::</span>less<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>());
</span></span></code></pre></div><p>如上，假设a和b都是从小到大排好序的数组，把它们合并成同样从小到大排序的c数组。如果是从大到小合并成从大到小，则改成std::greater</p>
<p>另外，它的操作逻辑是双指针。比如less情况下，指向a数组元素的指针为p1，指向b数组元素的指针为p2。他会判断p1大还是p2大，如果p1大，则把p1指向的数字放进c，然后p1自增。否则p2放进去后自增。他其实不会管你原来的数组是否真的排好序，有时候这可以用在一些数组的合并上。</p>
<h2 id="stdgreater-stdless">std::greater, std::less</h2>
<p>很简单，greater是大于号<code>&gt;</code>，而less是小于号<code>&lt;</code>。在sort函数里的第三个参数可以用这个，例如<code>std::greater&lt;int&gt;()</code>代表从大到小排序，<code>std::less&lt;int&gt;()</code>则是从小到大排序。</p>
<p>但是在优先队列里不一样，greater是小根堆，而less才是大根堆。</p>
<h2 id="stdlower_boundstdupper_bound">std::lower_bound,std::upper_bound</h2>
<p>对某个已经排序好的数组，查找第一个大于等于（lower_bound）或者大于(upper_bound)某个给定值的元素。复杂度：logn（对于随机访问的迭代器），n（对于其他迭代器）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">5</span>]<span style="color:#f92672">=</span>{<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">6</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> first <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>lower_bound(a,a<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">3</span>);
</span></span></code></pre></div><p>同样是左闭右开区间，第三个参数是指定的值。如果找到就会返回所查找元素的迭代器（或者指针）。找不到就会返回末尾元素的后一个指针（或者end迭代器）。</p>
<p>如果需要自定义比较方法，同sort函数。</p>
<h2 id="stdmaxstdmin">std::max,std::min</h2>
<p>对于两个元素返回最大值和最小值。复杂度：准确一次比较。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,b<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> maxv <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>max(a,b);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> minv <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>min(a,b);
</span></span></code></pre></div><p>同样，两个参数类型相同。自定义比较方法同sort。如果要比较三四个元素，可以使用initializer_list，例如std::max({1,2,3,4,5});</p>
<h2 id="stdmax_elementstdmin_element">std::max_element,std::min_element</h2>
<p>返回一个范围内的最大（最小元素）的迭代器（指针）。复杂度，准确比较max(N-1,0)次</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v{<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">14</span>,<span style="color:#ae81ff">9</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;*</span>std<span style="color:#f92672">::</span>max_element(v.begin(),v.end())<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span></code></pre></div><h2 id="stdabs">std::abs</h2>
<p>计算绝对值。复杂度：文档没写但应该是常数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>abs(a);
</span></span></code></pre></div><p>注意，函数只有float,double,long double的返回值类型。使用时如果给予整数参数会自动转换，这是否会导致精度问题有待观察。</p>
<h2 id="stdstring">std::string</h2>
<h3 id="swap">::swap</h3>
<p>将两个字符串互换。复杂度：常数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;123456&#34;</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string str2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;456789&#34;</span>;
</span></span><span style="display:flex;"><span>str.swap(str2);
</span></span></code></pre></div><h3 id="beginstdend">::begin,std::end</h3>
<p>返回字符串的起始得带器和结尾迭代器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>str.begin();str.end();
</span></span></code></pre></div><h3 id="size">::size</h3>
<p>返回字符串的大小。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>str.size();
</span></span></code></pre></div><h3 id="push_back">::push_back</h3>
<p>向字符串末尾添加一个字符，同时大小加一。复杂度：常数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>str.push_back(<span style="color:#e6db74">&#39;a&#39;</span>);
</span></span></code></pre></div><h3 id="pop_back">::pop_back</h3>
<p>将字符串末尾的字符弹出，同时大小减一。如果字符串为空则未定义。复杂度：常数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>str.pop_back();
</span></span></code></pre></div><h3 id="find">::find</h3>
<p>在字符串中寻找某个子串是否存在。复杂度：没有规定，编译器不一定都是使用的kmp算法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">::</span>size_type n;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;this is a string&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> s.find(<span style="color:#e6db74">&#34;is&#34;</span>);
</span></span></code></pre></div><p>如果找到则返回首个匹配的首字母位置。否则返回std::string::npos。如果是int n作为s.find的接收端，则会在找不到时接收到-1。</p>
<h3 id="replace">::replace</h3>
<p>将字符串的某个片段替换为另一个字符串</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abcd efgh&#34;</span>;
</span></span><span style="display:flex;"><span>s.replace(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#34;aaaa&#34;</span>);
</span></span></code></pre></div><p>第一个参数是开始位置的下标，第二个参数是指从开始位置有几个字符，第三个参数是将要替换进去的字符串，上式结果是&quot;aaaaa efgh&quot;。</p>
<h3 id="substr">::substr</h3>
<p>获取自字符串</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abcd efgh&#34;</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string b <span style="color:#f92672">=</span> s.substr(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>);
</span></span></code></pre></div><p>从下标1开始的3个字符，即b=&ldquo;bcd&rdquo;。</p>
<h2 id="stdmemset">std::memset</h2>
<p>将值复制到dest所指对象的前count个字节中。复杂度：没有规定。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">20</span>];
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>memset(a,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(a));
</span></span></code></pre></div><p>注意，赋的值不能随便取，这个函数是一个字节一个字节地去赋值的。如果取1并不会得到全部赋值为1的效果，通常只会取0和-1。</p>
<h2 id="stdcopy">std::copy</h2>
<p>将一个范围的值复制给另一个范围，复杂度：准确赋值 (last - first) 次</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">10</span>],b[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>copy(a,a<span style="color:#f92672">+</span><span style="color:#ae81ff">10</span>,b);<span style="color:#75715e">//源起点，源终点，目的地起点
</span></span></span></code></pre></div><p>需要注意的点是，不要数组越界，包括源不要越界，目标的大小也要足够复制。类型要一致。以及，目标起点的地址不能在源之内，否则行为是未定义的。</p>
<h2 id="stdfill">std::fill</h2>
<p>将给定值填写到整个范围中，复杂度：准确赋值 std::distance(first, last) 次。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>fill(v.begin(), v.end(), <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span></code></pre></div><p>之后v变成全-1的vector。</p>
<p>可以对C数组使用指针，和memset不一样的是，memset是字节赋值，fill并不会把4字节的int每一个字节都赋值一次。</p>
<p>注意，如果你对结构体数组使用，你不能直接像memset一样全部memset为0。你要创建一个你认为的初始化应该有的值，再fill进去。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a,b;
</span></span><span style="display:flex;"><span>}a[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>memset(a,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(a));
</span></span><span style="display:flex;"><span><span style="color:#75715e">//std::fill(a,a+100,0);//出错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>A tmp <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>fill(a,a<span style="color:#f92672">+</span><span style="color:#ae81ff">100</span>,tmp);
</span></span></code></pre></div><h2 id="stdmap">std::map</h2>
<p>map是有序键值对容器，通常用红黑树实现。元素的键是唯一的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Key</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Compare</span> <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>less<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Allocator</span> <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>allocator<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> Key, T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">map</span>;
</span></span></code></pre></div><p>可以通过迭代器来遍历</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it <span style="color:#f92672">=</span> mp.begin();it<span style="color:#f92672">!=</span>mp.end();it<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//访问元素用it-&gt;first和it-&gt;second
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//或者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> it:mp);
</span></span><span style="display:flex;"><span><span style="color:#75715e">//访问元素用it.first和it.second
</span></span></span></code></pre></div><h3 id="自定义比较函数">自定义比较函数</h3>
<p>map通常会按照key的大小关系进行升序排列。如果要自定义比较函数，则</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cmp</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> b) <span style="color:#66d9ef">const</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a<span style="color:#f92672">&gt;</span>b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,std<span style="color:#f92672">::</span>string,cmp<span style="color:#f92672">&gt;</span> mp;
</span></span></code></pre></div><h3 id="empty">::empty</h3>
<p>检测是否为空。</p>
<h3 id="size-1">::size</h3>
<p>返回大小。</p>
<h3 id="clear">::clear</h3>
<p>清除所有内容。复杂度：线性。</p>
<h3 id="erase">::erase</h3>
<p>提供迭代器，删除迭代器所指的键值对。复杂度：常数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> mp.begin();
</span></span><span style="display:flex;"><span>mp.erase(it);
</span></span></code></pre></div><p>当然也可以提供两个迭代器，删除这之间的所有元素（左闭右开区间）</p>
<h3 id="find-1">::find</h3>
<p>寻找key等于给定值的元素，返回迭代器。如果没有找到则返回end迭代器。复杂度：对数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> mp.find(<span style="color:#ae81ff">1</span>);
</span></span></code></pre></div><h3 id="lower_boundupper_bound">::lower_bound,::upper_bound</h3>
<p>寻找首个大于等于(或大于，对upper_bound)给定值的key。复杂度：对数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> it <span style="color:#f92672">=</span> mp.lower_bound(<span style="color:#ae81ff">1</span>);
</span></span></code></pre></div><h2 id="stdunordered_map">std::unordered_map</h2>
<p>可以看作是无序的map，通常由哈希表实现。这意味着map中和排序有关的函数都不能使用。</p>
<p><strong>警告</strong></p>
<p>unordered_map可能不能用auto x:mp或者迭代器遍历。它的遍历可能是遍历bucket，而不是遍历元素。但是只是查找是可以的。</p>
<p>这里的bucket是指哈希桶，也就是用拉链法实现的hash表。</p>
<h2 id="stdset">std::set</h2>
<p>set是关联容器，含有Key类型对象的已排序集，通常用红黑树实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Key</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Compare</span> <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>less<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Allocator</span> <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>allocator<span style="color:#f92672">&lt;</span>Key<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">set</span>;
</span></span></code></pre></div><p>遍历的方式与map相同。</p>
<h3 id="使用方法">使用方法</h3>
<p>自定义比较函数,empty,size,clear,erase,find,lower_bound,upper_bound都与map相同。</p>
<h3 id="insert">::insert</h3>
<p>map可以用[]进行插入，但是set只能用insert函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> st;
</span></span><span style="display:flex;"><span>st.insert(<span style="color:#ae81ff">1</span>);
</span></span></code></pre></div><p>返回值是一个pair，first是迭代器，指向被插入进去的元素（如果插入不成功则指向没插进去的元素），second是bool，插入成功时为true，否则为false。</p>
<h3 id="修改内部元素">修改内部元素</h3>
<p>有时候，我们需要修改内部元素。由于例如begin函数返回的迭代器是const的，我们无法直接修改数据。但我们可以给变量添加mutable修饰。这样我们就可以不用拿出来一个元素再插回去。例子可见珂朵莉树。</p>
<p>注意，如果你修改的数据和排序依据有关，set不会维护内部有序。要维护还得是拿出来再插入进去。</p>
<h2 id="stdunordered_set">std::unordered_set</h2>
<p>用哈希实现，没有内部排序。</p>
<p><strong>警告</strong></p>
<p>可能跟unordered_map一样不能遍历。</p>
<h2 id="stdmultiset">std::multiset</h2>
<p>与普通的set不同的是，可以插入多个相同的元素。这在一些情况下是有用的，而且它还是满足内部有序。</p>
<p>可以用::count(x)来统计Key为x的元素的数量，普通的set也有这个方法，但是要么是0要么是1，与find功能可以说是重复。但是multiset可以统计数量。</p>
<p>注意，用erase方法时，如果给出的是一个值，那么会把等于这个值的元素都删掉，如果给出迭代器，那么之后删一个。所以，只想删一个等于这个值的元素时，用erase(find(&hellip;))</p>
<h2 id="stdstack">std::stack</h2>
<p>栈，有先入后出特性。</p>
<h3 id="top">::top</h3>
<p>访问栈顶元素，复杂度：常数。</p>
<h3 id="empty-1">::empty</h3>
<p>检查是否为空，复杂度：常数</p>
<h3 id="size-2">::size</h3>
<p>返回元素个数，复杂度：常数</p>
<h3 id="push">::push</h3>
<p>将元素推入栈，复杂度：通常和deque的push_back相同，即常数</p>
<h3 id="pop">::pop</h3>
<p>将栈顶弹出，复杂度：通常和deque的pop_back相同，即常数</p>
<h3 id="emplace">::emplace</h3>
<p>在顶部原位构造元素，通常会用在栈的元素是结构体的时候，复杂度：通常和deque的emplace_back相同，即常数</p>
<h2 id="stdqueue">std::queue</h2>
<p>队列，拥有先入先出特性。</p>
<h3 id="front">::front</h3>
<p>访问队首元素，复杂度：常数</p>
<h3 id="back">::back</h3>
<p>访问队尾元素，复杂度：常数</p>
<h3 id="其他方法">其他方法</h3>
<p>同stack，不过push是推入队尾，pop是弹出队首。</p>
<h2 id="stdpriority_queue">std::priority_queue</h2>
<p>优先队列，提供常数时间的最大（或最小）元素查找，以及对数时间的插入与删除。</p>
<h3 id="自定义比较方法">自定义比较方法</h3>
<p>通常我们会重载元素的运算符来自定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> dis, u;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">const</span> node<span style="color:#f92672">&amp;</span> a) <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> dis <span style="color:#f92672">&gt;</span> a.dis; }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>priority_queue<span style="color:#f92672">&lt;</span>node, vector<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span>, greater<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> pq;
</span></span></code></pre></div><h3 id="方法">方法</h3>
<p>其方法与stack相同，只不过没有先入后出特性，插入元素或弹出元素后会根据大小关系进行排序，保证栈顶是最大的（或最小的）元素。</p>
<h2 id="stddeque">std::deque</h2>
<p>双端队列，允许在队首和队尾进行插入和删除。另外，在 deque 任一端插入或删除不会非法化指向其余元素的指针或引用。通常也会用来实现单调队列。</p>
<h3 id="方法-1">方法</h3>
<p>size、empty与stack、queue相同。其pop_back、push_back、pop_front、push_front、emplace_front、emplace_back用法也类似。</p>
<h2 id="stdvector">std::vector</h2>
<p>通常可以理解为一个可以变化长度的数组。</p>
<h3 id="声明方法">声明方法</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec;<span style="color:#75715e">//声明一个初始大小为0的vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec2(n);<span style="color:#75715e">//声明一个初始大小为n的vector，每个元素都会初始化为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec3(n,<span style="color:#ae81ff">1</span>);<span style="color:#75715e">//与上一个不同的是，每一个元素都会初始化为1
</span></span></span></code></pre></div><h3 id="元素访问">元素访问</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vec[<span style="color:#ae81ff">5</span>];<span style="color:#75715e">//像数组一样访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vec.at(<span style="color:#ae81ff">5</span>);<span style="color:#75715e">//与上一个方法的差别在会进行越界检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vec.front();<span style="color:#75715e">//访问第一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vec.back();<span style="color:#75715e">//访问最后一个元素
</span></span></span></code></pre></div><h3 id="size-3">::size</h3>
<p>获取大小，复杂度：常数</p>
<h3 id="empty-2">::empty</h3>
<p>查看是否为空，复杂度：常数</p>
<h3 id="push_back-1">::push_back</h3>
<p>向末尾添加元素，复杂度：常数</p>
<h3 id="pop_back-1">::pop_back</h3>
<p>把末尾元素弹出，复杂度：常数</p>
<h3 id="emplace_back">::emplace_back</h3>
<p>在末尾原位构造元素，复杂度：常数</p>
<h3 id="resize">::resize</h3>
<p>重新指定vector的大小，会改变size()，resize有两个参数(new_size, value)，第一个为要分配的大小，第二个为指定的初始值（可以忽略，此时调用默认构造函数）。注意只有加大size时，新增的元素会被赋值。</p>
<h3 id="reserve">::reserve</h3>
<p>给vector预留空间，但不会改变size()的大小。参数只有一个，为预留的元素个数。</p>
<p>如果dfs中参数引用的vector会导致RE，可以试试预留足够的大小。</p>
<h3 id="stdvectorbool">std::vector&lt;bool&gt;</h3>
<p>这是一个特化的vector，它每一个元素所占的空间是一位，而不是sizeof(bool)（通常是一字节）。</p>
<p>不建议使用，除非非常了解会发生什么。</p>
<p>operator[]返回的不是bool类型，返回的是一个proxy reference。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> c{false,true,true};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> a <span style="color:#f92672">=</span> c[<span style="color:#ae81ff">0</span>];<span style="color:#75715e">//经过了强制类型转换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span> b <span style="color:#f92672">=</span> c[<span style="color:#ae81ff">0</span>];<span style="color:#75715e">//没有转换，本身b就是引用了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>a <span style="color:#f92672">=</span> true;<span style="color:#75715e">//c是0 1 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>b <span style="color:#f92672">=</span> true;<span style="color:#75715e">//c是1 1 1
</span></span></span></code></pre></div><h2 id="stdbitset">std::bitset</h2>
<p>表示一串二进制位。</p>
<h3 id="声明方法-1">声明方法</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>bitset<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">100</span><span style="color:#f92672">&gt;</span> bs;<span style="color:#75715e">//声明一个位数为100位的bitset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>bitset<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span><span style="color:#f92672">&gt;</span> bs2{<span style="color:#ae81ff">0xA</span>};<span style="color:#75715e">//声明一个四位的bitset，其值等于0xA
</span></span></span></code></pre></div><h3 id="元素访问-1">元素访问</h3>
<p>同数组的访问方式。同样也可以用数组的方式进行修改。</p>
<h3 id="allanynone">::all,::any,::none</h3>
<p>检查是否全部，存在、没有元素被设置为true。</p>
<h3 id="count">::count</h3>
<p>返回设置为true的数量。</p>
<h3 id="运算">运算</h3>
<p>bitset和bitset之间能用所有的位运算符。也可以用等号和不等号比较。</p>
<h3 id="flip">::flip</h3>
<p>翻转某一位的值。</p>
<p>如果没有提供位置，就翻转所有。</p>
<h3 id="to_string">::to_string</h3>
<p>转化为二进制数的字符串。</p>
<h3 id="to_ulongto_ullong">::to_ulong,::to_ullong</h3>
<p>转化为unsigned long和unsigned long long。</p>
<h3 id="set">::set</h3>
<p>设置某一位为1，如果没有提供位置，则将所有位设为1</p>
<h3 id="reset">::reset</h3>
<p>设置某一位为0，如果没有提供位置，则将所有位设置为0</p>
<h2 id="stdpair">std::pair</h2>
<p>定义一个二元组，例如std::pair&lt;int,int&gt;, std::pair&lt;int,std::string&gt;等。其定义是在&lt;utility&gt;中，但是也可以#include &lt;algorithm&gt;来使用</p>
<h3 id="元素访问-2">元素访问</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> p;
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">-&gt;</span>first;<span style="color:#75715e">//访问第一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>p<span style="color:#f92672">-&gt;</span>second;<span style="color:#75715e">//访问第二个元素
</span></span></span></code></pre></div><h3 id="swap-1">::swap</h3>
<p>交换两个元素的内容。复杂度：没有定义。</p>
<h3 id="stdmake_pair">std::make_pair</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_pair(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);<span style="color:#75715e">//自动推断类型为std::pair&lt;int,int&gt;
</span></span></span></code></pre></div><h2 id="stdtuple">std::tuple</h2>
<p>定义一个多元组，可以说pair是tuple的特例。其定义是在&lt;utility&gt;中，但是也可以#include &lt;algorithm&gt;来使用</p>
<h3 id="元素访问-3">元素访问</h3>
<p>根据下标可以如下访问</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_tuple(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Foo&#34;</span>, <span style="color:#ae81ff">3.14</span>);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&gt;</span>(t);<span style="color:#75715e">//1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>(t);<span style="color:#75715e">//Foo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span><span style="color:#f92672">&gt;</span>(t);<span style="color:#75715e">//3.14
</span></span></span></code></pre></div><h3 id="stdmake_tuple">std::make_tuple</h3>
<p>同pair。</p>
<p>如果一个函数要返回tuple</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>tuple<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> foo_tuple() 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> {<span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};  <span style="color:#75715e">// N4387 前错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>tuple<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>{<span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};  <span style="color:#75715e">// 始终有效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> std<span style="color:#f92672">::</span>make_tuple(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 始终有效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>需要注意兼容性，有些编译器不支持第一种返回方式。</p>
<h3 id="stdtie">std::tie</h3>
<p>将tuple解包。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_tuple(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#34;Foo&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a,b;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string str;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>tie(a,b,str) <span style="color:#f92672">=</span> t;
</span></span></code></pre></div><p>当然也可以用auto，都不需要指定变量类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span>[c,d,str2] <span style="color:#f92672">=</span> t;
</span></span></code></pre></div><h2 id="stdlist">std::list</h2>
<h3 id="声明方法-2">声明方法</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> l;<span style="color:#75715e">//如果有初值可以l = {1,2,3};
</span></span></span></code></pre></div><h3 id="元素访问-4">元素访问</h3>
<p>链表的特性让我们无法随机访问，只能用<code>front()</code>和<code>end()</code>访问开始和结束元素。</p>
<h3 id="empty-3">::empty()</h3>
<p>返回是否为空</p>
<h3 id="size-4">::size()</h3>
<p>返回元素个数</p>
<h3 id="clear-1">::clear()</h3>
<p>清空</p>
<h3 id="begin-end-rbegin-rend">::begin(), ::end(), ::rbegin(), ::rend()</h3>
<p>返回开始、结束迭代器。返回反向开始、结束迭代器。所以list是双向链表。</p>
<h3 id="insertpos-value">::insert(pos, value)</h3>
<p><code>pos</code>是一个迭代器，会在<code>pos</code>前面插入值为<code>value</code>的元素，不会使任何迭代器失效。</p>
<h3 id="erasepos">::erase(pos)</h3>
<p><code>pos</code>是一个迭代器，移除<code>pos</code>所指的元素。只有指向该元素的迭代器会失效，其他的不会。</p>
<h3 id="push_backv-pop_back-push_frontv-pop_front">::push_back(v), ::pop_back(), ::push_front(v), ::pop_front()</h3>
<p>和双向队列一样，不再介绍</p>
<h3 id="mergelist-other">::merge(list&amp; other)</h3>
<p>将两个有序的链表合并，得到的新链表保持有序。另外新列表是调用这个方法的链表，other则会清空（如果两个链表相等则不会做任何事）。</p>
<p>迭代器和引用不会失效。指向other元素的迭代器之后会指向新链表里的对应元素。</p>
<h3 id="reverse">::reverse()</h3>
<p>翻转链表，迭代器不会失效。</p>
<h3 id="sort">::sort()</h3>
<p>排序，复杂度为nlogn</p>
<h3 id="unique">::unique()</h3>
<p>删除连续的重复的元素，只保留第一个，被删除元素的迭代器失效。</p>
<h2 id="stdnext_permutation-stdprev_permutation">std::next_permutation, std::prev_permutation</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">next_permutation</span> (Iterator first, Iterator last);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">prev_permutation</span>(Iterator first, Iterator last);
</span></span></code></pre></div><p>这两个算法都是“原地”算法，也就是说会直接更改原数组，而不会返回一个新数组。这两个函数的作用是，获取按字典序比当前排列小1号的排列，以及大1号的排列。</p>
<p>例如123是一个排列，比它正好大1号的排列是132，再大1号的是213。比321小1号的是312。</p>
<p>用法如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span>string number <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;213&#34;</span>;
</span></span><span style="display:flex;"><span>next_permutation(number.begin(), number.end());
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> number;
</span></span></code></pre></div><p>输出231。</p>
<p>如果当前已经是最小的还要得到更小的，则返回false。已经是最大的还要得到更大的，则返回false。其他情况返回true。</p>
<p>复杂度：线性。</p>
<h2 id="stdunique">std::unique</h2>
<p>对一个已经排好序的数组去除重复元素。或者说是，移除一个一般数组中相邻的、相同的元素。复杂度：线性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span>Iterator <span style="color:#a6e22e">unique</span>(Iterator first, Iterator last);
</span></span></code></pre></div><p>给出一个范围来进行这个操作。具体用例可以见离散化一节。</p>
<p>返回值是新数组的末尾的迭代器。</p>
<h2 id="stdmt19937_64">std::mt19937_64</h2>
<p>本功能在C++11后可以使用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;random&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;ctime&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>mt19937_64 rng(time(<span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>B;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    base[i] <span style="color:#f92672">=</span> rng() <span style="color:#f92672">%</span> mod[i]; <span style="color:#75715e">// 即随机生成[0,mod[i])之间的整数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>使用梅森缠绕算法，给出<span class="math inline">\([0,2^{64})\)</span>之间的随机数，如果想要32位的，用mt19937即可。其比cstdlib中的srand和rand生成的随机数性质要好得多，并且rand()的范围不那么好设置。推荐在涉及随机的算法中优先使用这个生成器。</p>
<h2 id="stdcin">std::cin</h2>
<h3 id="输入十六进制八进制二进制">输入十六进制、八进制、二进制</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>std<span style="color:#f92672">::</span>hex<span style="color:#f92672">&gt;&gt;</span>a;<span style="color:#75715e">//16进制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>std<span style="color:#f92672">::</span>dec<span style="color:#f92672">&gt;&gt;</span>a;<span style="color:#75715e">//10进制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>std<span style="color:#f92672">::</span>oct<span style="color:#f92672">&gt;&gt;</span>a;<span style="color:#75715e">//8进制
</span></span></span></code></pre></div><p>注意，使用一次std::hex之后所有的输入都会是十六进制，需要用std::dec输入一次十进制才会转换回来。</p>
<p>输入二进制可以考虑用bitset</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>bitset<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">32</span><span style="color:#f92672">&gt;</span> bs;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cin<span style="color:#f92672">&gt;&gt;</span>bs;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>bs.to_ulong();
</span></span></code></pre></div><h3 id="输入不忽略空格回车">输入不忽略空格、回车</h3>
<p>虽然可以用cin.get()和cin.getline()来实现，但是我们还是考虑用getchar比较好，当getchar返回EOF时代表输入结束。类似于逗号表达式返回最后一个的值，等号表达式返回等号左边的值，所以我们可以写(c=getchar())!=EOF。</p>
<h2 id="stdcout">std::cout</h2>
<h3 id="输出十六进制八进制二进制">输出十六进制、八进制、二进制</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">16</span>;
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>hex<span style="color:#f92672">&lt;&lt;</span>a;<span style="color:#75715e">//16进制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>oct<span style="color:#f92672">&lt;&lt;</span>a;<span style="color:#75715e">//8进制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>dec<span style="color:#f92672">&lt;&lt;</span>a;<span style="color:#75715e">//10进制
</span></span></span></code></pre></div><p>使用注意事项同前。</p>
<p>输出二进制也是考虑用bitset</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>bitset<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">32</span><span style="color:#f92672">&gt;</span> bs{<span style="color:#ae81ff">64</span>};
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>string ans <span style="color:#f92672">=</span> bs.to_string();
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>ans.substr(ans.find(<span style="color:#e6db74">&#39;1&#39;</span>),<span style="color:#66d9ef">int</span>(ans.end()<span style="color:#f92672">-</span>ans.begin()))<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span></code></pre></div><p>需要去除前导0，如果直接输出bs或者其to_string的话会带有前导0</p>
<h3 id="浮点数精度">浮点数精度</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>fixed;<span style="color:#75715e">//如果不用这个，则为有效数字四位。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout.precision(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>a;<span style="color:#75715e">//这里输出小数点后4位。
</span></span></span></code></pre></div><h2 id="scanf-todo">scanf TODO</h2>
<h3 id="输入十六进制八进制二进制-1">输入十六进制、八进制、二进制</h3>
<h2 id="printf-todo">printf TODO</h2>
<h3 id="输出十六进制八进制二进制-1">输出十六进制、八进制、二进制</h3>
<h2 id="atoi-todo">atoi TODO</h2>
<h2 id="正则表达式">正则表达式</h2>
<h3 id="正则表达式语法">正则表达式语法</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>功能</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>literal</td>
<td>匹配字符串的值</td>
<td>foo</td>
</tr>
<tr>
<td>\|转义符，将一些正则表达式需要的符号进行转义</td>
<td>\.</td>
<td></td>
</tr>
<tr>
<td>()</td>
<td>括选一些字符，方便星号、加号等当作一个整体处理</td>
<td>a(abc)*</td>
</tr>
<tr>
<td>re1|re2</td>
<td>匹配re1或匹配re2的值</td>
<td>foo|bar</td>
</tr>
<tr>
<td>.</td>
<td>匹配换行符以外的单字符</td>
<td>a.b</td>
</tr>
<tr>
<td>^</td>
<td>在字符串开头匹配（在方括号里除外）</td>
<td>^Dear</td>
</tr>
<tr>
<td>$</td>
<td>在字符串的结尾匹配</td>
<td>\.sh$</td>
</tr>
<tr>
<td>*</td>
<td>匹配星号前面的零次、一次或多次</td>
<td>a(abc)*</td>
</tr>
<tr>
<td>+</td>
<td>匹配加号前面的一次或多次</td>
<td>a(abc)+</td>
</tr>
<tr>
<td>?</td>
<td>匹配问号前面的零次或一次</td>
<td>a(abc)?</td>
</tr>
<tr>
<td>{N}</td>
<td>指定匹配次数</td>
<td>a(abc){5}</td>
</tr>
<tr>
<td>{M,N}</td>
<td>匹配出现次数在M,N之间的，如果左边留空代表0次，右边留空代表任意次</td>
<td>a(abc){2,8}</td>
</tr>
<tr>
<td>[&hellip;]</td>
<td>匹配其中的任意字符</td>
<td>[aeiou],[0-9A-Za-z]</td>
</tr>
<tr>
<td>[^&hellip;]</td>
<td>匹配除了其中字符的任意字符</td>
<td>[^aeiou]</td>
</tr>
<tr>
<td>\n</td>
<td>匹配回车符</td>
<td></td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符</td>
<td></td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空字符</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>贪婪匹配</strong></p>
<p>*，+都是贪婪匹配的，也就是说，如果用&quot;&lt;.*&gt;&ldquo;匹配&rdquo;&lt;h1&gt;测试&lt;/h1&gt;&ldquo;会匹配到全文，而不是只匹配到&rdquo;&lt;h1&gt;&ldquo;这叫做贪婪匹配。如果遇到第一个满足的就停下，要用&rdquo;&lt;.*?&gt;&quot;&quot;</p>
<h3 id="c正则表达式库">C++正则表达式库</h3>
<h4 id="stdregex">std::regex</h4>
<p>一个类型，可以设定匹配的模式串。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>regex pattern(<span style="color:#e6db74">&#34;.*&lt;.*?&gt;.*&#34;</span>);
</span></span></code></pre></div><p>后续如果要更换pattern的内容，可以使用pattern.assign(&ldquo;sth.&quot;)或者直接pattern = &ldquo;sth.&rdquo;</p>
<h4 id="stdsmatch">std::smatch</h4>
<p>一个类型，可以用于接收匹配的结果。</p>
<h4 id="stdregex_match">std::regex_match</h4>
<p>用于测试字符串是否匹配模式串</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">regex_match</span>(string s,regex pattern);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">regex_match</span>(string s,smatch res,regex pattern);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">regex_match</span>(s.cbegin(),s.cend(),smatch res,regex pattern);
</span></span></code></pre></div><p>如果匹配到，就会返回1，否则返回0。</p>
<p>s代表被匹配的字符串，pattern代表模式串。res代表，如果这个字符串被匹配了，就会返回这个字符串。注意这里是完全匹配，后面介绍的search函数是子串匹配。</p>
<p>res是smatch类型，不能直接cout，要输出res[0]。</p>
<p>如果要传入一个字符串的范围，需要传入const_iterator，也就是s.cbegin()和s.cend()返回的版本（这其实是因为smatch的模板是const_iterator，如果是c风格字符数组，传入的是头尾指针，则要用cmatch）。此时如果匹配上，返回res是这个范围的字符串，而不是整个。</p>
<p>const_iterator不是指迭代器指的位置不能变，而是指你不能通过这个迭代器去修改元素。</p>
<h4 id="stdregex_search">std::regex_search</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">regex_search</span>(string s,regex pattern);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">regex_search</span>(string s,smatch res,regex pattern);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">regex_search</span>(s.cbegin(),s.cend(),smatch res,regex pattern);
</span></span></code></pre></div><p>参数、返回值同前。</p>
<p>只不过，这个东西不是完全匹配，只要有任意子串匹配，就会返回1。而且只要匹配到一个就会返回（当然这里要注意贪婪和非贪婪），不会再往后搜索，所以如果你使用res[1]是不会输出第二个结果的。res[0]返回的是匹配到的子串的结果，res[1]以后的东西也有含义，但是我暂时觉得没什么用。</p>
<p>res[0]的类型是sub_match，可以使用.second方法得到res[0]在s中的匹配结果位置的末尾的迭代器，所以要遍历所有匹配的子序列，可以这么写：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(std<span style="color:#f92672">::</span>regex_search(it_begin,it_end,res,pattern)){
</span></span><span style="display:flex;"><span>   std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>res[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">&lt;&lt;</span>res.position()<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>   it_begin <span style="color:#f92672">=</span> res[<span style="color:#ae81ff">0</span>].second;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中你还可以用.position返回子串开头的位置（相对于it_begin而言）。</p>
<h4 id="stdregex_replace">std::regex_replace</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span>string regex_replace(string s,regex p,string rs)
</span></span></code></pre></div><p>s为源字符串，p为模式串，rs为匹配到的子串将会被替换成的字符串。</p>
<p>返回替换后的字符串。</p>
<p>这里会替换一切匹配到的子串，不像search一样麻烦。</p>
<p>如果我们只替换被匹配的子串的一部分，我们可以用如下方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-CPP" data-lang="CPP"><span style="display:flex;"><span>string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abcd123abcd&#34;</span>;
</span></span><span style="display:flex;"><span>regex <span style="color:#a6e22e">p</span>(<span style="color:#e6db74">&#34;(abcd)</span>([<span style="color:#ae81ff">0</span><span style="color:#f92672">-</span><span style="color:#ae81ff">9</span>]<span style="color:#f92672">+</span>)<span style="color:#e6db74">&#34;)</span>;
</span></span><span style="display:flex;"><span>string ss <span style="color:#f92672">=</span> regex_replace(s,p,<span style="color:#e6db74">&#34;a$2&#34;</span>);
</span></span></code></pre></div><p>则我们的ss会变成a123abcd。$2代表的是第二个捕捉组的意思（这里下标又是从1开始的，而不是0）。捕捉组是括号括起来的算一组。</p>
<table>
<thead>
<tr>
<th>转义符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$n</td>
<td>表示第n个捕捉组捕捉到的字符串</td>
</tr>
<tr>
<td>$&amp;</td>
<td>表示匹配到的整个子串，相当于$0</td>
</tr>
<tr>
<td>$`</td>
<td>在源字符串中，在匹配到的子串左边的部分</td>
</tr>
<tr>
<td>$'</td>
<td>在源字符串中，在匹配到的子串右边的部分</td>
</tr>
<tr>
<td>$$</td>
<td>美元符号</td>
</tr>
</tbody>
</table>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
        
            <a href="/tags/%E6%A8%A1%E6%9D%BF/">模板</a>
        
            <a href="/tags/%E5%B9%B2%E8%B4%A7/">干货</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/atcoder-beginner-conteset-263-e%E6%A6%82%E7%8E%87dp/">
        
        

        <div class="article-details">
            <h2 class="article-title">Atcoder Beginner Conteset 263 E（概率DP）</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/">
        
        
            <div class="article-image">
                <img src="/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/1.79caa0d7397355f82035319e18420be7_hue13a31d22502e6414becf06d466eec8f_119570_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-ecqg1zlzVfggNTGeGEIL5w==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">算法题-网络设备管理</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E5%90%91%E9%87%8F/">
        
        

        <div class="article-details">
            <h2 class="article-title">算法题-向量</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E7%AE%97%E6%B3%95%E9%A2%98-%E6%9C%89%E9%99%90%E5%B0%8F%E6%95%B0/">
        
        

        <div class="article-details">
            <h2 class="article-title">算法题-有限小数</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/inferior/%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97%E7%9A%84%E5%88%86%E9%85%8D%E5%BE%8B/">
        
        

        <div class="article-details">
            <h2 class="article-title">取余运算的分配律</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="kegalas/blogComments"
        issue-term="pathname"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2024 KegalaS的个人博客
    </section>
    
    <section class="powerby">
         <br />
        
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#字符串">字符串</a>
      <ol>
        <li><a href="#kmp">KMP</a></li>
        <li><a href="#字典树trie">字典树(Trie)</a></li>
        <li><a href="#字符串哈希">字符串哈希</a></li>
        <li><a href="#ac自动机">AC自动机</a></li>
        <li><a href="#最小表示法">最小表示法</a></li>
        <li><a href="#manacher">Manacher</a></li>
        <li><a href="#z函数">Z函数</a></li>
        <li><a href="#后缀数组">后缀数组</a></li>
        <li><a href="#后缀自动机">后缀自动机</a></li>
        <li><a href="#广义后缀自动机">广义后缀自动机</a></li>
        <li><a href="#回文字动机">回文字动机</a></li>
        <li><a href="#序列自动机">序列自动机</a></li>
      </ol>
    </li>
    <li><a href="#数论">数论</a>
      <ol>
        <li><a href="#欧几里得算法">欧几里得算法</a></li>
        <li><a href="#扩展欧几里得">扩展欧几里得</a></li>
        <li><a href="#欧拉筛">欧拉筛</a></li>
        <li><a href="#miller-rabin素数测试">Miller-Rabin素数测试</a></li>
        <li><a href="#乘法逆元">乘法逆元</a></li>
        <li><a href="#线性求逆元">线性求逆元</a></li>
        <li><a href="#线性同余方程">线性同余方程</a></li>
        <li><a href="#中国剩余定理">中国剩余定理</a></li>
        <li><a href="#积性函数">积性函数</a></li>
        <li><a href="#欧拉函数-todo习题">欧拉函数 TODO：习题</a></li>
        <li><a href="#狄利克雷卷积">狄利克雷卷积</a></li>
        <li><a href="#莫比乌斯反演-todo习题">莫比乌斯反演 TODO：习题</a></li>
        <li><a href="#数论分块">数论分块</a></li>
        <li><a href="#杜教筛">杜教筛</a></li>
      </ol>
    </li>
    <li><a href="#图论">图论</a>
      <ol>
        <li><a href="#存图">存图</a>
          <ol>
            <li><a href="#邻接矩阵">邻接矩阵</a></li>
            <li><a href="#邻接表vector版">邻接表（vector版）</a></li>
            <li><a href="#链式前向星vector版">链式前向星（vector版）</a></li>
            <li><a href="#链式前向星传统数组版">链式前向星（传统数组版）</a></li>
          </ol>
        </li>
        <li><a href="#最短路">最短路</a>
          <ol>
            <li><a href="#dijkstra">Dijkstra</a></li>
            <li><a href="#bellman-ford">Bellman-Ford</a></li>
            <li><a href="#spfa">SPFA</a></li>
            <li><a href="#floyd">Floyd</a></li>
            <li><a href="#johnson-todo">Johnson TODO</a></li>
          </ol>
        </li>
        <li><a href="#差分约束">差分约束</a></li>
        <li><a href="#拓扑排序">拓扑排序</a></li>
        <li><a href="#最小生成树">最小生成树</a>
          <ol>
            <li><a href="#kruskal">Kruskal</a></li>
            <li><a href="#prim算法">Prim算法</a></li>
          </ol>
        </li>
        <li><a href="#最小树形图朱刘算法">最小树形图（朱刘算法）</a></li>
        <li><a href="#二分图判定">二分图判定</a></li>
        <li><a href="#二分图匹配">二分图匹配</a>
          <ol>
            <li><a href="#最大匹配匈牙利算法">最大匹配（匈牙利算法）</a></li>
            <li><a href="#二分图的相关定理">二分图的相关定理</a></li>
            <li><a href="#最大匹配转换为网络流模型">最大匹配转换为网络流模型</a></li>
            <li><a href="#二分图最大权完美匹配km算法-todo-bfs版">二分图最大权完美匹配（KM算法） TODO: BFS版</a></li>
            <li><a href="#最大权匹配转化为费用流">最大权匹配转化为费用流</a></li>
          </ol>
        </li>
        <li><a href="#动态维护二分图判定-todo-例题">动态维护二分图判定 TODO: 例题</a></li>
        <li><a href="#网络流">网络流</a>
          <ol>
            <li><a href="#最大流">最大流</a>
              <ol>
                <li><a href="#dfs实现的ford-fulkerson">DFS实现的Ford-Fulkerson</a></li>
                <li><a href="#edmondskarp">EdmondsKarp</a></li>
                <li><a href="#dinic-todo-如果可能换成链式前向星">Dinic TODO: 如果可能换成链式前向星</a></li>
              </ol>
            </li>
            <li><a href="#isap算法-todo">ISAP算法 TODO</a></li>
            <li><a href="#最大流最小割定理">最大流最小割定理</a></li>
            <li><a href="#最小费用最大流">最小费用最大流</a>
              <ol>
                <li><a href="#ekspfa">EK+SPFA</a></li>
                <li><a href="#dinicspfa">Dinic+SPFA</a></li>
              </ol>
            </li>
            <li><a href="#上下界流">上下界流</a>
              <ol>
                <li><a href="#无源汇上下界可行流">无源汇上下界可行流</a></li>
                <li><a href="#有源汇上下界可行流">有源汇上下界可行流</a></li>
                <li><a href="#有源汇上下界最大流">有源汇上下界最大流</a></li>
                <li><a href="#有源汇上下界最小流">有源汇上下界最小流</a></li>
              </ol>
            </li>
          </ol>
        </li>
        <li><a href="#割边tarjan算法">割边（Tarjan算法）</a></li>
        <li><a href="#割点tarjan算法">割点（Tarjan算法）</a></li>
        <li><a href="#强连通分量tarjan算法">强连通分量（Tarjan算法）</a></li>
        <li><a href="#2-sat问题">2-SAT问题</a></li>
        <li><a href="#边双联通分量">边双联通分量</a></li>
        <li><a href="#边双联通缩点todo">边双联通缩点TODO</a></li>
        <li><a href="#点双联通分量">点双联通分量</a></li>
        <li><a href="#点双联通缩点todo">点双联通缩点TODO</a></li>
        <li><a href="#树的直径">树的直径</a></li>
        <li><a href="#树的重心">树的重心</a></li>
        <li><a href="#倍增求最近公共祖先">倍增求最近公共祖先</a></li>
        <li><a href="#虚树-todo">虚树 TODO</a></li>
        <li><a href="#点分治">点分治</a></li>
        <li><a href="#重链剖分">重链剖分</a>
          <ol>
            <li><a href="#重链剖分求lca">重链剖分求LCA</a></li>
            <li><a href="#重链剖分线段树维护树上路径点权和">重链剖分+线段树维护树上路径点权和</a></li>
          </ol>
        </li>
        <li><a href="#长链剖分">长链剖分</a>
          <ol>
            <li><a href="#求k级祖先">求K级祖先</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#计算几何-todo">计算几何 TODO</a>
      <ol>
        <li><a href="#基础板子">基础板子</a></li>
        <li><a href="#基本公式">基本公式</a>
          <ol>
            <li><a href="#正弦定理">正弦定理</a></li>
            <li><a href="#余弦定理">余弦定理</a></li>
            <li><a href="#向量积">向量积</a></li>
            <li><a href="#求任意多边形的周长">求任意多边形的周长</a></li>
            <li><a href="#求任意多边形的面积">求任意多边形的面积</a></li>
          </ol>
        </li>
        <li><a href="#二维凸包">二维凸包</a>
          <ol>
            <li><a href="#andrew扫描法">Andrew扫描法</a></li>
          </ol>
        </li>
        <li><a href="#旋转卡壳求最远点对">旋转卡壳求最远点对</a></li>
        <li><a href="#平面最近点对">平面最近点对</a></li>
        <li><a href="#扫描线算法">扫描线算法</a></li>
        <li><a href="#二维数点">二维数点</a></li>
        <li><a href="#pick定理">Pick定理</a></li>
      </ol>
    </li>
    <li><a href="#组合数学">组合数学</a>
      <ol>
        <li><a href="#用乘法逆元计算组合数">用乘法逆元计算组合数</a></li>
        <li><a href="#组合数的性质">组合数的性质</a></li>
        <li><a href="#圆排列">圆排列</a></li>
        <li><a href="#二项式反演">二项式反演</a></li>
        <li><a href="#斐波那契数列的性质">斐波那契数列的性质</a></li>
        <li><a href="#和式性质">和式性质</a>
          <ol>
            <li><a href="#基本性质">基本性质</a></li>
            <li><a href="#多重和式分配律">多重和式分配律</a></li>
            <li><a href="#多重和式次序交换">多重和式次序交换</a></li>
          </ol>
        </li>
        <li><a href="#卡特兰数">卡特兰数</a></li>
        <li><a href="#生成函数">生成函数</a></li>
        <li><a href="#稳定婚姻问题gale-shapley算法-todo">稳定婚姻问题(Gale-Shapley算法) TODO</a></li>
      </ol>
    </li>
    <li><a href="#数据结构">数据结构</a>
      <ol>
        <li><a href="#树状数组">树状数组</a>
          <ol>
            <li><a href="#树状数组求逆序对">树状数组求逆序对</a></li>
            <li><a href="#二维树状数组">二维树状数组</a></li>
          </ol>
        </li>
        <li><a href="#并查集">并查集</a></li>
        <li><a href="#线段树">线段树</a></li>
        <li><a href="#动态开点线段树">动态开点线段树</a></li>
        <li><a href="#权值线段树">权值线段树</a></li>
        <li><a href="#可持久化线段树">可持久化线段树</a>
          <ol>
            <li><a href="#单点修改">单点修改</a></li>
            <li><a href="#区间修改">区间修改</a></li>
            <li><a href="#主席树可持久化权值线段树">主席树（可持久化权值线段树）</a></li>
          </ol>
        </li>
        <li><a href="#线段树合并">线段树合并</a></li>
        <li><a href="#珂朵莉树">珂朵莉树</a></li>
        <li><a href="#分块">分块</a></li>
        <li><a href="#平衡树pbds实现">平衡树（pbds实现）</a></li>
        <li><a href="#01字典树">01字典树</a></li>
        <li><a href="#对顶堆">对顶堆</a></li>
        <li><a href="#单调栈">单调栈</a></li>
        <li><a href="#单调队列">单调队列</a></li>
        <li><a href="#st表">ST表</a></li>
      </ol>
    </li>
    <li><a href="#二分">二分</a>
      <ol>
        <li><a href="#二分答案">二分答案</a></li>
        <li><a href="#二分查找">二分查找</a></li>
        <li><a href="#二分求单调函数零点">二分求单调函数零点</a></li>
      </ol>
    </li>
    <li><a href="#三分法">三分法</a>
      <ol>
        <li><a href="#三分法求单峰函数的极值点">三分法求单峰函数的极值点</a></li>
        <li><a href="#三分套三分">三分套三分</a></li>
        <li><a href="#三分答案-todo">三分答案 TODO</a></li>
      </ol>
    </li>
    <li><a href="#动态规划">动态规划</a>
      <ol>
        <li><a href="#01背包">01背包</a></li>
        <li><a href="#完全背包">完全背包</a></li>
        <li><a href="#多重背包">多重背包</a></li>
        <li><a href="#分组背包">分组背包</a></li>
        <li><a href="#最长上升子序列">最长上升子序列</a></li>
        <li><a href="#dilworth定理">Dilworth定理</a></li>
        <li><a href="#最长公共子序列">最长公共子序列</a></li>
        <li><a href="#最大子段和">最大子段和</a></li>
        <li><a href="#斜率优化todo">斜率优化TODO</a></li>
        <li><a href="#四边形不等式todo">四边形不等式TODO</a></li>
        <li><a href="#悬线法">悬线法</a></li>
        <li><a href="#数位dp">数位DP</a></li>
      </ol>
    </li>
    <li><a href="#概率论">概率论</a>
      <ol>
        <li><a href="#处理分数期望概率">处理分数期望、概率</a></li>
      </ol>
    </li>
    <li><a href="#杂项">杂项</a>
      <ol>
        <li><a href="#快速幂">快速幂</a></li>
        <li><a href="#离散化">离散化</a></li>
        <li><a href="#莫队算法">莫队算法</a></li>
        <li><a href="#01分数规划">0/1分数规划</a></li>
        <li><a href="#表达式求值-可能需要进一步完善todo">表达式求值 可能需要进一步完善TODO</a></li>
        <li><a href="#艾弗森括号">艾弗森括号</a></li>
        <li><a href="#向上向下取整">向上、向下取整</a></li>
        <li><a href="#滚动哈希">滚动哈希</a></li>
        <li><a href="#线性规划">线性规划</a></li>
      </ol>
    </li>
    <li><a href="#c-stl用法">C++ STL用法</a>
      <ol>
        <li><a href="#stdswap">std::swap</a></li>
        <li><a href="#stdsort">std::sort</a></li>
        <li><a href="#stdmerge">std::merge</a></li>
        <li><a href="#stdgreater-stdless">std::greater, std::less</a></li>
        <li><a href="#stdlower_boundstdupper_bound">std::lower_bound,std::upper_bound</a></li>
        <li><a href="#stdmaxstdmin">std::max,std::min</a></li>
        <li><a href="#stdmax_elementstdmin_element">std::max_element,std::min_element</a></li>
        <li><a href="#stdabs">std::abs</a></li>
        <li><a href="#stdstring">std::string</a>
          <ol>
            <li><a href="#swap">::swap</a></li>
            <li><a href="#beginstdend">::begin,std::end</a></li>
            <li><a href="#size">::size</a></li>
            <li><a href="#push_back">::push_back</a></li>
            <li><a href="#pop_back">::pop_back</a></li>
            <li><a href="#find">::find</a></li>
            <li><a href="#replace">::replace</a></li>
            <li><a href="#substr">::substr</a></li>
          </ol>
        </li>
        <li><a href="#stdmemset">std::memset</a></li>
        <li><a href="#stdcopy">std::copy</a></li>
        <li><a href="#stdfill">std::fill</a></li>
        <li><a href="#stdmap">std::map</a>
          <ol>
            <li><a href="#自定义比较函数">自定义比较函数</a></li>
            <li><a href="#empty">::empty</a></li>
            <li><a href="#size-1">::size</a></li>
            <li><a href="#clear">::clear</a></li>
            <li><a href="#erase">::erase</a></li>
            <li><a href="#find-1">::find</a></li>
            <li><a href="#lower_boundupper_bound">::lower_bound,::upper_bound</a></li>
          </ol>
        </li>
        <li><a href="#stdunordered_map">std::unordered_map</a></li>
        <li><a href="#stdset">std::set</a>
          <ol>
            <li><a href="#使用方法">使用方法</a></li>
            <li><a href="#insert">::insert</a></li>
            <li><a href="#修改内部元素">修改内部元素</a></li>
          </ol>
        </li>
        <li><a href="#stdunordered_set">std::unordered_set</a></li>
        <li><a href="#stdmultiset">std::multiset</a></li>
        <li><a href="#stdstack">std::stack</a>
          <ol>
            <li><a href="#top">::top</a></li>
            <li><a href="#empty-1">::empty</a></li>
            <li><a href="#size-2">::size</a></li>
            <li><a href="#push">::push</a></li>
            <li><a href="#pop">::pop</a></li>
            <li><a href="#emplace">::emplace</a></li>
          </ol>
        </li>
        <li><a href="#stdqueue">std::queue</a>
          <ol>
            <li><a href="#front">::front</a></li>
            <li><a href="#back">::back</a></li>
            <li><a href="#其他方法">其他方法</a></li>
          </ol>
        </li>
        <li><a href="#stdpriority_queue">std::priority_queue</a>
          <ol>
            <li><a href="#自定义比较方法">自定义比较方法</a></li>
            <li><a href="#方法">方法</a></li>
          </ol>
        </li>
        <li><a href="#stddeque">std::deque</a>
          <ol>
            <li><a href="#方法-1">方法</a></li>
          </ol>
        </li>
        <li><a href="#stdvector">std::vector</a>
          <ol>
            <li><a href="#声明方法">声明方法</a></li>
            <li><a href="#元素访问">元素访问</a></li>
            <li><a href="#size-3">::size</a></li>
            <li><a href="#empty-2">::empty</a></li>
            <li><a href="#push_back-1">::push_back</a></li>
            <li><a href="#pop_back-1">::pop_back</a></li>
            <li><a href="#emplace_back">::emplace_back</a></li>
            <li><a href="#resize">::resize</a></li>
            <li><a href="#reserve">::reserve</a></li>
            <li><a href="#stdvectorbool">std::vector&lt;bool&gt;</a></li>
          </ol>
        </li>
        <li><a href="#stdbitset">std::bitset</a>
          <ol>
            <li><a href="#声明方法-1">声明方法</a></li>
            <li><a href="#元素访问-1">元素访问</a></li>
            <li><a href="#allanynone">::all,::any,::none</a></li>
            <li><a href="#count">::count</a></li>
            <li><a href="#运算">运算</a></li>
            <li><a href="#flip">::flip</a></li>
            <li><a href="#to_string">::to_string</a></li>
            <li><a href="#to_ulongto_ullong">::to_ulong,::to_ullong</a></li>
            <li><a href="#set">::set</a></li>
            <li><a href="#reset">::reset</a></li>
          </ol>
        </li>
        <li><a href="#stdpair">std::pair</a>
          <ol>
            <li><a href="#元素访问-2">元素访问</a></li>
            <li><a href="#swap-1">::swap</a></li>
            <li><a href="#stdmake_pair">std::make_pair</a></li>
          </ol>
        </li>
        <li><a href="#stdtuple">std::tuple</a>
          <ol>
            <li><a href="#元素访问-3">元素访问</a></li>
            <li><a href="#stdmake_tuple">std::make_tuple</a></li>
            <li><a href="#stdtie">std::tie</a></li>
          </ol>
        </li>
        <li><a href="#stdlist">std::list</a>
          <ol>
            <li><a href="#声明方法-2">声明方法</a></li>
            <li><a href="#元素访问-4">元素访问</a></li>
            <li><a href="#empty-3">::empty()</a></li>
            <li><a href="#size-4">::size()</a></li>
            <li><a href="#clear-1">::clear()</a></li>
            <li><a href="#begin-end-rbegin-rend">::begin(), ::end(), ::rbegin(), ::rend()</a></li>
            <li><a href="#insertpos-value">::insert(pos, value)</a></li>
            <li><a href="#erasepos">::erase(pos)</a></li>
            <li><a href="#push_backv-pop_back-push_frontv-pop_front">::push_back(v), ::pop_back(), ::push_front(v), ::pop_front()</a></li>
            <li><a href="#mergelist-other">::merge(list&amp; other)</a></li>
            <li><a href="#reverse">::reverse()</a></li>
            <li><a href="#sort">::sort()</a></li>
            <li><a href="#unique">::unique()</a></li>
          </ol>
        </li>
        <li><a href="#stdnext_permutation-stdprev_permutation">std::next_permutation, std::prev_permutation</a></li>
        <li><a href="#stdunique">std::unique</a></li>
        <li><a href="#stdmt19937_64">std::mt19937_64</a></li>
        <li><a href="#stdcin">std::cin</a>
          <ol>
            <li><a href="#输入十六进制八进制二进制">输入十六进制、八进制、二进制</a></li>
            <li><a href="#输入不忽略空格回车">输入不忽略空格、回车</a></li>
          </ol>
        </li>
        <li><a href="#stdcout">std::cout</a>
          <ol>
            <li><a href="#输出十六进制八进制二进制">输出十六进制、八进制、二进制</a></li>
            <li><a href="#浮点数精度">浮点数精度</a></li>
          </ol>
        </li>
        <li><a href="#scanf-todo">scanf TODO</a>
          <ol>
            <li><a href="#输入十六进制八进制二进制-1">输入十六进制、八进制、二进制</a></li>
          </ol>
        </li>
        <li><a href="#printf-todo">printf TODO</a>
          <ol>
            <li><a href="#输出十六进制八进制二进制-1">输出十六进制、八进制、二进制</a></li>
          </ol>
        </li>
        <li><a href="#atoi-todo">atoi TODO</a></li>
        <li><a href="#正则表达式">正则表达式</a>
          <ol>
            <li><a href="#正则表达式语法">正则表达式语法</a></li>
            <li><a href="#c正则表达式库">C++正则表达式库</a>
              <ol>
                <li><a href="#stdregex">std::regex</a></li>
                <li><a href="#stdsmatch">std::smatch</a></li>
                <li><a href="#stdregex_match">std::regex_match</a></li>
                <li><a href="#stdregex_search">std::regex_search</a></li>
                <li><a href="#stdregex_replace">std::regex_replace</a></li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
